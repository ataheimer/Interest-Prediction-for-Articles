t pure function realtim dequ caten a describ effici pure function implement dequ caten addit intrigu problem right find pure function implement caten dequ requir add certain sophist program construct function program languag solut worstcas run time o push pop inject eject caten best previous known solut ologk time bound kth dequ oper solut faster simpler key idea use result algorithm techniqu relat redund digit represent use avoid carri propag binari count b introduct persist data structur one chang structur made without destroy old version version structur persist least access the structur said partial persist even modifi the structur said fulli persist function program literatur fulli persist structur often call immut pure att laboratori florham park nj work done princeton univers support offic naval research contract no nj nsf grant no ccr ccr unit statesisrael educ foundat usief fulbright grant hklresearchattcom depart comput scienc princeton univers princeton nj usa intertrust technolog sunnyval ca research princeton univers partial support nsf grant no ccr ccr offic naval research contract no nj retcsprincetonedu function program without side effect properti everi structur creat automat fullypersist persist data structur aris function program also text program file edit mainten comput geometri algorithm applic area see number paper discuss way make specif data structur search tree persist smaller number propos method ad persist gener data structur without incur huge time space cost obviou method copi entir structur whenev chang made particular driscol sarnak sleator tarjan describ make pointerbas structur persist use techniqu call nodesplit relat fraction cascad way yet fulli understood dietz describ method make arraybas structur persist addit refer persist found driscol et al dietz paper gener techniqu fail work data structur combin rather chang local driscol sleator tarjan coin term confluent persist refer persist structur updat oper combin two differ version perhap simplest probabl import exampl combin data structur caten append list confluent persist list caten surprisingli power exampl use selfcaten one build list exponenti size linear time paper deal problem make persist list caten effici consid follow oper manipul list return new list consist singleton element x return list form ad element x front list l popl return pair consist first element list l list consist second last element lfor purpos paper pure function data structur one built use lisp function car con cdr though state construct explicitli term function routin verifi structur pure function definit pure function extrem strict not exampl allow techniqu memoiz contrast work with exampl okasaki discuss issu see section return list form ad element x back list l return pair consist last element list l list consist first nexttolast element l catenatek l return list form caten k l k first observ push inject special case caten conveni us treat separ oper howev accord convent call list subject push pop or inject eject stack list subject inject pop or push eject queue adopt terminolog knuth call list subject four oper push pop inject eject doubleend queue abbrevi dequ pronounc deck departur exist terminolog call list subject push pop inject stackend queue stequ pronounc steck knuth call stequ outputrestrict dequ stackend queue easi shorten evok idea stequ combin function stack queue stequ caten stack caten sinc caten make inject and push matter redund call data structur constant worstcas time bound oper realtim structur main result realtim pure function and henc confluent persist implement dequ caten data structur effici simpler previous propos structur addit interest problem right data structur provid way add fast caten listbas program languag scheme implement sophist program construct base continu function program languag see key ingredi result algorithm techniqu relat redund digit represent devis avoid carri propag binari count remaind paper consist six section section survey previou work deal problem relat make list persist ad caten effici list oper section motiv approach section describ make dequ without caten pure function therebi illustr idea simpl set section describ make stack or stequ caten pure function illustr addit idea need handl caten compar simpl set stack section present gener result implement dequ caten result use addit idea need handl underli treelik recurs structur place linear structur section mention addit relat result open problem preliminari version part work present th annual acm symposium theori comput previou work work relat found three branch comput scienc data structur function program and perhap surprisingli ture machin complex shall describ work approxim chronolog order detail attempt sort somewhat tangl histori let us put asid caten moment consid problem make noncaten list fulli persist easi make stack persist repres stack pointer singlylink list element top element stack first element list push element onto stack creat new node contain new element pointer node contain previous first element stack pop stack retriev first element pointer node contain previous second element standard lisp represent list collect persist stack repres way consist collect tree pointer child parent two stack common suffix share one list repres common suffix have common suffix guarante share howev sinc two stack ident content built two separ sequenc push pop oper maximum share suffix achiev use hash cons techniqu new node creat correspond distinct new stack see make queue stequ dequ persist simpl one approach advantag give pure function solut repres data structur fix number stack oper becom fix number stack oper is seek realtim simul queue stequ dequ fix number stack problem give realtim simul dequ fix number stack close relat old problem ture machin complex give realtim simul onedimension multihead tape unit fix number onedimension onehead tape unit two problem reduc one anoth note dequ simul twohead tape unit onehead tape unit simul two stack thu dequ problem reduc tape problem convers khead tape unit simul dequ two stack stack simul onehead tape thu tape problem reduc dequ problem two gap reduct first dequ element potenti chosen infinit univers wherea univers tape symbol alway finit allow possibl solv tape problem use clever symbol encod might applic dequ problem none known solut tape problem exploit possibl give solut dequ problem reduct abov second gap reduct necessarili minim number stack onehead tape simul goal dequ tape problem must address directli first step toward solv tape simul problem taken stoss produc lineartim simul multihead tape fix number onehead tape shortli thereaft fisher meyer rosenberg gave realtim simul multihead tape fix number onehead tape latter simul use tapefold techniqu directli relat method stoss later leong seifera gave realtim multiheadtap simul use fewer tape cleverli augment stosss idea approach also work multidimension tape appar true tapefold idea reduct describ abov dequ simul problem alreadi solv by two differ method time work problem began appear data structur function program literatur nevertheless latter work import deal dequ simul problem directli lead effici conceptu simpler solut although sever work deal dequ simul problem describ essenti solut solut base two key idea mimic idea stoss leong seifera first idea dequ repres pair stack one repres front part dequ repres rear part one stack becom empti mani pop eject oper dequ one stack copi two stack contain half dequ element fiftyfifti split guarante copi even though expens happen infrequ simpl amort argument use potenti function equal absolut valu differ stack size show give lineartim simul dequ constant number stack k dequ oper start empti dequ simul ok stack oper see discuss amort potenti function simpl idea essenc stosss tape simul idea repres queue two stack way appear represent dequ appear second idea use increment copi convert lineartim simul realtim simul soon two stack becom suffici unbalanc recopi creat two balanc stack begin recopi must proceed concurr dequ oper among thing caus size dequ move target detail simul littl complic hood melvil first spell detail method case queue hood thesi describ simul dequ see also chuang goldberg give particularli nice descript dequ simul okasaki give variat simul use memoiz avoid explicit stacktostack copi solut give persist strictli function sinc memoiz side effect complet differ way make dequ persist appli gener mechan driscol et al solut too strictli function constant time bound per dequ oper amort worstcas caten ad oper problem make stack dequ persist becom much harder method mention fail kosaraju obtain coupl intrigu result deserv mention although solv problem consid here first gave realtim simul caten dequ noncaten dequ unfor tunat solut support confluent persist particular kosaraju explicitli disallow selfcaten solut also realtim fix number dequ time per dequ oper increas least linearli number dequ second gave realtim randomaccess implement caten dequ find minimum oper problem discuss section solut realtim variabl number dequ support confluent persist inde kosaraju state these idea might help make mindequ confluent persist are howev previou solut problem make caten dequ fulli persist straightforward use balanc tree give represent persist caten dequ oper dequ dequ total size n take olog n time driscol sleator tarjan combin tree represent sever addit idea obtain implement persist caten stack k th oper take olog log buchsbaum tarjan use recurs decomposit tree obtain two implement persist caten dequ first time bound olog k second time bound olog k k th oper log k iter logarithm defin log log k log i g work motiv our recurs slowdown section describ key insight led result although insight explicit ultim construct need understand it idea may help make progress problem reason offer here spark work observ concern recurr give time bound buchsbaumtarjan data structur recurr follow form c constant oper structur size n take constant amount time plu fix number oper recurs substructur size log n first version buchsbaumtarjan structur c fix constant greater one recurr give time bound n second version structur c equal one recurr give time bound n olog n suppos could design structur constant c less one recurr would give bound n o inde recurr give bound n o constant c use similar observ improv time bound select minheap ok log k ok thu obtain o time bound oper data structur oper requir o time plu half oper smaller recurs substructur achiev effect data structur requir one oper recurs substructur everi two oper toplevel structur call idea recurs slowdown main new featur data structur mechan implement recurs slow down state abstractli basic problem alloc work cycl level linear recurs top level get half cycl second level get one quarter cycl third level get one eighth cycl on exactli happen binari count specif begin zero repeatedli add one binari addit one caus uniqu bit posit chang zero one everi second addit posit one bit everi fourth addit two bit everi eighth addit four bit on cours binari count addit one chang mani bit zero obtain realtim perform addit work must avoid one use redund digit represent number one represent singl digit chang need add one clanci knuth use idea implement finger search tree descript redund represent well applic found clancyknuth method repres number base two use three digit redund binari represent rbr nonneg number x sequenc digit n represent gener uniqu call rbr regular everi j exist word scan digit signific least signific find must find find anoth run digit impli particular add number x repres regular rbr first add result rbr x may regular restor regular find least signific digit set rbr alreadi regular straightforward show method correctli add chang constant number digit thu avoid explicit carri propag work alloc mechan list use threestat system correspond three digit clancyknuth number represent instead digit use color level recurs data structur green yellow red color base state structur level red structur bad convert green structur cost degrad structur one level deeper green yellow yellow red maintain invari level two red level separ least one green level ignor interven yellow level greenyellowr mechan appli underli linear structur suffic add constanttim caten stack handl dequ must extend mechan appli underli tree structur involv ad anoth color orang wherea greenyellowr system close analogu clancyknuth number represent extend system distantli relat postpon discuss extens section use dequ without caten section present realtim pure function implement dequ without cate nation exampl illustr idea simpl set provid altern implement base pair increment copi stack describ section section modifi structur support stack caten we add caten oper remov eject final section modifi structur support caten dequ oper last step involv extend work alloc mechan mention end section recal oper possibl dequ pushxd popd injectxd ejectd subsequ section say data structur set store element a represent repres dequ recurs structur built boundeds dequ call buffer buffer hold five element buffer two kind prefix suffix nonempti dequ set repres order tripl consist prefix prefixd element a child dequ childd whose element order pair element a suffix suffixd element a order element within one consist order compon part child dequ childd nonempti repres way thu structur recurs unwind linearli defin descend fchild dg dequ standard way name child child child d nonempti observ element element a element childd pair element a element childchildd pair pair element a on one think element child d complet binari tree depth i element leav one also think entir structur repres stack of descend element prefixsuffix pair element store prefix suffix variou level structur group binari tree appropri depth level contain prefix suffix child d see figur pair bring two element level one pop eject level similarli move two element level one push inject level twoforon payoff give recurs slowdown lead realtim perform obtain realtim perform must guarante toplevel dequ oper requir chang constant number level recurs structur reason impos regular constraint structur assign buffer dequ color either green yellow red buffer green two three element yellow one four red zero five observ add one element delet one element green yellow buffer without violat size constraint green buffer stay green becom yellow yellow buffer becom green red order color red yellow green red bad green good higher buffer color depth complet binari tree number edg roottoleaf path figur represent dequ squar bracket denot dequ descend dequ parenthes denot buffer curli bracket denot expans dequ compon part number denot level dequ triangl level three denot pair pair pair equival complet binari tree depth three indic insert delet buffer possibl size outsid allow rang defin color nonempti dequ minimum color prefix suffix unless child one buffer empti case color dequ color nonempti buffer regular constraint dequ constraint color sequenc descend dequ d childd child call semiregular two red dequ sequenc green dequ ignor interven yellow formal semiregular if two red dequ child d child j d k child k d green call regular semiregular if addit first nonyellow dequ if ani sequenc green observ regular semiregular childd inde child d semiregular furthermor semiregular red childd regular strategi obtain realtim perform maintain constraint toplevel dequ regular except possibl middl dequ oper dequ temporarili becom semiregular regular dequ top level green yellow mean dequ oper perform oper appropri toplevel buffer may chang top level green yellow yellow red either case dequ may longer regular semiregular semiregular topmost nonyellow descend dequ red restor regular chang red dequ green process possibl chang child dequ green yellow yellow red green observ color chang effect them restor regular process correspond addit redund binari number system discuss section process chang red dequ green chang element contain order mere move element buffer buffer child thu make chang obtain toplevel regular dequ mere restor level top chang dequ topmost red dequ may arbitrarili deep recurs structur sinc separ top level mani yellow dequ achiev realtim perform need constanttim access topmost red dequ reason repres dequ obviou way stack prefixsuffix pair instead break stack substack one substack toplevel dequ one nonyellow descend dequ top level substack consist toplevel nonyellow dequ consecut yellow proper descend dequ repres entir dequ stack substack prefixsuffix pair use partit substack equival pointerbas represent use node four pointer nonempti descend dequ d two pointer prefix suffix correspond level one pointer node child dequ dequ nonempti yellow one pointer node nearest nonyellow proper descend dequ dequ exist nonyellow toplevel see figur figur singl dequ oper requir access top three substack top two element substack color chang caus dequ oper produc minor chang stack partit substack chang made constant time particular chang color toplevel dequ affect partit g r g r figur pointer represent stack substack structur horizont line denot buffer letter indic dequ color left pointer link element within substack right pointer link top substack null pointer denot substack chang topmost red dequ green child yellow nonyellow split one substack first element new substack rest substack pop oper chang topmost red dequ green child green yellow merg singleton substack substack it substack push oper dequ oper remain describ detail buffer manipul verifi produc claim color chang perform push pop push pop appropri element onto toplevel prefix unless prefix child dequ empti case toplevel suffix inject eject symmetr origin dequ regular top level origin green yellow oper perform without overflow underflow buffer unless tri pop eject alreadi empti dequ top level may chang green yellow yellow red may make new dequ semiregular restor semiregular dequ that regular regular follow let topmost red th st level prefix st th level suffix respect view element perspect level i call element p i i pair sinc pair leve element note either p i i empti i sinc level cannot red appli appropri one follow three case twobuff case jp p i empti pop pair i inject eject pair p i push onto i jp eject two element p pair them push pair onto p i js j pop two element pair them inject pair i jp pair p i inject two element individu p js eject pair i push two element bottommost level p i i empti elimin level onebuff case jp level bottommost level creat new empti level js pop pair i inject p i eject two element p pair them push pair onto p i js j pop two element pair them inject pair p i jp pair p i inject two element p js eject pair p i push two element onto nobuff case jp contain leve element two pair p i i move element exist note even though dequ oper one end dequ regular procedur oper end descend dequ concurr theorem given regular dequ method describ perform push pop inject eject oper o time result regular dequ proof nontrivi part proof verifi regular procedur correct straightforward verifi dequ oper perform correctli time bound o given stackofsubstack represent twobuff case occur p i i nonempti level yellow first two step level start green yellow semiregular make p i i nonempti cannot make level red remain step make level green chang size p i i one each situat level green end red jp initi jp final case level must bottommost level elimin end case thu case make color chang need restor regular onebuff case occur sinc level initi red level must bottommost level case make level green make level empti case elimin thu case also make color chang need restor regular nobuff case occur p i i must contain pair otherwis level empti henc nonexist level yellow nonempti contradict fact level topmost red level also one p contain element follow case too restor regular data structur describ simplifi subset four oper push pop inject eject allow exampl push allow prefix restrict size red yellow green similarli eject allow suffix restrict size green yellow red thu repres queue inject pop onli buffer size altern repres stequ pair consist stack queue push onto stack inject queue pop stack unless stack empti case queue realtim caten next goal dequ structur support fast caten sinc caten stequ dequ without eject easier implement caten dequ discuss caten stequ here delay discuss structur support full set oper section throughout rest paper refer caten stequ simpli stequ represent represent stequ like structur section two major differ compon part section use buffer two differ kind prefix suffix unlik section buffer noncaten stequ upper bound size stequ implement use either method section stackrevers method sketch section possibl effici enhanc store buffer size although fact necessari obtain constanttim oper requir prefix contain least two element lower bound size suffix inde suffix empti second differ compon pair store child stequ defin pair set recurs follow pair consist prefix element possibl empti stequ pair a repres nonempti stequ either suffix suffix element a tripl consist prefix prefix element a child stequ child pair a suffix suffix element a child stequ nonempti repres way nonempti stequ one pair child order element within stequ one consist order compon path figur figur partial expans represent stequ squar bracket denot caten stequ horizont line denot buffer curli bracket denot expans stequ compon part arrow denot membership circl denot element base set number denot level stequ figur structur doubli recurs stequ structur either toplevel stequ child anoth stequ second compon pair store anoth stequ defin level stequ structur follow toplevel stequ level stequ level child leve stequ pair store leve observ everi leve stequ type element name element level stequ element a element level stequ pair a element level stequ pair pair a on stequ caten need level otherwis element differ type extra kind recurs compar structur section one sequenc descend stequ mani toplevel stequ stequ store pair structur begin sequenc consist stequ s child grandchild on among descend one repres suffix instead prefix child suffix tripl last one may order stequ oper term implement complex follow push inject simplest caten nextsimplest pop mostcompl push inject simpl oper singl buffer buffer grow arbitrarili larg mean overflow problem perform caten oper push inject oper extra kind recurs pop complic oper requir caten may also threaten buffer underflow prevent mechan like use section prefix color red prefix contain two element yellow three green four more nonempti stequ structur also color color prefix one otherwis green call stequ semiregular if pair red stequ descend sequenc within s green stequ ignor interven yellow call stequ regular semiregular if addit first nonyellow stequ sequenc s child s child ani green section maintain invari toplevel stequ regular except possibl middl stequ oper may temporarili semiregular observ regular child semiregular semiregular stequ green prefix child stequ regular represent stequ correspond section name repres descend sequenc stack substack break descend sequenc subsequ begin first stequ nonyellow stequ contain consecut follow yellow stequ element substack pair consist prefix suffix correspond stequ with null indic nonexist prefix element prefix suffix element base set prefix suffix level pair appropri type prefix suffix deeper structur see figur r g r g figur pointer represent substack decomposit part partial expand stequ figur sequenc descend shown letter denot stequ color left pointer link element within substack right pointer link top substack null pointer denot stequ oper note abov push inject oper simplest stequ oper implement chang singl buffer increas size one specif inject element x stequ s inject x suffix push element x onto stequ s push x onto prefix unless prefix case push x onto suffix push may chang color toplevel stequ red yellow yellow green help regular constraint chang substack decomposit caten oper somewhat complic consist push inject oper specif form caten two stequ appli appropri one follow three case case tripl suffix contain least two element inject pair suffix child thi convert suffix prefix otherwis suffix contain one element push element onto tripl inject pair prefix tripl prefix case suffix tripl jsuffix j push pair prefix onto let result tripl suffix green prefix otherwis pop three element suffix push opposit order onto prefix let prefix case suffix onli jsuffix j let suffix suffix thi make suffix green prefix otherwis pop three element suffix push opposit order onto suffix let suffix lemma semiregular semiregular addit regular regular proof case stequ toplevel one green thu regular case push onto child happen preserv semiregular child prefix result stequ green thu regular case child child semiregular inject child preserv semiregular stequ prefix child stequ save possibl one two inject thu semiregular is regular is pop complic stequ oper pop stequ suffix onli mere pop suffix pop stequ tripl pop prefix may result stequ longer regular semiregular restor regular modifi nearest red descend stequ say toplevel stequ follow child empti pop two element prefix push opposit order onto suffix repres suffix onli otherwis pop pair say p pop two element prefix push opposit order onto p caten child form replac tripl p lemma restor method describ convert semiregular stequ regular thu implementaiton pop correct proof let nearest red descend stequ s child empti replac green stequ child result regular stequ suppos child nonempti pop regular semiregular sinc semiregular sinc red nearest nonyellow descend child must green henc child least semiregular pop tripl p replac p green semiregular mean regular theorem push pop inject regular stequ take o time result regular stequ caten two regular stequ take o time result regular stequ proof o time bound per stequ oper obviou stack substack represent use regular obviou push inject true caten lemma pop lemma altern way build realtim caten stequ use noncaten stack buffer see caten dequ final extend idea present previou two section obtain data structur support full set dequ oper name push pop inject eject caten o time omit certain definit obviou extens previou section common featur two data structur present far underli linear skeleton the sequenc descend structur caten dequ replac linear skeleton binarytre skeleton seem requir effici handl pop eject branch skeleton turn requir chang workalloc mechan must funnel comput cycl branch tree add one color orang color scheme replac twobeat rhythm greenyellowr mechan threebeat rhythm obtain o time bound per dequ oper essenti correspond branch factor tree structur correspond rhythm work cycl connect redund number system much looser greenyellow red scheme use section nevertheless abl show directli extend mechan solv problem represent represent dequ use two kind buffer prefix suffix buffer noncaten dequ implement buffer either describ section use increment stackrevers method outlin section henceforth dequ mean caten dequ unless explicitli state otherwis section option store buffer size may provid constantfactor speedup defin tripl set recurs prefix element a possibl empti dequ tripl a suffix element a tripl dequ call store tripl repres nonempti dequ either one tripl a call tripl order pair tripl a left tripl right tripl dequ within tripl repres recurs way order element within dequ one consist order compon part defin parentchild relat tripl follow dequ suffix tripl dequ children one two tripl make dequ defin ancestor descend standard way relat tripl group tree whose node unari binari toplevel tripl store tripl root tree dequ repres one two tree root toplevel tripl figur figur partial expans represent caten dequ convent figur two tripl compris dequ separ comma figur four differ kind tripl store tripl tripl left tripl right tripl impos size constraint buffer tripl depend upon kind is store tripl requir p contain least three element unless one buffer empti case buffer must contain least three element tripl requir p contain least five element unless one buffer empti case buffer contain nonzero number element left tripl requir p contain least five element exactli two symmetr right tripl requir contain least five element p exactli two assign color tripl base type buffer size follow let s tripl store tripl green left tripl green p contain least eight element yellow p contain seven orang six red five symmetr right tripl green contain least eight element yellow seven orang six red five tripl green p contain least eight element yellow one contain seven least seven orang one contain six least six red one contain five least five tripl group tree parentchild relat partit tree path follow yellow orang tripl prefer child left child child tripl yellow right child child tripl orang prefer children defin prefer path start tripl prefer child pass success prefer children reach tripl without prefer child thu prefer path consist sequenc zero yellow orang tripl follow green red tripl everi tripl children green assign prefer path color green red accord color last tripl impos regular constraint structur like section littl complic call dequ semiregular follow condit hold everi prefer path start child red tripl green path everi prefer path start nonpref child orang tripl green path definit impli dequ semiregular dequ constitu tripl semiregular call dequ regular semiregular if addit prefer path start toplevel tripl one one two repres entir dequ green path maintain invari toplevel dequ regular except possibl middl dequ oper may temporarili semiregular note empti dequ regular need represent tree tripl allow us shortcut prefer path end introduc notion adopt child adopt parent everi green red tripl prefer path least three tripl adopt child first tripl path adopt parent is adopt parentadopt child relationship first last tripl prefer path contain least three tripl defin compress forest parentchild relat tripl except adopt child child adopt parent instead natur parent compress forest tripl three children one may adopt repres dequ compress forest node tripl contain prefix suffix tripl pointer node repres child tripl see figur figur oper describ next section reli follow properti compress forest represent given node tripl extract constant time pointer compress forest represent toplevel tripl store tripl color either red green dequ oper simplest dequ oper push inject next caten may requir push inject both complic oper pop eject violat regular may forc repair deep forest tripl but shallow compress forest begin describ push inject symmetr let dequ onto wish push element empti creat new tripl repres new dequ one nonempti buffer contain push element nonempti let left tripl tripl p nonempti push new element onto otherwis push new element onto g r g g figur toplevel tree compress forest represent dequ letter denot tripl correspond color dash arrow denot adoptivepar adoptivechild relationship replac natur parentchild relationship mark hatch arrow complet compress forest represent not shown would includ buffer tripl lowerlevel compress tree root store tripl lemma push onto semiregular dequ produc semiregular dequ push onto regular dequ produc regular dequ proof push chang color t lemma immedi push chang color t must yellow green orang yellow red orang redtoorang happen origin dequ semiregular regular yellow togreen case obvious preserv semiregular regular orangetoyellow case let u nonpref child push nonpref child u exist semiregular impli prefer path contain u green path push add front path mean push preserv semiregular regular u exist push chang prefer path chang orang yellow case also push preserv semiregular regular redtoorang case push everi child start prefer path green mean push nonpref child t exist start prefer path green thu push preserv semiregular note effect push prefer path decomposit add delet front prefer path or both mean compress forest updat o time push next describ caten let e two dequ caten assum nonempti otherwis caten trivial caten e appli appropri one follow four case case buffer two three four toplevel tripl e nonempti new dequ consist two tripl u form toplevel tripl tripl d u form toplevel tripl tripl e four subcas format t subcas a dequ consist two tripl each contain exactli two element singl buffer p eject last two element add new buffer rest inject p subcas b dequ consist two tripl inject element p p form p replac represent tripl p appli subcas c appropri subcas c dequ consist tripl eject last two element add new buffer let remaind form new tripl inject form subcas d dequ consist tripl contain eight element move last two element p form p let remain two element form contain eight element move first three element p form p move last two element new buffer let remaind push tripl empti dequ form dequ let oper symmetr e form u case dequ consist tripl one nonempti buffer buffer toplevel tripl tripl e nonempti let left tripl e combin form new tripl t left tripl new dequ right tripl e exist right tripl new dequ form t let p nonempti one p p contain less eight element push element otherwis form tripl p push onto case dequ e consist tripl one nonempti buffer buffer toplevel tripl tripl nonempti case symmetr case case dequ e consist tripl singl nonempti buffer let p nonempti buffer nonempti buffer e either p contain fewer eight element combin singl buffer b let lemma caten two semiregular dequ produc semiregular dequ caten two regular dequ produc regular dequ proof consid case shall show that subcas tripl descend satisfi semiregular regular constraint appropri symmetr argument appli u give lemma case subcas d tripl green either green child grandchildren child all either case satisfi regular constraint consid subcas c dequ form semiregular dequ inject henc semiregular lemma color tripl least good color tripl sinc color depend size p wherea color depend minimum size p must consid sever case depend color whether tri verifi regular semiregular green descend satisfi regular constraint red semiregular impli henc regular descend satisfi semiregular constraint orang regular henc must regular descend satisfi regular constraint orang semiregular nonpref child exist start green path correspond nonpref child also start green path argument like lemma mean descend satisfi semiregular constraint yellow semiregular impli descend satisfi semiregular constraint final yellow regular prefer child green path correspond child t argument like lemma thu descend satisfi regular constraint subcas b creat onetripl represent semiregular origin represent regular origin one is subcas b follow applic c appropri case too tripl descend satisfi semiregular regular constraint appropri last subcas subcas a case c argument depend color whether tri verifi regular semiregular case exactli color dequ semiregular lemma sinc semiregular remaind argument exactli subcas c consid case p contain less eight element form seven push onto satisfi regular semiregular lemma otherwis dequ form dequ push tripl either green color tripl remaind argument exactli subcas c case symmetr case case obvious preserv semiregular regularitya caten chang color composit tripl constant number level top compress forest structur henc structur updat constant time caten come final last two oper pop eject shall describ pop eject symmetr pop consist two part first remov element pop second repair damag regular caus remov let left tripl dequ pop first part pop consist pop prefix t pop suffix prefix empti replac tripl result pop form shall see below may regular semiregular prefer path start may red case let u red tripl end prefer path use compress forest represent access u constant time second part pop replac u descend tree tripl repres element green root v satisfi regular constraint produc regular represent finish pop repair appli appropri one follow case sinc u red case tripl u left tripl pop first tripl p rest case a p nonempti push onto push element caten dequ case b one p empti combin singl buffer p let case tripl u tripl appli appropri one follow three case case a suffix contain least eight element proce case obtain contain least eight element case b prefix p contain least eight element proce symmetr case obtain contain least eight element case c p contain seven element pop first tripl p without repair let rest otherwis eject last tripl without repair let rest one p empti combin singl buffer p let push element p onto p form p caten form symmetr one p empti combin p singl buffer let otherwis inject p form inject element form let lemma remov first element from first buffer regular dequ produc semiregular dequ whose violat regular constraint prefer path contain left toplevel tripl may red remov first last element from first last buffer respect regular dequ produc semiregular dequ proof let regular dequ let left tripl let form pop p let form replac green yellow orang t cannot red regular yellow orang red respect one transit occur unless green case regular sinc is case easi verifi regular impli tripl satisfi appropri semiregular constraint tripl sinc color chang possibl violat regular prefer path contain may red analog argument show last element remov form still semiregular tripl d two remov degrad color one color left tripl argument symmetr appli sibl lemma pop regular dequ produc regular dequ proof let dequ pop let dequ form remov first element first buffer d let left tripl lemma semiregular violat regular prefer path contain may red prefer path green regular pop finish lemma true suppos hand prefer path red let red tripl path sinc semiregular u red must regular claim repair describ case replac u descend tree tripl green root satisfi semiregular constraint impli dequ result repair regular thu give lemma consid case abov sinc regular dequ form pop tripl case a push onto form leav lemma dequ semiregular sinc regular lemma dequ form caten semiregular tripl give claim case b tripl semiregular give claim consid case abov argument case verifi claim case b case c green semiregular give claim case c semiregular lemma dequ semiregular appropri applic lemma v green claim true oper pop chang constant number level top compress forest henc perform constant time theorem dequ oper take o time preserv regular proof straightforward verifi compress forest represent allow dequ oper perform describ o time lemma give preserv regular dequ represent present hybrid two altern structur describ one base pair quadrupl other suggest okasaki base tripl quintupl present structur offer conceptu simplif altern buffer size constraint represent reduc slightli cost make structur less symmetr exampl lower bound suffix size right tripl tripl reduc one modifi definit color appropri result open problem conclud section addit result open problem begin two extens structur mention recent work final give open problem set element store dequ total order extend structur describ support addit heap order base order a specif support addit oper find minimum element dequ but delet it oper remain constanttim implement remain pure function mere store buffer dequ pair minimum element contain it relat work see also support flip oper dequ structur section flip oper revers linear order element dequ ith front becom ith back viceversa noncaten dequ section implement flip maintain revers bit flip flip oper revers bit set push becom inject pop becom eject inject becom push eject becom pop support caten well flip requir littl work need symmetr structur add revers bit level nonsymmetri structur definit prefer children prefer child yellow tripl left child prefer child orang tripl right child flip exchang left right want oper chang prefer children want partit compress forest prefer path unaffect flip thu creat brandnew tripl design current left child prefer child yellow current right child prefer child orang tripl chang orang yellow yellow orang switch prefer child irrespect current left right handl flip add revers bit everi dequ everi buffer structur revers bit set mean entir dequ buffer flip revers bit cumul along path descend compress forest given dequ buffer revers odd number ancestor includ itself revers bit set flip entir dequ flip revers bit whenev dequ oper push revers bit structur dequ actual manipul revers revers buffer push inject pop eject switch role detail straightforward turn recent relat work work independ our okasaki devis confluent persist implement caten stack or stequ implement realtim give constant amort time bound per oper also pure function use memoiz okasaki use root tree repres stack element pop use memoiz version path revers techniqu previous use data structur disjoint set union problem though okasaki solut neither realtim pure function simpler our extend okasaki method case dequ open problem see earli version work okasaki observ amort time bound suffic memoiz allow data structur consider sim plifi idea perform fix lazi fashion use memoiz record result avoid need maintain stack stack structur represent also allow buffer shorter okasaki call result gener method implicit recurs slow down argu standard techniqu amort analysi suffic case need deal persist idea fact much gener recurs slowdown howev standard techniqu inde suffic analysi work okasaki devis even simpler version structur need constants buffer take o amort time per dequ oper use replac oper gener memoiz final mention open problem note abov one extend okasaki path revers techniqu dequ second one modifi structur section use buffer bound size know case stack doubleend case unresolv technic cours one solut plug structur section inlin structur section simplifi extent possibl direct approach may well work lead simpler solut anoth open problem devis version structur section use one subdequ instead two thu lead linear recurs structur final open problem devis pure function implement finger search tree randomaccess list constanttim caten best solut problem olog log n caten time acknowledg thank adam buchsbaum david wagner ian munro chri okasaki vital contribut paper adam buchsbaum engag extens fruit discuss concern idea david wagner suggest idea color invari altern explicit use binari count work alloc mechan ian munro see present idea point connect color invari redund binari represent chri okasaki provid valuabl comment draft work also thank refere insight valuabl suggest r anatomi lisp data structur bootstrap confluent persist dequ via data structur bootstrap effici function implement fifo queue search histori fraction cascad i program problemsolv seminar fulli persist array effici use past fulli persist list caten make data structur persist theori practic firstclass prompt abstract continu mathemat semant handl full function jump optim select minheap dequ heap order scienc program effici implement veryhighlevel program languag construct symmetr set effici list oper store partial continu firstclass object languag environ pure function list simpl confluent persist caten list extend abstract persist list caten via recurs slowdown pure function represent caten sort list fundament algorithm optim ram implement caten min doubleend queue new realtim simul multihead tape unit persist list caten via lazi link simpl effici pure function queue dequ pure function data structur caten doubleend queue search past search past persist data structur planar point locat use persist search tree control delimit hierarchi exampl hierarch design proof amort comput complex worst case analysi set union algorithm tr worstcas analysi set union algorithm search histori planar point locat use persist search tree search sort similar list dequ heap order abstract continu mathemat semant handl full jump make data structur persist store partial continu firstclass object languag environ theori practic firstclass prompt control delimit hierarchi realtim dequ multihead ture machin pure function program optim algorithm select minheap fulli persist list caten confluent persist dequ via datastructur bootstrap datastructur bootstrap linear path compress caten heapord doubleend queue persist list caten via recurs slowdown pure function represent caten sort list caten doubleend queue pure function list pure function data structur worstcas effici prioriti queue optim ram implement caten min doubleend queue realtim simul multihead tape unit new realtim simul multihead tape unit exampl hierarch design proof art comput program volum box set scienc program anatomi lisp simpl confluent persist caten list extend abstract fulli persist array extend array amort lazi evalu persist realtim simul concaten doubleend queue doubleend queue preliminari version program problemsolv seminar effici implement veryhighlevel program languag construct persist data structur ctr amo fiat haim kaplan make data structur confluent persist proceed twelfth annual acmsiam symposium discret algorithm p januari washington dc unit state amo fiat haim kaplan make data structur confluent persist journal algorithm v n p august georg lagogianni yanni panagi spyro siouta athanasio tsakalidi survey persist data structur proceed th wsea intern confer comput p juli athen greec