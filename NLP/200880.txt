t design program check work a program correct checker algorithm check output comput is given program instanc program run checker certifi whether output program instanc correct paper defin concept program checker design program checker specif care chosen problem class fp function comput polynomi time problem fp checker present paper includ sort matrix rank gcd also appli method modern cryptographi especi idea probabilist interact proof design program checker group theoret computationstwo structur theorem proven here one character problem check theorem establish equival class problem whenev one problem class checkabl problem class checkabl b introduct paper introduc concept program checker program checker program p program c instanc program p run c run subsequ c either certifi program p correct declar p buggi method propos gain confid output program exampl program verif seek achiev prove program correct program verif suffer problem hard prove program correct also argu proof correct program improv confid correct natur proof recent discuss role verif softwar develop see program test run program test input output known see program output match expect output test fairli ad hoc techniqu gener method gener test data theorem proven behavior program pass test addit work theoret comput scienc commun concept help may regard determinist version check program check easier verif yield mathemat proof program behavior unlik test allow cointoss greatli enhanc power checker comparison model help abov idea paper aris cryptographi probabilist algorithm program test particularli import work interact proof goldwass micali rackoff subsequ relat work seen sever correct checker construct paper use probabilist interact proof first step design equal import work paper random algorithm rabin freivald latter remark enough includ excel program checker integ polynomi matrix multi plicat work budd angluin weyuk relev seek give program test rigor mathemat basi notion program check use paper first formal defin blum kannan paper draw heavili concept program check defin checker exhibit grouptheoret problem select problem p class problem polynomialtim checker character sinc sever paper shed light problem blum lubi rubinfeld extend notion program check one step sever direct focu larg collect numer problem includ integ multipl modular multipl problem show possibl detect error program also correct error program mostli correct also provid effici test determin whether program mostli correct process result yield program tester provabl perform program pass selftest la instanc size n possibl prove theorem say high probabl p correct most instanc size n most precis quantifi anoth concept introduc librari program allow checker one problem librari call program problem librari long program librari check mean extens allow design effici simpl checker problem hitherto much complex checker adleman huang kompella provid checker sever numbertheoret problem includ integ greatest common divisor conjectur effici checker gcd would hard find lipton consid program test way ensur mostli correct show one correct error program transform given instanc sever random instanc comput answer given instanc answer random instanc lipton build work beaver feigenbaum show polynomi gener perman particular amen techniqu rubinfeld extend notion check parallel check blum et al extend program store retriev data unreli memori kannan yao consid problem check cointoss program produc specifi output probabl distribut sever concept complex theori intim relat check two concept coher randomselfreduc concept consid extens literatur definit concept relat program check found exampl rest paper organ follow formal descript program check model given section section illustr concept prototyp exampl graph isomorph problem section deriv structur theorem allow us deriv checker one problem checker other section present program checker grouptheoret problem section demonstr close connect design program checker design interact proof section present checker number common function comput fp specif problem consid extend gcd sort matrix rank final section character class problem polynomialtim checker checker let denot comput decis search problem x input let x denot output let p determinist program supposedli halt instanc say program p bug instanc x p x x defin effici program checker c problem follow c p probabilist expectedpolytim oracl ture machin satisfi follow condit program supposedli halt instanc instanc posit integ k the socal secur paramet present unari p bug ie p instanc x probabl p i i probabl probabl comput sampl space finit sequenc coin flip c could toss remark order i run time c includ whatev time take c submit input receiv output p exclud time take p comput ii definit p bug p give correct output input c p may output correct buggi assum program p problem halt instanc done order help focu problem hand gener howev program alway halt definit bug must extend cover program error slow program caus diverg altogeth case definit program checker must also extend requir addit condit p x exce precomput bound phix run time valu x submit checker oracl program checker sound warn name c p remaind paper assum program p problem halt instanc condit everywher suppress possibl extend notion program check probabilist algorithm bpp order thi simpli run program suffici often make probabl error a correct program much smaller k simpli treat program though determinist program check accordingli rest paper consid determinist program assur result checker determinist program extend checker probabilist program approach program correct question natur aris one cannot sure program correct one sure checker correct seriou problem one solut prove checker correct sometim easier prove origin program correct case extend gcd checker section anoth possibl tri make checker extent independ program check end make follow definit say probabilist program checker c littl oh properti respect program p expect run time c littl oh run time p shall gener requir checker littl oh properti respect program check princip reason ensur checker program differ program check instanc two program problem run time definit disallow checker run one check other desir checker howev definit necessarili constrain us design effici checker although run time checker littl oh program run time account time spent call program checker made one call program run checker would result increas asymptot run time program gener hard achiev signific subclass problem such one consid one design checker run time wors constant time run time program check take account time spent run program check exampl graph isomorph present exampl good checker checker adapt goldreich micali interact proof system graph isomorph see model reli exist allpow prover prover replac program check power program turn suffici simul prover applic checker result practic way check comput program graph isomorph graph isomorph problem lot heurist work instanc append checker heurist give us confid output possibl unproven heurist graph isomorph decis problem defin follow graph isomorph gi input two graph g h output ye g isomorph h otherwis checker c p check program p input graph g h begin comput p g h ye use p as bugfre search isomorph g h thi done standard selfreduct hoffmann page check whether result correspond isomorph not return buggi ye return correct p g h no time toss fair coin gener random permut g g comput p g g no return buggi gener random permut h h comput enddo return correct end program checker correctli check comput program whatsoev purport solv graph isomorph problem even bizarr program design fool checker caught run input caus output incorrect answer follow theorem prove formal theorem p correct program graph isomorph c p gi alway output correct p g h incorrect probc p gi output correct moreov c p gi run polynomi time gi run polynomi time way count run time checker p bug g isomorph h c p construct isomorph g h correctli output correct p bug g isomorph h c p coin discov output correct p g h incorrect two case p g h ye g isomorph h c p gi fail construct isomorph sinc none exist correctli output buggi p g h no g isomorph h way c return correct p g g orh ye whenev coin come head come tail g isomorph h sinc g h permut randomli produc g h g h probabl distribut therefor p correctli distinguish g chanc ie k possibl sequenc coin toss beigel theorem follow theorem due richard beigel theorem beigel let two polynomialtim equival decis problem polynomi time checker possibl construct polynomialtim checker proof simplic assum initi decis problem reduc karp reduct checker c program p also two way polynomialtim transform f f go respect exist f give us program p defin term f p p x defin p f x way count run time checker check program p call p accomplish polynomi time sinc f polynomialtim function call p count step check p instanc comput p y transform instanc z use function f use checker c check correct p z call checker make p includ call instanc z transform polynomi time call p procedur describ abov convinc correct p z convinc us correct p y p correct p defin term p too thu checker find p correct z convinc us p correct y p wrong y two case p correct z discov contradict immedi p wrong z checker c design catch precis situat declar p buggi therebi convinc buggi p checker describ run polynomi time let n length instanc check run time checker broken follow three compon ffl run time checker instanc whose length polynomi n ffl one applic transform f input length n ffl polynomi number applic transform f input whose length polynomi n show theorem hold even problem possibl search problem reduct problem cook reduct case also program p defin term p proof correct checker essenti follow along line proof case karp reduct detail check program make polynomi mani call p input transform f replac program take instanc polynomi time produc set instanc queri also transform f one particular applic beigel theorem graph isomorph sinc graph isomorph known polynomialtim checker problem polynomialtim equival graph isomorph also checker import note statement beigel theorem requir equival follow exampl suggest reduct one direct suffici observ group isomorph gi reduc extend group isomorph egi group given multipl tabl gi differ egi ye answer former explicit isomorph latter know effici checker egi gi gener beigel theorem let f complex class let problem reduc f suppos checker f condit give us checker f consid situat f determinist time complex class situat similar replac time complex circuit size circuit depth time complex class nc n time complex function suppos algorithm whose run time bound fn input length n put problem f call f time complex function f call complex class f robust two time complex function f g f time complex function f word f robust class sum product composit two time complex function f time complex function f exampl robust time complex class includ p log o n theorem let f robust time complex class two problem reduc f c checker f checker c f proof sketch checker c construct along line checker construct beigel theorem run time analysi note definit robust precis one need guarante c lie f use fact algorithm run time fn make fn call oracl such program check produc output transform instanc whose length bound fn input length n thu run time checker bound sum product composit run time two reduct checker true even case reduct problem cook reduct corollari equival ncreduct ncchecker proof although nc time complex class proof follow robust class nc complex function nc thought order pair function depthn sizen function class p depthn function log o n sum product composit complex function comput componentwis order pair repres function sinc argument theorem robust time complex class hold depth size well robust class p log o n establish robust complex function nc turn impli checker nc ncchecker problem p use gener version beigel theorem prove pcomplet problem checker nc theorem p complet problem checker nc proof light gener version beigel theorem suffici prove pcomplet problem checker nc pcomplet problem nc reduc other particular pcomplet problem provid ncchecker lexicograph first maxim independ set lfmi problem ncchecker lfmi lexicograph first maxim independ set lfmi input graph g vertic number n vertex v graph output ye lfmi contain vertex v no lfmi not present ncchecker inform algorithm pram detail pram model see instanc step th processor ask whether v lfmi thu processor determin lfmi step step associ vertex group n processor th group processor associ v assum answer obtain step queri correct assumpt check see answer queri v correct done o time sinc v lfmi iff edg v smaller number vertex lfmi thu crcw pram model checker run o time use on proce sor step care allow us reduc processor count on m alreadi mention find nc checker lfmi give us ncchecker pcomplet problem interest prove most difficult problem p checker nc although know whether decis problem p checker nc ncchecker pcomplet problem big open question whether npcomplet problem checker p fact neg evid question checker group theoret problem mani group theoret problem checker resembl graph isomorph subsect show two fairli gener class exampl give gener approach checker construct work particularli well group theoret problem work group theoret problem group theori rich sourc problem checker elementari properti group lagrang theorem often exploit design checker structur group often impli relationship among correct answer differ instanc relationship use check consist program sometim consist check proven suffici ensur correct program instanc checker graph isomorph describ introduct view group theoret checker sinc problem graph isomorph polynomialtim equival problem determin automorph group graph graph isomorph essenti check consist program case program say input graph g h isomorph structur problem impli g random permut g isomorph g isomorph h g isomorph random permut h h comput use extens tool group theori fact classif finit simpl group motiv aid comput calcul classif shown group belong infinit famili group group refer sporad group exist sporad group confirm comput construct reason check group theoret problem fruit endeavour equival search canon element problem problem and correspond checker describ subsect state term set element group g act s a b s defin jg b g let esp s g denot equival search problem otherwis proposit let esp s g equival search problem given g suppos exist effici probabilist algorithm find random g g accord uniform distribut effici program checker c p problem esp s g exampl equival search problem includ graph isomorph quadrat residuos gener discret log game rubic cube exampl aris knot theori block design code matric gf q latin squar page applic burnsid polya theorem relat equival search problem equival decis problem defin by equival decis problem edp instanc question jg b would nontrivi prove similar proposit edp esp seem reduc edp follow argument indic recal n posit integ z n denot group posit integ less n rel prime n group oper multipl mod n p prime let action g g map g mod p observ jg b b g mod p g z suppos given oracl factor find g b g mod p essenti solv discret log problem cryptograph circl believ solvabl polynomi time even given oracl factor hand edp solvabl polynomi time given oracl factor proof consist show mod p g orderbjordera x exactli ordera solut name a final ordera orderb determin factor p gamma canon element problem cep input output c g c uniqu canon element equival class a g g proposit effici program checker canon element problem provid probabilist procedur select random g g effici remark cep program fail two canon element class defin true canon element class uniqu element ani half element class map program group intersect problem use twostep approach design checker group intersect first design interact proof system show interact proof system convert checker babai moran independ and earlier provid interact proof system group intersect use checker group intersect beigel trick obtain checker sever problem known polynomi equival group intersect first briefli discuss variou represent group comput three common represent use increas order difficulti manipul are multipl tabl represent permut group represent abstract group represent multipl tabl represent explicitli specifi product pair group element permut represent group thought act set group element permut group oper composit usual group specifi specifi polynomi mani size set gener permut abstract group represent group present gener relat relat specifi amongst them relat impli specifi relat hold gener complet specifi group describ checker group intersect problem follow group intersect problem input two permut group g h specifi gener output gener g h let n size set g h act gener specif gener set g n bit done polyn bit henc take input length n probabilist polynomialtim algorithm known solv group intersect problem surpris sinc graph isomorph polynomialtim reduc group intersect follow interact proof protocol work group intersect ip protocol prover send verifi set permut supposedli gener verifi check element sent prover actual lie g h involv test membership g h verifi method consequ verifi convinc element sent prover either gener proper subgroup it verifi send prover element gh obtain select random element multipli togeth prover send back factor b g b h verifi check gamma element group gener gener prover provid step theorem protocol step repeat k time allow prover k probabl cheat verifi proof denot group gener gener prover send step clear step g h step aim give verifi random element g h follow lemma effect lemma notat protocol gamma random element g h ab g b h x thu two factor element recov comput gamma x thu x uniqu factor along remain prove everi pair factor correspond element g h suppos two factor ab rearrang gamma left hand side last equat element g right hand side element h sinc equal element must belong g h random factor ab impli random element g h obtain procedur sinc prover know factor ab use verifi proof lemma essenti complet proof theorem use lagrang theorem note proper subgroup g h random element g h belong probabl half perform k repetit step reduc error probabl k convert ip protocol checker verifi protocol ask prover factor certain element gh convert ip protocol checker one must show program group intersect use factor element gh factor search problem fsp shown equival group intersect problem one could use program group intersect factor fsp follow problem factor search problem input two permut group g h permut output no gh g b h ab otherwis associ factor decis problem fdp known equival group page follow lemma show equival fsp fdp lemma fdp equival fsp proof obviou fdp reduc fsp remain shown fsp reduc fdp proof reli notion strong gener introduc assum strong gener g h defin furst hopcroft luk assum without loss gener set gener convert set strong gener polynomi time brief descript notion strong gener mg group g mg size permut domain matrix entri diagon diagon posit ij entri permut g fix pointwis element move j case permut exist ij th entri permut g conveni and customari make diagon entri ident permut properti represent given without proof everi element g express uniqu way product n row mg use convent string permut leftmost one act first rightmost one last consequ previou fact jgj product number nonempti entri row mg anoth consequ random element g obtain multipli togeth random element row mg also g subgroup g fix point gener entri row n mg final membership g permut oe test follow oe move j look posit j entri none exist oe g otherwis entri oe fix point move second row check membership g proceed thu either find oe g find express oe product entri mg suppos gh consid h subgroup h consist permut fix point sinc gh ab g b h also b equal product oe n oe th row mh thu permut oe first row mh abo gh use oracl fdp find entri first row mh properti entri oe consid oe factor gh factor gh yield factor gh seen techniqu appli recurs yield factor gh complet reduct show ip protocol describ convert checker problem fp section program checker use oracl to determin sever time case instead program checker denot c p denot c k latter notat advantag clarifi must test for case checker nonprobabilist denot c instead mani problem fp effici program checker challeng find them follow give fairli complet descript program checker three problem becaus one oldest nontrivi algorithm book sort becaus one frequent solv problem matrix rank becaus unusu seem requir multical checker twosid error extend gcd problem integ gcd is given two integ b find gcd b adleman huang kompella recent given probabilist checker problem extens problem make easi check idea extend problem without incur addit run time solv extend problem import one area program check extend gcd input two integ b output integ integ u v check gcd checker perform arithmet oper ffl check divid b valid check obviou definit gcd point convinc divisor b ffl check b done three arithmet oper justifi check show two check convinc us gcd refer follow standard lemma lemma let b posit integ smallest posit integ express integ combin b gcd d sort hardli necessari mention sort one commonli solv problem comput scienc larg number algorithm avail sort fairli complex program thu necessari check output sort program sort trivial check comparison tree model model input output given order input variabl permut oe output x checker sort confirm output inequ valid done use fact use linear number oper reason model comput gener assum output point input came from check sort mere check output right order ram model comput easi check sort linear time ram reflect mani sort scenario defin problem sort provid reason model comput sort input array integ x x repres multiset output array consist element x list nondecreas order model comput comput fix number tape includ one contain x anoth contain x n element element rang a random access memori olog nlog a word memori word capabl hold integ rang a particular word hold element ffl singl precis oper gamma theta take one step denot integ divid ffl multiprecis oper gamma step integ word long step addit machin usual oper shift tape copi word tape ram vice versa take step model comput describ easi check output list order on step need also check multiset done probabilist on step right method depend rel size n n simpl bucket sort work need bucket number rang a sinc log n random access memori space enough bucket thu could run valu x put one appropri bucket could run element take one appropri bucket time bucket tri take valu turn empti checker declar program buggi situat interest case present follow two method check multiset equal method method but specif import choic hash function first suggest wegman carter comput check jy select x probabl least sum differ see remov x largest submultiset element common both result x still size intersect empti comput two sum equal set hx distinguish x sum differ set hx distinguish two either case h probabl distinguish two set sinc random function requir enorm number random bit replac random function h suitabl chosen hash function choos easi comput hash function difficult wegmancart hash function particular requir random access memori henc cannot implement model comput differ hash function work recal select random prime p interv delta delta log m set inde prime p x point karp rabin least half prime interv deltaa delta log m choic interv size aris estim larg get sinc sum n term term bound sum bigger n delta sinc bound sum a interv chosen suitabl constant time log a thu show prime randomli chosen interv delta delta log m hash function probabl least catch error method idea first suggest lipton recent ravi kannan multiset iff g sinc f g polynomi degre n either n gamma valu z probabilist algorithm decid select k valu random set n or more possibl say n compar fz gz k valu comput kept reason size arithmet oper modulo randomli chosen small prime comput product fz term bound absolut valu n henc product bound a accord prime chosen approxim rang n loga compar two method show regardless rel valu n one method alway run time on log n comparison method recal multiset n integ rang a also recal n bucket sort use check comput sinc word size model olog a n prime method fit constant number word number word w requir hold prime method omax log n log run time method on log a need perform log multipl comput i constant time oper sinc prime moduli constant number word long run time method function number word w equal nw sinc n multipl perform number w word long overrid cost method describ transit one method anoth decreas function n use bucket sort n becom less long n log on log n use method run time on log a instanc could use method long n greater log log threshold valu n log n log log log log henc log olog n n dip threshold prime method fit log log word method run time onlog log a notic typic case sort n a case method run linear time thu algebra finagl mainli prove exist littl oh checker rel valu n a check matrix rank subsect describ checker matrix rank checker rank mainli theoret interest satisfi littl oh properti requir howev make on call program check henc would highli ineffici implement practic blum lubi rubinfeld subsequ discov practic checker matrix rank howev checker conform origin definit check instead use idea program matrix multipl check check rank one call matrix multipl program count call one step consid matric whose entri drawn finit field f let p program take matrix input output integ r supposedli rank describ checker p checker given integ k unari k desir confid checker output ie probabl checker wrong o k describ checker three part first part checker produc r x r submatrix supposedli full rank process selfreduct use program obtain intermedi answer part checker check result r x r matrix inde full rank incident prove rank origin matrix least r final also need ensur rank r done part checker selfreduct let n x matrix input p suppos p output r let u um column delet u feed result matrix p p say the rank endfor number column remain r return selfreduct obtain r column vector supposedli linearli independ r column nvector selfreduct row n x r matrix have arriv r x r matrix supposedli full rank cours want take program word matrix full rank need check matrix actual full rank thu even program return wrong answer cours selfreduct detect declar program bad done part checker lower bound rank r x r matrix full rank column matrix form basi f r case everi vector f r uniqu represent linear combin column vector matrix part checker exploit uniqu represent r column r x r matrix supposedli full rank idea creat k linear combin x r column matrix suppos exampl toss fair coin come head subtract c v x otherwis choos random c f subtract av x expect x basi x clearli true v form basi suppos v form basi then let v j first v s nonzero coeffici depend relat among v s v j could coeffici linear combin produc x coeffici v j affect valu coeffici v thu program way distinguish situat subtract c j time v j situat subtract multipl v j thu linear combin x program probabl escap undetect wrong claim independ idea yield requir algorithm describ below gener k random linear combin let k random combin x k j r begin toss fair coin head els random c j replac v j origin matrix ask program rank new matrix head rank r gamma return program bad tail rank r return program bad endfor endfor clear program wrongli claim independ probabl k escap detect upper bound rank go back origin matrix column um selfreduct left r column say supposedli linearli independ ndimension space randomli pick vector x vector u basi n dimension space use program help decid set n column have full rank program say not redo experi pick vector x follow lemma lemma r independ probabl greater posit constant delta delta delta n vector obtain augment r random vector b form basi f n proof worstcas occur f gf requir build random basi scratch case number good choic th vector out total n choic work probabl th vector independ first gamma yield result lemma clear lemma random trial constant probabl succeed ie produc basi perform experi ok time program alway say set vector depend report program buggi know correct overwhelm probabl howev small chanc k program right unlucki enough hit upon basi next need follow lemma lemma u depend u linear combin u depend u one u depend u linear combin u depend u probabl half proof first statement lemma obviou second part suppos u rj independ u linear combin x depend chang coeffici u rj anyth els besid one x make new vector independ count establish least mani independ combin depend one equal occur case vector space gf lemma suffic check k random linear combinationsi u depend u ensur probabl program correct suppos one independ u denot follow let uniqu express linear combin u r lemma represent c r probabl nonzero probabl choic random extens basi although program influenc distribut random extens statement lemma still hold vector space gener first vector basi let w complement v r take appropri compon vector w problem restat follow suppos random basi z l w ldimension space nonzero vector w basi vector coeffici uniqu represent linear combin basi vector nonzero probabl prove statement fix vector respect random basi thought equival random vector respect random basi for let random nonsingular l x l matrix consid correspond set base set base take basi z l basi az ay imag linear transform a nonsingular a random vector w new basi random basi w correspond abov given basi random vector w gener randomli pick coeffici basi vector thu random vector probabl coeffici zero result translat back fix vector y result lemmata note u depend high probabl one replac one x basi u idea yield follow checker repeat k time toss fair coin head w random linear combin origin basi nonzero coeffici x j els w random linear combin origin basi without x j nonzero coeffici replac x j w feed result matrix p head rank r reject program tail rank reject program endrepeat endfor endfor clear program wrong origin claim u um depend escap detect probabl k thu checker error probabl o k number place overal probabl error bound sum probabl therefor o k analysi run time expens oper creation random linear combin mani vector care taken keep number oper down part checker self reduct run on time part gener k linear combin take time okn loop repeat onk time run loop take time on thu overal run time part okn part gener random basi take okn time sinc might gener kn differ vector finish creat k linear combin take okn time bottleneck howev loop repeat ok time pass take on time thu overal complex checker ok n point discuss amount time charg call program analysi made call charg step justifi least theoret sens follow assum model checker queri tape write instanc program run call program could justifi charg amount time take modifi queri tape order produc new instanc previou instanc queri possibl use suitabl data structur implement modif o step comput checker character theorem section character set problem check polynomi time purpos section checker run polynomi time call effici take definit ip interact proofsystem definit appear gold wasser micali rackoff except replac for suffici larg x definit for x modif conform commonli accept definit ip appear exampl goldwass sipser tompa woll functionrestrict ip cofunctionrestrict ip set decis problem interact proof system yesinst noinstanc satisfi condit prover honest prover must comput function prover dishonest prover must function set instanc fye nog restrict impli two thing verifi may ask question instanc prover and prover must answer verifi question answer independ prover prover previou histori question answer theorem effici program checker c exist decis problem lie function restrict ip cofunctionrestrict ip proof theorem immedi definit effici program checker complex class functionrestrict ip let npsearch denot class problem x no x noinstanc ye togeth proof x yesinst otherwis corollari let np search problem effici program checker c exist functionrestrict coip main purpos corollari point np cofunctionrestrict ip seem like effici program checker c in sens npcomplet problem note result lund et al shamir give functionrestrict ip proof npcomplet languag overview conclus thrust paper show mani case possibl check program output given input therebi give quantit mathemat evid program work correctli input allow possibl incorrect answer just one would comput done hand program design confront possibl bug consid answer wrong give altern prove program correct may achiev suffici mani situat one way develop theori would requir program checker prove correct paper howev pure check mean proof correct whatsoev instead requir checker c differ program p check two way first inputoutput specif c differ p c get p s output respond correct buggi second demand run time checker os run time program check prevent programm undercut approach could otherwis simpli run program second time call check whatev els programm doe must think problem acknowledg grate ronitt rubinfeld mani long convers marvel idea includ extens check idea parallel comput she sandi irani raimund seidel design interest checker variou problem comput geometri convex hull wish thank well russel imapagliazzo shafi goldwass len adleman idea enthusiast support r effici checker numbertheoret problem mathemat proof comput system correct hide instanc multioracl queri incoher without hard design program check work check correct memori correct problem comput scienc two notion correct relat test taxonomi problem fast parallel algorithm softwar test evalu social process proof theorem program local random reduct interact complex theori fast probabilist algorithm proof yield noth valid languag np zeroknowldeg proof system knowledg complex interact proof system public coin vs privat coin interact proof system finit simpl group introduct classif person commun s program checker probabl gener effici random pattern match algorithm parallel algorithm sharedmemori machin help robust oracl machin comput automorph group combinatori object new direct test algebra method interact proof system note graph isomorph count problem combinatori enumer group probabilist algorithm design checker program run parallel robust algorithm differ approach oracl random selfreduc zero knowledg interact proof possess inform evalu programbas softwar test data adequaci criteria new hash function use authent set equal tr taxonomi problem fast parallel algorithm softwar test evalu combinatori enumer group graph chemic compound help robust oracl machin arthurmerlin game random proof system hierarchi complex class evalu programbas softwar test data adequaci criteria knowledg complex interact proof system design program check work hide instanc multioracl queri selftestingcorrect applic numer problem program checker probabl gener parallel algorithm sharedmemori machin proof yield noth valid languag np zeroknowledg proof system check correct memori algebra method interact proof system randomselfreduc complet set incoher without hard effici checker numbertheoret comput social process proof theorem program correct problem comput scienc ctr christian collberg stephen g kobourov jessica miller suzann westbrook agovista tool enhanc algorithm design understand acm sigcs bulletin v n septemb thoma sterl daniel s katz larri bergman high perform comput system autonom spaceborn mission intern journal high perform comput applic v n p august edgar f a leder romeo a dumitrescu specificationconsist coordin model comput proceed acm symposium appli comput p februari march atlanta georgia unit state christian collberg stephen g kobourov suzann westbrook algovista algorithm search tool educ set acm sigcs bulletin v n march dick hamlet continu softwar system acm sigsoft softwar engin note v n juli ronitt rubinfeld madhu sudan selftest polynomi function effici ration domain proceed third annual acmsiam symposium discret algorithm p septemb orlando florida unit state dick hamlet dave mason denis woit theori softwar reliabl base compon proceed rd intern confer softwar engin p may toronto ontario canada zhizhong chen mingyang kao reduc random via irrat number proceed twentyninth annual acm symposium theori comput p may el paso texa unit state t y chen t h tse zhiquan zhou semiprov integr method base global symbol evalu metamorph test acm sigsoft softwar engin note v n juli paul ammann dahlard l luke john c knight appli data redund differenti equat solver annal softwar engin p a arbaugh jame r davin david j farber jonathan m smith secur virtual privat intranet comput v n p septemb amit paradkar toward modelbas gener selfprim selfcheck conform test interact system proceed acm symposium appli comput march melbourn florida t y chen fc kuo zhi quan zhou effect test method endus programm acm sigsoft softwar engin note v n juli daniel lewin salil vadhan check polynomi ident field toward derandom proceed thirtieth annual acm symposium theori comput p may dalla texa unit state christian s collberg todd a proebst problem identif use program check discret appli mathemat v n p decemb peifeng hu zhenyu zhang w k chan t h tse empir comparison direct indirect test result check approach proceed rd intern workshop softwar qualiti assur novemb portland oregon w k chan m y cheng s c cheung t h tse automat goalori classif failur behavior test xmlbase multimedia softwar applic experiment case studi journal system softwar v n p may borislav nikolik test suit oscil inform process letter v n p fast approxim probabilist checkabl proof inform comput v n p march fast approxim pcp proceed thirtyfirst annual acm symposium theori comput p may atlanta georgia unit state ronen shaltiel christoph uman lowend uniform hard vs random tradeoff am proceed thirtyninth annual acm symposium theori comput june san diego california usa dan gutfreund ronen shaltiel amnon tashma np languag hard worstcas easi find hard instanc comput complex v n p decemb manindra agraw somenath biswa primal ident test via chines remaind journal acm jacm v n p juli dan gutfreund ronen shaltiel amnon tashma uniform hard versu random tradeoff arthurmerlin game comput complex v n p septemb taejoon park kang g shin soft tamperproof via program integr verif wireless sensor network ieee transact mobil comput v n p may rahul santhanam circuit lower bound merlinarthur class proceed thirtyninth annual acm symposium theori comput june san diego california usa shafi goldwass dan gutfreund alexand heali tali kaufman guy n rothblum verifi decod constant depth proceed thirtyninth annual acm symposium theori comput june san diego california usa valentin kabanet russel impagliazzo derandom polynomi ident test mean prove circuit lower bound proceed thirtyfifth annual acm symposium theori comput june san diego ca usa lori a clark david s rosenblum histor perspect runtim assert check softwar develop acm sigsoft softwar engin note v n may luca trevisan salil vadhan pseudorandom averagecas complex via uniform reduct comput complex v n p decemb christian s collberg clark thomborson watermark tamperprof obfusc tool softwar protect ieee transact softwar engin v n p august valentin kabanet russel impagliazzo derandom polynomi ident test mean prove circuit lower bound comput complex v n p januari marco kiwi frdric magniez miklo santha exact approxim testingcorrect algebra function survey theoret aspect comput scienc advanc lectur springerverlag new york inc new york ny