t synerget effect compil architectur manual optim perform cfd multiprocessor a paper discuss comprehens perform profil improv benchmark comput fluid dynam code one grand challeng applic three popular multiprocessor process analyz perform consid languag compil architectur algorithm chang quantifi increment contribut bottomlin perform demonstr parallel alon cannot result signific gain granular parallel thread effect parallel data local taken account unlik benchmark studi often focu perform effect parallel compil specif loop kernel use entir cfd code measur global effect compil parallel architectur probe perform bottleneck case deriv solut elimin neutral perform inhibit factor major conclus work overal perform extrem sensit synerget effect compil optim algorithm code tune architectur idiosyncrasi b introduct despit continu quest achiev high perform complet scientif applic obtain fraction expect speedup modern multiprocessor hand prolifer parallel architectur throughout spectrum comput system indisput would argu signific parallel even fewer would suggest parallel machin deliv perform user come expect paper mean grand challeng applic show compil architectur limi tation algorithm characterist restrict perform sever amdahl law suggest even case parallel may abund result indic synerget approach simultan address limit result signific perform payback work focus comprehens multilevel analysi complet commerci scientif applic comput fluid dynam cfd code base simpl semiimplicit method pressurelink equat paper report perform bottleneck hardwar architectur compil oper system import manual optim code tune hand optim use work improv perform well as isol hardwar bottleneck point possibl architectur softwar improv allevi perform limit multiprocessor machin experi use three commerci multiprocessor sgi challeng alliant fx alliant fx use two commerci two experiment parallel compil result suggest user cfd applic expert code optim andor comput architectur expect see littl ani perform improv run code multiprocessor true even presenc power automat parallel compil tool effect expert intervent even though result singl commerci applic cannot gener across spectrum scientif applic size type code make cfd program repres converg time iterationsolv continu equat solv nseqz compon solv nseqi compon solv nseqx compon boundari condit boundari condit boundari condit boundari condit set time input data output result coefv coefv coefv corect coefp solv system set coeffici system set coeffici system set coeffici system set coeffici system solv system solv system solv system add p p figur algorithm cfd applic simpl linear system solver pde solver core major numer applic mani perform evalu benchmark studi employ select kernel complet applic may amen automat parallel parallel execut resist approach work consid perform entir applic profil perform compon cfd code weight contribut overal speedup result hand optim target compil code tune avoid architectur bottleneck signific improv overal perform find also underscor need predict maximum possibl theoret perform gain given applic upper bound perform could use refer point automat manual parallel come surpris runtim overhead play import role perform serial bottleneck amdahl law cfd code experiment environ inflowm x z densiti kgm figur model cube divid mesh direct cfd program base simpl method outlin figur algorithm first increment time step step figur iter solv navierstok equat comput veloc step continu equat step converg step figur consist three modul i assembl system linear equat discret ii modifi equat accord boundari condit iii solv system linear equat employ miccg modifi incomplet choleski conjug gradient solv continu equat modul solvep ilucr incomplet lu conjug residu solv navierstok equat modul solvev perform evalu use dimension space shown figur experi measur entir cfd code except input output data identifi step figur perform result code measur compar three multiprocessor system alliant fx alliant fx sgi challeng alliant fx processor mimd system processor vector unit processor share quadrant cach alliant fx next gener mimd machin alliant processor machin use intel processor final sgi system use experi sgi challeng configur processor machin use measur specifi explicitli experiment section execut time paper measur dedic mode three machin measur repeat sever time averag taken case standard deviat equival experi repeat thu measur report standard deviat almost zero serial parallel version cfd code use measur machin use term serial parallel refer serial parallel execut time respect serial parallel version cfd compil use two experiment parallel compil manufacturersuppli parallel machin explain below serial serial version cfd code use measur serial execut time compil use nativ nonparallel compil optim option turn on parallel case parallel execut time comput run parallel version cfd obtain follow origin code compil system nativ parallel compil alliant use alliant compil automat parallelizationvector option sgi challeng use sgi parallel fortran acceler pfa parafras polari origin code compil experiment sourcetosourc parallel compil parafras polari parallel sourc output two parallel compil backend fortran compil machin sgi alliant backend compil parallel loop explicitli indic follow section increment effect compil system architectur manual optim limit overal perform discuss effect compil parallel optim section discuss effect automat parallel cfd code moreov consid specif limit compil test identifi sever area potenti improv allt coefv coefp corect normal execut serial parallel ppolari alliant fx serial parallel ppolari alliant fx serial parallel ppolari figur perform automat parallel execut processor parallel indic execut time run applic use comput nativ compil term function perform four compil test cfd code machin figur show normal execut time cfd code machin use four compil took serial execut time as defin abov normal time nativ parallel system use comput time label parallel figur differ shade bar correspond execut time modul cfd code illustr figur first clear observ none four compil improv perform significantli best case speedup automat parallel cfd dismal perform circumst cours could due serial natur underli algorithm howev shown later case cfd code expos signific amount parallel none parallel compil abl exploit due number reason figur evid four compil perform uniformli poorli hardli signific differ observ closer observ output code reveal parafras polari a local variabl els endif b statement f reduct figur code sampl illustr compil bottleneck fact parallel signific number loop howev much expos parallel expens exploit three machin although experiment compil power pfa alliant compil tend extract maxim parallel regardless impact perform result parallel execut small loop result execut time wors serial time clearli point need compiletim determin exploit nonexploit paral lelism exist compil provid even rudimentari support determin qualiti expos parallel group four compil pfa provid capabl comput tradeoff runtim overhead amount parallel although cfd loop parallel experiment compil perform sgi challeng notic wors two alliant due mostli architectur bottleneck sgi challeng whose effect profound alliant examin architectur bottleneck later section order better understand character poor perform compil use cfd code isol largest loop character serial parallel undetermin serial undetermin version examin loop hand determin caus serial partial parallel follow discuss limit compil identifi highyield optim significantli improv perform tabl character parafras polari term import optim give percentag improv serial execut time cfd processor sgi challeng time normal serial execut time taken observ signific payoff due local variabl recognit alloc loop follow comparison limit analysi sgi consid two experiment compil sgi pfa a local variabl loop present parafras cannot parallel loop localiz variabl one shown figur a unless invok scalar expans pass howev scalar expans pass power enough handl mani loop code polari effect identifi local variabl result parallel simpl loop privatar localiz variabl b statement loop parafras much effect parallel loop whose bodi contain statement loop figur b polari howev cannot parallel loop sinc larg loop local variabl branch neither parafras polari could parallel loop branch local variabl although experiment compil deal effect either local variabl recognit branch insid loop neither could handl combin local variabl control flow statement insid loop bodi result appli optim manual origin code code involv index express order two miss compil pfa alliant compil even weaker respect depend analysi power depend analysi scheme necessari order improv effect automat parallel previous fals tabl characterist parafras polari bottleneck parafras polari impact local variabl loop weak ye b statement loop ye c index express higher order e distribut strongli connect compon reduct optim depend due higher order index express manual remov d loop distribut although parafras effect distribut loop appli loop distribut possibl case result larg number rel small loop even though may desir gener vector code may counter product case parallel loop ideal distribut loop enabl parallel loop figur d typic case reason distribut pass use experi handoptim version distribut loop manual help distribut strongli connect compon loop shown figur e cannot parallel polari parafras howev two statement bodi loop distribut find distribut loop paralleliz current way determin legal distribut automat compil would abl execut loop symbol order determin legal distribut thu automat parallel loop typic reduct shown figur f loop reduct cannot parallel parafras polari parallel back end compil handl reduct reduct oper parallel break loop sever part sum part and final calcul total sum parallel version code add element togeth differ order sequenti version roundoff error accumul differ two version code thu answer may differ slightli impact optim shown tabl express improv relat optim thu aggreg improv appli optim necessarili equal sum individu improv exampl first row tabl show improv execut time specifi local variabl parallel loop includ loop branch contribut improv shown second row tabl incorpor optim discuss section perform cfd code improv achiev speedup automat parallel prove ineffect case cfd code especi sgi challeng incorpor improv particular transform may result signific payoff implementationimprov transform would necessari achiev improv suggest tabl perhap one least look issu parallel compil use versu useless parallel equival coars fine grain parallel compil need abil quantit analyz section code determin tradeoff payoff cost particular tran format symbol program analysi provid power mean comput symbol size code section howev except parafras compil provid capabl architectur bottleneck compil transform manual incorpor code perform parallel version compar sgi challeng alliant machin impact architectur bottleneck profound sgi multiprocessor as shown section alliant mostli due cost enforc cach coher a nonexist problem alliant use share cach limit bu bandwidth therefor experi solut architectur bottleneck focus sgi challeng runtim overhead tabl cost schedul synchron oper sgi oper initi subsequ use createus thread barrier entri barrier exit sec order put follow experiment result perspect first measur overhead associ primit oper bookkeep function sgi challeng cost issu parallel loop iter barrier synchron set thread use parallel loop execut use sgisuppli timer make detail perform measur tabl show cost creat thread cost reus exist thread loop iter assign empti thread cost sec cost creat thread extrem high indic tabl approach sec howev cost paid per thread thread recycl subsequ parallel loop nevertheless accumul runtim overhead thread creation thread assign loop iter high detriment perform applic small number loop andor loop small loop bodi barrier synchron overhead measur pair number barrier entri exit former comput time differ complet last first processor includ skew due load balanc latter measur differ time last iter complet execut time loop exit figur show spacetim diagram execut parallel loop iter larg loop bodi figur show startup phase with exist thread complet phase processor assign one iter parallel loop top horizont bar indic time execut enter loop time loop complet execut although right part figur show notic unbal processor complet within interv total execut time loop although sgi support gang schedul parallel loop all processor start loop simultan observ notic differ among processor start execut differ due l iter number time sec iter number time sec figur diagram processor cdoacross localj i j a program emul fals share cdoacross localj r i j air b elimin local variabl dimens ad j c elimin keep array separ figur share synchron overhead associ exclus access loop index case processor total approxim sec spent lock updat loop index sec lock oper approxim term total overhead associ processor particip execut parallel loop lower bound sec equival approxim clock cycl therefor parallel execut start pay loop whose bodi contain instruct fals share fals share occur multipl processor access and cach small section memori although memori access may truli independ may treat access share data figur a show loop give rise fals share like mani complic loop cfd code fals l timesec iter number a time stamp figur a proc local time sec b execut time figur b c figur perform share fals share enforc cach line level byte word level thu processor write byte cach line entir line invalid modifi byte discuss two techniqu avoid fals share measur effect perform sampl code first solut fals share use local variabl wherev possibl shown figur b loop manual rewritten order make explicit use local variabl execut time loop figur b vari number processor shown second column figur b header local second approach spread alloc share data memori separ address differ cach line size improv illustr code exampl c last three column figur b show execut time loop figur c three differ alloc share array d distanc number array element variabl access success loop iter notic worst perform observ d correspond maximum amount fals share sinc cach line size sgi challeng byte elimin fals share keep element thread number shown ital display poor perform share array spread wide enough avoid fals share worth note execut time local variabl version better share array version due effect local variabl whose valu written back memori suspect regist effect use them local variabl allow support write back memori dimens anmax store data local cach c cdoacross localjji sharea j inmax execut time loop figur program emul bu content iadd switch paramet iadd bu content iadd bu content valu thu reduc perform implicitli suggest although avoid fals share either method use local variabl appear effect possibl due opportun extens regist reus none compil test abl handl effect problem fals share bu content clearli local data import cach perform also minim memori access network traffic busbas multiprocessor sgi challeng bu content seriou perform bottleneck modul cfd code perform poorli due combin fals share bu content bu content measur compar perform two almost ident loop kernel figur first version loop need data local cach iadd iadd loop access data present local cach processor request signific amount data share memori remot cach anticip bu content vari number processor attempt data transfer read local cach read also cach proc time msec a kb read local cach read also cach proc time msec b mb figur influenc bu content perform simultan measur perform effect bu content chang size array number processor use execut kernel figur size array nmax taken element equival kb mb respect execut time parallel loop shown figur array size kb worst case scenario increas execut time processor cach miss account differ array size mb execut time longer compar case cach entir array local cach perform differ cannot attribut cach miss alon fals share play role case sinc data skew appropri share memori order avoid fals share thu bulk slow due bu content although attempt separ perform loss due cach miss due bu content possibl measur event level clock period softwar timer alliant avoid network content due fals share coher gener sinc neither applic perform alliant limit raw bu bandwidth satur larg array access cach simultan differ processor x z a b line execut parallel allow execut serial parallel loop execut serial c plane execut parallel figur comput order a origin serial code b dimension hyperplan method c dimension hyperplan project method algorithm chang section discuss extens hand recod cfd code border algorithm chang although current compil technolog insuffici perform type code restructur futur parallel compil could potenti perform restructur comput not languag level order improv degre qualiti exploit parallel order improv perform timeconsum modul cfd code chang order calcul perform without violat algorithm depend addit exploit nonloop or function parallel comput veloc latter involv chang algorithm simpl among seven modul shown figur solvep solvev coefv timeconsum modul coefv extens parallel compil optim discuss section structur calcul solvep solvev similar thu limit discuss solvep similar approach use solvev detail handrestructur code given paper outlin chang highest possibl level comput solvep sweep dimension structur shown figur a parallel difficult case due depend point comput depend three immedi neighbor x y z dimens figur b show one alter order comput respect converg time iter set time input data output result solv continu equat solv nseq solv nseq z compon solv nseq y compon figur parallel simpl algorithm veloc certain subcomput step distribut step three dimens without chang underli algorithm order shown figur b yield maximum amount parallel sinc element within crossdiagon plane comput parallel refer dimension hyperplan method howev plane close begin end cube contain element translat parallel loop iter provid littl opportun exploit cach local sensit runtim overhead figur c show altern order calcul solvep organ comput across diagon plane adopt optim cfd code refer approach dimension hyperplan project method although parallel less case b result parallel loop longer bodi sweep across element plane direct arrow thu parallel loop iter perform comput element local vector local data profound effect perform case addit larger granular parallel loop iter contribut amort overhead result restructur base figur c outperform one base b speedup achiev solvep version figur b c processor sgi challeng respect final manual chang code target exploit nonloop parallel figur show altern order perform comput within iter algorithm illustr figur code restructur order take advantag simultan comput across x tabl perform improv parallel compon veloc part serial parallel speedup coefv coefp corect normal execut serial parallel ppolari mcom mcomalg mall alliant fx serial parallel ppolari mcom mcomalg mall alliant fx serial parallel ppolari mcom mcomalg mall sgi challeng figur perform processor parallel refer parallel nativ compil z compon model done structur calcul across dimens shown figur addit highlevel parallel result simultan execut three solver parallel loop level still exploit within compon approach expect yield better perform due significantli higher degre data local tabl show speedup new cfd code nonloop parallel exploit unabl exploit function loop parallel sgi challeng due fact system allow one level parallel nest parallel support pfa compil runtim librari perform analysi figur give comprehens account perform cfd code three multiprocessor set automat manual optim incorpor three group execut time bar one three multiprocessor use experi alliant fx fx sgi challeng respect shadeskey right handsid figur show correspond variou shade bar major modul cfd code defin figur case seven perform bar shown follow data left right leftmost bar group correspond normal serial execut time cfd code machin serial optim turn on execut time normal respect serial execut time next three bar label parallel p polari correspond parallel execut time code machin code compil manufacturersuppli parallel parafras polari respect ident time shown figur illustr figur automat parallel fail major way worth note compil effect parallel specif loop howev combin bia toward specif transform lack quantit analysi result bottomend improv exampl loop parallel miss cach iter hardli benefit parallel execut bar label mcom correspond parallel execut time code manual compil optim parallel techniqu describ section carri out reflect optim restructur techniqu automat integr exist parallel compil notic signific improv manual parallel three machin result speedup bar label mcomalg show result execut time compil optim algorithm code chang discuss section incorpor case alliant algorithm chang result yet signific improv correspond addit speedup approxim howev algorithm chang increas parallel eg dimension hyperplan method section result littl improv sgi challeng case latter case perform top due lack addit number processor speed figur scalabl cfd code parallel due cach miss satur bu bandwidth interfer coher overhead bu satur challeng becom evid rightmost bar figur bar label mall show parallel execut time cfd code addit automat manual optim algorithm chang code alter elimin interfer architectur bottleneck fals share bu bandwidth fact dimension hyperplan project method outlin section restrict amount parallel promot data local elimin fals share mall bar sgi data figur reflect improv achiev due elimin bottleneck obtain dimension hyperplan project major improv came case sgi addit speedup almost three result elimin fals share increas data local reduct bu traffic optim discuss section cfd code achiev total speedup approxim three system figur show speedup cfd benchmark sgi three differ problem size case comput speedup took serial execut time execut time parallel code singl processor optim sequenti code thu speedup report fall conserv side least sgi fx figur attest scalabl cfd code problem size sequenti execut time alliant fx obtain run parallel version code singl processor without vector vector use parallel run discuss abov labori timeconsum analysi optim cfd code result total speedup approxim howev result tell us anyth regard maximum potenti parallel maximum perform attain cfd benchmark machin test order determin posit deliv speedup respect ideal use two ap proach first use amdahl law comput maximum speedup measur serial parallel part code actual execut sgi measur execut time cfd sever time differ number processor use least squar approxim estim parallel serial fraction code use estim upper bound perform use amdahl law tabl show maximum attain speedup estim measur sgi challeng three problem size indic speedup correspond problem size use obtain measur report figur deliv speedup approxim half amdahl upper bound maximum speedup believ factor two differ attribut network bandwidth interfer cach miss addit abov estim maximum speedup use properti underli algorithm handcarri analysi code amdahl law use obtain upper bound howev serial parallel fraction code estim inspect code static analysi approach yield maximum speedup dimension dimension hyperplan project method respect problem size fix xx factor ideal maximum measur maximum speedup discrep attribut architectur bottleneck thu power parallelizerbackend combin multiprocessor architectur without bottleneck would expect deliv speedup cfd applic factor almost highli optim cfd version optim version run bottleneckfre architectur infinit number processor tabl scalabl maximum speedup element maximum speedup conclus paper present comprehens perform profil analysi optim tune commerci comput fluid dynam code cfd one import applic run highperform comput one demand term comput resourc find underscor sever limit commerci experiment parallel compil well architectur bottleneck and perform implic popular highperform multiprocessor sgi challeng importantli find stress import synerget effect compil algorithm optim overal perform prowess compil individu transform optim littl effect bottomlin perform howev global approach optim consid interdepend among variou optim result signific perform improv experi base perform complet cfd code oppos select kernel although individu compil perform excel specif loop perform entir applic prove dismal true deliv perform perform cfd code sgi challeng strike case mismatch compil optim architectur idiosyncrasi parallel may result far less expect deliv perform attempt custom parallel underli architectur altern order parallel work effect architectur bottleneck elimin taken consider compil final sophist program restructur captur alter order type comput result certain case improv similar parallel code optim r alliant comput system corpor alliant comput system corpor symbol analysi parallel compil parallel cfd code guidelin usag incomplet decomposit solv set linear equat occur practic problem new gener parallel compil mpp numer heat transfer fluid flow silicon graphic inc tr symbol analysi parallel compil