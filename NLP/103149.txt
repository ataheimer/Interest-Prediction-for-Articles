t reliabl solut special event locat problem ode a comput solut initi valu problem ordinari differenti equat ode may part larger task one task find algebra function solut an event function root an event occur task difficult theori softwar practic certain use kind event function possibl avoid two fundament difficulti describ achiev reliabl solut problem way allow capabl graft onto popular code initi valu problem b introduct comput solut yfflr n initi valu problem ordinari differenti equat may part larger task possibl common task find either first point set point ft g one equat satisfi g j call event function event j said occur root jth event function paper concern class problem event function g j defin polynomi either specif assum g j form either x compon solut vector yx gener polynomi form g j treat techniqu expens rather complic machineri common problem i find compon solut assum given valu ii find compon solut extremum form singl event function allow sever event function form time solv complic problem iii tabul valu depend variabl iv determin locat switch point point discontinu defin term linear function depend variabl v determin zero gener event function qx adjoin differenti equat q system difficulti event locat problem often appreci next section investig theoret difficulti two fundament difficulti that usual approach one cannot sure notic event all one realiz event occur one cannot sure find first occurr special problem consid here present effici way overcom difficulti least principl difficulti remain section state key observ describ exploit it presenc one event function caus mani complic present softwar design reason easi use provid consider flexibl produc code event locat use mani popular code initi valu problem goal add capabl locat event without alter integr itself section describ accomplish section discuss code import applic them problem difficulti popular code initi valu problem step b produc approxim yx set point usual code test valu event function differ sign x x i chang sign one indic event occur x adam backward differenti formula bdf code produc polynomi px approxim yx whole interv natur comput first root approxim locat event j popular rungekutta formula produc solut mesh point x approach event locat problem import reason recent work aim provid formula polynomi approxim solut valid x way locat event describ natur mani led think task easi far true mesh point x chosen provid effici approxim yx x specifi accuraci event function influenc select mesh space may appropri locat posit event is root even number root count multipl occur x x i notic presenc event notic gener way certain rootsolv find first root cours one might monitor behavior close reduc chanc miss root particularli care algorithm watt expens guarante succeed unlik deceiv nearpatholog case event function form qx yx convert form consid analyt partial deriv avail thi new depend variabl ad system note dz dx look event convers forc integr select step size appropri qx yx consequ locat event much reliabl unfortun may expens comput qx yx accur way cost would paid even event occur a b also partial deriv q x q may difficult obtain state event locat problem equat integr least first event occur common use event function determin function fx y redefin exampl might one set differenti equat describ temperatur room temperatur drop low thermostat switch heater new situat describ new set equat exampl definit f clearli depend histori integr natur locat event restart integr new definit f decept problem occur f may redefin variou possibl definit depend histori integr exampl suppos fx otherwis temptat program f straightforward fashion larg measur defeat effici locat event difficulti code initi valu problem expect f smooth program f valu determin simpl test magnitud present integr function f continu lack continu deriv integr step valu valu function f smooth enough basic theori underli construct integr appli happen unpredict integr may realiz produc inaccur solut mathemat softwar solv differenti equat tri recogn cope problem design qualiti code like recogn inaccur solut reject step tri smaller step often case code repeatedli tri step cross event and reject step fall short succeed way eventu integr step past event step size small result accur proper use code event locat abil avoid clumsi unreli handl discontinu initi valu jyj smooth function fx integr one event occur locat event determin f redefin intgrat restart new f smooth name fx case may be way proceed effici furnish reliabl solut task intend paper then suppos function f smooth f redefin event new integr initi point accur locat event depend accur integr underli differenti equat conditiong root difficulti present even simpl event function treat discuss matter specif context find root event function step code produc polynomi px approxim solut compon j x event approxim root equat minor sourc error locat event comput code requir user specifi accur comput we author prefer comput accur possibl precis avail reason suppos comput satisfi exactli though quit true discrep far smaller error consid relat j approxim p simpl root approxim second term lead immedi approxim error p small root poorli determin easi extend argument deal multipl root come conclus multipl root illcondit differ usual algebra case term repres true global error integr code initi valu problem even tri control error directli is best size compar local error toler use integr gener cannot expect locat event accur integr toler problem illcondit may achiev even close accuraci would help user code event locat capabl estim error report code provid estim quantiti multipli global error equival quantiti multipl root esim refer event function form easi obtain analag result event function form code estim condit problem similar way estim error locat would need estim global error j one case other awar satisfactori way estim quantiti commonli assum global error compar local error toler assumpt along condit number provid yield crude use indic error implic fact discomfit perfectli possibl event occur integr done one toler occur differ toler unpleas wors happen toler integr perform differ exampl differ output requir alter choic step size particular repeat integr code step alleg locat event ordinarili result valu gx yx x differ obtain use polynomi approxim px mesh point relat matter gener comput event posit contrari one might expect often discuss typic code allow yx x larg part answer suffic mani problem seen practic howev fundament difficulti higher order deriv polynomi may fit yx well yet deriv exhibit even qualit agreement y adam method base polynomi approxim x perfectli natur includ method presenc x debat expens way handl first deriv elimin solv instead reliabl nonstiff problem avoid stiff problem wellknown p x associ bdf code ordinarili far better approxim x fx px deriv handl analyt partial deriv avail ad deriv new variabl system rather like event function q ad variabl abov proceed way caus code produc independ polynomi approxim deriv specifi local accuraci unfortun obtain equat satisfi deriv may difficult besid fundament difficulti anoth aris polynomi approxim produc popular code polynomi produc popular fehlberg rungekutta formula horn adam code shampin gordon connect mesh point x form global continu function bdf adam code gear form continu function first deriv jump discontinu jump seen code compar size local error toler obvious scheme describ locat event exhibit anomal behavior approxim solut use remedi difficulti number author recent suppli algorithm c piecewis polynomi approxim rungekutta adam bdf code rootfind algorithm section describ techniqu use solv special event locat problem appropri necessari describ detail code aim present import idea suitabl structur realiz code discuss detail section present consid task integr first posit satisfi locat key observ event function form yx approxim polynomi px function polynomi cours true kind event function well restrict form allow us solv interest practic problem still provid simpl user interfac approach also gener kind approxim found x purpos piecewis ration approxim yx offer advantag easi see event function form ration approxim also lead find root polynomi shall say obviou gener use sturm sequenc say can principl answer question is root polynomi g j x px p x interv also possibl sure comput first root one present use exampl bisect sturm sequenc test presenc root follow describ one way exploit observ first need clear mean first posit equat satisfi quit possibl inde fairli common practic satisfi initi point cours user abl check without assist need report it integr intend employ code use mode call routin integr step current point x intern chosen point x i direct integr intend search current integr interv next occur event defin defin current integr interv half open interv overal lose point rang integr except possibl initi point x definit two signific advantag first techniqu determin posit event base sturm sequenc algorithm count number zero given algorithm alway defin interv second locat event point wish go locat next event direct integr interv search initi natur code provid two basic modul i one modul design sole check whether event modul take input interv shift power seri represent event function g j use standard sturm sequenc algorithm determin precis mani occurr count multipl event ii second modul use locat first event user specifi interv call modul describ determin one event occur modul output accur estim first posit event c multipl andor type depend context condit number interv c search t c largest interv seen contain one event solut yx approxim px chang posit event possibl multipl especi origin problem event high multipl well separ assum solv state section return condit number root use gain impress accuraci want algorithm locat first posit event effici robust tri devis algorithm converg rapidli satisfi reduc task locat event singl event function cautiou less frequent occur circumst insist effici might employ simpler algorithm exampl could appli standard code comput root polynomi locat occurr event rank result determin locat first event approach would palpabl ineffici even first check event occur shall say event function activ import effici fact mani applic one event function is also whether expect mani integr interv event all event occur usual one interv sever event occur one integr interv usual isol rel machin roundoff code whenev isol singl activ event function singl occurr and henc comput c use standard bisec tionsec algorithm rewritten revers commun form locat posit event accur get stage first identifi event activ interv c current interest ani make list them next use bisect algorithm identifi point dc that first element activ event list event occur c suppos current interv c initi set c may singl activ event case set c use bisectionsec algorithm locat precis even one activ event worth proceed similar way varieti possibl includ use bisectionsec algorithm activ event turn follow rank comput posit find first second possibl locat posit first activ event accur check posit first event not find activ event c start again have howev adopt approach gener effici choos arbitrarili work first activ event proceed one iter time bisectionsec algorithm event comput estim e posit event call bisectionsec code sever possibl estim right locat event reduc interv c e similarli left reduc interv e case comput new estim locat event first function repeat remain possibl some all event function event left e case reduc list activ event function restart interv c e possibl new first event function two variat basic problem comput first event occur frequent present difficulti softwar involv continu integr next event one case event function remain same other chang difficulti first task one event occur immedi anoth comput posit t obtain interv c c contain event big help also difficulti event may occur sever time vicin finit precis arithmet use yet infinit precis arithmet henc even though exclud interv search posit next event point nearbi may identifi incorrectli posit help overcom problem search search proce two stage first check remain part current integr interv use inform comput alreadi least one event occur interv comput posit closest proceed abov otherwis move next integr interv proceed case find first posit event second problem inform contain comput interv longer use chang event definit may occurr one newli defin event t henc never avoid possibl numer root without recours error analysi discuss section implement redefin set event point proceed must comput intern data for exampl sturm sequenc coeffici may check occurr event t x i algorithm proce like one describ earlier possibl work throughout set event includ possibl definit aris stage integr point view of least sometim avoid round effect would better choic possibl one use algorithm describ first problem rather second even though might involv postprocess user event posit inform combin rootfind integr section consid design interfac allow root find code graft onto mani popular integr version plan dissemin make minim assumpt integr assum use mode return call program step x x i polynomi known degre r repres solut x note earlier anomal behavior possibl interpol certain popular code connect smoothli mesh point interfer rootfind treatment interv provid user appreci potenti difficulti aris lack smooth reason cannot use rootfind code effect lack smooth similar mark aris loss smooth due numer error algorithm discuss end section modul written rootfind task assum polynomi form r r r popular integr repres interpol polynomi mani form viz taylor lagrangian divid differ hermit routin need e e tabl condv convert standard form first consid inform form suppli abil evalu interpol hardli surpris better job done inform suppli exampl taken up abil evalu polynomi px degre r provid integr convert form choos r form valu construct p way involv solut van der mond system comput illcondit especi high degre sometim occur adam code tabl give extrema chebyshev polynomi r x shift degre typic bdf rungekutta code higher degre occur adam code condit number uncomfort larg higher degre howev notori pessimist analysi show expect size condit number reflect error coeffici r long use appropri algorithm solv van der mond system gener purpos packag written use node specifi except user may overrid choic approach one might hope for nordsieck form interpol polynomi use number popular code taylor seri expans polynomi special interfac convert shift scale form need much natur gener approach special interfac less troubl condit matter straightforward go detail e e tabl condv r interpol node function deriv routin evalu px evalu p x time odd replac set distinct point tabl tabul condv valu littl smaller tabl increas similarli recent consider interest provid rungekutta code kind polynomi interpol requir paper provid entri literatur propos algorithm base dormandprinceshampin dp formula pair embed formula use local extrapol yield fifth order approxim local solut deriv x quintic hermit interpol yield polynomi approxim order five x connect approxim interv yield global c piecewis polynomi approxim solut natur take node fs g f solv directli use experi special interfac similar case well gener one present earlier observ even underli polynomi px is theori global properti share comput piecewis polynomi function defin interv x turn loss smooth aris inaccur solut van der mond system interv and obtain evalu px onli impos condit p directli manifest error locat event and importantli far less frequent loss event occurr mesh point switch polynomi success interv gener littl code driver routin control move one interv next check report discontinu event locat caus error mesh point first check sign chang mesh point represent event function two interv meet point first approach reveal noth check sturm sequenc count match two represent small subinterv new interv ffi chosen fairli small rel size interv extrapol represent comput like inaccur larger code present collect subroutin implement algorithm describ paper refer reader fuller descript code restrict gener comment pertin materi paper also discuss use driver subroutin alevnt import applic theoret discuss faith reflect code give adequ appreci effici clearli make usual assumpt evalu ode expens part integr event locat techniqu constitut addit overhead compar low cost particular normal case evalu ode requir algorithm requir integr alon assum common modern code calcul interpol associ ode solver involv ode evalu even did extra evalu would made per step rather per event function evalu interv contain event locat algorithm nearli effici root finder base use standard way calcul root singl equat addit comput event locat code return condit number base extens take account high order zero turn point event function event occur order m is g r similarli occurr order event locat event code return condit number appropri note due round integr error effect code may return small valu m case compens close cluster root p m p m thu small henc condit number larg consid problem tabul independ variabl x term equispac valu depend variabl y is wish solv locat first point x given valu given increment delta pose problem two way first approach defin singl event function proceed comput posit x event redefin event on sinc necessari redefin event function differenti equat use subroutin alevnt figur second approach defin set event function simul taneous name tabul point interest event locat must process maintain order tabul subroutin alevnt use purpos too design drive integr user choic determin locat event import distinct approach if exampl start wish know yx valu etc quit possibl first approach know definit use next event function happen find exampl wish continu look next event again first approach priori inform behavior solut expect reflect comput solut even believ inform use check problem formul code use second approach possibl modifi includ event function could occur start current posit that three event function almost case exampl consid problem tabul x equispac step solut artifici construct equat equat solut tabul valu x use nag code dnbf integr rel local error toler gamma we would expect result reproduc approxim standard integr defin one event function time alevnt event locat redefin event function altern use four event function correspond four tabul point simultan tabl present tabul valu latter approach error estim base substitut local error toler express though valu substitut global error j local error toler use quantiti avail relat error j though well establish error estim clearli tabul point multipl error estim tabl tabul point equispac valu y reason approxim true error overestim error approxim doubl zero comput event use differ error toler call dnbf suffici stringent toler obtain underlin event locat given tabl case detect one event never detect multipl root even though root multipl two numer approxim either root close pair valu error estim associ close pair consist error toler integr alway indic illcondit root result illustr valu use four event function simultan reveal monoton result first approach abov use one event function exactli underlin valu tabl result obtain redefin event function restart integr not gener like accur calcul without restart integr case restart error made calcul earli event locat propag later integr henc accuraci later event locat case restart effect conclus outlin approach find event locat certain special event function associ solut ode addit emphas difficulti problem shown construct event locat code outlin graft code onto standard integr interpol featur graft process requir integr step orient mode determin degre associ interpol polynomi step evalu interpol polynomi anywher span step pseudocod redefin event function locat detect f declar g f user initi integr set x tend g f user defin first event set neqg comp alpha appropri g f irevcm revers commun integ variabl set alevnt exit determin next action requir userg call alevntneqg comp alpha turn x x nord mxord neqf xval yval lbound xevent rbound mltplc f variabl input valu alevnt which output integr variabl output variabl alevntg f user check ier natur error g f user call integr take first integr step goto call alevnt f user call integr take integr step g goto call alevnt f user evalu interpol xval yval g goto call alevnt print xevent f user reset comp alpha defin next event g goto call alevnt endif end figur use alevnt redefin event function r c interpol code base backward differ formula code reliabl solut special event locat problem ode algorithm minimis without deriv numer initi valu problem ordinari differenti equat practic aspect interpol rungekutta code analysi bjorckpereyra algorithm solv van der mond system fourth fifthord scale rungekutta algorithm treat dens output first cours numer analysi nd edit comput solut ordinari differenti equat initi valu problem practic rungekutta formula backward differenti formula revisit improv debdf new root solv code rdebd smoother interpol adam code tr italiccsupscrpt interpol code base backward differenti formula smoother interpol adam code practic rungekutta formula practic aspect interpol rungekutta code analysi bjomyampersandumlrckpereyra algorithm solv vandermond system numer initi valu problem ordinari differenti equat ctr r w brankin i gladwel algorithm rksuite_ fortran softwar ordinari differenti equat initialvalu problem acm transact mathemat softwar tom v n p sept joel m esposito vijay kumar state event detect algorithm numer simul hybrid system model singular acm transact model comput simul tomac v n pe januari joel m esposito vijay kumar asynchron integr event detect algorithm simul multiag hybrid system acm transact model comput simul tomac v n p octob przemyslaw prusinkiewicz mark s hammel eric mjols anim plant develop proceed th annual confer comput graphic interact techniqu p septemb aleksandar donev salvator torquato frank h stilling neighbor list collisiondriven molecular dynam simul nonspher hard particl ii applic ellips ellipsoid journal comput physic v n p januari