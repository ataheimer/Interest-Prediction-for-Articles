t approach explor code improv transform a although code transform routin appli improv perform program scalar parallel machin properti codeimprov transform well understood articl present framework enabl explor analyt experiment properti codeimprov transform major compon framework specif languag gospel express condit need safe appli transform action requir chang code implement transform framework includ techniqu facilit analyt investig codeimprov transform use gospel specif also contain tool genesi automat produc transform implement transform specifi gospel demonstr use framework explor enabl disabl properti transform first present analyt result enabl disabl properti set code transform includ tradit parallel transform describ experiment result show type transform enabl disabl interact actual found set program b introduct although code improv transform appli compil mani year properti transform well understood wide recogn place program code transform appli order appli code transform select particular code transform appli impact qualiti code produc although concentr research effort devot develop particular code improv transform properti transform adequ identifi studi due part inform method use describ code improv transform lack common formal languag notat difficult identifi properti code transform compar transform determin transform interact one anoth identifi variou properti code improv transform interact cost expect benefit applic frequenc inform decis made transform appli appli them order appli them order applic import qualiti code transform interact one anoth creat destroy potenti code improv transform work partial support nsf grant ccr slipperi rock univers ccr univers pittsburgh dr whitfield address depart comput scienc slipperi rock univers slipperi rock pa exampl qualiti code produc would neg affect potenti appli benefici transform destroy applic less benefici transform certain type transform may benefici one architectur anoth benefit transform also depend type schedul dynam static use one approach taken determin appropri transform order applic set program implement code transform program optim includ number code improv transform appli transform program evalu perform transform code howev actual implement code transform tool time consum process especi detect complex condit global control data depend inform requir also ad hoc manner code transform usual develop addit transform even delet transform may necessit substanti effort chang transform anoth approach modifi exist optim howev optim compil often quit larg eg suif line c code gnu c compil line code complex make difficult use experi take account variou factor influenc perform transform code paper present framework explor properti code improv transform major compon framework code transform specif languag gospel framework includ techniqu util specif analyt investig properti transform gospel also use design genesi tool automat produc code transform program specif enabl experiment specif transform consist express condit program code must exist transform safe appli action need actual implement transform program code specif use variant first order logic includ express code pattern global data control depend requir appli transform action express use primit oper modifi code code improv transform express gospel requir fixpoint comput class includ mani tradit parallel code improv transform demonstr framework use studi phase order problem transform explor enabl disabl properti transform use gospel first show enabl disabl properti establish analyt also demonstr use genesi properti studi experiment use genesi code transform automat produc set transform specifi gospel execut transform test suit program present result experi explor kind transform found test suit type number transform interact found number benefit accru framework guidelin suggest applic order set code improv transform deriv analyt experiment explor interact also new transform specifi gospel relationship transform analyt experiment investig specif transform gener genesi use sampl sourc program user experiment investig transform system consider decis transform includ particular architectur order transform appli easili explor new transform particularli tailor architectur specifi use gener transform effect transform experiment determin use architectur transform effect remov consider new transform ad simpli chang specif rerun genesi produc program transform implement new transform transform safe combin could also investig analyt need combin explor experiment anoth use gospel genesi teach tool student write specif exist transform transform modifi tune transform implement transform gener genesi enabl experiment transform prior research report tool assist implement code improv transform includ analysi need research perform automat code gener use develop peephol transform work transform consid local requir global data flow inform number tool design gener analys sharlit pag use latticebas specif gener global dataflow analys spare anoth tool facilit develop program analysi algorithm tool support high level specif languag analysi algorithm express denot natur specif enabl automat implement well verif algorithm softwar architectur use rapid prototyp data flow analyz also recent present approach develop integr analysi code transform approach doe techniqu combin specif transform creat transform templat fulli describ combin oper develop part framework iterationreord loop transform new transform may ad framework specifi new rule work appli iterationreord execut order loop interact perfect tight loop nest provid techniqu specifi character transform gener next section paper discuss framework develop specifi transform section present detail gospel languag section show gospel use analyt investig enabl disabl condit transform automat gener transform section demonstr util specif techniqu use genesi present experiment result conclus present section overview transform framework code improv transform framework shown figur three compon gospel code transform specif languag analyt techniqu use gospel specif facilit formal proof transform properti genesi tool use gospel specif produc program implement applic transform three compon use explor transform properti paper use framework explor disabl enabl properti gospel specif consist precondit need program code order transform applic code modif implement transform part precondit specif textual code pattern need transform exampl includ exist statement assign variabl constant exist nest loop thu code pattern oper program object loop statement express oper operand order determin whether safe appli transform certain data control depend may also need program object also use express depend relationship describ transform gospel use depend express term flow anti output control depend depend quantifi combin use logic oper produc complex data control condit flow depend s j depend statement defin variabl statement j use definit antidepend s j exist statement use variabl defin statement j output depend s depend statement defin or write variabl later defin or written j control depend exist control statement statement j control concept data direct vector forward backward loopcarri depend array element also need transform parallel element data depend vector consist either forward backward equival direct repres respect direct combin mean direct number element direct vector correspond loop nest level statement involv depend case code improv transform tradit express use global data flow inform inform either express combin data control depend introduc gospel relationship need comput check underli assumpt gospel algorithm need comput data flow data depend inform avail thu gospel use basic control data depend inform possibl extens type data flow inform note twenti transform studi research data flow inform express term combin data control depend sampl transform specif given appendix b gospel also includ specif code modif need implement transform although code improv transform produc complex code modif code chang express gospel primit oper appli combin specifi complex action oper appli code object statement express operand oper use primit oper express code modif provid flexibl specifi wide rang code modif easili anoth compon framework analyt techniqu use prove properti transform techniqu use specif gospel provid clear concis descript transform use analysi show compon use establish enabl disabl properti set transform last compon framework genesi tool gener program implement transform gospel specif transform thu gener program contain code check condit need safe applic transform satisfi also contain code perform code modif express gospel specif program transform input program gener genesi output produc program transform specifi transform runtim interfac provid either permit user select type place applic transform automat find applic transform point demonstr util genesi determin kind frequenc transform occur number program type frequenc enabl disabl interact figur present code improv framework use framework three compon framework shown box applic framework shown oval solid line connect framework applic describ paper solid line connect framework interact prover use establish enabl disabl properti transform anoth solid line framework experiment studi enabl disabl properti dot line connect framework combin transform repres potenti use framework yet fulli explor _ code improv transform framework use figur compon util transform framework ________________________________________________________________________ descript gospel languag gospel declar specif languag capabl specifi class transform perform without use fixpoint comput specifi twenti transform use gospel includ specif invari code motion loop fusion induct variabl elimin constant propag copi propag loop unrol transform requir fixpoint comput partial dead code elimin partial redund elimin cannot specifi likewis although gospel use specifi type constant propag fold cannot use exampl specifi constant propag transform requir fix point comput howev studi shown code seldom contain type optim need iter bnf grammar section gospel appear appendix a grammar use construct wellform specif also use implement genesi transform paper assum gener form statement program transform three address code extend includ loop header array refer howev gospel genesi adapt handl represent includ sourc level represent assum basic three address code statement form three address code retain loop header array refer sourc program enabl user specifi loop level transform array transform templat specif transform consist name use identifi particular code improv transform follow three major specif section identifi keyword declar precondit action precondit section decompos two section code_pattern depend overal design gospel specif follow combin genesi proof techniqu enabl disabl interact properti experiment studi enabl disabl transform gospel declar precondit code_pattern depend action declar section use declar variabl whose valu code object interest eg loop statement code object attribut appropri head loop posit operand precondit section contain descript code pattern data control depend condit action section consist combin primit oper perform transform figur present gospel specif constant propag ctp transform see section detail specif use three variabl j l whose valu statement code_pattern section specifi code pattern consist statement defin constant type s opr const valu statement exist depend section j use determin statement use constant po attribut record operand posit first second third flow depend j second statement l ensur definit constant assign might reach j again po attribut record posit flow depend j l j l specif indic two statement statement operand s j po operand s l po specif ensur depend posit record j involv variabl depend found _______________________________________________________________________ declar precondit code_pattern find constant definit depend use definit s j po flow_dep s j s l po flow_dep s l operand s po operand s l po action chang use constant modifi operand s j po opr figur gospel specif constant propag j found meet requir l s found meet specifi requir oper express action section perform action modifi use j constant found second operand next consid specif parallel transform loop circul crc found figur defin two statement three tightli perfect nest loop loop without statement occur header code_pattern section specifi occurr tightli nest loop l l l data depend condit depend section first ensur loop tightli nest specifi flow depend loop header next depend section express pair statement loop flow depend direct vector statement found head end loop interchang specifi action section next section provid detail gospel languag gospel type oper variabl whose valu code element defin declar section declar id_list variabl declar one follow type statement loop nest loop tight loop adjac loop thu object type valu pointer statement loop nest loop tight loop adjac loop respect type predefin attribut denot relev properti next nxt previou prev usual numer constant integ real avail gospel specif besid constant two classif predefin constant also avail operand type opcod valu constant ________________________________________________________________________ declar precondit code_pattern find tightli nest loop l depend ensur perfect nest flow_dep with action interchang loop move figur gospel specif loop circul reflect constant valu code element specifi gospel exampl constant includ const constant operand var variabl operand typic mathemat opcod well branch label appear specif code gospel extend includ op code variabl type chang grammar tool genesi use grammar variabl type statement valu statement program possess attribut indic first second third operand opr opr opr respect oper opcod addit po attribut exist maintain operand posit depend requir depend section aloop type variabl point header loop attribut bodi identifi statement loop head defin lcv loop control variabl init initi valu final last valu loop control variabl end loop also attribut thu typic loop structur attribut is head lhead defin linit lfinal llcv loop_bodi lbodi end_of_loop lend nest loop tight loop adjac loop composit object whose compon type loop nest loop defin two or more loop second name loop appear lexic within first name loop tight loop restrict nest loop ensur statement loop header adjac loop nest loop without statement end one loop header next loop id_list keyword declar either simpl list eg statement loop identifi list pair eg identifi pair nest adjac tight loop exampl tight loop_on loop_two defin loop structur consist two tightli nest loop gospel precondit section order specifi code improv transform condit safe appli pattern code data control depend condit need must express two compon constitut precondit section specif keyword precondit follow keyword code_pattern identifi code pattern specif depend identifi depend specif code pattern specif code pattern section specifi format statement loop involv transform code pattern specif consist quantifi follow element need requir format element quantifi element_list format_of _element quantifi oper one ani follow mean return set element request type success match return set one element request type match success return null set request match success exampl quantifi element list s j return pointer statement j second part code pattern specif format_of_el describ format element requir statement element type formatofel restrict statement operand oper similarli loop element type formatofel restrict loop attribut thu constant requir operand loop requir start iter requir specifi format_of_el exampl code pattern specif specifi final iter count greater initi valu is loop loopfin loopinit express construct format_of_el use oper usual mean also restrict place either type operand ie const var posit po opcod seen code_pattern section figur depend specif second compon precondit section depend section specifi requir data control depend transform depend specif consist express quantifi ani no return boolean truth valu set element meet condit po attribut use operand posit depend also return gener form depend specif is quantifi element sets_of_el dependence_condit sets_of_el compon permit specifi set membership element memel specifi element member defin set set describ use predefin set name specif set express involv set oper set function union intersect dependence_condit claus describ data control depend code element take form type_of_depend stmtid stmtid direct version gospel depend type either flow depend flow_dep anti depend anti_dep output depend out_dep control depend ctrl_dep direct descript direct vector element vector consist either forward backward equival direct repres respect also use ani allow direct direct vector need specifi loopcarri depend array element parallel transform direct vector may omit loopcarri depend relev exampl follow specif one element name element loop j element loop either flow depend anti depend j gospel action section decompos code modif effect appli transform sequenc five primit oper semant indic tabl oper overload appli differ type code element five primit oper paramet semant are tabl action oper exampl move oper move loop_ header loop_ header is moveloop_head loop_head exampl modifi action modifi end loop_ jump header loop_ is modifyloop_end address loop_head primit oper combin fulli describ action transform may necessari repeat action statement found precondit section henc list action may preced foral express describ element action appli flow control specif implicit except foral construct avail action section word action keyword act guard permit entranc section unless condit met applic gospel specif gospel specif use number way section demonstr util specif explor phase order problem transform oper paramet semant move object after_object move object place follow after_object add obj_desc obj_nam after_obj add obj_nam obj_desc place after_obj delet object delet object copi obj after_obj new_nam copi obj new_nam place after_obj modifi object object_descript modifi object object_desc analyt establish enabl disabl properti section show gospel use produc automat transform gener genesi use explor properti transform experiment techniqu analyz specif gospel specif analyz determin properti transform particular use analysi techniqu establish enabl disabl properti transform enabl disabl condit interact transform creat condit destroy condit appli transform determin know interact occur among transform use determin appli transform exampl strategi might appli transform destroy condit appli anoth transform order exploit potenti second transform especi second transform consid benefici enabl disabl condit enabl interact occur two transform applic one transform creat condit applic anoth transform previous could appli disabl interact occur one transform invalid condit exist appli anoth transform word transform enabl transform b denot b perform b applic perform b appli bs precondit true similarli transform disabl transform b denot b precondit transform b true appli bs precondit becom fals properti involv phase order problem transform determin interact among transform condit enabl disabl transform must establish enabl disabl condit found analyz precondit specif transform condit code_pattern depend section transform least one enablingdis condit produc exampl code pattern includ statement statementopcod assign enabl condit creation statement opcod assign disabl condit delet statement modif statement opcod enabl disabl condit six transform deriv specif see appendix b gospel specif given tabl interact among transform use gospel specif prove nonexist interact also use specif develop exampl demonstr exist interact transform enabl condit disabl condit dead code elimin dce creat use nonexist l s d l delet l path delet destroy use exist l s d l introduc l use valu comput constant propag ctp creat insert j s d nonexist l s l d modifi l l destroy s l d j a introduc definit b delet l c path delet destroy nonexist j s d exist l s l d modifi l l creat s l d j a definit delet b introduc l l c path l j creat constant fold cfo creat form const opcod const remov modifi loop unrol creat loop l destroy loop l loop fusion exist adjac loop add loop two loop ident head er modifi header nonexist n backward depend forward remov n add definit n delet path n non exist s d remov remov add def destroy depend delet path j exist nonadjac loop add loop two loop ident header modifi header the exist n backward depend forward insert n delet definit n creat path n exist s d delet def depend hold creat path j loop interchang exist nest loop add loop nonexist n depend remov n add definit n delet path n loop header invari modifi header nonexist nest loop remov loop exist n depend insert n remov def n creat path n loop header vari respect other modifi header denot condit possibl correct specif ie maintain semant equival tabl enabl disabl condit exampl interact given figur loop fusion fu enabl loop interchang inx two inner loop j fuse one larger loop interchang sometim interact two transform complex transform enabl disabl transform invari code motion icm loop interchang inx two transform shown figur icm enabl inx also disabl inx figur a exampl icm enabl inx given figur b exampl icm disabl inx shown eas prove noninteract use formal notat gospel specif directli deriv specif languag use mathemat symbol place languag relat word comparison two style exemplifi by languag figur loop fusion enabl loop interchang _______________________________________________________________________ _______________________________________________________________________ _______________________________________________________________________ figur enabl disabl transform a icm enabl inx b icm disabl inx follow claim proof illustr techniqu prove nonexist enabl disabl interact transform claim loop interchang inx cannot disabl applic constant propag ctp proof util disabl condit ctp given previous tabl disabl constant propag proof assum inx ctp inx disabl ctp inx ctp must applic inx appli inx applic must two tightli nest loop l l loop limit invari data depend direct vector ctp applic must exist defin constant j use constant valu s l l sinc ctp applic inx must alter state code disabl ctp three disabl condit ctp given tabl produc follow case case destroy defin constant inx delet statement move header l defin variabl loop header defin loop control variabl loop control variabl variabl defin same ctp applic defin constant valu inx destroy statement defin constant case nonexist j remov depend s inx delet statement move header l howev move header outsid loop would destroy relationship s sinc header must invari rel order inx applic inx destroy j case creation l s l inx creat modifi statement three way inx creat condit could delet definit legal action transform could introduc l inx creat statement move header l could header l defin constant creat path l reach j j could header definit l would reach j prior inx sinc header must invari inx creat l thu show inx ctp is loop interchang appli destroy opportun constant propag explor exampl interact develop proof noninteract deriv by hand interact tabl display potenti occurr interact tabl display interact eight transform dead code elimin dce constant propagationctp copi propag cpp constant fold cfo invari code motion icm loop unrol lur loop fusion fu loop interchang inx entri tabl consist two element separ slash first element indic enabl relationship transform label row transform label column second element disabl relationship indic interact occur wherea e d indic enabl disabl interact occur respect exampl first row indic dce enabl dce disabl ctp notic high degre potenti interact among tripl fu inx lur ctp cfo lur impact interact transform order disabl enabl relationship transform use transform appli automat transform appli interact transform appli automat case optim compil interact use order applic appli mani transform possibl appli transform interact mode knowledg interact help user determin transform appli first use interact properti two rule use particular order goal appli mani transform possibl transform enabl transform b order b ab transform disabl transform b order b b a rule cannot produc definit order conflict aris when b b b b b b ctp ed e e e e e lur e e e e e ed ed fu d d d ed ed tabl theoret enabl disabl interact case precis order cannot determin properti howev shown next section experiment perform use genesi determin valu appli one transform transform exampl use order consid scenario transform design decid lur extrem benefici transform target architectur transform design could benefit two piec inform transform enabl lur transform disabl lur seen tabl ctp cfo lur enabl lur interact indic ctp cfo appli prior lur architectur addit one could infer tabl sinc ctp enabl cfo cfo enabl ctp two transform appli repeatedli lur cours may factor consid appli loop unrol paper focu one name transform interact factor may includ impact unrol loop cach factor import applic transform factor could embed genesi experi eg ad measur cach perform tabl also display interact disabl lur fu transform disabl lur decis must made import appli fu target architectur lur import either fu appli end transform process inform interact could also use develop transform guidanc system inform user transform potenti disabl anoth transform also inform user transform potenti enabl anoth transform interact among transform also use determin pairwis order transform instanc tabl indic appli cpp ctp cpp appli first inform glean tabl genesi automat transform gener tool anoth use framework construct transform tool automat produc transform code specifi transform genesi tool analyz gospel specif gener code perform appropri pattern match check requir data depend call necessari primit routin appli specifi transform figur present pictori descript design genesi valu genesi greatli reduc programm burden automat gener code rather programm implement optim hand figur code transform develop gener constructor gener produc code specifi transform util predefin routin transform librari includ routin comput data control depend constructor packag code produc gener librari routin add interfac prompt interact user gener section genesi analyz gospel specif use lex yacc produc data structur code three major section gospel specif gener first establish data structur code element specif code gener find element requir format three address code code verifi requir data depend next gener final code gener action statement genesi system line c code includ code comput data depend high level represent algorithm use genesi given figur gener code reli set predefin routin found transform librari routin transform independ repres routin typic need perform transform librari contain pattern match routin data depend comput algorithm data depend verif procedur code manipul routin pattern match routin search loop statement possibl pattern found gener code call verifi item operand opcod initi final valu loop control variabl possibl applic point found intermedi code data depend must verifi data depend verif may includ check nonexist particular data depend search depend search one depend within gener constructor gospel specif transform librari routin transform appli user option transform code transform system code perform _______________________________________________________________________ figur overview genesi loop set gener code may simpli if ensur depend exist may complex integr test loop exampl statement depend need examin code gener collect statement requir direct vector associ depend specif match direct vector depend exist sourc program depend verifi action execut routin consist action specifi action section specif gener appropri code element constructor compil routin transform librari gener code produc transform set transform specifi constructor also gener interfac execut variou transform interfac transform read sourc code gener intermedi code comput data depend interfac also queri user interact option interact capabl permit user execut ________________________________________________________________________ genesi iter transform list readgospel specif transform analyz gospel specif use lex yacc gen code setup data structur gen code search pattern gen_code_depend_verifydata_depend gen code verifi data depend gen code perform primit action end creat interfac templat construct_optimizergenerated_cod library_routin readsource_cod convert sourc intermedi represent user_interaction_desir select_transform select_application_point compute_data_depend perform_optim users_direct endwhil figur genesi algorithm number transform order user may elect perform transform one applic point possibl overrid depend constraint possibl point program prototyp implement order test viabil robust approach implement prototyp genesi produc number transform eas experiment prototyp produc transform everi transform specifi transform specifi gener produc four procedur tailor transform set_up_tran match_tran pre_tran act_tran procedur correspond declar code_pattern depend action section specif implement transform consist driver call routin gener specif transform code driver given figur format driver transform gener driver call procedur gener call interfac specif transform set_up_tran match_tran pre_tran act_tran call interfac turn call gener procedur implement transform the gener transform specif code ctp given figur set_up_tran procedur consist singl call set_up_ctp driver requir success pattern match match_ctp pre_ctp order continu thu match_tran pre_tran call interfac procedur return boolean valu _______________________________________________________________________ done fals match_success match match code pattern match_success pre_success pre_condit verifi depend pre_success perform action optim done true end figur driver algorithm gener set_up procedur consist code initi data structur element specifi use precondit section type tabl data structur typet contain identifi inform statement loop variabl specifi declar section typet hold identifi string creat entri quantifi may use identifi precond section maintain type identifi eg statement loop adjac loop nest loop type statement entri initi type correspond identifi looptyp variabl specifi addit flag nest adjac loop set type tabl entri entri fill inform relev element found transform perform statement declar section call typetable_insert gener identifi type identifi place set_up procedur execut ctp shown figur type tabl entri initi type statement identifi transform execut procedur set_up_ctp set_up_ctp procedur termin driver indirectli initi exhaust search statement record type tabl call match_ctp sourc program statement match transform driver restart search new statement match procedur gener statement code_pattern section gospel specif quantifi statement code_pattern section call settable_insert made identifi type identifi quantifi settable_insert search request type initi set_tabl data structur appropri attribut type eg statement opcod operand set next restrict code_pattern section directli translat condit statement determin request restrict met current quantifi all loop gener check object found set_tabl ctp exampl figur code gener search assign statement constant right hand side next routin pre procedur gener statement depend section quantifi statement call settable_insert gener howev pattern match perform runtim ctp exampl pre_ctp procedur insert element set_tabl structur depend condit statement j insert set_tabl depend librari routin call find first statement flow depend statement found condit fail l also insert set_tabl depend routin call again l l flow depend j examin determin operand l caus depend variabl involv depend j l found condit fail next assign statement gener assign hit field set_tabl data structur result request depend membership procedur call exampl set hit field result flow_depend call hit field contain either for quantifi mani for quantifi statement number flow depend requir direct vector next statement directli gener relat condit exist specif last procedur call action procedur action procedur gener statement action section gospel specif individu action call primit transform made requir paramet eg modifi requir object modifi new valu gospel foral construct use loop ________________________________________________________________________ type tabl _insertstat si set type tabl statement tabl _insertstat si ani classifi set statement set tabl siopcodekind assgn return failur j s opcod assgn fail set tabl sioperand_akind const match success pre_ctp tabl _insertstat sj all classifi j set statement tabl _insertstat sl no classifi l set statement tabl find assign flow dep j ifset tabl sihit null flow dep j exist tri return failur tabl foreachsettableslhit quad_numb involv depend modifi one j s operand ifsioprcsjorpa modifi sjopra sioprc els endif figur gener code ctp ________________________________________________________________________ return failur gener call primit transform place within loop exampl figur simpli modifi operand collect j modif occur either first second modifi statement depend operand carri depend thu first call modifi consid operand a j replac second call consid operand b replac effect implement pattern match need determin operand posit depend procedur act_ctp call driver match_ctp pre_ctp termin success implement detail reader refer anoth paper experiment use prototyp implement genesi perform experi demonstr genesi use explor properti transform includ frequenc appli transform interact occur among transform use genesi transform produc ten twenti transform specifi lur fu experiment perform use program found hompack test suit numer analysi test suit short descript gospel specif transform given appendix b hompack consist fortran program solv nonlinear equat homotopi method numer analysi test suit includ program fast fourier transform program solv nonlinear equat use newton method total ten program use experiment benchmark program code fortran languag accept front end rang size line intermedi code statement program numer natur mixtur loop structur includ nest adjac singl loop tradit optim parallel transform could appli program interest interact type transform longer program would like show opportun transform thu opportun interact order verifi genesi capabl find applic point four transform specifi gospel run hompack test suit number applic point transform record compar number applic point found tini comparison reveal genesi found number applic point tini found furthermor seven optim specifi gospel optim gener genesi gener optim compar handcod optim verifi genesi abil find applic point again optim gener genesi found applic point optim test program ctp frequent applic transform often enabl applic point icm found note intermedi code includ address calcul array access may introduc opportun icm ctp also found creat opportun appli number transform expect total applic point ctp enabl dce enabl cfo enabl lur assum constant bound need unrol loop cpp occur two program creat opportun transform result shown tabl entri indic interact theoret possibl number give number interact occur exampl entri inxfu indic enabl interact found disabl interact found applic point investig order transform consid transform fu inx lur show section theoret enabl disabl one anoth one program fu inx lur applic heavili interact one anoth creat destroy opportun transform exampl appli fu disabl inx appli lur disabl fu differ order produc differ transform program transform also interact three transform appli appli fu inx one instanc fu program destroy opportun appli inx howev lur appli fu inx inx disabl thu user awar appli transform point program may prevent anoth transform applic complic process determin benefici order differ part program respond differ order one segment program inx disabl fu anoth segment inx enabl fu thu right order applic context applic point need use theoret result interact formal specif transform guid user may need multipl pass discov seri transform would fruit given system framework could also use explor valu combin transform freq dce ctp cpp cfo icm lur fu inx lur fu tabl enabl disabl interact block transform combin strip mine interchang perform preliminari experi appli variou order loop interchang inx loop unrol lur loop fusion fu experi lur follow inx produc opportun transform order thu perform experiment examin happen seri transform appli might benefici combin certain transform appli pair exampl would consid combin lur inx conclud remark code improv transform framework present paper permit uniform specif code improv transform specif develop use analysi automat gener transform analysi transform enabl examin properti transform interact determin transform creat destroy condit anoth transform relationship offer one approach determin order appli transform maxim effect implement gospel specif permit automat gener transform autom method enabl user experiment investig properti rapidli creat prototyp transform test feasibl particular machin genesi also permit user specifi new transform quickli implement them futur work research includ examin possibl automat prove interact expand specif detail level transform interact prove tool would enabl user determin properti transform also design transform guidanc system prototyp examin feasibl type system would aid user appli transform interact provid interact inform gospel specif also explor determin easili combin creat use transform acknowledg especi grate topla associ editor jack davidson insight critic advic earlier draft paper also thank anonym refere help comment suggest result improv present paper appendix precondit grammar gospel prototyp precon_list precon_list quantifi code_list mem_list condition_list precon_list e quantifi code_list stmtid stmtid_list mem_list mem_list mem_list mem_list mem_list mem mem no_mem condition_list condition_list condition_list condition_list condition_list condition_list type stmtid stmtid dir_vect type flow_dep out_dep anti_dep ctrl_dep dir_vect dir dir_list e gospel specif transform bump bmp modifi loop iter bump index preset amount eg declar precondit code_pattern l depend s flow_dep llcv s ani action add sprev sopr sopr modifi liniti evalliniti modifi lfinal evallfin constant fold cfo replac mathemat express involv constant equival valu declar precondit code_pattern find constant express const const opcod assign check action fold constant express modifi modifi s opcod assign copi propag cpp replac copi variabl origin declar precondit code_pattern find copi statement depend use def along path action propag delet copi modifi operand s j po opr delet s loop circul crcinterchang perfectli nest loop more two declar precondit code_pattern find tightli nest loop l depend ensur perfect nest flow_dep action interchang loop move move common subexpress elimin cse replac duplic express calcul perfom onc declar precondit code_pattern find binari oper n depend find common subexpress action add modifi s n assign n opr temp modifi dead code elimin dce remov statement defin valu variabl use declar precondit code_pattern find statement assign variabl valu express depend statement may use action delet dead code delet s loop fusion combin loop header declar precondit code_pattern find adjac loop equival head l depend depend backward direct first def reach prior loop action fuse loop modifi modifi delet l end delet l head invari code motion icm remov statement within loop valu comput chang declar precondit code_pattern loop l depend statement without depend within loop k mem s k l mem s l action move statement within header move s k lstartprev loop unrol lur duplic bodi loop declar precondit code_pattern loop iter least const type l final const check action unrol one iter updat origin loop initi modifi modifi l initi eval initi delet l end delet l headlabel parallel par modifi loop type parallel declar precondit code_pattern depend action modifi l opcod par mine smi modifi loop util vector architectur declar precondit code_pattern l lfinal liniti sz depend action copi lhead lheadprev l head modifi l lcv tempt modifi l step sz modifi l initi t modifi copi lend lend l end loop unswitch un modifi loop contain contain loop declar precondit code_pattern l depend find els k mem s k l ctrl_dep k action copi lhead k l head copi lend lendprevprev l end modifi l end addressl head move lhead move lend k prev r gener effici interprocedur analyz pag fair numer analysi global code motion global valu number automat gener peephol transfor mation a flexibl architectur build data flow analyz automat gener fast optim code gener automat gener machin specif code transform gnu c compil manual v peep architectur descript driven peephol transform advanc compil transform supercom puter a gener framework iterationreord loop transform stanford suif compil group sharlit tool build transform spare develop environ program analysi algorithm techniqu integr parallel transform compil base schedul method an approach order optim transforma tion investig properti code transform the design implement genesi automat gener global optim tini loop restructur research tool high perform compil parallel comput tr advanc compil optim supercomput automat gener fast optim code gener approach order optim transform automat gener global optim sharlitmyampersandmdasha tool build optim gener framework iterationreord loop transform techniqu integr parallel transform compilerbas schedul method design implement genesi global code motionglob valu number flexibl architectur build data flow analyz peep automat gener peephol optim automat gener machin specif code optim gener effici interprocedur analyz pag ctr prasad a kulkarni david b whalley gari s tyson jack w davidson search nearoptim optim phase order acm sigplan notic v n juli spyridon triantafylli manish vachharajani neil vachharajani david i august compil optimizationspac explor proceed intern symposium code gener optim feedbackdirect runtim optim march san francisco california prasad a kulkarni david b whalley gari s tyson jack w davidson exhaust optim phase order space explor proceed intern symposium code gener optim p march prasad a kulkarni david b whalley gari s tyson evalu heurist optim phase order search algorithm proceed intern symposium code gener optim p march mathieu verbaer arnaud payement oeg de moor script refactor jungl companion st acm sigplan confer objectori program system languag applic octob portland oregon usa m haneda p m w knijnenburg h a g wijshoff gener new gener compil optim set proceed th annual intern confer supercomput june cambridg massachusett m haneda p m w knijnenburg h a g wijshoff optim gener purpos compil optim proceed nd confer comput frontier may ischia itali prasad kulkarni stephen hine jason hiser david whalley jack davidson dougla jone fast search effect optim phase sequenc acm sigplan notic v n may stephen hine prasad kulkarni david whalley jack davidson use deoptim reoptim code proceed th acm intern confer embed softwar septemb jersey citi nj usa min zhao bruce childer mari lou soffa predict impact optim embed system acm sigplan notic v n juli prasad kulkarni wankang zhao hwashin moon kyunghwan cho david whalley jack davidson mark bailey yunheung paek kyle gallivan find effect optim phase sequenc acm sigplan notic v n juli keith d cooper alexand grosul timothi j harvey steve reev devika subramanian linda torczon todd waterman explor structur space compil sequenc use random search algorithm journal supercomput v n p may prasad a kulkarni stephen r hine david b whalley jason d hiser jack w davidson dougla l jone fast effici search effect optimizationphas sequenc acm transact architectur code optim taco v n p june decid phase order problem optim compil proceed rd confer comput frontier may ischia itali keith d cooper alexand grosul timothi j harvey steven reev devika subramanian linda torczon todd waterman acm adapt compil made effici acm sigplan notic v n juli prasad kulkarni wankang zhao stephen hine david whalley xin yuan robert van engelen kyle gallivan jason hiser jack davidson baosheng cai mark bailey hwashin moon kyunghwan cho yunheung paek vista vpo interact system tune applic acm transact embed comput system tec v n p novemb mike jochen anteneh addi anteneh lori l pollock lisa m marvel enabl control adapt program transform dynam evolv mobil softwar valid acm sigsoft softwar engin note v n juli stephen drape oeg de moor ganesh sittampalam transform net intermedi languag use path logic program proceed th acm sigplan intern confer principl practic declar program p octob pittsburgh pa usa l almagor keith d cooper alexand grosul timothi j harvey steven w reev devika subramanian linda torczon todd waterman find effect compil sequenc acm sigplan notic v n juli sorin lerner david grove craig chamber compos dataflow analys transform acm sigplan notic v n p jan min zhao bruce r childer mari lou soffa modelbas framework approach profitdriven optim proceed intern symposium code gener optim p march sorin lerner todd millstein erika rice craig chamber autom sound proof dataflow analys transform via local rule acm sigplan notic v n p januari min zhao bruce r childer mari lou soffa approach toward profitdriven optim acm transact architectur code optim taco v n p septemb ganesh sittampalam oeg de moor ken frii larsen increment execut transform specif acm sigplan notic v n p januari mathieu verbaer ran etting oeg de moor jungl script languag refactor proceed th intern confer softwar engin may shanghai china david lacey neil d jone eric van wyk carl christian frederiksen compil optim correct tempor logic higherord symbol comput v n p septemb oeg de moor david lacey eric van wyk univers regular path queri higherord symbol comput v n p marchjun