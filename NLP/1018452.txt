t complex synchron iter doall crash a abil cooper common task distribut set key solv broad rang comput problem rang distribut search seti distribut simul multiag collabor doall abstract cooper activ problem perform n task distribut system p failurepron processor mani distribut parallel algorithm develop problem sever algorithm simul develop iter doall algorithm effici solut doall measur term work complex process step taken processor count work ideal express function n p f number processor crash howev known lower bound upper bound extant algorithm adequ show work depend f present first nontrivi lower bound doall captur depend work n p f model comput processor abl make perfect loadbalanc decis local also present match upper bound defin riter doall problem abstract fact repeat use doall found typic algorithm simul fsensit analysi enabl us deriv tight bound riter doall work that stronger rfold work complex singl doall approach model perfect loadbalanc allow analysi specif algorithm divid two part i analysi cost toler failur perform work free loadbalanc ii analysi cost implement loadbalanc demonstr util gener approach improv analysi two known effici algorithm give improv analysi effici messagepass algorithm also deriv tight complet analysi best known doall algorithm synchron sharedmemori model final present new upper bound simul synchron sharedmemori algorithm crashpron processor b introduct perform set task decentr set fundament problem distribut comput ing often challeng set processor avail comput abil commun may dynam chang due perturb comput medium abstract statement problem refer doall problem p faultpron processor perform n independ task one standard problem research complex faulttoler distribut comput problem studi varieti set ting eg sharedmemori model writeal messagepass model partition network omnido solut doall must perform task ecient presenc specic failur pattern ecienc assess term work time commun complex depend specic model comput design practic distributedparallel program one need ensur good perform depend unpredict load pattern caus exampl deviat synchroni failur processor complet task time again common challeng perform n independ task p processor task could copi larg array search collect data appli function element matrix exampl includ check point larg solut space tri gener wit refut exist simpli perform number similar independ calcul paper focu work complex doall problem presenc arbitrari failur pattern impos adversari processor synchron assum failstop work complex ect amount process step expend algorithm solv problem incorpor total number task includ multipl perform algorithm distinguish featur new result complex express term number processor crash f addit number processor p size problem n approach motiv part analys consensu problem vener flp imposs result algorithm solv consensu model allow faulttoler solut teach follow i asynchron model weak faulttoler ii maximum number processor failur need includ upperlow bound imposs result eg toler f failur model consensu algorithm requir processor work consid crash failur ensur solut exist long number failur f inferior number processor p aim express work synchron processor function n p f recent unsatisfactori landscap exist respect understand upper lower bound work depend f number failur is work typic given function n p either elucid f impact work or f part equat primarili due natur specic algorithm due inher properti doall problem exampl work best known synchron sharedmemori algorithm given sole function n p also case best known asynchron sharedmemori algorithm similarli best known sharedmemori lower bound work doall parameter term f howev shown sharedmemori algorithm take least log p time step likewis best known lower bound applic messagepass model involv f work messagepass algorithm eg typic includ f due use singl coordin mean f coordin failur work necessarili includ factor f p messagepass algorithm use multipl coordin avoid ineci includ factor depend log f but show paper analysi involv f somewhat superci way thu prior lowerupp bound result doall teach adequ work complex depend number failur f consid synchron sharedmemori comput failurepron processor impact imprecis analysi work complex especi signic approach use iter doall approach execut synchron parallel pram algorithm failurepron processor simul parallel step ideal processor help chosen doall algorithm see also relat work below particular shown execut singl nprocessor step p failurepron processor exceed asymptot complex solv nsize instanc doall problem use p failurepron processor thu wnp complex solv doall instanc size n use p processor parallel timeprocessor product given nprocessor algorithm n algorithm determinist simul work o wnp analysi accur ect impact number failur f result upper bound needlessli ate contribut work studi work complex determinist doall presenc arbitrari dynam pattern stopfailur let n size doall problem p number processor f number crash f p n present rst complet analysi doall work complex perfect load balanc assumpt prove match upper lower bound function n p f model comput comput fulli abstract away lowlevel sharedmemori messagepass issu worstcas omnisci dynam adversari caus f crash also establish rst nontrivi lower bound doall moder number failur f p log p import contribut work denit analysi riter doall problem model repetit use doall algorithm such found algorithm simul demonstr util gener result show new bound work faulttoler simul arbitrari pram algorithm crashpron processor improv analysi two known ecient algorithm deriv new complet failur sensit analysi best known algorithm synchron sharedmemori model algorithm w also give improv analysi ecient messagepass algorithm algorithm let doalln stand doall problem n task p processor f failur let doall n f denot doalln problem solv use omnisci oracl assist processor but unlik oracl delphian colleagu cannot predict futur oracl assumpt use tool studi work complex pattern faulttoler algorithm implement perfect workload balanc allow complex analysi specic algorithm divid two part i analysi cost toler failur perform work assum perfect loadbalanc ii analysi cost implement perfect loadbalanc use exactli approach deriv new fsensit upper bound messagepass sharedmemori model recent shown build prior result doall n f solv work onp log p log log p f p gave match lower bound specic case log log p log log p meant long adversari caus least p log log p failur doall n p f match upper lower bound n p log p log log p also show log p doall n f solv work on thu prior newest result i nontrivi lower bound known f p log p ii fsensit analysi avail upper bound f p log p p log log p therefor iii exist gap upperlow bound analysi rang f p log log p practic concern would well serv knowledg happen doall number failur moder particular import understand behavior best known algorithm entir rang f detail contribut work follow i provid upper bound section match lower bound section address remain gap henc give complet analysi doall n f entir rang f bound work w are a log log p log c f f c p log c lower bound cours appli algorithm weaker model turn quantiti q pf dene extract bound play import role analysi complex sever algorithm log p log log p f c p log c f log c use bound deriv new bound algorithm extant analys integr f adequ done analyz workload balanc implement algorithm eg use coordin global datastructur show follow ii section provid new analysi algorithm chlebu et al doall messagepass model crash algorithm best known work moder number failur show complet analysi work w messag complex iii section give complet analysi work complex w algorithm kanellaki shvartsman solv doall writeal problem synchron sharedmemori system processor crash note two algorithm design dierent model use dissimilar data control structur howev algorithm make loadbalanc decis gather global knowledg understand work expend load balanc vs inher work overhead due lower bound abl obtain new result demonstr util gener approach doall algorithm use develop simul failurefre algorithm failurepron processor eg done iter use doall algorithm simul step failurefre processor paper abstract idea iter doall problem follow riter doalln problem use p processor solv r instanc ntask doall one set task time let g stand o describ upper bound describ lower bound logarithm base unless explicitli speci otherwis express log x stand maxf log xg given x descript complex result oracl rdoall n f dene similarli obviou solut problem run doall algorithm r time work complex doall given model wnpf work rdoall clearli r wnpf present substanti better analysi iv section show match upper lower bound work w rdoall n f p n specic rang failur a r log log p log r log pr f f p r log extract quantiti r rpf dene below bound ab abov play import role analysi complex iter doall algorithm r rpf log p log log p log log p log pr f f p r log note r q pf r rpf specic rang f b respect r xed p f thu bound asymptot better obtain comput product r noniter doall bound v section show rdoalln f solv synchron messagepass processor follow work complex w messag complex r log f r n r rpf vi section use rdoalln f show p processor crash simul synchron nprocessor rtime sharedmemori algorithm pram work last result strictli better previou determinist bound parallel algorithm simul use doall algorithm the best known date simul techniqu due relationship q pf r rpf point abov relat workalgorithm simul doall algorithm use iter simul parallel algorithm formul synchron failurefre processor determinist probabilist set commonli requir i individu processor step made idempot sinc may perform multipl time due failur asynchroni ii linear number processor auxiliari memori made avail to use scratchpad store intermedi result former solv help autom tool eg compil latter requir sophist solut diculti reus auxiliari memori due late writer ie processor slow unknowingli write stale valu memori exampl random solut address problem includ anoth import aspect algorithm simul use optimist approach comput may proceed sever step assum task assign activ processor success complet exampl seri potenti incorrect tent step combin complet denit step detect roll back incorrect comput step overal comput ecient high probabl note determinist model optim simul possibl cf howev random solut abl achiev optim whp broader rang model algorithm practic implement discuss also observ parallel comput made faster essenti ignor processor slower other rest paper structur follow section present model denit section present bound perfect loadbalanc assumpt section give new upper bound messagepass model section give upper bound sharedmemori model pram simul conclud section model denit dene model abstract problem perform n task distribut environ consist p processor subject stopfailur work complex measur distribut set consid distribut system consist p synchron processor assum p xed known processor uniqu identi pid set pid total order processor activ govern local clock nonfaulti synchron system processor clock ident model failur introduc delay local clock tick task dene task comput perform processor one time step execut depend task task also idempot ie execut task mani time andor concurr eect execut task onc task uniqu identi task identi tid set tid total order denot set n task assum known processor model failur assum failstop processor model processor may crash moment comput crash restart let omnisci adversari impos failur system use term failur pattern denot set event ie crash caus adversari failur model set failur pattern given adversari failur pattern f dene size f failur pattern the number failur oracl model section consid comput processor assist determinist omnisci oracl processor may contact oracl per step introduct oracl serv two purpos oracl strengthen model provid processor inform progress comput the oracl cannot predict futur thu lower bound establish oracl model also appli weaker model eg without oracl oracl abstract away concern commun normal domin specic messagepass sharedmemori model allow gener result establish enabl us use result context specic model understand inform provid oracl simul specic algorithm commun section deal messagepass sharedmemori model comput messagepass model assum known upper bound messag delay commun complex dene section consid comput sharedmemori model assum read write memori cell take one time unit read write concurr doall problem dene doall problem follow doall given set n task p processor perform task failur pattern failur model f let doalln stand doall problem n task p processor p n pattern crash f jf j f p let doall n stand doalln problem oracl dene iter doall problem follow iter doall given r set r n task p processor perform r n task one set time failur pattern failur model f denot riter doall rdoalln oracl version rdoall n f dene similarli measur ecienc interest studi complex doall measur work cf assum take unit time processor perform unit work singl task correspond unit work denit work complex base avail processor step measur let f adversari model comput subject failur pattern f f f denot p number processor complet unit work step comput denit given problem size n p processor algorithm solv problem failur model f algorithm solv problem pattern f f jf j f time step work complex w algorithm is note idl processor still consum unit work per step even though contribut comput denit depend specic lowlevel target model comput eg whether messagepass sharedmemori we give similar denit commun complex section bound perfect load balanc section give complet analysi upper lower bound doall n rdoall n problem entir rang f crash f p n note use quantiti q pf r rpf dene section equat respect doall upper bound studi upper bound doall give oraclebas algorithm figur oracl tell processor whether task perform oraclesay task perform next oracletask the correct algorithm trivial thu oracl perform termin loadbalanc comput behalf processor processor global n not done perform task oracletaskpid od end figur oraclebas algorithm lemma doall n problem f p n solv use work log log p note lemma teach how all work depend f number crash lemma c doall n f solv stopfailur pattern f c p log p use work proof proof base proof theorem let f denot number processor stopfailur within singl iter comput f dierent iter though sum iter cannot exceed f set f dene w n f work requir solv doall n goal show u p f work w u f p u p log p u op u p log p f u u n denot number undon task proof proce induct u base case observ u w u desir induct case assum prove theorem u u n p f consid u investig two case case u case processor assign uniqu task henc u p fp f f f u u and induct hypothesi u u p f desir case u case assumpt get f ratio number remain task u fraction processor fail iter see thi observ uc u u let u c u u bcc observ c bcc u may appli induct hypothesi complet proof suce show fp u p log bpf upper bound divid p sucient show or equival log bpf focu left hand side equat log bpf log bpf log bpf u log p p f in particular log bpf note f task complet iter recal p therefor desir induct proof denit o give main upperbound result theorem doall n f solv failur pattern use work proof follow directli lemma doall lower bound show match lower bound doall n note result section hold also doalln problem without oracl lemma algorithm alg solv doall n exist pattern f stopfailur f p result work w log log p dene specic adversari strategi use deriv lower bound let alg algorithm solv doall problem let p number processor remain end th step alg let u denot number task remain done end step i initi log p adversari adv step i alg adversari stop processor follow among u task remain step adversari choos u task least number processor assign crash processor adversari continu long u soon u adversari allow remain processor perform singl remain task alg termin follow two lemma use proof lemma lemma sort list nonneg integ lemma given g n g integ log n log g follow inequ hold z time lemma given c algorithm alg solv doall n adversari adv caus f stopfailur f c p log p f n denit adv follow u z time use lemma get log n recal log p f log log f then z time tell us adversari adv caus algorithm alg cycl least log n log p f log log fiter let denot number iter need alg termin note algorithm cycl least one iter henc log n log p f log log f now need comput lower bound p quantiti processor assign task sort ascend order let also includ quantiti unassign processor ie least number processor assign task next least quantiti processor etc let thu adversari stop exactli processor begin iter i number processor therefor number surviv processor ij use lemma get p u substitut u use properti observ work must least p p surviv processor alg ter minat consid two case case log p log p let f denot total number failstop alg termin log p log p f sinc log log p log p f log p therefor adversari adv caus processor failstop allow work caus adv case is f log p case log p f log log f log p log n log p f log log f p log p log p log p log p log p log p f henc adv caus failstop allow work caus adv case is log n log p log n log n f log n note w sinc p log n p recal f c p log p henc p c p f in particular suce p two case denit get that wnpf log n log p f lemma given c algorithm alg solv doall n exist adversari caus f stopfailur f c p log p f follow lemma slightli modifi adversari adv give main lowerbound result theorem given algorithm alg solv doall n exist adversari caus proof rang failur f c p log establish bound lemma also obtain fact log p work must log log p larger f adversari establish worst case work use initi c p log p failur iter doall doall algorithm use develop simul failurefre algorithm failurepron processor done iter use doall algorithm simul step failurefre processor studi iter doall problem understand complex implic iter use doall algorithm obviou rdoalln f solv run doalln time work doall solut w work riter doall r w howev show possibl obtain ner result refer doall iter round rdoall n theorem rdoall n solv denot th round rdoall n number activ processor begin r f number crash r note p rst round rdoall n f p consid two case case f p r log consid round r theorem get work round log log log log p howev case f log p r without run out processor thu work case or log log p case f p r log first observ reason adversari would kill p log processor round r sinc would caus work on log log log p which achiev f log therefor consid f log round r henc work everi round r per theorem on log log log p let w n f oneround upper bound upper bound rdo n f given maxim failur pattern may assum p purpos upper bound show maximum attain f simplic treat f continu paramet consid factor singl round work express given abov depend f here c constant hidden o notat rst deriv f clog p second deriv clog p observ second deriv neg domain consid and long p henc rst deriv decreas with f case given two f failur pattern obtain replac f result increas work impli sum maxim f equal specic f upper bound sum rang hold particular choic made adversari must cours caus integ number fault round therefor log pr f result follow denit r rpf combin two case theorem given algorithm solv rdoall n exist stop failur adversari caus r n r rpf consid two case case f p r log case adversari may failstop p log p processor everi round r doall n note adversari processor remain aliv rst dre round per theorem result dre log log p log log p work case f p r log case adversari ideal would kill f r processor everi round case f divid r case adversari kill f r e processor r round b f r c r b round way consid rst half round appeal theorem result rn p log rp f lower bound work note consid case r f otherwis work trivial new bound messagepass model section demonstr util complex result perfect loadbalanc assumpt give tight complet analysi algorithm establish new complex result iter doall messagepass model analysi algorithm algorithm present chlebu et al use multiplecoordin approach solv do alln f crashpron synchron messagepass processor model assum messag incur known bound delay reliabl multicast avail howev messag tofrom faulti processor may lost ecienc algorithm character term work messag complex dene messag complex similarli denit work comput subject failur pattern f f f denot number pointtopoint messag sent step comput given problem size n comput solv problem step presenc failur pattern f jf j f messag complex descript algorithm an due space limit give brief descript algorithm addit detail given appendix but avoid complet restat refer reader algorithm proce loop iter task execut singl iter loop call phase phase consist three consecut stage stage consist three step stage processor use rst step receiv messag sent previou stage second step perform local comput third step send messag processor coordin worker phase may multipl coordin number processor assum coordin role determin martingal principl none expect coordin surviv entir phase number coordin next phase doubl least one coordin surviv given phase next phase one coordin phase complet least one coordin aliv call attend otherwis call unattend processor becom coordin balanc load accord processor local view processor local view contain set processor id assum aliv local view partit layer rst layer contain one processor second two processor third four processor on given phase rst stage processor perform task accord load balanc rule deriv local view report complet task coordin phase determin local view second stage coordin gather report updat knowledg done task multicast inform processor accord local view aliv last stage processor receiv inform sent coordin updat knowledg done task local view given full detail algorithm dicult see combin coordin local view allow processor obtain inform would avail oracl algorithm figur shown work algorithm log n log log n log f messag complex new analysi work complex assess work w consid separ attend phase unattend phase execut let w part w spent attend phase w u part w spent unattend phase henc note p n lemma execut algorithm f p w log log p w give new analysi algorithm an lemma execut algorithm w on p log p f log p c given phase execut algorithm an dene p number live processor u number undon task begin phase attend phase execut last phase execut observ hold u u i follow construct algorithm an sinc phase attend least one coordin call c aliv phase c execut one task henc least one task execut consequ least one task taken u number processor decreas sinc allow restart therefor focus attend phase proof lemma induct size undon task u note proof proce proof lemma p n theorem execut algorithm follow lemma fact analysi messag complex assess messag complex consid separ attend phase unattend phase execut let number messag sent attend phase u number messag sent unattend phase henc lemma execut algorithm ow theorem execut algorithm proof proof follow lemma fact analysi messagepass iter doall consid rdoalln f problem p n messagepass model theorem rdoalln f problem solv synchron messagepass crash prone processor work r n or n r rpf sketch iter doall solv run algorithm r instanc size n sequenc call algorithm an analyz ecienc an use approach proof theorem current context base work complex argument result theorem base messag complex argument result theorem new bound sharedmemori model give new rene analysi workeci known doall algorithm sharedmemori model algorithm w also establish complex result iter doall simul synchron parallel algorithm crashpron processor analysi algorithm w algorithm w solv doalln f sharedmemori model where doall better known writeal work pattern crash on note bound conserv sinc includ f number crash descript algorithm give brief descript algorithm addit detail found appendix but avoid complet restat refer reader algorithm w structur parallel loop four phase w failur detect phase w load reschedul phase w work phase w phase estim progress comput remain work control parallel loop phase use full binari tree on leav processor travers binari tree topdown bottomup accord phase travers take olog n time the height tree singl processor iter loop call blockstep sinc four phase one tree travers per phase block step take olog n time algorithm w tree store share memori serv gather place global inform number activ processor remain task load balanc dicult see binari tree inde provid inform processor would avail oracl oracl model binari tree use phase w implement load balanc phase w assess remain work call progress tree use parameter version algorithm p n progress tree leav task associ leav tree nu task per leaf note blockstep still take time olog n new complex analysi give work analysi charg processor block step start regardless whether processor complet crash lemma failur pattern f p number blockstep requir processor algorithm w u leav progress tree log log p lemma failur pattern f c p log p for c number blockstep requir p processor algorithm w u leav progress tree f processor blockstep shown equival processor step perfect loadbalanc assumpt henc proof proof lemma theorem algorithm w solv doalln consid follow two case case p n log number leav progress tree log n work phase w processor perform task cost singl blockstep c sinc four phase take log n time consid two subcas a f p log p lemma give number blocksstep b case ou log p f o n log log p f therefor work w case b c log p f log p lemma give number blockstep b b case ou p log p log log p o n log n p log p log log p therefor work w b case b b c log log p two subcas togeth denit q pf yield w case n log n p n number leav progress tree work phase w processor perform n task thu cost singl blockstep consid two subcas a f p log p lemma give number blockstep b case ou log p f opp log p log p f log p f therefor work w case b c log p f log p lemma give number blockstep b b case op p log p log log p op log p log log p therefor work w b b b c log log p last two subcas denit q pf yield w combin case case result get iter doall parallel algorithm simul consid complex sharedmemori rdoalln f pram simul theorem rdoalln f problem solv p crashpron processor p n use share memori work sketch iter doall solv run algorithm w r instanc size n sequenc call algorithm w analyz ecienc w use approach proof theorem current context base work complex argument result theorem state anoth main result paper theorem synchron nprocessor rtime sharedmemori parallel algorithm pram simul p crashpron synchron processor work or n r rpf log n proof complex simul singl parallel step n ideal processor p crashpron processor exceed complex solv singl doalln instanc result follow theorem conclus paper gave rst complet analysi doall problem perfect loadbalanc assumpt introduc analyz iter doall problem model repeat use doall algorithm found algorithm simul transform uniqu contribut analys precis describ eect crash failur work comput analys obtain perfect loadbalanc assumpt immedi use use analyz algorithm simul attempt balanc load among processor final provid rst failuresensit analysi work iter doall problem messagepass sharedmemori model r tr effici parallel algorithm made robust effici robust parallel comput combin tent definit execut fast depend parallel comput achiev optim crcw pram faulttoler effici program transform resili parallel comput via random preliminari version perform work effici presenc fault workoptim asynchron algorithm share memori parallel comput complex certifi writeal algorithm timeoptim messageeffici work perform presenc fault parallel algorithm processor failur delay algorithm certifi writeal problem faulttoler broadcast relat problem failstop processor setihomemyampersandmdashmass distribut comput seti faulttoler parallel comput distribut cooper absenc commun complex synchron iter doall crash optim freliabl protocol doall problem singlehop wireless network resolv messag complex byzantin agreement beyond parallel random access machin parallel process network workstat cooper comput fragment mergeabl group ctr chryssi georgiou dariusz r kowalski alexand a shvartsman effici gossip robust distribut comput theoret comput scienc v n p novemb antonio fernndez chryssi georgiou alexand russel alex a shvartsman doall problem byzantin processor failur theoret comput scienc v n p march