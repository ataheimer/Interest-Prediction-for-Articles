t onlin hierarch cooper cach a address hierarch gener wellknown disk page problem hierarch cooper cach problem set n machin resid ultrametr space cooper one anoth satisfi sequenc read request collect readonli file semin result area competit analysi state lru the widelyus determinist onlin page algorithm base least recent use evict polici constantcompetit given constantfactor blowup capac offlin algorithm constantcompetit determinist algorithm with constantfactor blowup machin capac exist hierarch cooper cach problem main contribut present paper answer question neg specif establish log log n lower bound competit ratio onlin hierarch cooper cach algorithm capac blowup olog n denot arbitrarili small posit constant b introduct tradit page problem extens studi defin follow given cach sequenc request file uniform size system satisfi request one one file f request cach cost incur otherwis uniform retriev cost incur place f cach need be file determin onlin cach algorithm know futur request sequenc evict make room f object minim total retriev cost wise choos file evict cost onlin algorithm compar optim oin algorithm opt full knowledg request sequenc follow sleator tarjan call onlin algorithm ccompetit cost c time opt request sequenc wellknown optim oin strategi evict file request furthest futur page problem also known cach file nonuniform size retriev cost semin paper sleator tarjan shown lru least recentlyus sever determinist page algorithm k competit k cach space use lru h use opt also shown k kh best possibl among determinist algorithm call k h capac blowup lru file nonuniform size retriev cost young propos landlord algorithm shown landlord k kh competit state focu landlord is simpl local cach strategi rather distribut strategi cach cooper cach page across network cooper cach set cach cooper serv request make cach deci sion benefit cooper cach support sever studi exampl harvest cach introduc notion hierarch arrang cach harvest use internet cach protocol support discoveri retriev document cach harvest project later becam public domain squid cach system adapt web cach build mesh overlap multicast tree popular file pull toward user origin server localarea network environ xf system util cooper cach obtain serverless file system cooper cach scheme roughli divid three compon placement determin place copi file search direct request appropri copi request file consist maintain desir level consist among variou copi file paper studi placement problem assum separ mechan enabl cach locat nearest copi file free cost assum file readonli ie copi file alway consist focu class network call hierarch network precis definit given section call cooper cach problem network hierarch cooper cach hcc problem notion hierarch network constantfactor relat notion hierarch wellsepar tree metric introduc bartal refin earlier result bartal fakcharoenphol et al shown metric space approxim wellsepar tree metric logarithm distort henc mani result tree metric impli correspond result arbitrari metric space addit logarithm factor access frequenc file cach known advanc korupolu et al provid exact approxim algorithm minim averag retriev cost practic access frequenc often unknown expens track sinc lru landlord provid constant competit singl cach natur ask whether exist determinist constantcompetit algorithm with constant capac blowup hierarch cooper cach problem paper answer question neg show log n lower bound competit ratio determinist onlin algorithm capac blowup olog n n number cach hierarchi arbitrarili small posit constant particular construct hierarchi sucient larg depth show adversari gener arbitrarili long request sequenc onlin algorithm incur costt log n time adversari in terestingli oin algorithm associ lower bound argument replic file hand onlin algorithm given suffici larg capac blowup constant competit easili achiev appendix show result that given od capac blowup depth hierarchi ie n lrulik onlin algorithm constantcompetit note term d lower bound result yield capac blow od competit ratio d henc result impli small rang valu capac blowup separ region constant competit achiev unachiev draw analog tradit cach lru landlord provid constant competit may think constantcompetit algorithm exist hcc perhap hierarch variant lru landlord fact began investig search algorithm sinc hcc problem gener page problem cannot hope achiev constant compet without least constant capac blowup in regard remark result incompar requir capac blowup sever page problem eg distribut page file mi gration file alloc consid lit eratur relat hcc problem see eg survey paper bartal definit problem particular hcc problem formul readonli version distribut page problem ultrametr hcc problem without replic special case constrain file migrat problem access migrat file cost exist work problem focus upper bound result lower bound result appli algorithm without capac blowup exampl distribut page problem awerbuch et al shown that given polylogn capac blowup exist determinist polylogn competit algorithm gener network normal diamet net work constrain file migrat problem bartal given determinist upper bound m total size cach random lower bound m network topolog olog log n random upper bound arbitrari network topolog use recent result fakcharoenphol et al last upper bound improv olog log n rest paper organ follow section give preliminari problem section present main result paper lower bound constant capac blowup section provid conclud remark appendix present upper bound su cientli larg capac blowup preliminari section formal defin hcc problem given fix sixtupl f set file c set cach dist function cc n size function f n cap function c n penalti function f n n denot nonneg integ assum dist ultrametr defin below c assum everi file f f penaltyf diamc diamu denot maxuvu distu v everi set cach u ultrametr hierarch network distanc function c c n defin metric nonneg symmetr satisfi triangl inequ du special case metric satisfi inequ subsum triangl inequ equival perhap intuit character ultrametr assumpt cach c form hierarch tree simpli tree defin follow everi leaf node tree correspond distinct cach everi node tree associ nonneg valu call diamet node everi two cach u v distu v equal diamet least common ancestor u v sinc hierarch network natur correspond tree rest paper use tree terminolog develop algorithm analysi follow definit ancestor descend parent children follow standard tree terminolog use denot tree cach use root denot root depth root depth maximum depth node capac node total capac cach within subtre root node impos arbitrari order children everi intern node hcc problem goal hcc algorithm minim total cost incur movement file serv sequenc request respect capac constraint cach facilit formal definit problem introduc addit definit below copi pair u f u cach f file set copi call placement u f belong placement p say copi f place u p placement p bfeasibl total size file place cach b time capac cach feasibl placement simpli refer feasibl placement given placement p upon request file f cach u algorithm incur access cost serv request p place least one copi f cach cost defin sizef distu v v closest cach copi f place otherwis cost defin penaltyf serv request algorithm may modifi placement via arbitrarili long sequenc follow two oper may add copi p incur access cost defin abov may remov copi p incur cost given capac blowup b goal hcc algorithm maintain bfeasibl placement total cost minim lower bound section show that given constant capac blowup b competit ratio onlin hcc algorith is d depth hierarchi prove lower bound algorithm show exist suitabl hierarchi set file request sequenc feasibl oin hcc algorithm incur d factor lower cost request sequenc onlin bfeasibl hcc algorithm result easili extend analyz lower bound competit ratio vari function nonconst capac blowup depth hierarchi particular capac blowup fix competit ratio onlin hcc algorithm still ill d present adversari argument lower bound let denot bfeasibl onlin hcc algorithm adv adversari oin feasibl hcc algorithm choos fix valu capac blowup b adv subsequ choos instanc hcc problem ie sixtupl introduc section follow hi erarchi tree consist n units cach form leav regular kari tree depth given choic k set file consist units file diamet everi leaf node ie cach diamet node depth bk diamet everi intern node least time diamet child file f penaltyf least diamroot given instanc hcc problem describ section give program take input gener request sequenc oin hcc algorithm incur d less cost on high level on lack futur knowledg empow adv play game analog shell game game maintain compact placement file tailor request sequenc adv gener forc guess off placement incur reloc cost guess incorrectli final zero off placement switch placement around incur small fraction reloc cost alreadi expend repeat game exampl consid simpl twolevel hierarchi associ equals depart within univers set file say a universitywid interest remain file departmentspecif interest capac constraint set way depart either cach file interest univers set simultan store file idl depart ie one access activ hand guess ident idl de partment guess incorrectli adv creat request forc move file dierent depart best strategi evenli distribut file across depart yet expos nonidl unfortun even strategi end incur significantli higher cost off cours simplist case circumv predica simpli twofold blowup capac use algorithm describ appendix a rest paper present formal shellgamelik adversari strategi extens strategi hierarchi nonconst depth adversari algorithm adv fix disjoint set file sd sd d call depth file f f defin function gi j adv shown figur key notat use algorithm and rest paper explain tabl adv nonneg integ n specifi number request gener code figur show adv gener bad request sequenc on section show augment code obtain oin algorithm serv request sequenc incur much lower cost everi node adv maintain two integ field x y summar state on adv global variabl record current node adv gener next request initi set root program proce round end round algorithm gener request base on adjust placement adv adjust use loop loop former move ancestor latter move descend play especi three walnut shell notat mean parent parent anc ancestor desc descend depth depth diam diamet file cap total capac with blowup cach ch children hierarchi place set distinct file place cach load number file f place depth f less depth miss set file f depth f depth f place act gdepth r activ valu react gdepth k reactiv valu deact gdepth k deactiv valu tabl key notat initi count n main loop load deact up loop everi child set x y parent od end loop miss down loop child satisfi x load react els exactli one child x equal everi child set x y child set x y act od end loop gener request element miss arbitrari cach serv request arbitrarili updat placement count count od end main loop figur adv algorithm correct adv show section adv welldefin ie root line leaf line line find child round termin gener request sake breviti reason below call predic global invari hold everywher adv ie hold initi hold two adjac line pseudocod figur lemma let denot everi intern node child x field equal denot intern node denot load deact global invari hold everywher loop proof predic hold initi root hold loop due guard loop next show everi line code loop preserv i ie hold line hold line everi line code loop preserv i i everi line code loop preserv none assign nonzero valu x field line aect line observ root line due guard loop observ root load root deact henc line preserv loop line aect inner statement establish least two children x field equal line henc line preserv line aect line first observ line depth bk state depth bk impli depth sinc load integ impli load bk impli miss bk contradict guard loop henc depth bk line therefor line preserv show line also preserv let ch x let r denot a denot depth observ a load a load load load deact react in deriv abov second equal due guard loop definit load first inequ due guard outer statement henc averag argument exist child load act henc line find child shown abov depth line henc line preserv line aect line preserv definit act deact react deact claim lemma follow lemma loop termin proof everi iter loop move parent root load root deact definit henc loop termin lemma loop termin proof everi iter loop move one children lemma alway intern node henc loop termin lemma adv termin gener sequenc n request proof follow lemma cost account section show exist oin hcc algorithm serv sequenc request gener adv incur cost log less incur bfeasibl onlin hcc algorithm properti adv first prove properti adv follow directli structur sake breviti properti global invari sometim state properti omit state properti hold everywher lemma react proof claim hold initi line assign nonzero valu x preserv claim definit act react lemma y equal react x proof claim hold initi rooti rootx line modifi x line modifi inspect code line trivial preserv claim lemma let p denot predic everi node anc posit x valu everi node neither anc child node anc zero x valu p hold initi loop invari loop loop main loop proof initi p hold let denot anc let b denot set node neither children node a everi iter loop move parent avoid confus use denot old node ie child denot new node ie parent iter loop remov a add ch b set x valu ch therefor preserv p everi iter loop move one chil dren avoid confus use denot old node ie parent denot new node ie child suppos loop take first branch outer statement add posit x valu remov ch b henc preserv p suppos loop take second branch outer state ment line execut p preserv line preserv b chang x valu node neither b line preserv p add posit x valu line remov ch b henc preserv p main loop preserv p loop loop preserv p lemma y x proof claim hold initi line modifi x field line x field becom valu follow lemma guard loop line root x follow lemma line preserv y x introduc notion activ sequenc subsequ proof sequenc a ar call iactiv lemma everi intern node nonzero x field children form iactiv sequenc proof claim hold initi root line modifi x field line preserv claim x field children becom preserv claim for parent x becom act definit equal gi k j j equal number children parent posit x field lemma let p denot predic ancestor y react p hold initi p loop invari loop loop main loop proof predic p hold initi root loop preserv everi iter first establish y react move parent loop preserv set field nonzero valu main loop preserv p loop loop preserv p color order facilit present oin algorithm section introduc notion color section notion consist placement next color recal tree cach assign one color white black everi node follow rule observ root white everi intern white node exactli one black child k white children children black node black color call consist with adv everi x white color c pair sibl node defin swapcc swap color color obtain c exchang color node subtre root correspond node subtre root note subtre root ident structur consist placement placement color exist color c that white intern node set file file store and fill cach associ uniqu black child white leaf set file file store and fill cach note preced definit color place ment color c exist uniqu placement call consist color associ color consist placement p pair sibl defin swappp swap placement placement obtain p exchang content cach correspond cach note color placement p associ color c pair sibl node placement swappp color associ color swapcc offlin algorithm everi intern node maintain addit variabl last defin follow first partit execut adversari algorithm epoch respect first epoch begin start execut subsequ epoch begin either line line execut variabl last updat start epoch set child line execut furthest futur if one children line never execut futur last set arbitrari child note variabl last introduc sole purpos analysi impact execut adv point execut adv valu last field determin uniqu color denot coff follow root white black child intern white node last defin oin algorithm maintain placement poff follow initi poff arbitrari consist placement associ color coff updat poff swapppoff whenev line line execut denot valu last execut line algorithm use placement poff serv request gener line placement poff updat serv request poff updat line lemma throughout execut adv poff color associ color coff proof immedi way poff updat whenev last field updat lemma execut line line preserv consist coff proof assum coff consist line white coff line lemma x posit line definit coff line last black let last line let last line line x valu descend equal lemma x valu proper descend equal line sinc line x valu descend equal line henc swapp oper preserv consist coff argument appli line lemma execut line preserv consist coff proof assum coff consist line line impli root line let denot parent lemma x henc white line therefor lemma last black child let denot start current epoch ie recent time last assign time t x valu children equal definit t child set sinc time t lemma everi intern node least one child x equal therefor time execut line k children x valu set nonzero valu note line line set x nonzero valu thu definit last lastx remain execut line thu last sinc white last black coff conclud white coff coff remain consist even addit constraint requir white note x set posit valu line lemma placement poff alway consist proof observ coff alway consist due lemma observ line line aect consist coff becaus line modifi last field x field node follow lemma poff alway consist potenti function argument let denot arbitrari onlin bfeasibl algorithm section use potenti function argument show let ton denot total cost incur on similarli let toff denot total cost incur off except exclud toff cost initi poff thi initi cost taken account proof theorem below defin potenti as ancroot parent diam x parent diam x y conveni exposit account cost move empti placement first placement separ lemma cost incur swappp parent diam proof cost incur cost exchang file place other parent diam note capac lemma predic loop invari loop proof everi iter loop move parent avoid confus use refer old node ie child use refer new node ie parent consid chang singl iter loop incur cost loop definit line preserv lemma line increas let execut line incur cost diam move current consist mark placement next thu total chang iter in deriv abov first inequ due guard loop line second inequ due assumpt diamet node separ lemma predic loop invari loop proof everi iter loop move one children avoid confus use refer old node ie parent refer new node ie child incur cost loop consid follow three case suppos outer statement take first branch case incur cost thu chang inequ due lemma guard outer statement suppos outer statement take second branch line execut case incur cost thu chang first inequ due lemma second inequ due line suppos outer statement take second branch line execut lemma case incur cost thu chang due line ch ch in deriv first inequ follow lemma first equal follow lemma analysi previou case ie outer statement take second branch line execut line increas thu everi iter loop preserv lemma line preserv proof guard loop ensur exist file miss line thu incur cost least parent diam diam line incur cost diam store file miss child let u cach request gener let set node path u exclud sinc add file miss u chang a parent diam in deriv last inequ follow line allow make arbitrarili mani updat placement suppos updat caus load node increas definit load set node increas load valu form path from say leaf incur cost least parent diam let set node path b sinc diamet node path separ chang parent diam parent diam parent diam parent diam parent diam claim lemma follow theorem competit proof initi loop invari main loop therefor lemma ton hold initi loop invari main loop let c cost incur move empti placement first placement note ton serv everi request cost least becaus diamet intern node least henc given arbitrarili long sequenc request ton grow unbound therefor make arbitrarili close increas length n request sequenc gener program the log bound competit ratio capac claim begin section follow bk choos arbitrarili larg discuss cooper cach fact found applic area distribut system exampl nuca nonuniform cach architectur switch network allow data migrat dierent cach region accord access frequenc although nuca support singl processor time write multiprocessor nuca develop data replic possibl r serverless network file system distribut page gener network approxim arbitrari metric tree metric distribut page harvest inform discoveri access system cooper cach use remot client memori improv file system perform tight bound approxim arbitrari metric tree metric adapt placement algorithm hierarch cooper cach amort e squid internet object cach tr amort effici list updat page rule harvest inform discoveri access system serverless network file system distribut page gener network placement algorithm hierarch cooper cach adapt nonuniform cach structur wiredelay domin onchip cach distribut page tight bound approxim arbitrari metric tree metric probabilist approxim metric space algorithm applic