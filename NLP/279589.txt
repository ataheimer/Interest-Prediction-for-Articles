t analysi cacherel preemption delay fixedprior preemptiv schedul a abstractw propos techniqu analyz cacherel preemption delay task caus unpredict variat task execut time context fixedprior preemptiv schedul propos techniqu consist two step first step perform pertask analysi estim cacherel preemption cost execut point given task second step comput worst case respons time task includ cacherel preemption delay use respons time equat linear program techniqu step take input preemption cost inform task obtain first step paper also compar propos approach previou approach result show propos approach give predict worst case cacherel preemption delay percent tighter obtain previou approach b introduct realtim system task time constraint must satisfi correct op erat guarante time constraint extens studi perform schedul analysi they mani case make number assumpt simplifi analysi one simplifi assumpt cost task preemption zero real system howev task preemption incur addit cost process interrupt manipul task queue actual perform context switch mani direct cost address number recent studi focu practic issu relat task schedul howev addit direct cost task preemption introduc indirect cost due cach memori use almost comput system today comput system cach memori task preempt larg number memori block belong task displac cach memori time task preempt time task resum execut preempt task resum execut spend substanti amount time reload cach previous displac memori block cach reload greatli increas task execut time may invalid result schedul analysi overlook cacherel preemption cost rectifi problem recent studi address issu incorpor cacherel preemption cost schedul analysi studi assum cach block use preempt task replac cach memori block need preempt task pessimist assumpt lead loos estim cacherel preemption delay sinc replac memori block may use preempt task exampl possibl replac memori block one longer block minimum unit inform either present present cachemain memori hierarchi assum without loss gener memori refer made unit block need one replac without rereferenc even preemption paper propos schedul analysi techniqu consid use cach block comput cacherel preemption delay goal reduc predict inaccuraci result pessimist assumpt propos techniqu consist two step first step perform pertask analysi comput number use cach block execut point given task use cach block execut point defin cach block contain memori block may rereferenc replac anoth memori block number use cach block execut point give upper bound cacherel preemption cost incur task preempt point result pertask analysi given tabl specifi worst case preemption cost given number preemption task tabl second step deriv worst case respons time task use linear program techniqu worst case respons time equat paper organ follow section ii survey relat work section iii describ overal approach schedul analysi consid cacherel preemption cost section iv v detail two step propos schedul analysi techniqu focus directmap instruct cach memori section vi present result experi assess effect propos approach section vii describ extens propos techniqu setassoci cach memori also data cach memori final conclud paper section viii ii relat work a schedul analysi fixedprior schedul larg number schedul analysi techniqu propos within fixedprior schedul framework liu layland show rate monoton prioriti assign task shorter period given higher prioriti optim task deadlin equal period also give follow suffici condit schedul task set consist n period task c worst case execut time wcet estim period condit state total util task set ie lower given util bound ie n n gamma task set guarante schedul rate monoton prioriti assign later lehoczki et al develop necessari suffici condit schedul base util bound anoth approach schedul analysi worst case respons time approach approach use follow recurr equat comput worst case respons hpi set task whose prioriti higher equat term jhpi r ec j total interfer higher prioriti task r c s execut time equat solv iter iter termin r converg valu r valu compar s deadlin notat use throughout paper along denot deadlin assum without loss gener higher prioriti determin schedul recent katcher et al burn et al provid methodolog incorpor cost preemption schedul analysi approach preemption cost aris interrupt handl task queue manipul contextswitch taken account schedul analysi paper also interest incorpor cost preemption schedul analysi howev unlik studi main focu indirect preemption cost due cach memori increasingli use realtim comput system b cach realtim system cach memori use almost comput system today bridg ever increas speed gap processor main memori howev due unpredict per formanc cach memori wide use realtim comput system guarante worst case perform great import unpredict perform come two sourc intratask interfer intertask interfer interfer occur memori block task conflict cach anoth block task recent consider progress analysi intratask interfer due cach memori interest reader refer intertask interfer main focu paper occur memori block differ task conflict one anoth cach two way address unpredict result intertask interfer first way use cach partit cach memori divid disjoint partit one partit dedic realtim task techniqu task allow access partit thu need consid intertask in terfer two differ approach cach partit hardwarebas softwarebas hardwarebas approach extra addressmap hardwar place processor cach memori limit cach access task partit hand softwarebas approach special compil linker use map task code data assign cach partit cach partit improv predict system remov cacherel intertask interfer number drawback one common drawback hardwar softwarebas approach requir modif exist hardwar softwar anoth common drawback limit amount cach memori avail individu task final case hardwarebas approach extra addressmap hardwar may stretch processor cycl time affect execut time everi instruct way address unpredict result intertask interfer devis effici method analyz time effect basumallick nilsen extend rate monoton analysi explain previou subsect take account intertask interfer approach wcet estim task modifi c origin wcet estim comput assum task execut without preemption fl worst case preemption cost task might impos preempt task modif base pessimist assumpt cach block use preempt task replac cach memori block need preempt task approach total util given task set comput modifi wcet estim compar util bound given equat determin schedul task set one drawback approach suffer pessimist util bound given equat approach larg n mani task set total util higher bound success schedul rate monoton prioriti assign rectifi problem busquetsmataix et al propos techniqu base respons time approach techniqu make pessimist assumpt cach block use preempt task replac cach memori block need preempt task assumpt lead follow equat comput worst case respons time task e theta c j cacherel preemption cost task j might impos lower prioriti task term fl j comput multipli number cach block use task j time need refil cach block util bound base respons time base approach assum cach block use preempt task replac cach memori block need preempt task pessimist assumpt lead loos estim cacherel preemption delay sinc possibl replac memori block one longer need one replac without rereferenc even lower prioriti task execut without preemption iii overal approach section overview propos schedul analysi techniqu aim minim overestim cacherel preemption delay due pessimist assumpt explain previou section purpos respons time equat augment follow propos pc r total cacherel preemption delay task r ie total cach reload time r fig exampl pc r mean pc r best explain exampl one given figur exampl three task arrow figur denot point task preempt shade rectangl denot cach reload correspond task resum execut set pc r total cacherel preemption delay task r total sum cach reload time r correspond sum shade rectangl figur augment respons time equat solv iter follow r r k r k befor iter procedur termin r converg r valu compar s deadlin determin schedul comput pc r k iter take follow twostep approach pertask analysi static analyz task determin cacherel preemption cost execut point cost task pay preempt execut point upperbound number use cach block execut point base inform inform worst case visit count execut point construct follow preemption cost tabl task preemption cost tabl f k kth margin preemption cost cost task pay worst case kth preemption preemption preemption delay analysi use linear program techniqu comput r k preemption cost tabl task set constraint number preemption task higher prioriti task follow two section detail two step iv pertask analysi use cach block section describ pertask analysi techniqu obtain preemption cost tabl task initi focu case directmap instruct cach memori section section vii discuss extens setassoci cach memori also data cach memori exampl cacherel preemption cost consid directmap cach four cach block assum cach time cach block c assum follow memori block refer made t directmap cach memori block place exactli one cach block whose index given memori block number modulo number block cach exampl use cach block time cach block c c sinc contain memori block respect rereferenc replac hand cach block c c use time sinc replac without rereferenc preemption occur time t memori block contain cach block c c may replac memori block interven task thu need reload cach resumpt addit time reload use cach block cacherel preemption cost time t note addit cach reload time need task preempt follow explain techniqu estim number use cach block point program a estim number use cach block techniqu estim number use cach block base data flow analysi task program express control flow graph cfg give cfg node repres basic block edg repres potenti flow control basic block x b cach state p use use cach block j cach block a control flow p fig analysi use cach block intuit idea data flow analysi consid cfg given figur figur pair c m denot refer memori block map cach block c cfg two incom path execut point p ie two outgo path p ie control flow came incom path cach block c would contain memori block point p sinc last refer cach block c reach p similarli cach block c would memori block b point p control come incom path thu either b may resid cach block c p depend incom path either first refer cach block c outgo path p cach block may reus thu defin use point p outgo path path thu cach block c defin use p formal descript defin reach memori block rmb live memori block lmb cach block similar reach definit live variabl use tradit data flow analysi set reach memori block cach block c point p denot rmb c contain possibl state cach block c point p possibl state correspond memori block may resid cach block point memori block resid cach block c first map cach block c furthermor last refer cach block execut path reach p set live memori block cach block c point p denot p defin similarli set memori block may first refer cach block c p definit use cach block point p defin cach block whose rmb lmb least one common memori block figur rmb c fm b g lmb c p fm g thu cach block c defin use point p follow explain comput rmb cach block variou execut point given program initi focu rmb begin end point basic block rmb point easili deriv rmb basic block boundari see later formul problem comput rmb data flow problem defin set gen c b set either null contain singl memori block null basic block refer memori block map cach block c hand basic block b least one refer memori block map c gen c b contain uniqu element memori block last refer cach block c basic block note latter case memori block gen c b one resid cach block c end basic block b also note gen c b defin manner comput local basic block exampl consid cfg given figur cfg show instruct memori block refer made basic block assum instruct cach direct map two block gen c b fm g sinc memori block whose refer last refer c b gen c b set basic block cach block comput similarli given figur gen c b defin manner rmb c begin b end b denot rmb c b rmb c b respect comput follow two equat p predecessor b b gen c b gen c b null b otherwis first equat state memori block reach begin basic block deriv reach end predecessor b second equa basic block sequenc consecut instruct flow control enter begin leav end without halt possibl branch except end c c c fig exampl gen c b tion state rmb c b equal gen c b gen c b null rmb c b otherwis data flow equat solv use wellknown iter approach start rmb c iter converg desir valu rmb c s rmb c s iter process describ procedur follow algorithm find rmb cach block begin end basic block assum gen c b comput basic block b cach block c initi rmb c b rmb c bs cs basic block b cach block c begin equat rewritten set kill c b set reach memori block cach block c kill basic block b set kill c b obtain follow null gen c b null mc gamma gen c b gen c b null mc set memori block map c program rewritten form commonli use tradit data flow analysi b b gen c b chang true chang begin chang fals basic block b cach block c begin b p predecessor b p oldout rmb c b b gen c b els rmb c b rmb c b rmb c b oldout chang true indic earlier rmb point within basic block comput rmb begin basic block assum basic block follow sequenc instruct memori block refer refer process sequenti start c clear cach block c point follow refer conflict memori block c point therefor rmb c refer simpli fm g howev rmb cach block b gener rmb c cach block c problem comput lmb formul similarli case rmb differ lmb problem backward data flow problem set ie lmb c b comput set ie lmb c b wherea rmb problem forward data flow problem set ie rmb c b comput set ie rmb c b lmb problem set gen c b either set one element correspond memori block whose refer first refer cach block c basic block b null none refer b memori block map c use gen c b defin manner follow two equat relat lmb c b lmb c b successor b s b gen c b gen c b null b otherwis iter algorithm similar one comput rmb use solv backward data flow problem differ algorithm start lmb c bs cs use two equat instead given equat comput lmb begin end basic block lmb point comput analog case rmb differ process refer backward start end basic block rather forward start begin lmb problem lmb c refer cach block use cach block determin point comput intersect cach block rmb lmb point trivial calcul total number use cach block point simpli count use cach block point multipli total number use cach block time refil cach block worst case cacherel preemption cost point comput b deriv preemption cost tabl subsect explain construct preemption cost tabl task whose kth entri cost task pay worst case kth preemption th preemption preemption cost tabl construct two type inform preemption cost point worst case visit count point directli deriv cfg given program loop bound loop program construct assum worst case preemption scenario sinc cannot predict advanc preemption actual occur worst case preemption scenario occur first preemption point largest preemption cost ie point largest number use cach block second preemption point next largest preemption cost on worst case preemption scenario assum analysi safe worst case preemption scenario entri preemption cost tabl fill follow first pick point p largest preemption cost fill first entri v p th entri preemption cost v p worst case visit count p that pick point second largest preemption cost perform step start v p th entri process repeat number entri preemption cost tabl exhaust assum number entri tabl k k th margin preemption cost k k conserv estim kth margin preemption cost sinc margin preemption cost nonincreas appli pertask analysi explain section task task set obtain follow set preemption cost tabl one task f ij jth margin preemption cost preemption cost f f f preemption cost f f f preemption cost f f f preemption cost f n f n f n v calcul worst case preemption delay task section explain comput safe upper bound pc r k use equat section iii preemption cost tabl formul problem integ linear program problem set constraint first defin g jl number invoc j preempt least l time given respons time r k exampl consid figur task j invok three time given r k first invoc task j ie j preempt three time second third invoc j ie j j preempt onc definit g jl g j g j g j note sinc highest prioriti task cannot preempt fig definit g jl assum know g jl valu give worst case preemption scenario among task calcul worst case cacherel preemption delay r k r k f jl lth margin preemption cost j note total cacherel preemption delay includ delay due preemption higher prioriti task r k gener howev cannot determin exactli g jl combin give worst case preemption delay task analysi safe conserv assum scenario guarante wors actual preemption scenario conserv scenario deriv constraint valid g jl combin satisfi give number constraint g jl s follow first g jl given interv r k cannot larger number invoc j interv thu formul n j maximum number preemption singl invoc experi r k upper bound n j valu calcul a r j a r k worst case respons time higher prioriti task avail worst case respons time comput thi index l g jl bound n j formul second number preemption task j given interv r k cannot larger total number invoc interv sinc arriv task prioriti higher j preempt j thu gener total number preemption given interv r k cannot larger total number invoc interv thu na note constraint subsum previou constraint maximum valu pc r k s satisfi constraint safe upper bound total cacherel preemption delay task r k problem formul integ linear program problem follow maxim r k subject constraint constraint na iter iter procedur explain section iii integ linear program problem solv comput pc r k applic iter procedur given appendix vi experiment result assess effect propos approach predict worst case respons time task sampl task set use propos techniqu compar predict use previou approach valid purpos predict worst case respons time also compar measur respons time target machin idtr board mhz r risc cpu r fpa float point acceler instruct cach data cach kbyte each cach direct map block size byte sram static ram use target machin main memori cach refil time cycl although target machin timer chip provid userprogramm timer resolut low measur purpos accur measur execut respons time task built daughter board implement timer resolut one machin cycl experi also implement simpl fixedprior schedul base tick schedul explain schedul manag two queue run queue delay queue run queue maintain task readi run task order prioriti delay queue maintain task wait next period task order releas time schedul invok timer interrupt occur everi machin cycl invok schedul scan delay queue task delay queue releas time invoc time schedul move run queue one newli move task higher prioriti current run task schedul perform context switch current run task highest prioriti task task complet execut place delay queue next highest prioriti task dispatch run queue take account overhead associ schedul use analysi techniqu explain techniqu schedul overhead respons time r given number schedul invoc r number time schedul move task delay queue run queue r ffl c int time need servic timer interrupt machin cycl exper iment set task period wcet instruct use memori block cach block unit machin cycl unit block task set specif ffl c ql time need move first task delay queue run queue machin cycl experi ffl c qs time need move addit task delay queue run queue machin cycl experi detail explan equat beyond scope paper interest reader refer use three sampl task set experi specif given tabl i first column tabl task set name second column list task task set four differ task use fft lud lm fir task fft perform fft invers fft oper array float point number use cooleytukey algorithm lud solv simultan linear equat doolittl method lu decomposit fir implement point finit impuls respons fir filter gener signal final lm point adapt fir filter filter coeffici updat input signal firdata section map noncach area lm fft lud instruct cach memori schedul schedul fig code placement task set tabl also give third fourth column period wcet task task set respect use measur execut time task wcet sinc tight predict task wcet accur estim cacherel preemption delay two orthogon issu measur execut time task obtain execut task without preemption execut time includ time initi task also time two context switch one context switch task task anoth task upon complet tabl also give total number instruct memori block maximum number use cach block task fifth sixth column respect experi intent place code task way caus conflict among memori block differ task although instruct cach target machin larg enough hold code use task expect case typic largescal realtim system figur show code placement task set furthermor sinc consid preemption delay relat instruct cach cf section vii disabl data cach map data unit machin cycl ii worst case respons time predict measur respons time stack segment task noncach area tabl ii show predict worst case respons time lowest prioriti task task set four differ method use predict worst case respons time task method worst case preemption cost assum cost complet refil cach c method explain u method worst case preemption cost assum cost complet reload code use preempt task final p method propos paper worst case preemption cost assum cost reload maximum number use cach block tabl worst case respons time predict four method denot ra rc ru r p respect also denot delta predict worst case cacherel preemption delay method m differ worst case respons time predict method without cacherel preemption cost result show propos techniqu give significantli tighter predict cacherel preemption delay previou approach result fact that unlik approach propos approach consid use cach block comput cacherel preemption cost one case task set propos techniqu give predict tighter best previou approach cycl vs cycl howev still nontrivi differ r p measur respons time differ result number sourc first contrari pessimist assumpt use cach block task replac cach time task preempt time task resum execut replac preemption actual execut second mani actual preemption occur execut point execut point maximum number use cach block final worst case preemption scenario assum deriv upper bound cacherel preemption delay linear program techniqu occur actual execut anoth point note result cacherel preemption delay ie delta occupi small portion worst case respons time less case result follow two reason first wcet task unrealist larg experi sinc disabl data cach diminish rel impact cacherel preemption delay worst case respons time second sinc target machin use sram main memori cach refil time much smaller current comput system rang cycl cycl dram use main memori dram use instead worst case cacherel preemption delay would occupi much greater portion worst case respons time furthermor sinc speed improv processor much faster dram expect worst case cacherel preemption delay occupi increasingli larg portion worst case respons time futur assess impact cacherel preemption delay worst case respons time typic set predict worst case respons time task set increas cach refil time enabl data cach figur a b show delta deltaw orst case respons time respect new set result show cach refil time increas delta increas linearli four method result wider gap cacherel preemption delay predict method p cach refil timea u a cach refil time worst case respons u b fig cach refil time vs delta deltaw orst case respons time method cach refil time increas result task set deem unschedul method a c u cach refil time cycl respect hand task set schedul p even cach refil time cycl method c u sudden jump delta cach refil time cycl jump occur increas worst case respons time due increas cach refil time caus addit invoc higher prioriti task result also show cach refil time increas cacherel preemption delay take proport larger percentag worst case respons time result even method p cacherel preemption delay take worst case respons time cach refil time cycl method cach preemption delay take much higher percentag worst case respons time vii extens a set associ cach comput number use cach block section iv consid simplest cach organ call directmap cach organ memori block place one cach block gener cach organ call nway setassoci cach organ memori block place one n block map set whose index given memori block number modulo number set cach setassoci cach organ requir polici call replac polici decid block replac make room new block among block map set least recent use lru polici replac block referenc longest time typic use purpos follow explain comput maximum number use cach block setassoci cach assum lru replac polici accord definit section iv set rmb c contain possibl state cach block c execut point p case directmap cach possibl state correspond memori block cach block c may execut point p interpret state need extend setassoci cach sinc index unit cach set rather unit cach block state cach set nway setassoci cach defin vector m m least recent referenc block n recent referenc block follow formul problem comput rmb setassoci cach data flow analysi term directmap cach initi focu rmb begin end basic block defin set rmb c b rmb c b set possibl state cach set c begin end basic block b respect set gen c b contain state cach set c gener basic block b element n distinct memori block referenc basic block b map cach set c specif either empti when none memori block map cach set c referenc basic block b singleton set whose element vector gen c vector compon gen c n b memori block whose last refer basic block b last refer cach set c b similarli compon gen c memori block whose last refer b last refer c b except refer memori block gen c n b gener gen c memori block whose last refer b last refer c b except refer memori block gen c exampl consid cach two set assum follow memori block refer made cach set basic block b accord definit gen c b cach set four block ie way setassoci cach set gen c b fm similarli cach set eight block ie way setassoci cach set gen c b fnull null null definit gen c b set rmb c b rmb c b whose element vector n memori block relat follow p predecessor b b fgen c gen c gen c gen c b gen c b empti case directmap cach rmb cach set c point begin end basic block b deriv rmb c b memori block refer within basic block assum basic block follow sequenc memori block refer refer memori block map cach set c befor refer process sequenti start c process need follow element rmb rmb c updat rmb sinc rmb j recent referenc memori block cach set updat rmb note rmb c need updat refer refer affect state cach set set lmb c setassoci cach contain possibl refer sequenc cach set c p refer sequenc suffici inform determin block cach set c whether rereferenc replac nway setassoci cach lru replac polici inform correspond n distinct memori block referenc p reason set gen c b lmb problem defin either empti singleton set fgen c whose compon first n distinct memori block referenc basic block b map cach set c specif gen c b memori block whose first refer b first refer c b gen c b memori block whose first refer b first refer c b except refer memori block gen c b on set lmb c b lmb c b correspond set possibl refer sequenc cach set c begin end basic block b respect relat follow successor b s fgen c gen c b fgen c gen c b fgen c gen c b gen c b empti lmb begin end basic block comput lmb point within basic block comput analog manner case rmb set rmb c p lmb c comput execut point p calcul maximum number use block cach set c p straightforward element rmb lmb rmb c comput number cach hit would result refer memori block lmb appli cach set state defin rmb pick element rmb yield largest number cach hit give maximum number use cach block cach set c p total number use cach block p comput sum maximum number use cach block cach set cach inform preemption cost tabl construct case directmap cach b data cach memori now focus preemption cost result use instruct cach memori subsect explain extens propos techniqu need data cach memori unlik instruct refer data refer address fix compiletim exampl refer loadstor instruct use implement array access differ address data refer complic direct applic propos techniqu data cach memori sinc techniqu requir address refer basic block fix refer also complic wcet analysi task wcet analysi techniqu take conserv approach them fortun conserv approach greatli simplifi adapt propos techniqu data cach memori take extend time schema approach exampl follow discuss wcet analysi base extend time schema approach loadstor instruct refer one memori block call dynam loadstor instruct two cach miss penalti assum refer it one cach miss penalti refer may miss cach may replac use cach block analysi preemption cost result use data cach memori loadstor instruct dynam refer handl exactli way case instruct refer sinc address cfg fix also extend time schema approach assum refer dynam loadstor instruct miss cach cannot contribut use cach block furthermor sinc approach conserv assum everi one replac use cach block deriv wcet estim complet ignor comput rmb lmb viii conclus cach memori introduc unpredict variat task execut time use realtim system preemption allow among task propos new schedul analysi techniqu take execut time variat account propos techniqu proce two step first step pertask analysi techniqu construct task tabl call preemption cost tabl tabl give given number preemption upper bound cacherel delay caus them then second step comput worst case respons time task use linear program techniqu take input preemption cost tabl obtain first step experiment result show propos techniqu give predict worst case cacherel preemption delay tighter obtain previou approach improv predict accuraci result fact propos techniqu consid use cach block deriv worst case cacherel preemption delay number extens possibl analysi techniqu explain paper exampl pertask preemption cost inform made accur pertask analysi section iv cach block consid use use least one path mani path howev cannot taken simultan exampl figur show exampl cach block c use flow control hand cach block c j use flow control two flow control compat one two cach block use one time nevertheless cach block consid use data flow analysi order rectifi problem preemption cost comput path basi initi attempt base idea describ anoth interest extens propos analysi techniqu consid intersect cach block use preempt task use higher prioriti task releas former task preempt purpos propos techniqu augment follow perform data flow analysi explain section iv preempt task count use cach block map intersect cach block use preempt task use higher prioriti task releas preemption although approach accur approach explain paper requir larg number analys ie one analysi preemption instanc current work approxim techniqu similar approach trade accuraci low analysi complex appendix consid task set consist three task preemption cost tabl given preemption cost preemption cost note need preemption cost tabl highest prioriti task sinc cannot preempt worst case respons time lowest prioriti task comput follow r r r pc r comput solv follow integ linear program problem maxim r subject constraint e r e constraint e e problem formul use fact sinc task highest prioriti task cannot preempt thu g also give n maximum number preemption singl invoc task experi comput divid worst case respons time period task worst case respons time equal must comput beforehand thu avail comput worst case respons time task give n maximum number preemption task comput divid r period task cf equat solv integ linear program problem pc r give r valu use next iter comput r obtain solv follow integ linear program problem maxim theta f subject constraint e e constraint e e solut integ linear program problem give pc r thi turn give r repeat procedur r r thu procedur converg r safe upper bound worst case respons time task sinc worst case respons time smaller task s deadlin task schedul even cacherel preemption delay consid acknowledg author grate jose v busquetsmataix help suggest comment earlier version paper r some result earliest deadlin schedul al gorithm find respons time realtim system the rate monoton schedul algorithm exact character averag case behavior schedul algorithm multiprogram hard realtim environ dynam schedul hard realtim task realtim thread an extend approach analyz fix prioriti hard realtim task effect analysi engin realtim fix prioriti schedul the impact ada runtim system perform characterist schedul model account interrupt handl cost dynam prioriti task system engin analysi fix prioriti schedul comput architectur quantit approach cach issu realtim system ad instruct cach effect schedul analysi preemptiv realtim system linear nonlinear program bound worstcas instruct cach perform integr time analysi pipelin instruct cach worst case time analysi risc processor rr case studi effici microarchitectur model path analysi realtim softwar an accur worst case time analysi techniqu risc pro cessor smart strateg memori alloc realtim cach design smart strateg memori alloc real time cach design use mip r alloc smart cach segment schedul softwarebas cach partit realtim applic high perform compil parallel comput dftfft convolut algorithm theori elementari numer analysi c algorithm realtim dsp effici worst case time analysi data cach calcul worst case preemption cost instruct cach tr ctr anupam datta sidharth choudhuri anupam basu use random round satisfi time constraint realtim preemptiv task proceed confer asia south pacif design automationvlsi design p januari yudong tan vincent j mooney iii wcrt analysi uniprocessor unifi priorit cach acm sigplan notic v n juli m kandemir g chen w zhang i kolcu data space orient schedul embed system proceed confer design autom test europ p march hiroshi nakashima masahiro konishi takashi nakada accur effici simulationbas analysi worst case interrupt delay proceed intern confer compil architectur synthesi embed system octob seoul korea mahmut kandemir guilin chen localityawar process schedul embed mpsoc proceed confer design autom test europ p march account cacherel preemption delay dynam prioriti schedul analysi proceed confer design autom test europ april nice franc hemendra singh negi tulika mitra abhik roychoudhuri accur estim cacherel preemption delay proceed st ieeeacmifip intern confer hardwaresoftwar codesign system synthesi octob newport beach ca usa hiroyuki tomiyama nikil d dutt program path analysi bound cacherel preemption delay preemptiv realtim system proceed eighth intern workshop hardwaresoftwar codesign p may san diego california unit state i kadayif m kandemir i kolcu g chen localityconsci process schedul embed system proceed tenth intern symposium hardwaresoftwar codesign may est park colorado sheayun lee sang lyul min chong sang kim changgun lee minsuk lee cacheconsci limit preemptiv schedul realtim system v n p nov yudong tan vincent j mooney iii time analysi preemptiv multitask realtim system cach proceed confer design autom test europ p februari yudong tan vincent mooney time analysi preemptiv multitask realtim system cach acm transact embed comput system tec v n februari jan staschulat rolf ernst scalabl precis cach analysi preemptiv schedul acm sigplan notic v n juli zhang chandra krintz adapt code unload resourceconstrain jvm acm sigplan notic v n juli johan strner lar asplund measur cach interfer cost preemptiv realtim system acm sigplan notic v n juli jan staschulat rolf ernst multipl process execut cach relat preemption delay analysi proceed th acm intern confer embed softwar septemb pisa itali sungpack hong sungjoo yoo hoonsang jin kyumyung choi jeongtaek kong sookwan eo runtim distributionawar dynam voltag scale proceed ieeeacm intern confer computeraid design novemb san jose california changgun lee kwangpo lee joosun hahn yangmin seo sang lyul min rhan ha seongsoo hong chang yun park minsuk lee chong sang kim bound cacherel preemption delay realtim system ieee transact softwar engin v n p septemb nikil dutt alex nicolau hiroyuki tomiyama ashok halambi new direct compil technolog embed system embed tutori proceed confer asia south pacif design autom p januari yokohama japan