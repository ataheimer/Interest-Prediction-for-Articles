t buffer manag sharedmemori time warp system a mechan manag messag buffer time warp parallel simul execut cachecoher sharedmemori multiprocessor studi two simpl buffer manag strategi call sender pool receiv pool mechan examin respect effici particular interact multiprocessor cachecoher protocol measur implement kendal squar research ksr machin use synthet workload benchmark applic demonstr sender pool offer signific perform advantag receiv pool howev also observ scheme especi sender pool mechan prone sever perform degrad due poor local refer larg simul use substanti amount messag buffer memori third strategi call partit buffer pool approach propos exploit advantag sender pool exhibit much better local measur approach indic partit pool mechan yield substanti better perform sender receiv pool scheme largescal smallgranular parallel simul applicationsth central conclus studi are buffer manag strategi play import role determin overal effici multiprocessorbas parallel simul partit buffer pool organ offer significantli better perform sender receiv pool scheme studi demonstr poor perform may result proper attent paid realiz effici buffer manag mechan b introduct largescal sharedmemori multiprocessor kendal squar research ksr more recent convex spp import class parallel comput high perform comput applic recent sharedmemori machin becom popular comput server multiprocessor workstat sgi challeng sun sparcserv becom common engin scientif comput laboratori technolog advanc enabl multipl cpu place within singl chip substrat multichip modul simpler program model offer sharedmemori machin enabl remain import class parallel comput forese futur well known mani largescal discret event simul comput excess time consum natur candid parallel comput time warp well known synchron protocol detect outoford execut event occur recov use rollback mechan time warp demonstr success speed simul combat model commun network queu network digit logic circuit among other assum reader familiar time warp mechan describ here concern effici implement time warp sharedmemori multiprocessor comput prior work area focus data structur synchron implement share state concern effici buffer manag strategi messag pass sharedmemori machin assum hardwar platform cachecoher sharedmemori multiprocessor commerci machin mention earlier type assum multiprocessor contain set processor local cach automat fetch instruct data need assum mechan place ensur duplic copi memori locat differ cach remain consist typic accomplish either invalid copi cach one processor modifi block updat duplic copi particularli concern largescal small granular discreteev simul applic specifi calli envis applic contain thousand tensor hundr thousand simul object modest amount comput per simul event event may requir execut littl hundr machin in struction small granular aris mani discreteev simul applic eg celllevel simul asynchron transfer mode atm network simul wireless person commun servic network gatelevel simul digit logic circuit applic even modest amount overhead central event process mechan lead substanti perform degrad thu import overhead incur messag pass event process loop parallel simul execut kept minimum messagepass fundament time warp mecha nism messagepass util frequent crucial effici implement particularli small granular simul becom appar later effici buffer manag essenti achiev effici messag pass mechan issu examin here remaind paper organ follow section describ underli messag pass mechan assum throughout studi contrast messag pass mechan messagebas parallel comput section describ simpl approach buffer alloc call receiv pool altern approach call sender pool propos perform rel receiv pool compar evalu experiment use implement execut ksr multiprocessor section observ sender pool approach gener superior receiv pool approach suffer sever perform degrad simul util larg amount memori section describ third mechan call partit pool approach address flaw sender pool scheme section present perform result use mechan section extend result consid synthet workload compar perform three mechan two benchmark applic studi demonstr partit pool approach yield superior perform compar two mechan messag pass mechan let us first consid implement messag pass sharedmemori multiprocessor assum time warp execut maintain certain number memori buffer contain inform associ singl event or messag use term synonym here transmit messag one processor anoth involv follow step sender alloc buffer hold messag sender write data transmit messag sender enqueu pointer messag queue access receiv receiv detect messag queue remov it read possibl modifi content messag buffer mani time warp system messag buffer includ variou field pointer enqueu buffer local data structur field eg flag requir time warp execut case receiv modifi content buffer implement applic program may allow modifi receiv messag buffer itself although time warp execut would maintain separ copi case rollback occur altern pointer flag field may kept separ data structur extern messag buffer case content messag may modifi receiv essenti question concern organ pool free unalloc messag buffer central global pool clearli becom bottleneck nat ural distribut approach associ buffer pool processor here consid altern organ assum processor maintain separ buffer pool instruct contrast messag pass mechan describ messagebas parallel comput messagebas machin pool unalloc memori buffer maintain processor new buffer must alloc prior send messag messag written buffer transmit destin processor buffer reclaim return send contrast sharedmemori multiprocessor messag need explicitli transmit copi receiv requir messagepass machin instead suffici pass pointer messag buffer destin processor memori cach mechan transpar transfer content messag referenc receiv second differ messagepass sharedmemori architectur latter provid global address space present much richer set possibl buffer organ compar messagepass machin sender vs receiv buffer pool here assum princip atom unit memori buffer buffer contain fix amount storag hold singl event processor maintain pool free unallo cate buffer singl buffer alloc prior messag send buffer reclaim messag cancel fossil collect either case processor last receiv buffer via messag send respons ad free pool key issu discuss follow interact cach coher protocol messag send mechan number lock oper requir oper requir access nonloc memori typic expens exist machin instanc ksr ten hundr machin instruct may execut time singl cach miss hundr thousand instruct may execut time singl lock oper receiv pool one simpl approach manag free buffer associ pool processor receiv messag mean buffer alloc routin obtain unus buffer buffer pool processor receiv messag prior messag send call receiv pool strategi althoughsimpl implement receiv pool suffer two drawback first lock requir synchron access free pool even sender receiv lp map processor processor list share among processor send messag processor second drawback concern cach effect discuss next multiprocessor system use invalidatebas cachecoher protocol receiv pool make effect use cach buffer free pool processor usual resid cach processor assum buffer delet cach replac polici case buffer last access event process procedur execut processor assum sender receiv messag resid differ processor send processor alloc buffer receiv write messag buffer seri cach miss invalid occur buffer move sender cach later receiv dequeu messag buffer place local queue second set miss occur buffer content transfer back receiv cach invalid also occur messag buffer modifi receiv process thu two round cach miss one two round invalid occur messag transmiss sender pool altern approach use sender pool scheme send processor alloc buffer local pool ie buffer pool processor send messag write messag it enqueu receiv scheme free pool local processor lock requir control access it also sender alloc buffer write content messag it memori refer hit cach scenario describ abov receiv processor access messag buffer cach miss possibl invalid occur case receiv pool mechan thu round cach miss avoid use sender pool compar receiv pool approach sender pool creat new problem howev messag send effect transfer buffer send receiv processor buffer pool messag buffer alway reclaim receiv fossil collect can cellat buffer effect migrat processor processor less random fashion reus messag send differ processor contrast receiv pool scheme buffer alway return processor pool pool buffer initi alloc problem buffer migrat memori buffer accumul processor receiv messag send lead unbalanc distribut buffer buffer pool processor becom deplet processor bloat excess buffer lock could circumv local messag send howev separ buffer pool local messag address problem mechan requir redistribut buffer processor receiv messag send processor opposit behavior buffer redistributioncan accomplish use addit global buffer pool serv conduit transmit unus buffer exampl processor accumul mani buffer place extra globalpool diminish buffer pool extract addit buffer need pool thu princip advantag sender pool elimin lock free pool better cach behavior multiprocessor use cach invalid protocol central disadvantag overhead buffer redistribut cach updat protocol previous describ cach behavior invalidatebas coher protocol let us consid updatebas protocol updatebas cach coher protocol sender receiv pool exhibit similar cach behavior though receiv pool offer slight edg sender pool result ad dition unnecessari updat traffic among cach see thi consid follow receiv pool scheme buffer resid cach receiv processor assum suffici space cach sender write messag buffer miss occur unless buffer recent referenc send processor anoth messag send updat protocol automat transfer messag via cach updat receiv copi buffer result cach hit receiv read messag sender pool scheme cach hit occur sender write messag buffer receiv access result cach miss unless buffer alreadi receiv cach thu scheme experi one round hit one round miss messag transmiss howev updat protocol processor access buffer maintain copi local cach even use buffer longer exampl receiv pool scheme five differ processor reus buffer send messag processor p buffer appear cach five processor well p sixth processor use buffer send messag p write messag buffer updat copi resid five processor well p updat sent five sender processor clearli unnecessari sender pool exhibit even wors behavior messag buffer may migrat arbitrari number processor thu resid mani cach receiv pool scheme receiv pool approach buffer migrat limit processor send messag p number processor cach must updat is cours reduc processor replac cach block to make room other cach miss howev system larg cach replac may occur time busbas multiprocessor main disadvantag updat sever processor content cach directori updat inher broadcast request thu see neither sender receiv pool scheme provid total satisfactori solut multiprocessor use updatebas cach coher protocol howev later propos third scheme call partit buffer pool provid satisfactori solut avoid unnecessari updat describ abov hardwar platform compar perform sender receiv pool scheme implement multiprocessorbas time warp system implement use direct cancel minim cost messag cancel buffer contain variou pointer flag as describ earlier modifi receiv messag hardwar platform use experi kendal squar research ksr multiprocessor ksr processor contain mbyte local cach memori faster kbyte subcach ksr somewhat differ cachecoher multiprocessor main memori hold data store processor cach effect secondari storag act main memori ksr processor organ ring ring contain processor cach invalid protocol use maintain coher data neither subcach local cach fetch anoth processor cach resid anoth cach secondari storag via virtual memori system detail machin architectur perform describ machin contain mhz twoway superscalar pro cessor access subcach requir clock cycl access local cach requir cycl time access anoth processor cach depend ring traffic cach miss servic processor ring take approxim cycl cach miss servic processor anoth ring requir approxim cycl discuss follow cach miss refer miss megabyt cach subcach estim singl ksr processor approxim faster sun sparc workstat base measur sequenti simul lock unlock oper requir sec absenc content sec pair processor ring sec pair processor differ ring p experi describ use singl ring except processor run use processor two differ ring experi perform ksr run ksr os r manufactur provid c compil use experi except explicitli state otherwis special compil optim use gener object file sens perform report conserv perform measur receiv pool implement memori evenli distribut across processor sender pool scheme total memori place global pool rest evenli distribut among processor free pool fraction select empir maxim perform number buffer processor buffer pool exce initi alloc excess buffer move free pool buffer pool contain five fewer buffer addit buffer reclaim global pool if avail restor processor initi alloc initi experi use synthet workload model call phold model use fixeds messag popu lation event gener one new messag timestamp increment select exponenti distribut destin logic process lp select uniform distribut first measur send time messag transmit differ processor time includ alloc free buffer write messag buffer enqueu buffer queue destin processor phold lp messag popul execut processor megabyt memori alloc state event buffer scheme time perform messag send measur use ksr x user timer primit sender receiv pool implement use prefetch mechan gain exclus copi buffer prior receiv messag prefetch also invalid copi messag resid send processor cach figur show averag time messag send use receiv pool the uppermost line sender pool the third line top strategi differ messag size ex pect sender pool outperform receiv pool scheme line two the second line top separ perform improv result elimin free pool lock the distanc upper two line improv result better cach behavior the distanc second third line lock time measur approxim sec consist time report one consid content lock increas access time degre addit cach overhead receiv pool implement increas size messag miss occur write data messag buffer measur approxim sec per cach miss consist vendor report cach miss time lower line repres messag copi time ie time write data messag sender pool scheme ie cach miss use hardwar monitor provid ksr machin measur number cach miss occur sender receiv pool implement figur show number cach miss differ messag size phold lp messag processor run length approxim one million commit event approxim megabyt alloc simul data confirm receiv pool approach encount cach miss sender pool approach time msg size kb recv pool sender pool msg copi figur messag send time sender receiv pool four curv repres from top bottom messag send time use receiv pool messag send time sender pool plu addit cach overhead encount receiv pool messag send time sender pool time copi messag messag buffer sender pool larger slope addit cach overhead receiv pool mention earlier central drawback send pool scheme need redistribut buffer here buffer redistribut use global pool perform fossil collect turn occur time processor determin fewer five free buffer remain free pool perform metric use studi number event commit per second real time execut calcul total number event commit simul divid total execut time refer metric commit event rate simpli event rate note event rate declin number rollback increas raw perform eg speed messag send decreas cach page million messag size kb receiv pool sender pool figur cach miss sender receiv pool figur show commit event rate parallel simul use receiv pool sender pool mechan experi use eight ksr processor benchmark program phold use lp messag popul seen sender pool significantli outperform receiv pool strategi indic reduc time perform messag send far outweigh time requir buffer redistribut third curv shown figur show perform altern buffer manag scheme discuss later final note sinc hardwar provid mechan prefetch data may possibl lessen cach effect receiv pool scheme prefetch buffer prior messag send assum cours sender determin destin processor suffici far advanc send perform prefetch current examin perform improv result techniqu howev even prefetch messag send still faster sender pool lock free pool need perform larg simul although sender receiv pool good perform small amount memori observ dramat perform degrad larg simul util substanti amount messag buffer memori perform phold simul assum proce sor lp messag popul total amount memori alloc messag buffer chang shown figur run includ execut approxim one million commit event point repres median valu least run typic run use seen perform declin dramat total amount buffer memori across processor exceed megabyt observ behavior independ number processor use simul declin perform surpris run util processor total megabyt cach memori avail yet signific perform degrad occur amount buffer memori increas compar modest level eg perform eventssec processor partit pool sender pool receiv pool figur number event commit per second real time phold sender receiv partit pool mechan reason declin perform intern fragment virtual memori system result poor spatial local lead excess larg number page processor work set page thrash behavior among cach page size ksr kbyte discuss below page thrash lead disk access ksr which would result much sever perform degrad nevertheless caus signific reduct perform perform eventssec memori alloc mb partit pool sender pool receiv pool figur perform amount memori chang consid execut sender pool simul ini tialli buffer alloc processor pack contigu block memori howev sender pool scheme buffer migrat one processor anoth messag send global pool via buffer redistribut mechan thu short period time set buffer contain sender pool processor includ buffer origin alloc mani differ processor thu scatter across address space thu instant time processor buffer pool includ portion mani differ page entir possibl and mani case like buffer particular proce sor buffer pool includ portion everi page buffer memori avail system page memori alloc mb receiv pool sender pool partit pool figur page miss count amount memori chang well known perform virtual memori system declin number page processor work set increas memori manag overhead becom larg uniprocessor multiprocessor minim miss translat lookasid buffer tlb occur eventu page fault occur perform poor ksr space must alloc entir page portion resid cach cach miss occur referenc page alreadi map processor cach space must alloc page cach miss servic here referenc block load cach page miss subsequ block load cach demand referenc ie result cach miss page miss page miss usual result access secondari storag assum total amount memori well amount physic cach memori page usual resid one cach nevertheless tabl manag virtual memori system must updat miss page miss due poor local reason perform poor total amount buffer memori exceed megabyt amount buffer memori less megabyt page entir buffer memori across processor maintain cach processor howev amount exce size processor work set page longer fit local megabyt cach page must map processor result thrash behavior excess overhead incur map unmap page valid effect reason poor per formanc number page miss measur experi depict figur data shown figur seen aforement declin perform beyond megabyt memori accompani dramat increas number page miss page miss problem also sever receiv pool scheme caus signific perform degrad larg simul receiv pool approach avoid page miss overhead processor hold page correspond buffer pool plu receiv pool processor send messag thu processor send messag small subset processor system like page fit cach page miss occur worst case howev processor send messag processor system case page miss overhead may sever sender pool scheme phold applic repres worst case processor send messag everi processor system sender pool outperform receiv pool low amount memori cach local verifi better page miss figur bigger amount memori sender pool cannot hold page tlb subsequ show wors perform page miss receiv pool verifi evalu effect page miss local iti set experi conduct use receiv pool strategi modifi version phold workload origin phold workload select destin process processor messag uniform distribut modifi workload processor select among k processor number processor destin use uniform distribut valu k refer size processor neighborhood workload processor receiv messag k processor number page miss measur amount memori vari k set impli unidirect ring topolog use receiv pool result experi shown figur seen amount memori necessari yield aforement increas page miss becom progress smaller k increas agreement analysi assum processor effect util megabyt memori the knee observ earlier experi messag buffer pool k equal page miss avoid long two buffer pool the local pool one remot pool processor messag sent util less megabyt data impli buffer pool larg megabyt per processor megabyt entir system recal processor toler ate similarli one would anticip knee occur neighborhood size megabyt k equal megabyt k equal data figur consist approxim analysi page memori alloc mb local figur page miss receiv pool differ neighborhood size vs amount memori alloc line are top bottom neighborhood size local partit buffer pool third strategi develop design capit advantag sender pool scheme time avoid page miss problem minim number page miss buffer manag scheme minim number page contain messag buffer util processor anoth way state set buffer use processor pack contigu memori locat much possibl achiev thi necessari prevent arbitrari migrat buffer one processor anoth partit buffer pool scheme use sender buffer pool but pool processor subdivid set sub pool one processor send messag let refer buffer pool ie subpool processor use send messag processor j processor must alloc buffer b ij whenev wish send messag j further processor j reclaim messag buffer via fossil collect messag cancel must return buffer b ji buffer subsequ return processor either j send messag util buffer buffer return via buffer redistribut mechan strict rule concern buffer return pool global pool need buffer redistribut elabor upon later partit pool scheme memori buffer initi alloc b ij may resid b ij b ji lifetim simul size work set processor page hold b ij for for k page miss problem avoid long page resid processor cach second advantag partit pool scheme provid type flow control must provid use separ mechan origin sender receiv pool scheme time warp prone buffer hog phenomena certain processor may alloc disproportion share buffer classic exampl behavior sourc process serv purpos provid stream messag simul sourc process use simul open queu network instanc model new job arriv system sourc process never receiv messag never roll back fact gener true event event eventu commit howev process throttl flow control mechan easili execut far ahead simul time process fill avail memori new event leav buffer messag phenomenon sever degrad perform processor memori fill messag gener sourc origin sender receiv pool scheme noth prevent sourc fill buffer certain processor messag problem compound sender pool scheme sourc immedi scoop up addit free buffer appear global pool via buffer redistribut mechan therebi hog even larger portion system buffer partit buffer pool scheme buffer hog limit buffer pool util processor execut sourc process commun processor affect separ pool reserv buffer use thu partit pool scheme provid protect buffer hog problem third advantag partit buffer pool scheme updatebas cach protocol oper effici either origin sender receiv pool scheme recal problem origin scheme buffer may simultan resid sever cach ie cach processor use buffer result unnecessari cach updat traffic partit pool scheme buffer may util two processor buffer use processor resid processor cach processor alloc buffer write content messag it cach hit occur assum buffer delet replac memori refer updat protocol immedi write messag destin processor cach also hold copi messag buffer receiv access buffer experi cach hit fewer unnecessari updat request gener buffer manag scheme central disadvantag partit pool scheme buffer pool processor subdivid sever smaller pool buffer result somewhat less effici util memori thu scheme may requir memori either origin sender receiv pool scheme processor send messag processor j b ij empti messag send cannot perform even though mani buffer may resid pool local processor send messag one could cours alloc buffer anoth pool satisfi request howev would quickli degener origin sender pool scheme result perform problem cite earlier gener desir use differ size buffer pool within processor size pool proport amount traffic flow processor gener size pool chang dynam how ever purpos studi consid fixeds buffer pool size pool manual set begin simul implement detail perform partit buffer pool scheme implement sharedmemori time warp system messag send perform buffer avail design pool event abort return unprocess event list typic result busi wait behavior event continu abort retri buffer redistribut pair processor necessari perform fossil collect perform period user defin interv net increas number buffer resid particular pool exce certain threshold origin size pool experi processor attempt return number buffer equal net gain restor initi distribut buffer among pool note earlier partit buffer pool scheme requir buffer reclaim fossil collect return appropri buffer pool specif buffer correspond messag sent processor j must return processor js buffer pool rather labori scan fossil collect buffer return appropri pool mechan call onthefli fossil collect use soon messag process immedi return even though buffer may still requir handl futur rollback buffer alloc allow alloc buffer timestamp larger gvt ensur buffer reclaim gvt guarante messag contain buffer longer need buffer reclaim messag cancel assign zero timestamp return buffer pool ensur immedi reus onthefli fossil collect amort overhead fossil collect entir simul commit event rate receiv sender partit pool strategi differ amount memori compar figur again workload phold lp messag popul seen partit buffer pool approach consist outperform two scheme unlik origin receiv pool sender pool scheme declin perform detect beyond megabyt figur verifi page miss problem elimin partit buffer pool scheme number remain rel low partit pool scheme memori size test applic perform data present thu far result measur synthet workload appropri ask behavior also preval actual parallel simul applic one would encount practic impact buffer manag cach effect overal per formanc answer question addit experi perform use three buffer manag polici certain small granular simul name hypercub topolog commun network person commun servic pc network simul benchmark amount memori use sender receiv pool scheme optim experiment maxim perform use less megabyt partit pool implement use megabyt per processor messag buffer experi hypercub rout first applic messag rout simul dimension binari hypercub node messag rout randomli select destin node use wellknown e cube rout algorithm messag length select uniform distribut addit transmiss delay may delay due congest node queu messag messag serv node use firstcomefirstserv disciplin messag reach destin immedi reinsert network new destin select uniform distribut experi messag continuouslyrout throughth network fashion figur show commit event rate simul three buffer manag scheme differ number processor partit pool strategi outperform two scheme case perform differenti increas number processor increas perform eventssec processor partit pool sender pool receiv pool figur perform hypercub rout simul person commun servic network pc simul wireless commun network set radio port structur squar grid one port per grid sector grid sector cell assign fix number channel portabl mobil phone resid cell period time move anoth cell phone call arriv portabl move new cell new radio channel must alloc connect maintain phone call correspond portabl channel busi call block drop princip output measur interest block probabl simul pc network contain cell a grid portabl cell contain radio channel portabl remain cell averag minut time select exponenti distribut portabl move one four neighbor cell equal probabl call length time period call also exponenti distribut mean minut minut respect averag comput time event exclud time schedul new event approxim microsecond lp pc simul selfiniti ie send messag advanc simul time commun highli local typic messag transmit lp map processor mani messag sent lp itself figur show commit event rate simul use three buffer manag scheme seen again partit buffer pool scheme outperform strategi though differenti larg experi due high amount local commun pc simul perform eventssec processor partit pool sender pool receiv pool figur perform pc three buffer manag scheme conclus futur work implement effici parallel simul system sharedmemori multiprocessor requir care consider interact simul execut hardwar cach virtual memori system work focus one aspect name buffer manag messag pass mechan experi ksr multiprocessor demonstr sever perform degrad may result interact care consid simul execut design studi three buffer manag strategi term sender pool receiv pool partit pool scheme sender pool scheme gener perform better receiv pool scheme flaw sever perform degrad occur simul requir larg amount memori but much less physic memori provid machin partit pool scheme outperform two approach much factor two benchmark applic futur avenu research refin partit buffer scheme automat alloc appropri amount memori individu pool automat adjust size pool maxim perform anoth open question quantit evalu effect examin context machin architectur although experi perform context time warp execut ksr believ result also applic context first method improv perform involv restructur simul execut maxim local memori refer pattern local fundament effici util cach virtual memori system sens believ measur suggest approach fruit appli sharedmemori multiprocessor though perform gain realiz depend heavili specif architectur fur ther messag pass common wide use construct nearli parallel simul mechan propos date thu believ result ramif synchron protocol conserv opti mistic also applic nonsimul applic requir high perform messag pass acknowledg work support nation scienc foundat grant number mip thank samir da comment r distribut simul largescal pc network ring perform kendal squar multiprocessor time warp share memori multiprocessor perform time warp synthet workload parallel discret event simul use spacetim memori virtual time synchron parallel discret event simul sharedmemori multi processor share variabl distribut simul benchmark time warp oper system comput network simul distribut combat simul time warp model perform benchmark smtw ss perform model simul tr virtual time time warp share memori multiprocessor highperform comput architectur nd ed share variabl distribut simul distribut simul largescal pc network ctr girindra d sharma radharamanan radhakrishnan umesh kumar v rajasekaran nael abughazaleh philip a wilsey time warp simul clump proceed thirteenth workshop parallel distribut simul p may atlanta georgia unit state chri j m booth david i bruce peter r hoar michael j kirton k roy milner ian j relf dynam memori usag parallel simul case studi largescal militari logist applic proceed th confer winter simul p decemb coronado california unit state christoph d caroth kalyan s perumalla richard m fujimoto effect statesav optimist simul cachecoher nonuniform memori access architectur proceed st confer winter simul simulationa bridg futur p decemb phoenix arizona unit state z xiao b unger r simmond j schedul critic channel conserv parallel discret event simul proceed thirteenth workshop parallel distribut simul p may atlanta georgia unit state kiran s panesar richard m fujimoto adapt flow control time warp acm sigsim simul digest v n p juli christoph d caroth david bauer shawn pearc ross highperform low memori modular time warp system proceed fourteenth workshop parallel distribut simul p may bologna itali marcelctlin rou karsten schwan richard fujimoto support parallel applic cluster workstat virtual commun machinebas architectur cluster comput v n p samir r da richard m fujimoto empir evalu performancememori tradeoff time warp ieee transact parallel distribut system v n p februari samir r da richard m fujimoto adapt memori manag optim control time warp acm transact model comput simul tomac v n p april