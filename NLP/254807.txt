t industri strength theorem prover logic base common lisp a abstractacl reimplement extend version boyer moor nqthm kaufmann pcnqthm intend larg scale verif project paper deal primarili scale nqthm logic industri strength program languagenam larg applic subset common lispwhil preserv use total function within logic make possibl run formal model effici keep logic simpl enumer mani import featur acl briefli summar two industri applic model motorola cap digit signal process chip proof correct kernel float point divis algorithm amdk microprocessor advanc micro devic inc b introduct formal verif use mathemat techniqu verifi properti system descript work report perform author employ comput logic inc matt kaufmann motorola lakewood po box md f austin z j moor depart comput scienc univers texa austin austin receiv oct revis mar recommend accept c heitmey sr faulk inform obtain reprint articl pleas send email to transsecomputerorg refer ieeec log number particular style formal verif shown consider promis recent year use generalpurpos autom reason system model system prove properti them everi reason system requir consider assist user make import system provid conveni way user interact it one stateoftheart generalpurpos autom reason system acl a comput logic applic common lisp number autom reason system exist discuss subsect paper describ acl offer user conveni industrialstrength use begin section histori acl project next section describ logic support acl design conveni specif verif section discuss guard connect acl effici execut common lisp provid power specif capabl illustr role guard section section discuss import featur acl section present two industri applic conclud section brief comparison theorem prover mention abov mani autom reason system besid acl ancestor although beyond scope paper survey field provid descript system say word order provid context work activ research continu autom reason number area incomplet list case give one two repres system certainli area contain consider overlap ffl prover provid strong support specif comput system see below ffl ctl model checker ffl geometri prover ffl firstord prover ffl classic mathemat construct mathemat ffl prover symbol comput engin ffl metatheoret system prover first categori distinguish conveni offer specifi comput system case could made prover first categori capabl categori convers prover categori could place one first categori may subdivid follow ffl higherord tacticbas prover eg hol ffl higherord heavilyautom prover eg pv ffl firstord heavilyautom prover eg acl nqthm ffl prover integr program verif system eg neverev again space permit detail comparison here bill young paper special issu compar pv acl particular exampl acl ancestr sy tem nqthm compar nuprl extrem difficult compar two generalpurpos theorem prover least part experienc user dramat affect system behavior proper formul problem said system cite support logic power acl hand acl theorem prover encourag relianc user system automat aspect user happi essenti quantifierfre firstord logic believ acl offer overal conveni type reason requir model prove properti digit comput system addit sophist infer engin provid acl provid extrem effici evalu allow formal model often serv simul system describ thi turn provid immedi proofindepend payoff eg requir test code develop addit reason acl conveni broadli lump proof engin consider discuss section see url httpwwwformalstanfordeducltar arsdbhtml data base autom reason system includ brief descript link home page system mention mani more histori acl direct descend boyermoor sy tem nqthm interact enhanc pc nqthm see introduct two ancestr system includ reason larg set refer accomplish use system particular success describ tutori introduct system may found like nqthm acl support lisplik firstord quantifierfre mathemat logic base recurs defin total function experi earlier system support claim logic suffici express permit one address deep mathemat problem realist verif project fact nqthm logic execut also import asset use model hardwar softwar system model execut mean corrobor accuraci consid exampl nqthm model mc corrobor fabric chip run test vector nqthm model largest formal verif project done far carri nqthm cite explicitli cli short stack design fabric fm microprocessor verif berkeley c string librari top mc microprocessor formal model project collect sever hundr page long involv mani function despit success nqthm design kind largescal project sever inadequaci import inadequaci nqthm lack theorem prove power would quickli settl everi question put it one could proceed effici alway look better proof techniqu eg know build significantli power automat theorem prover nqthm logic therefor scale up nqthm focus engin issu decid good first step would adopt logic applic subset commonli use program languag therebi gain access mani effici execut platform model written logic mani program develop ie model environ chose common lisp express effici familiar properli formul common lisp execut speed compar c three guid tenet acl project conform compliant common lisp implement add noth logic violat understand user input submit directli common lisp compil execut in environ suitabl aclspecif macro function acl kernel defin use acl implement languag acl system third tenet akin recod nqthm nqthm logic task believ would produc unaccept slow perform program acl system acl emphas word significantli acl theorem prover fact power nqthm mani way see section repeatedli forc us extend subset could accept effici code sever iter system built current system consist megabyt applic sourc code includ document first version system written summer fall boyer moor time went by boyer involv decreas kaufmann increas eventu boyer decid longer consid coauthor acl use model verif project within comput logic inc cli sever year releas first public version acl septemb see url httpwwwclicom acl logic definit common lisp use work also close studi acl logic firstord quantifierfre logic total recurs function provid mathemat induct ordin ffl two extens principl one recurs definit one encapsul sketch logic here syntax syntax acl common lisp formal acl term either variabl symbol quot constant applic nari function symbol lambda express f n term written f t n illustr syntax primit constant below formal syntax extend facil defin constant symbol macro rule infer rule infer nqthm name proposit calculu equal togeth instanti mathemat induct ffl two extens prin cipl recurs definit encapsul also pro vide discuss subsect axiom primit data type follow primit data type axiomat ffl acl number number consist ration complex number ration compon exampl numer constant ffl charact object acl support distinct charact includ common lisp standard char acter charact constant a a newlin space ffl string acl support string charact eg string constant arithmet overflow ffl symbol common lisp provid sophist class object call symbol constant logic speak symbol constant object contain two string packag name constant packag mc name exec written mcexecbi con vention one packag alway select cur rent name need written thu mc current packag symbol may simpli written exec packag may import symbol packag al though acl import must done time packag defin mcexec import stringlib packag stringlibexec fact symbol mcexec ffl list acl support arbitrari order pair acl object eg list constant x mcx hello axiom defin primit function symbol essenti common lisp function data type axiomat defin function macro acl common lisp function mean program specifi i applic ii depend state implicit paramet data type acl iii complet specifi unambigu hostindepend manner approxim function axiomat common lisp function partial defin possibl input acl function total roughli speak logic function given name acl complet common lisp function name obtain ad arbitrari natur valu argument outsid intend domain common lisp function acl requir everi acl function symbol guard may thought predic formal function describ intend domain guard entir extralog involv axiom defin function discuss role guard explain relat acl common lisp axiom addit common lisp applic common lisp add four import new featur introduc new function symbol appropri axiom ffl add new multiplevalu function call return primit syntact restrict similar common lisp primit multiplevaluebind valu primitivesrequir functionalway return number valu call context ex pect appropri number valu restrict allow multiplevalu function implement effici common lisp at least case gnu common lisp logic speak vector multipl valu return function list valu implement effici list actual construct ffl add explicit notion state allow acl programm accept input caus output in putoutput function common lisp acl applic depend implicit notion current state acl state ntupl contain among thing file system open inputoutput channel file primit inputoutput function axiomat take state explicit paramet return new state explicit result usual one sever result syntact check languag ensur state singlethread ie function take state argument call function return new state new state or precis final descend it must return give rise welldefin notion current state suppli toplevel call statedepend acl function state return call becom definit next current state restrict execut statedepend function need and not actual construct new state ntupl liter modifi underli common lisp state ffl add fast applic array impl ment behind scene common lisp array manner alway return valu accord axiom oper effici provid certain program disciplin follow name use singlethread way recent updat version array use syntact enforc disciplin failur follow simpli lead ineffici but cor rect execut warn messag ffl add fast applic properti list manner similar array extens principl final acl two extens principl definit encapsul preserv consist extend logic inde standard model number list alway extend includ newli introduc function symbol inconsist thu caus user add new axiom directli rather via extens principl encapsul principl allow user introduc new function symbol constrain axiom certain properti consist ensur requir user exhibit wit function satisfi constraint set function symbol constrain wit use establish consist irrelev axiom new function state constraint theorem prove constrain function theorem instanti higherord way deriv analog result function satisfi constraint made possibl deriv rule infer call function instanti name encapsul stem way principl implement encapsul command essenti wrapper around admiss sequenc definit theorem wrapper allow one mark certain definit theorem local local definit theorem export wrapper nonloc one export within local context establish encapsul constrain function local defin wit constraint nonloc theorem function outsid encapsul function symbol undefin theorem appear consist axiom implement make encapsul use even new function symbol introduc allow larg proof structur see section definit principl ensur consist requir proof defin function termin done nqthm identif ordin measur formal decreas recurs show for nqthm ensur one one settheoret function satisfi recurs definit proof carri acl case appropri treatment nonuniqu constrain function use definit form acl function definit common defun f acl extend common lisp declar permit specif guard express g x x n well permit option specif ordin measur hint addit syntact restrict put bodi ensur common lisp version f execut effici accord claim make below roughli speak enforc syntact notion current state singl thread by restrict use variabl name state ensur multipl valu use appropri syntact restrict met requir termin theorem prove axiom f x ad new axiom observ axiom ad independ guard relat acl common guard role logic howev crucial relat logic common lisp implicit guard common lisp allow great effi cienci implement common lisp exampl gnu common lisp perform compil code gener arithmet list process function compar handcod c arithmet pointer manipul except execut effici wide varieti platform combin clear applic semant use properli one great attract base acl logic common lisp consid exampl primit function car page say argument car must be con nil page learn in place state soandso must must not may not case is error state requir met page learn it error mean no valid common lisp program caus situat occur if situat occur effect result complet undefin no common lisp implement requir detect error thu implement function car may assum actual con nil suitabl represent data implement car simpli fetch content memori locat actual store check necessari cours car appli result unpredict possibl damag runtim imag usual implement depend aspect lisp make difficult debug compil lisp code also rais problem direct embed applic common lisp logic situat far wors mere know valu car know valu object logic car might exampl wors still know car function form equal car car instanc axiom equal x x might sometim evalu nil common lisp first car might return second might return acl solv problem axiomat car x total function return nil outsid intend do main describ guard or consp x equal x nil claim axiom describ common lisp car argument car satisfi guard further more acl provid gener mean verifi situat obtain evalu given express contain car read rest section reader may wish consid possibl approach could carri program languag although program commerci avail mainstream languag c check certain kind error believ util match capabl make arbitrari semant check static describ acl perhap analog approach c would present opportun integr formal verif mainstream softwar develop practic lessen need dynam errorcheck gold function symbol term make precis relat acl common lisp defin two interrel notion function gold term gold hypothesi when hypothesi given implicitli t true hypothesi roughli speak function symbol gold if guard true guard subroutin encount evalu true argument ffl acl logic primit function symbol gold ffl defin function f guard g bodi b gold everi function symbol mention g gold term g gold everi function symbol besid f mention b gold term b gold g ffl variabl quot constant gold term ffl term if b c gold h gold h b gold and h a c gold and h not a ffl term f an f guard where v formal f gold h provid gold thank one refere pose question h impli h g an theorem formula must prove call guard conjectur subterm question sometim say function term common lisp compliant synonym say gold call process check whether function symbol term gold guard check guard verif stori relat logic common lisp claim function symbol acl gold gold theorem prove it everi execut function compliant common lisp produc answer consist theorem provid argument function satisfi guard resourc error eg stack overflow occur less precis gold acl theorem describ behavior common lisp claim made precis follow present claim restrict set simplic suppos f function symbol one argument defin certifi book eg file admiss acl definit theorem guard f t f gold equal f x t necessarili gold theorem acl prove book consid common lisp compliant acl kernel load load book lisp let x common lisp object also object acl applic lisp f x return els caus resourc error eg stack overflow memori exhaust essenc proof claim observ f x evalu logic becaus sound logic comput step exercis function symbol outsid guard domain becaus f gold sinc logic common lisp agre insid guard domain common lisp comput f x return also less restrict altern formul thm gold theorem certifi book acl instanc thm evalu nonnil compliant common lisp acl kernel book load guard effici one obviou implic stori one formal model prove common lisp compliant one wish evalu gold applic model one ignor acl theorem prover altogeth load model compliant common lisp contain acl kernel directli execut model obtain result consist axiom exampl one might build gold simul microprocessor highlevel languag provid user via standalon common lisp engin acl theorem prover need present less obviou use claim made insid acl theorem prover cours theorem prove uncommon ground subexpress aris certain instanti lemma case split enumer do main base case induct etc like nqthm acl interpret evalu ground express acl complet common lisp primit built in runtim type check done interpret eg determin valu axiom car appli constant a interpret determin whether consp either use lisp car return default valu nil interpret call userdefin function requir recurs evalu and typecheck bodi repeatedli acl evalu call gold function symbol use direct common lisp comput guard evalu t nqthm acl interpret implement defin compil auxiliari common lisp function runtim type check gold acl function gener compil acl type check thu interpret approach gold shortcircuit enjoy benefit compil effici differ acl avoid runtim type check certain subexpress make substanti differ industrials model summari one import increment effect prove acl function symbol gold subsequ applic function effici comput guard specif devic guard may also use type specif gold function welltyp howev guard much express convent type arbitrari term logic cours acl type check decid reason relat work see one attach restrict guard one function prove function gold one obtain assur function exercis intend domain precis one gain knowledg comput valu provabl equal function applic weaken logic system equal function applic bodi condit guard true nqthm provid assur mechan exampl section illustr point made guard admit definit consid problem concaten two list defin function app thi follow defun app x y declar xarg measur m x guard truelistp x if equal x nil con car x app cdr x y ignor declar moment observ function termin x nil otherwis cdr x recurs intent x alway true list ie con tree whose rightmost branch termin nil function appli common lisp result would unpredict nil recur cdr cdr undefin common lisp replac equal x nil test atom x more sensibl know x con cdr it lisp programm tend use test effici type check equival provid x true list declar guard truelistp x make clear intend domain logic speak must admit function reason it logic speak guard irrelev must show measur argument decreas recurs matter x use suitabl measur m x suppli user declar m x defin elsewher x nil otherwis one greater length rightmost branch x easi show measur decreas recurs ie m cdr x xnil intuit recurs termin acl cdr complet return nil noncons recurs hit atom bottom rightmost branch stop atom nil otherwis goe one step cdring atom produc termin nil function admit axiom axiom app x y if equal x nil con car x app cdr x y ad note axiom mention guard equal test symbol done singl address comparison requir memori refer type check do theorem prove surpris theorem theorem surprisingappcal equal app con nil return surpris exampl later also prove use power uncondit equal state app associ theorem associativityofapp equal app app b c app app b c proof take advantag fact car cdr return nil noncon argument number guard app infect definit app limit applic true list app would uncondit associ identifi suffici condit difficult sinc appear first argument call app conjectur must true list order use definit app call similarli b must true list app b also first argument call app use definit app call system must abl establish either third hypothesi proof hypothes app b true list short guard function infect definit axiom theorem inherit complex composit weaken encumb hypothes weaken theorem rais problem three way ffl harder user state accur ffl often harder prove induct induct hypothesi weaken ffl harder use subsequ one must reliev hypothes point made decis guard affect definit axiom thu far reach effect fact guard play logic role earlier version acl driven return nqthm paradigm total function complex guard introduc industrialstrength proof effort particularli cap project describ later complianc return app exampl next ask relationship common lisp prove app gold ie common lisp compliant everi function use definit except app itself gold they primit bodi evalu everi guard encount true guard app true initi latter condit expand follow three subroutin bodi app nontrivi guard car cdr recurs call app definit gold theorem must prove call subroutin bodi app particular call must prove guard app togeth test lead call impli guard call prove app gold therefor suffic observ x nonnil true list x must con cdr true list extralog natur guard brought home observ could defin anoth function say xapp analog app contain guard ie guard t two function provabl equiva lent app common lisp compliant xapp guard conjectur cannot prove know app common lisp compliant stori tell us call app satisfi guard execut accord axiom acl put anoth way wish determin valu axiom app b b constant simpli execut express common lisp provid true list thu user wish execut formal model concret data satisfi guard run model common lisp provid model prove compliant furthermor guard gold term suitabl data determin common lisp evalu also gold theorem theorem gold function app surpris result equal app con nil know everi compliant common lisp evalu true no theorem gold guard app violat noth infer common lisp via claim common lisp may caus sever troubl command evalu app associ result app expect app uncondit associ common lisp again answer theorem gold howev follow theorem gold theorem goldassociativityofapp impli and truelistp a equal app app b c app app b c impli thought lazi ie impli p q read if p q t given proper treatment definit gold cours must prove theorem proof trivial given uncondit associ result must also verifi gold ie guard everi call satisfi argument call context call two truelistp hypothes true guard three call app first argument variabl symbol guard requir variabl question b appropri truelistp guard condit trivial given hypothes final guard condit app app b c gener interest guard condit app b true list b are separ concern note acl treatment guard separ con cern theorem prove simplic nqthm tradit acl make function total complet primit arbitrari natur default valu function introduc logic without address question whether compliant common lisp properti prove without concern oneself question whether guard satisfi often allow properti simpli state allow data base rule less restrict power easili appli nevertheless nongold function evalu axiom nqthm effici system acl function defin logic properti prove one move question common lisp complianc either gain execut effici acl set standalon common lisp gain type assur effici gain increment guard verif core subroutin outli checker preprocessor postprocessor typic involv big system further more prove certain function gold one stop settl correspond effici type assur one prove key properti prove also gold recal exampl one carri follow sequenc step ffl admit app function ffl prove uncondit associ ffl prove gold ie common lisp compliant welltyp ffl trivial prove restrict version associ ffl prove restrict version associ gold common lisp compliant version acl predat version guard part definit equat issu often intertwin imposs address separ make littl differ set simpl app associ make great deal differ model involv thousand function properti proof engin argu acl industri strength main argument improv effici nqthm virtu execut common lisp special consider effici execut oper involv array properti list state also indic express kind typecorrect gain guard verif yet capabl separ logic proper proof needlessli hinder beloww consid strength acl besid effici program languag robust gener featur maintain proof support robust notion industri strength robust tool put consider effort make program bulletproof handl user error gracious appropri messag interfac consist provid abil submit definit theorem well abil execut applic lisp code effici usabl yet anoth notion industri strength tool support featur crucial get job done partial list featur offer acl ffl extens onlin document may read termin well text way hypertext emac info html ffl support undo back given command well undo undo ffl notion book allow independ develop inclus librari definit theorem book share underli implement encapsul form within mark local author book reader book see nonloc definit theorem possibl complex environ necessari certifi book need export reader environ book hierarch may includ book local otherwis reader may includ mani independ develop book creat environ author book instal theori invari help reader manag environ creat multipl book author book document definit theorem book book inclus updat onlin document within consist check done book includ book carri certif help commun versioncontrol ffl program mode allow definit execut function without proof burden impos without risk unsound introduc as prover know pro gram mode function ffl realist collect data type includ string complex ration number support reason data eg fulli integr linear arithmet decis procedur ration extens capabl control prover see below ffl common lisp macro eas program specif without clutter collect function one need reason ffl mani use program primit includ effici use multipl valu array properti list file io ffl common lisp packag support distinct name space mutual recurs definit support maintain also found applic style program amen mainten fix bug implement enhanc moreov subset common lisp acl support suffici code lowest level system which need implement primit believ common lisp program applic perhap even perform io fact acl program nearli so proof support nqthm pcnqthm proof signific theorem acl tend requir seriou effort part user prove appropri support lemma primarili store use condit rewrit rule howev acl offer mani way user control proof engin ffl nqthm proof commentari english assist user debug fail proof ffl pcnqthm interact loop proof discoveri extens macro access full power theorem prover ffl capabl appli hint individu subgoal ffl proof tree display show evolv structur proof real time also make conveni inspect fail proof effici handl proposit logic normal claus gener much effici nqthm also facil integr order binari decis diagram rewrit ing ffl function instanti facil give acl like nqthm conveni higherord logic without sacrif simplic first order logic ffl breakrewrit facil sophist nqthm or prover far know allow prooftim debug rewrit stack ffl theori mechan make easi manipul set rule especi turn also check desir invari set rule ffl forc mechan give prover permiss defer check hypothes specifi rule end main proof ffl support varieti type rule includ type support nqthm includ condit rewrit rule may use replac equal equal may also work respect userdefin equival relat linear arithmet rule togeth mechan creat rule certain simpl order standard lessthan order ration compound recogn forward chain type prescript equival congru enc builtin claus rule effici automat use certain fact improv meta lemma facil allow lemma condit ie hypothes rule use outsid simplifierrewrit elimin gener thu claim acl industri strength effici consist robust interfac array gener featur eas mainten flexibl theorem prover industri applic cours ultim test whether tool indu trial strength must whether use job interest industri first two import applic acl support claim task ap plicat summar below discuss detail also detail time manpow resourc spent compon task motorola cap digit signal processor bishop brock cli work collabor mo torola inc produc execut formal acl specif motorola cap digit signal processor design motorola execut point complex fft microsecond everi welldefin behavior cap model includ pipelin io interrupt breakpoint trap but exclud hard soft reset sequenc cap much complex processor recent subject formal model name fm mc aamp principl cap singl instruct simultan modifi well regist brock acl model cap bitaccur cycleaccur run faster motorola spw model furthermor acl use reason cap model acl comput symbol effect complic instruct second acl brock prove suitabl condit model cap equival simpler pipelinefre model perhap import aspect cap work acl possibl prove correct program complex instruct set mechan analysi cap microcod program perhap way assur program certain properti brock use acl verifi microcod produc motorola assembl sever applic program includ fir filter peak find algorithm use adder array chain compar work discuss follow approach use nqthm mc brock configur acl make easi symbol execut cap microcod program data specifi mechan prove total correct microcod program consid ere possibl and often less labor intens use cap model acl prove weaker properti mi crocod error occur believ microcod engin cap specifi acl applic program mechan verifi it subsequ microcod applic done rou tine routin mean technic detail symbol execut particular microcod manag acl effort verif task domin consider specif behavior given program anoth import aspect acl cap model execut cap program faster motorola spw model make conveni debug tool two reason speed one code somewhat higher level spw model ie arithmet model arithmet common lisp simul combin logic brock use strict guard ensur model type correct regist contain data appropri size address legal object use cap machin state appropri form etc function cap model prove gold thu acl cap model compil faith execut directli common lisp amdk floatingpoint divis anoth test industri applic acl collabor tom lynch advanc micro devic inc formal mechan prove correct microcod kernel float point divisionop erat use amdk microprocessor amd first pentiumclass processor particular prove p doubl extend precis floatingpoint number d mode round mode specifi round style target format precis n result algorithm pd round accord mode explain detail algorithm use tabl obtain bit approxim reciproc d two iter effici comput variat newtonraphson iter use refin approxim rel error less gamma approxim use comput four floatingpoint number whose sum suffici close pd round accord mode result round pd instead algorithm implement microcod comput use float point oper direct round prove algorithm work specifi develop acl much floatingpoint folk lore also formal algorithm acl use acl check fairli deep mathemat proof necessari step proof show everi intermedi result fit floatingpoint resourc alloc amd industri strength aspect acl use proof fact acl execut impor tant proof two applic newtonraphson iter produc suffici accur answer gener away particular tabl use amd defin predic recogn tabl contain suffici accur bit approxim prove newtonraphson step start tabl correct answer produc predic execut given concret tabl common lisp determin evalu whether satisfi predic thu appli result actual amd tabl acl mere execut predic amd tabl aspect acl crucial proof encapsul macro book use encapsul macro abl conveni configur acl temporarili deriv key step proof without impos proof strategi key step use book abl partit respons variou part proof among collabor assembl final result subsequ proof floatingpoint divis microcod david russinoff use acl prove correct amdk s floatingpoint squar root microcod conclus acl reimplement extend version boyer moor nqthm kaufmann pcnqthm intend larg scale verif project acl logic extens larg applic subset common lispsup port practic collect data type singl thread state io multiplevalu function array properti list care design notion guard acl allow eleg express proof theorem logic without mani encumbr typelik hy pothes time allow function logic relat common lisp way allow extrem effici comput furthermor design allow clear separ problem admiss logic definit proof simpli state properti typecorrect common lisp complianc effici execut design allow increment achiev goal via proof allow user focu effort import aspect project acl provid widevarieti featur supportiveof industri strength goal includ rug extens document implement mani conveni featur construct model develop structur proof good maintain final demonstr acl use tackl problem import industri acknowledg especi initi stage acl develop quit possibl acl would never creat also especi grate bishop brock provid valuabl feedback base heavi use acl mani month bill young improv contribut tutori materi document art flatau noah friedman laura lawless contribut technic aspect document provid use feedback also acknowledg contribut bill bevier alessandro cimatti rich cohen john cowl warren hunt jun sawada bill schel ter mike smith final grate util provid gnu emac particular richard stallman provid texinfo patch assist build documen tation also thank anonym refere paper provid mani valuabl suggest paper extend version paper acl industri strength version nqthm appear proceed eleventh annual confer comput assur compass ieee comput societi press pp june work report support part comput logic inc advanc research project agenc arpa order d contract no n c arpa order offic naval re search contract no nc view conclus contain document author interpret repres offici polici either express impli comput logic inc unit state govern r strong static type check function common lisp model valid test boyermoor prover nuprl experiment comparison special issu system verif machin check proof design faulttoler circuit function instanti first order logic boyermoor theorem prover interact enhanc computationallog comput logic handbook autom correct proof machin code program commerci microprocessor acl theorem commerci microprocessor mechan geometri theorem prov ing theorem prover mathematica implement mathemat nuprl proof develop system coq proof assist eve overview architectur complex arithmet processor com municationsign process introduct hol theorem prove environ higherord logic imp interact mathemat proof system user manual interact enhanc boyermoor theorem prover interact boyermoor theorem prover tutori studi use arithmeticgeometr mean theorem ramsey theorem boyermoor logic type harmless otter refer manual guid symbol model check formal verif aamp microprocessor case studi industri use formal method mechan check proof correct kernel amdk float point divis algorithm formal model asynchronouscom munic use mechan verifi biphas mark protocol introductionto obdd algorithm atp commun isabel gener theorem prover draft propos american nation standard inform system program languag common lisp mechan proof quadrat reciproc mechan check proof correct amdk floatingpoint squar root microcod compar verif system interact consist acl tr ctr michael lowri daniel dvorak analyt verif flight softwar ieee intellig system v n p septemb georg s avrunin stephen f siegel andrew r siegel finitest verif high perform comput proceed second intern workshop softwar engin high perform comput system applic may st loui missouri sean w smith vernon austel trust trust hardwar toward formal model programm secur coprocessor proceed rd confer usenix workshop electron commerc p august septemb boston massachusett josiah dykstra softwar verif valid destini parallel approach autom theorem prove crossroad v n p spring zaher s andrau karem a sakallah automat abstract verif verilog model proceed st annual confer design autom june san diego ca usa j strother moor mechan check proof multiprocessor result via uniprocessor view formal method system design v n p march d young compar verif system interact consist acl ieee transact softwar engin v n p april stephen mccamant greg morrisett evalu sfi cisc architectur proceed th confer usenix secur symposium p juli august ruben a gamboa correct fast fourier transform structur proof acl formal method system design v n p januari matt kaufmann j strother moor structur theori develop mechan logic journal autom reason v n p februari zaher s andrau mark h liffiton karem a sakallah refin strategi verif method base datapath abstract proceed confer asia south pacif design autom januari yokohama japan j strother moor toward mechan check theori comput acl project logicbas artifici intellig kluwer academ publish norwel ma matthew wild david greve david hardin effici simul formal processor model formal method system design v n p may alessandro armando silvio ranis constraint contextu rewrit journal symbol comput v n p juli paolo bientinesi john a gunnel margaret e myer enriqu s quintanaort robert a van de geijn scienc deriv dens linear algebra algorithm acm transact mathemat softwar tom v n p march andrew ireland alan bundi automat verif function accumul paramet journal function program v n p march jeremi w nimmer michael d ernst automat gener program specif acm sigsoft softwar engin note v n juli j strother moor thoma w lynch matt kaufmann mechan check proof amdktm floatingpoint divis program ieee transact comput v n p septemb ramesh bharadwaj constanc l heitmey model check complet requir specif use abstract autom softwar engin v n p januari jack minker introduct logicbas artifici intellig logicbas artifici intellig kluwer academ publish norwel ma