t zeroalias model fault a abstractwhen use builtin selftest bist test vlsi circuit circuit respons input test sequenc may consist thousand million bit compact signatur consist ten bit usual linear feedback shift regist lfsr use respons compact via polynomi divis compact function manytoon function result erron respons may map signatur good respons known aliasingin paper deal select feedback polynomi compact lfsr erron respons result model fault map signatur differ good respons lfsr call zeroalias lfsr zeroalias lfsr primit irreduc feedback polynomi consid due suitabl bist test pattern generationupp bound deriv least degre irreduc primit zeroalias lfsr polynomi bound show practic test applic polynomi degre less expect bound deriv show number fault less degre procedur find irreduc primit zeroalias lfsr polynomi of smallest degre prespecifi degre present lowcomplex procedur find zeroalias lfsr polynomi also present worst case well expect time complex procedur deriv experiment result present practic problem size demonstr applic propos procedur b introduct builtin selftest bist capabl circuit test itself idea behind bist creat pattern gener pg gener test pattern circuit respons analyz ra compact circuit respons input appli circuit respons may consist thousand million bit compact signatur consist ten bit compact function manytoon function result erron respons might map signatur good respons known alias erron respons map differ signatur good respons zeroalias two previou scheme achiev zeroalias take account possibl error sequenc first gupta et al scheme ra linear feedback shift regist lfsr compact function polynomi divis good respons feedback polynomi scheme requir quotient good respons period achiev proper select lfsr feedback polynomi good respons known give bound n length requir regist test sequenc length n second scheme due chakrabarti hay use nonlinear logic detect error respons number memori cell ra dlog ne bound extra logic requir implement scheme major differ scheme aforement zeroalias scheme target specif set possibl fault tri achiev zeroalias error sequenc result model fault tri recogn possibl error sequenc mainli never occur fault model let us focu probabl error sequenc result use less hardwar aforement scheme previou method find zeroalias feedback polynomi model fault present pomeranz et al differ heurist find zeroalias polynomi suggest heurist necessarili find minimum degre zeroalias polynomi necessarili find irreduc primit polynomi import regist also function pg work present upper bound minimum degre irreduc primit zeroalias polynomi provid algorithm find minimum degre polynomi pg ra usual implement reconfigur exist regist regist configur pg gener test block logic reconfigur ra test block logic lfsr feedback polynomi serv purpos overhead reconfigur design save scheme lfsr use pg multipl input shift regist misr use ra exampl misrbas ra shown figur regist configur shift regist input cell xor function previou cell output bit circuit test cut and depend linear feedback function feedback bit number cell k stage misr feedback come cell kgamma feedback function repres polynomi feedback feed cell iff f feedback polynomi misr figur differ lfsr misr extra input connect output cut pg lfsr ra misr use feedback polynomi overhead reconfigur polynomi save previou paper show select feedback polynomi pg paper deal select feedback polynomi ra sinc kstage pg primit feedback polynomi gener nonzero ktupl oppos pg irreduc feedback polynomi prefer primit zeroalias polynomi even though take effort find them compact function misr polynomi divis gf effect output polynomi divid feedback polynomi signatur remaind divis cut k output k output sequenc denot sequenc input sequenc length n view polynomi output valu ith output time j effect polynomi l x l object select feedback polynomi compact misr given set model fault erron respons result model fault map differ signatur signatur good respons cut output avail regist might short achiev zeroalias case need lengthen regist ad flipflop keep hardwar overhead minimum want add flipflop possibl henc interest feedback polynomi smallest degre achiev object regist serv pg ra advantag feedback polynomi degre avail regist henc interest feedback polynomi prespecifi degre time might want find feedback polynomi fast even result misr requir extra flipflop optimum assum follow test scenario input sequenc cut design effect output polynomi due target fault differ effect polynomi good respons ie error polynomi nonzero let r effect polynomi good respons effect polynomi due fault repres r h linear remaind oper get differ remaind erron polynomi iff h divis feedback polynomi assum given error polynomi target fault problem deal paper follow given set polynomi find polynomi rel prime polynomi h polynomi refer nonfactor h nonfactor use feedback polynomi compact misr zeroalias achiev set target fault particular irreduc primit feedback polynomi present upper bound smallest degre zeroalias misr procedur select zeroalias misr smallest degre procedur determin whether zeroalias lfsr prespecifi degre exist so find one procedur fast select zeroalias misr analyz worst case well expect time complex propos procedur note notat use logarithm notat ln x denot natur logarithm x log x denot base logarithm x polynomi fh g repres error polynomi degre h repres product polynomi h denot h degre h h h product distinct degre j irreduc factor h denot g ij ij degre g ij product i polynomi g ij denot g j nonfactor seek refer repres degre a rest paper organ follow section establish upper bound degre nonfactor section review polynomi oper gf complex section present procedur find nonfactor smallest degre set h section present procedur find nonfactor prespecifi degre find nonfactor fast also discuss effect conduct exhaust search least degre nonfactor section present experiment data conclud section bound least degre nonfactor set polynomi consid follow problem problem let h set jhj polynomi h give upper bound sd h degre irreduc polynomi upper bound pd h degre primit polynomi divid h ie exist irreduc primit polynomi degre sd h pd h divid h similarli let esh eph expect degre irreduc primit polynomi nonfactor h bound sd pd refer worst case bound bound esh eph refer expect bound first establish worst case bound proceed expect bound worst case bound bound sd follow let j denot number irreduc polynomi degre j gf degre product irreduc polynomi degre j j let sd denot least integ product irreduc polynomi degre less equal sd degre q sd greater d replac h q sd h least one root root h henc q sd h least one irreduc factor factor h thu sd h upper bound degre irreduc polynomi rel prime polynomi set h follow lemma provid bound sd h turn find bound pd number primit polynomi degre gf ism oeq euler function denot number integ less rel prime q p l p s distinct prime factor q lemma p q except the product first nine prime replac lemma q log log q proof first prove case q lemma log log q equat verifi directli help us deriv bound pd introduc valu t let t denot least integ ratio t time number primit polynomi degre t time number irreduc polynomi degre greater ie lemma lemma p lemma log log te proof definit t verifi express lemma valid valid prove case q function q log log q increas function henc log logq log log also log logq log log q thu sinc log log q log logq gamma log log q least integ log log t log log equat t get due lemma thu definit t t t bound t abov solv definit t must satisfi log t set log log te log logt thu log log te satisfi henc log log te lemma pd denot least integ d proof definit t lemma logdlogde lemma definit sd exampl tabl valu oe the degre product primit polynomi degre m the degre product primit polynomi degre m tabul long less maximum valu tabl pd obtain tabl instead use lemma exampl number model fault cut length test sequenc degre product primit polynomi degre less equal first greater thu zeroalias lfsr primit feedback polynomi degre exist cut hand use bound lemma get pd h closer look tabl show product primit polynomi degre less equal degre greater thu long product number fault test sequenc length less which case practic test applic zeroalias misr degre less equal exist expect bound deriv expect bound assum polynomi fh g random polynomi denot product distinct irreduc factor degre j h g ij denot number distinct irreduc factor h degre j v valu v rang minfbd jc jg lemma j expect valu v the number irreduc degreej factor equal proof let ir set irreduc polynomi degre j gf given polynomi q degre greater equal j defin indic function dp q one p divid q zero otherwis probabl polynomi degre j divid random polynomi degre greater equal j gammaj henc probabl equal gammaj thu type analysi use bound v arv varianc v oe v standard deviat v lemma j varianc number irreduc factor g ij less standard deviat less proof varianc v given v j ik j ik j henc j comput mean varianc number irreduc factor degre j per polynomi comput confid measur result lemma j expect number polynomi g ij factor less jhj jhj proof use chebyshev inequ p probabl v greater less use result defin second random process random variabl x iff v greater otherwis process bernoulli experi sec expect number ij s factor upper bound jhj varianc similarli probabl v greater less expect number g ij s factor bound jhj lemma expect degre smallest irreduc nonfactor set polynomi h bound dlog jhje proof denot product polynomi g ij jhj g j lemma expect number not necessarili distinct factor g j less jhjj smallest j j exce valu upper bound expect degre nonfactor henc ffi appli lemma result lemma corollari expect degre smallest primit nonfactor set polynomi h bound exampl use number exampl let first j exce jhjj henc expect find zeroalias misr primit feedback polynomi degre less equal oppos worst case corollari would give us upper bound expect bound function number fault length test sequenc expect degre zeroalias misr never exceed fact long number fault less million expect find zeroalias misr degre less equal polynomi oper gf search least degre nonfactor h use procedur sift factor degre given polynomi procedur base follow lemma lemma lemma p x product irreduc polynomi degre l l divisor m thu basic step find distinct irreduc factor polynomi bx comput result oper product irreduc factor degre l ljm bx polynomi bx interest us degbx therefor first comput analyz complex propos procedur reli follow result state greater detail appendix complex polynomi gcd oper om log s pp degre larger polynomi operand ms complex polynomi multipl product degre s complex polynomi divis also consid two multipl algorithm first algorithm due schonhag complex os log log log s second algorithm suggest cormen et al p complex os log s sequel shall use notat om complex polynomi multipl whenev possibl mean log s otherwis taken log log log s similarli notat ls denot either log log log log s appropri cost find remaind x divid bx without actual carri divis omm thu comput omm ms log s find nonfactor smallest degre given set polynomi establish bound least degre nonfactor h section section address question find least degre nonfactor h problem given set polynomi let find irreduc primit polynomi ax dega equival h j mod a irreduc primit polynomi bx degb h j mod b or equiv alent exist h j mod b one way solv problem factor polynomi h would requir much work sinc need know factor order find nonfactor need know small factor section present algorithm solv problem analyz complex complex given two form first worst case complex bound refer worst case complex second expect complex bound refer expect complex expect complex refin worst case complex base expect size result procedur lemma section upper bound depend whether look irreduc primit nonfactor use bound begin search process made three phase h h find g ij x product distinct irreduc primit factor h degre j found polynomi g ij determin whether irreduc primit polynomi degre j factor h irreduc primit polynomi degre j factor h find one not worst case complex three phase irreduc case ojhju mn log n ojhj n u mu domin term ojhj n u mu worst case complex three phase primit case ojhju mn ojhj delta log n ojhj n u mu log log u domin term ojhj n u mu log log u expect complex first two phase ojhju mn ojhj log jhju delta log n expect complex third phase ojhj log jhjd md find irreduc nonfactor ojhj log jhjd log log md find primit nonfactor domin term ojhju mn worst case complex function jhj n multipli term logarithm jhj n wherea expect complex function jhjn multipli term logarithm jhj n product distinct factor degre given polynomi given polynomi h x upper bound u wish comput g ij product distinct factor h degre j u procedur comput polynomi g ij given figur polynomi g ij comput three step first u comput gamma x g ij product distinct irreduc factor h x degre j degre l ljj j less equal u j u theorem g ij contain product irreduc factor degre l ljj h sinc degre g ij much less degre h effici comput g ij g ij h thu step end step g ij contain factor degre ljj h sift factor degre less j g ij need divid g ij g il l rang set divisor j carri step procedur distinct factor enough look primit nonfactor end procedur g ij product distinct irreduc polynomi degre j factor h g ij need sift nonprimit factor describ aspect introduc notion maxim divisor distinct prime factor q set maxim divisor q set exampl one prime factor polynomi gf q degre irreduc iff divid x divid x divisor k m primit degre iff irreduc divid x l gamma l mdq ch procedur distinct primit shown figur sift nonprimit factor g ij lemma complex procedur distinct factor ou mn complex procedur distinct primit ou mn complex first phase ojhju mn irreduc case ojhju delta mn primit case express irreduc case primit case proof worst case complex procedur distinct factor follow step procedur perform u gcd comput involv h complex gcd comput ojmd thu total work first stage u step procedur carri u gcd oper work requir step step everi element set divisor procedur perform divis oper cost express omd ojmd ij complex procedur distinct primit follow iter procedur distinct primit reduc ij perform one gcd one divis oper cost iter ojmd ij u run procedur u time therefor addit work primit case bound ou md case valu ij much less n henc actual work much less ou mn domin factor step procedur distinct factor set h base complex first phase jhju mn irreduc case jhju mn primit case valu u either sd h correspond either irreduc primit case lemma expect complex first phase ojhju mn u equal either esh eph proof expect complex procedur distinct factor domin complex step ou mn differ complex step worst case come use expect size ij s instead worst case size equal n expect complex procedur includ procedur distinct primit set h is thu ojhju mn u equal either esh eph number distinct factor degre set polynomi first phase degre j u jhj polynomi g ij product distinct irreduc primit factor degre j h g ij s might equal pair might factor common goal find least degre nonfactor h first must determin whether irreduc polynomi degre j appear second three phase page simpl test compar degg j j degg j nonfactor degre j primit case compar oe j gamma j way determin whether irreduc primit polynomi degre j factor g j find factor appear one g ij s elimin appear except one consid two method remov repeat factor first refer lcm method second refer gcd method lcm method shown faster also requir space might avail lcm method first sort g ij accord degre place set k g ij k iff set fs k g order accord index increas order begin comput lcm two polynomi taken first set set one polynomi take second polynomi next set result lcm polynomi place set correspond degre process end left one polynomi repres lcm polynomi g ij gcd method polynomi g ij sort degre iter polynomi highest degre taken set pairwis gcd polynomi taken gcd greater polynomi divid gcd end iter none remain polynomi set factor common polynomi taken out thu procedur end factor appear one g ij s lemma complex second phase ojhj mn log n expect complex second phase ojhj log jhjln logjhjn proof bound work requir lcm method follow first assum jhj ij power if not bound purpos increas nearest power also assum polynomi leav binari tree polynomi level degre each level correspond differ set k assum everi lcm step degre lcm sum degre two operand ie operand rel prime maximum degre final lcm jhjn comput lcm cost omjhjn logjhjn comput two lcm next last level cost o delta mjhjn delta logjhjn lower level twice mani lcm comput cost less half cost level it henc total cost bound ologjhjnmjhjn logjhjn ou mjhjn use lcm method need enough memori store final lcm requir memori use gcd method work requir ojhj mn log n take account expect size polynomi g ij factor becom practic factor algorithm use cantor zassenhau complex factor product r distinct irreduc polynomi degre j given ormrjj logrj lemma expect number polynomi g ij factor less jhj k take number polynomi factor jh j polynomi factor assum polynomi assum etc expect work requir factor polynomi bound ob jhj use fact j bound sum ob factor complet irreduc factor sort time ojhj delta log jhj uniqu factor count sum log n sinc u log jhj express becom ojhj log jhjln logjhjn find nonfactor third phase know smallest degre exist nonfactor h also have jhj polynomi g id product distinct irreduc primit factor h g id s pairwis rel prime everi irreduc primit factor degre h factor one polynomi want find irreduc primit polynomi degre nonfactor h one approach divid product irreduc primit polynomi degre product polynomi find factor result might pose problem product hand ie polynomi g id product larg handl one polynomi anoth way randomli select irreduc primit polynomi check whether factor nonfactor way check actual divis divis howev regular long divis fft divis whenev divisor small degre compar degre dividend irreduc primit polynomi rel prime g ida s nonfactor divid least one polynomi keep result divis reduc work upcom trial reduct requir polynomi repeat select process lemma complex find nonfactor known ojhj md irreduc case ojhj n md log log primit case expect complex ojhj log jhjd md irreduc case ojhj delta log jhj delta log log md primit case proof procedur gener random polynomi check irreduc primit whether factor not expect number random polynomi test irreduc primit irreduc primit polynomi degre found dalog log work requir test polynomi irreduc od md md sum ij s cannot exceed jhjn therefor jh jn da irreduc polynomi tri nonfactor found work involv tri jhjn delta long divis thu expect work requir find nonfactor ojhj md primit case work md log log polynomi g ij factor see proof lemma known draw irreduc primit polynomi nonfactor found expect jhjd factor irreduc primit polynomi drawn take olog jhj check whether factor not henc expect work requir find non known bound ojhj log jhjd md irreduc case ojhj log jhjd md delta log log primit case practic scenario section discuss practic scenario find zeroalias polynomi first want nonfactor prespecifi degre second want find nonfactor fast third compar algorithm find least degre nonfactor exhaust search irreduc primit polynomi ascend degre case type search faster find nonfactor prespecifi degre case regist requir function ra pg nonfactor prespecifi degre need thu problem given set polynomi irreduc primit nonfactor degre h problem exactli find least degre nonfactor except need consid case t instead iter j u first comput polynomi g it determin whether nonfactor degre exist find one lemma complex find nonfactor degre ojhj irreduc case ojhj n mt log log t primit case expect complex ojhjmnt log n proof comput polynomi g it involv comput g l mdt comput f cost first gcd comput otmd cost jmdtj subsequ gcd divis bound olog ttmd it md it log it substitut n it get olog log n polynomi g it need sift multipl instanc irreduc polynomi use gcd method worst case cost ojhj mn delta log n stage know whether nonfactor degre exist not one exist carri phase worst case complex ojhj domin term whole process analysi primit case henc worst case complex find irreduc primit nonfactor given degre set polynomi h ojhj log log t turn analyz expect complex h comput g x cost ojhjmnt log n cost sift factor degre less g it s base expect number factor degre insignific factor sort polynomi second phase expect cost ojhj log jhjt log n eq expect number distinct irreduc factor degre h bound jhjt thu cost find nonfactor stage consist draw jhj irreduc primit polynomi expect cost o ttmt o tlog log delta mt check list factor bound o jhj ttmt logjhjt irreduc case ojhjlog jhj gamma log tt mt log log t primit case henc expect complex find nonfactor degre h bound ojhjmnt log n find nonfactor fast problem given set polynomi find irreduc primit nonfactor h less c tri sum degre irreduc primit polynomi degre less equal sd h pd h greater h look p u draw uniformli irreduc prim itiv polynomi degre u c draw expect find nonfactor expect work cost case o c delta cost c iter draw polynomi test irreduc one found divid jhj polynomi candid nonfactor use long divis primit case becom o c delta u mu log log u exampl use number exampl again say want find nonfactor tri comput bound p draw primit polynomi comput bound use tabl see instead look polynomi degre less equal need consid primit polynomi degre gener c henc lemma consid polynomi degre greater case want minimum degre nonfactor also use expect bound esd epd lower degre candid nonfactor exhaust search subsect compar algorithm exhaust search least degre nonfactor look irreduc case assum least degre irreduc nonfactor degre also assum list irreduc polynomi ascend order number irreduc root degre j less j bound work requir find nonfactor exhaust search ojhjn da use expect bound d olog jhj bound work n expect work requir find least degre nonfactor algorithm ojhju mn becom ojhj log jhj delta n log n substitut valu u take account constant involv two result ratio work requir exhaust search rel work requir algorithm log jhj log n assum ratio less n assum ratio less n ratio less n suggest number fault interest small less exhaust search might effici algorithm howev number fault increas algorithm effici test sequenc realist length final number fault greater practic test length algorithm effici simpl exhaust search experiment result follow experi conduct verifi result experi conduct hp workstat random select base absolut bound experi set follow gener set random polynomi degre correspond cut fault ie test length ie degre product polynomi d h less equal want probabl greater find nonfactor one draw primit polynomi look tabl achiev select set primit polynomi degre less equal polynomi drawn step process first step select degre primit candid second select candid first step select number took valu modulo number primit root field gf gf result use determin degre primit candid look first field gf number primit root field gf gf greater result select actual polynomi done set coeffici lfsr primit feedback polynomi degre gamma initi random state guarante candid select twice candid chanc consid candid test primit primit test nonfactor point found factor search continu current state degre ran experi experi first primit candid turn nonfactor nonfactor found degre degre degre degre degre degre degre degre degre number polynomi test primit one found rang averag number time took find primit polynomi rang second second averag time second took second find nonfactor averag second experi show given error sequenc fault interest easi find zeroalias polynomi circuit random select base expect bound base expect bound corollari abl find nonfactor degre ran experi abov time select primit polynomi degre the expect bound base tabl first primit candid select nonfactor experi experi found nonfactor second candid third fourth fifth sixth ran experi select primit candid degre number primit candid tri nonfactor found rang averag number candid test tight expect bound ran experi random polynomi degre gener exhaust search increas order degre conduct find least degre nonfactor expect bound least degre less one experi least degre remain experi least degre experi conclud error polynomi fact random polynomi expect bound base analysi expect number factor certain degre random polynomi fact upper bound least degre nonfactor set polynomi expect bound obtain tabl tighter corollari experi benchmark circuit tri worst case expect bound error sequenc two circuit berkeley synthesi benchmark first circuit in second in use fault simul take account fault collaps henc number fault twice number line circuit for stuckat stuckat fault line circuit fault six redund henc detect fault circuit primari output use test sequenc length detect nonredund fault comput effect output polynomi fault nonzero henc cancel error one output error anoth output thu error polynomi degre tabl worst case bound degre primit nonfactor draw primit nonfactor probabl greater need consid primit polynomi degre less conduct experi draw zeroalias primit polynomi base worst case bound experi first candid nonfactor conduct anoth experi time draw primit polynomi degre size regist avail circuit output experi first candid nonfactor base expect bound tabl find nonfactor degre less tri find nonfactor degre degre experi case first primit candid nonfactor two experi found nonfactor second tri one third conduct degre experi consid primit polynomi degre primit polynomi degre factor nonfactor averag number candid tri nonfactor found primit polynomi degre factor circuit fault nonredund circuit primari output use test sequenc length use worst case bound ensur select primit nonfactor probabl greater consid primit polynomi degre less experi found nonfactor first candid expect bound tabl degre primit nonfactor tri find nonfactor degre the size regist avail output degre experi found nonfactor first tri found nonfactor first tri second one third circuit tri find least degre nonfactor use exhaust search sinc fault extractor use fault collaps error polynomi ident sum valu nonzero erron output word simul fault found least differ error polynomi least differ error polynomi in would make expect bound tabl in circuit least degre nonfactor degre took cpu minut find polynomi experi two benchmark circuit show assumpt error polynomi behav random polynomi invalid analysi result expect bound case random experi upper bound least degre nonfactor conclus paper present procedur select zeroalias feedback polynomi misr base ra pg ra design lfsrsmisr scheme combin algorithm select effici feedback polynomi pattern gener enabl select one feedback polynomi serv task thu reduc overhead reconfigur regist present upper bound least degre irreduc primit zeroalias polynomi set model fault show practic test applic polynomi alway degre less fact expect bound number fault less degre experi conduct zeroalias polynomi degre less expect bound alway found also present procedur find zeroalias polynomi object minim degre specif degre speed analyz comput effort requir worst case condit expect condit partial summari result present tabl worst case analysi expect analysi tabl show upper bound smallest nonfactor comput complex find smallest nonfactor complex find factor given degre speed requir show find zero alias polynomi with averag two tri increas degre polynomi consid two upper bound size minimum degre base analysi experi conclus error polynomi model target fault avail zeroalias easili achiev goal thu ensur high qualiti test premium put fault model autom test pattern gener design fault simul tool avail zeroalias problem acknowledg wish thank professor l a adleman m a breuer d j ierardi l r welch mani help discuss also wish thank anonym refere help comment r design analysi comput algo rithm logic minim algorithm vlsi synthesi factor polynomi larg finit field new algorithm factor polynomi finit field introduct algorithm concret mathemat complex multipl finit field test embed discret logarithm introduct finit field applic achiev zero alias model fault a new framework design analyz bist techniqu probabilist algorithm finit field book prime number record schnell multiplik von polynomen uber korpern der charakteristik tr ctr krishnendu chakrabarti brian t murray john p hay optim zeroalias space compact test respons ieee transact comput v n p novemb o novk z plva j nosek a hlawiczka t garbolino k gucwa testperclock logic bist semideterminist test pattern zeroalias compactor journal electron test theori applic v n p februari