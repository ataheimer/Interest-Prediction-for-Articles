t comput local consensu tree a infer consensu set evolutionari tree fundament problem number field biolog histor linguist mani model infer consensu propos paper present model deriv call local consensu tree set tree cal t model propos presum function f call total local consensu function determin everi tripl speci form local consensu tree take a show local consensu tree exist construct polynomi time mani fundament problem solv linear time also consid partial local consensu function studi optim problem model present linear time algorithm sever variat final point local consensu approach tie togeth mani previou approach construct consensu tree b introduct evolutionari tree also call phylogeni phylogenet tree speci set root tree leav label distinct element s evolutionari histori difficult determin it comput difficult optim problem area nphard scientif difficult well sinc rang approach appropri differ type data exist common approach solv problem appli mani differ algorithm given data set differ data set repres speci set look common element set tree return sever method describ literatur deriv one tree set tree paper propos new model call local consensu model base upon function call local consensu rule infer root topolog homeomorph subtre induc tripl speci show local consensu function support part nsf grant ccr support part aro grant daalpri z support part aro grant daalpri comput polynomi time mani natur form local consensu comput linear time also analyz optim problem base upon partial local consensu rule show mani also solv polynomi time preliminari definit let set speci evolutionari tree also known phylogenet tree or simpli phylogeni root tree n leav label distinct element s intern node denot ancestor speci s arbitrari subset ae denot tj homeomorph subtre induc leav particular specifi tripl fa b cg ae denot tjfa b cg homeomorph subtre induc leav label a b c topolog complet determin specifi pair speci among a b c whose least common ancestor lca lie furthest away root a b pair denot a b c said resolv tripl a b c binari may happen three pair speci least common ancestor case say unresolv denot topolog a b c given tree contain node u v w let lca u v w denot least common ancestor u v w also let u v denot v path u root set input tree ft consensu problem sometim refer profil let a b c repres set root subtre leaf set fa b cg local consensu rule function given local consensu rule f set r evolutionari tree s flocal consensu if exist tree r f tripl s r f said total local consensu otherwis f said partial local consensu problem determin flocal consensu exist construct call flocal consensu problem also consid optim version local consensu problem discuss subsequ section set gener machineri look special case need build consensu two tree describ specif local consensu function f produc effici algorithm particular local consensu rule defin binari local consensu optimist local consensu pessimist local consensu problem below binari local consensu problem take input two binari tree wherea optimist local consensu pessimist local consensu problem take input two tree necessarili binari exampl total local consensu rule definit local consensu rule f conserv everi tripl fa b cg jfa b cg requir resolv particular profil tree profil resolv fa b cg differ tree necessarili binari local consensu rule interpret unresolv tripl one two distinct way suppos resolut three way split possibl suppos unresolv node repres threeway speciat event depend upon interpret therefor local consensu rule may decid resolv unresolv tripl output resolv ident unresolv call first type local consensu rule optimist second type pessimist defin three consensu rule definit let two root binari tree leaf set s root tree which necessarili binari call binari local consensu iff tripl a b c jfa b definit let two root tree leaf set s root tree call optimist local consensu iff tripl a b c c a b c definit let two root tree leaf set s root tree call pessimist local consensu iff tripl a b c differ appropri particular type data given definit three model local consensu tree may exist section give linear time algorithm either construct tree look exist conclud tree exist howev practic biologist linguist need build kind consensu tree therefor consid variant local consensu tree problem alway solut end defin notion relaxedaccord local consensu relaxeddiscord local consensu follow definit let two root binari tree leaf set s root tree which necessarili binari call relaxedaccord local consensu whenev tripl a b c differ topolog tripl unresolv preserv topolog maxim set tripl agre prove exist relaxedaccord local consensu tree suffici show exist tree everi tripl disagre unresolv set tree properti partial order base set tripl on agre whose topolog preserv partial order known nonempti prove exist relaxedaccord local consensu sinc maxim element partial order consensu tree note star topolog leav unresolv tripl disagre henc partial order nonempti relaxedaccord local consensu tree alway exist section show tree uniqu definit let two root tree not necessarili binari leaf set s root tree call relaxeddiscord local consensu preserv topolog tripl agre addit leav unresolv maxim set tripl disagre use argument similar one use prove exist relaxedaccord local consensu note or preserv topolog tripl agre conclud relaxeddiscord local consensu alway exist section show relaxeddiscord local consensu also uniqu look problem give standard definit avail literatur definit let root tree leaf set s given node v v t denot lt v set leav subtre v root v also call cluster v repres ff v set ct call cluster encod everi root tree leav label contain singleton entir set ct cluster call trivial cluster defin maxim cluster cluster defin child root here allow maxim cluster defin leaf also also defin notion compat set cluster definit set cluster said compat iff exist tree ct follow proposit found proposit set cluster compat iff ff g state theorem use later section theorem let two root tree leaf set let f conserv local consensu rule flocal consensu tree exist ct compat set proof suppos suppos without loss gener ct compat set proposit ff ct fi ct ff g pick ff topolog tripl a b c a c b a b c sinc f conserv local consensu rule imposs binari local consensu section look binari local consensu problem start restat definit binari local consensu tree let two root binari tree leaf set s root tree which necessarili binari call binari local consensu iff tripl a b c jfa b character construct show althought binari local consensu two tree may exist exist nice character proposit given binari tree cluster ff ff compat ct iff proof ff ct ff compat ct exist proper refin ct binari tree proper refin lemma let root binari tree leaf set s f conserv local consensu function flocal consensu tree exist proof previou lemma ct sinc f conserv corollari binari local consensu tree exist t binari ct proof need show ff ct ff ct ff pick ident also resolv tree ct call strict consensu tree particular consensu tree alway exist construct on time construct part algorithm binari local consensu tree therefor simpl remain verif strict consensu tree also binari local consensu tree ie tree construct use algorithm satisfi constraint impos upon binari local consensu rule verifi consensu tree binari local consensu tree prove structur lemma help determin whether consensu tree fact binari local consensu lemma let root binari tree leaf set let ff cluster intersect let strict consensu tree let e e edg respect respect intern node defin cluster ff let speci ff binari local consensu subtre e binari local consensu subtre e e upon replac subtre t respect binari local consensu proof clearli binari local consensu tree condit hold convers hold binari local consensu tree tripl a b c incorrectli handl tripl a b c e condit handl a b c correctli similarli least two e condit handl tripl correctli remain show handl tripl exactli two a b c one edg e then sinc cluster tripl properli thu binari local consensu lemma yield obviou divideandconqu strategi determin whether binari local consensu exist next explor pair binari tree possibl binari local consensu star ie tree none trivial cluster definit caterpillar root binari tree one pair sibl leav given leaf label caterpillar root r height h natur order induc leav let hg function gs distanc r speci order increas order ga note pair sibl leav arbitrarili order definit two caterpillar x leaf set said opposit orient iff k k smallest element x contain among k largest element vice versa proposit let two root binari tree leaf set whose binari local consensu star a b sibl pair leav lca b must root proof suppos not speci c least common ancestor a c least common ancestor a b jfa b henc binari local consensu cannot star lemma suppos binari tree leaf set suppos least leav binari local consensu tree star must caterpillar proof suppos contradict caterpillar two pair sibl leav a b c d previou proposit pair must root least common ancestor thu without loss gener c lie left subtre root b lie right subtre root thu follow must two sibl pair p q r s one subtre root note least common ancestor p q least common ancestor r root without loss gener let p r lie left subtre root q lie right subtre root x either subtre figur topolog respect p q let x speci besid p q figur suppos without loss gener x lie left subtre root consid follow two tripl topolog tripl x p s x q r respect show agre least one tripl two case x lie left subtre root topolog tripl x p clearli x p s x lie right subtre root topolog tripl x q r x q r thu either case tripl agre tripl binari local consensu cannot star lemma let two caterpillar leaf set binari local consensu star opposit orient caterpillar proof suppos two caterpillar opposit orient ie satisfi two intersect condit let x z three leav let indic order leav respect topolog x z x y z look smallest element set must contain z cannot contain x consequ topolog tripl x y z star valid binari local consensu convers suppos two caterpillar satisfi intersect condit without loss gener suppos exist least one k k smallest element contain within largest element pick smallest k say x leaf rank k x belong set k largest element pigeonhol principl exist least two leav rank greater k contain set k largest element suppos two leav z jfx impli binari local consensu cannot star b c e f c figur exampl opposit orient caterpillar corollari binari local consensu two tree verifi star linear time binari local consensu tree algorithm use day algorithm produc strict consensu tree nontrivi cluster maintain pointer edg give rise cluster travers postord nontrivi cluster found check subtre edg caterpillar satisfi condit lemma replac entir subtre singl node belong subtre not declar binari local consensu tree theorem construct verif binari local consensu done linear time proof day algorithm run linear time also step algorithm take linear time sinc linear number speci reintroduc replac abov also check caterpillar done time linear number leav caterpillar optimist local consensu section look problem find optimist local consensu olc tree two tree defin previou section note optimist local consensu two tree may exist recal definit olc tree let two root tree leaf set s root tree call optimist local consensu iff tripl c a b c character olc tree follow lemma character optimist local consensu tree exist theorem let two root tree speci set s optimist local consensu tree olc exist ct olc ff ct ff compat ct ct g proof pick cluster ff a look tripl x tripl resolv x y z one tree either resolv unresolv tree either case ff ct olc convers pick cluster a two case here name case ff compat least one ct ct case ff compat ff compat least one ct ct use theorem observ second case pick smallest cluster ff note node v u defin cluster ff ff respect lca respect speci ff fi smallest cluster respect contain ff sinc ff compat ct ct impli ff union cluster least two children v also union cluster least two children u moreov a b ff a b a b thu pick c fi jfa b c topolog given olc a b c thu construct phase sinc optimist local consensu rule conserv tree set cluster henc exist tree satisfi ct construct refin reduc contract unnecessari edg thu obtain olc approach take note approach break construct two stage refin contract refin main object refin includ cluster olc explain precis introduc notat lemma previou work enabl us effici definit let v arbitrari node tree children repres set v set fx x denot repv one repres set lemma optimist local consensu tree olc tree exist olc jrepv isomorph jrepv proof follow fact jrepv star definit let v node tree children subtre induc fv g refin follow modifi tree initialis postord fashion everi seen v also number children v sinc process done postord fashion say replac subtre v root v follow manner replac nv isomorph copi next replac x subtre root u let tree produc consid node theorem let given suppos olc exist tree produc algorithm describ previou paragraph satisfi ct proof sinc ct olc need show olc jrepv cannot proper refin jrepv were fa b cg repv olc jfa b cg would resolv jfa b cg unresolv sinc fa b cg repu jfa b cg also unresolv forc olc also unresolv note reduc problem construct problem discov linear time algorithm howev need abl comput jrepv quickli cite follow result use us case lemma given lefttoright order leav tree abil determin topolog tripl leav a b c constant time construct tree linear time use lemma need two thing abl determin topolog tripl o time node order repres set order consist lefttoright order leav accomplish first preprocess lca queri then determin topolog tripl a b c simpli compar lca a b b c a c second requir challeng also handl show comput order repres set on time ffl initi node empti label ffl s taken lefttoright order leav trace path leaf toward root encount either root node alreadi label append order set node path trace includ first node encount alreadi label figur show exampl comput describ b c e b c e b c e c ad rep set w v lefttoright order c b e c r ad rep set u v r iv complet figur exampl show comput repres set node base lefttoright order speci note comput take on time sinc node v visit odegv time order produc exactli requir thu node v v t defin set leav leaf differ subtre v everi subtre v repres order leav appear lefttoright order thu prove lemma comput jrepu ojrepuj time therefor follow theorem given construct tree ct exist on time rest task construct olc contract unneed edg contract simpli go edg check need kept must delet note edg ad refin phase requir need check therefor need check origin tree edg let u v edg repres set u v easili choos three speci a b c lcaa lcab c v topolog tripl differ resolv a b c know edg u v contract hand jfa b cg either a b c a b c u v retain optimist local consensu tree olc construct algorithm phase preprocess make copi respect node v tree comput order repres set order lefttoright order tree preprocess tree answer lca queri leav well intern node phase i refin refin postord fashion end ct exist phase ii contract contract edg e et c e cluster e lie ct thu shown follow theorem theorem algorithm state construct olc two tree olc exist analysi run time phase preprocess harel tarjan give on time algorithm preprocess tree answer lca queri constant time alreadi shown comput order repres set take on time thu preprocess stage take on time phase i refin stage involv local refin shown cost refin around node v odegv sum node v obtain on time phase ii contract edg stage clearli take on time theorem construct optimist local consensu tree done linear time verif phase lemma let tree leaf set s let obtain sequenc refin follow sequenc edg contract exist function subset v children fv proof defin set cluster therefor subset v children fv v sv ff v lemma suppos olc on leaf set contain least speci star iff either one follow hold opposit orient caterpillar star proof if direct easi see assum olc star contain tripl a b c unresolv must also unresolv a b c convers whenev resolv a b c must differ resolv a b c thu either binari not case binari definit olc coincid definit binari local consensu appeal proof lemma lemma argu must opposit orient caterpillar binari show node v children fu node v children fu k g ff u pick three speci a b c a b c unresolv let a b c a b c must unresolv let v a b c claim ff see whi suppos subtre v a contradict assumpt star thu ff next note x child v differ children exist z x y z resolv unresolv would contradict fact star establish claim impli nonbinari node v root find two speci a b a v b v speci c c v cg thu root must three children case mean cluster defin child root contain two speci tripl agre thu must star verif proce follow phase suppos tree construct refin contract edg result tree modif ie refin use inform contract edg result tree befor call tree clearli isomorph termin output olc exist know compat set cluster defin uniqu tree know olc exist uniqu character phase phase success verifi further comput order repres set everi node w v t node w check homeomorph subtre induc repw star opposit orient caterpillar neither these termin output olc exist identifi parent w say w look repw exclud repres element w call set a identifi lca repw check speci belong lie lca repw so termin output olc exist implement step phase use lefttoright order speci comput order repres set rep node shown previou section u v t abl quickli comput homeomorph subtre induc speci repu need know order these speci appear lefttoright order associ u new rep set rep u rearrang version speci repu accord order defin specifi s node v v t closest root repv function limit togeth lefttoright order speci help fill rep set sinc belong rep set node path limit first show comput use algorithm limit show rep set fill initialis visit topdown travers f repv set limit identifi s proceed comput rep u follow look lefttoright order speci now speci lefttoright order trace path leaf toward root add rep set node encount path termin reach limit note process identifi rep rep done onc analysi run time isomorph test phase perform on use simpl modif treeisomorph test algorithm on cost preprocess answer lca queri phase implement step phase involv one time on cost preprocess identifi rep rep node time step call node w addit time odegrepw taken exploit fact preprocess answer lca queri seen step phase take odegw thu total time taken verif phase on correct verif procedur theorem pass test olc proof need show handl everi tripl properli follow case handl assum pass isomorph test case pass isomorph test tripl a b c two tree resolv differ unresolv follow sinc creat refin contract action take resolv tripl differ resolut case involv tripl a b c topolog a b c claim first step phase pass topolog tripl a b c see whi suppos a b c unresolv a b c cannot resolv a b c a c b look node u v lca a b respect node w lcaa b c also lcaa b sinc a b c unresolv infer f function defin lemma becaus node w contain speci c node w contain either b similar argument now look repw comput homeomorph subtre induc repw induc tree exist three speci x z x u and v and z charact defin u and v thu induc tree tripl x topolog x y z is induc tree neither star opposit orient caterpillar thu verif process termin output olc exist case involv tripl a b c resolv a b c one tree unresolv other proof case essenti follow line proof case case involv tripl a b c unresolv tree claim second step phase pass tripl unresolv see whi suppos a b c resolv a b c let lca a b c x let lca a also suppos without loss gener x parent y let child ff let child b ff let z child x c ff z let a b c a b c look function f f defin lemma v t v t respect v note cluster defin child u nonempti intersect one ff ff similarli v thu repres chosen ff ff respect least common ancestor u v howev f z v thu repres chosen ff z lie u v respect caus us conclud olc exist pessimist local consensu recal definit pessimist local consensu two root tree leaf set s root tree call pessimist local consensu iff tripl a b c jfa b character follow theorem character plc tree two tree theorem let two tree leaf set s pessimist local consensu tree plc exist ident equal ct proof pick cluster ff ct sinc ff belong tree look tripl ff tripl resolv x y z thu convers pick cluster two subcas ff compat least one ct ct case theorem ff compat ct ct case pick node defin smallest cluster contain ff pick tripl a b c ff tripl unresolv either thu construct phase theorem pessimist local consensu tree exist ident strict consensu tree thu construct pessimist local consensu tree suffic use on algorithm strict consensu tree verif phase let input tree let strict consensu tree construct use algorithm want abl verifi whether actual pessimist local consensu case star alreadi star noth verifi sinc true pessimist local consensu assum case two case consid first either say least two children root leav second case exactli one child root leaf made observ case appli divid conquer strategi adopt binari local consensu problem lemma suppos two tree leaf set s least two children root leav let ff ff l maxim cluster maxim cluster pessimist local consensu star iff proof suppos mean x y lcax y root lcax y root thu tripl x topolog agre thu star suppos defin node leaf look ff k node defin ff k leaf node two case handl here either least one speci ff k fi j speci ff k fi j ie ff k ae fi j former case pick speci z ff k fi j also pick two speci x ff agre tripl x name tripl topolog x y z tree thu cannot star latter case sinc know fi j s pick two speci x y ff k anoth speci z gamma fi j topolog tripl x y z thu cannot star sinc speci belong one maxim cluster tree test done linear time follow lemma handl case exactli one child root leaf lemma suppos two tree leaf set pessimist local consensu star suppos exactli one child root leaf let leav children root let v lca everi child v contain one speci x g moreov pair speci x g least common ancestor x lie path v root proof suppos child v contain least two speci gamma fs g pick x lie child v pick lie differ child v find tree topolog tripl cannot star furthermor x lcax y lie path v root tripl x would ident topolog tree star definit root tree milliped set intern node defin singl path root leaf b c figur exampl milliped g js milliped say let l children root leav look js say either one nonleaf child least two nonleaf children former case appli previou lemma infer milliped later case appli lemma check pessimist local consensu star follow subsect show verifi star input tree milliped verif input tree milliped proof follow lemma straightforward lemma suppos two milliped leaf set s pessimist local consensu star iff exist tripl tree topolog tripl describ linear time algorithm verifi tripl topolog defin order speci use function f distanc root and h height write union set sequenc height contain exactli speci distanc root now replac speci set fs call multiset integ thu get sequenc multiset definit say tripl integ p q r special observ pessimist local consensu star iff special tripl p q r exist follow algorithm check plc take input sequenc return fail exist special tripl integ otherwis return pass check plc work scan multiset th iter make use three variabl global min local min temp start th iter global min store smallest integ seen first multiset variabl local min use store smallest integ b b local min initialis variabl temp initialis long temp remain local local min store temp store b previous mention realtionship b hold th iter check plc either return fail if special tripl exist or necessari modifi variabl global min local min temp hold intend valu first multiset sequenc reason store valu start th iter follow p i p q r special tripl global min togeth q r also special tripl sinc global min p similarli p j q l i p q r special tripl local min temp r also special tripl describ check plc initialis global local procedur output fail and termin pessimist local consensu star output pass otherwis f f scan jaj output fail y local global f scan either jaj jbj output fail els global min minm set local min global min global min minm set local min global min y global output pass analysi run time check plc run linear time sinc scan constant number time theorem algorithm check plc correct proof induct observ step execut th iter j l x follow step execut th iter start iter local thu case global min store smallest integ seen first multiset now first multiset special tripl p q r exist q r check plc correctli output fail sinc global min p otherwis two case depend upon valu a variabl global min temp local min updat global min hold smallest valu first multiset also local min correctli hold smallest valu exist b store temp b case case global min updat hold minm which smallest valu first multiset observ temp updat store nonzero valu never store again thu temp set nonzero valu iter iter iter k step execut assum step execut iter assum induct start iter global min store smallest valu first multiset local min store smallest valu exist b store temp b iter easili seen check plc correctli output fail exist special tripl p q r case ensur iter global min store smallest valu first multiset local min store smallest valu exist b store temp b use argument seen check plc give correct output sequenc multiset thu also follow theorem theorem given two milliped check pessimist local consensu star linear time relax version local consensu rule seen far output tree satisfi particular rule need exist motiv need look relax version local consensu solut alway exist recal definit relaxedaccord local consensu relax discord local consensu exist solut problem shown section relaxedaccord local consensu subsect show relax accord local consensu two binari root tree actual strict consensu two tree theorem two root binari tree relaxedaccord local consensu alway exist ident strict consensu proof exist relaxedaccord local consensu tree shown section show tree strict consensu tree suppos exist tripl a b c resolv differ say a b c a b c respect say lca neither ff u ff v strict consensu tree thu strict consensu tree leav unresolv tripl differ topolog let tree everi tripl a b c differ unresolv topolog tripl suppos possibl contain cluster intersect set cluster let ff cluster suppos without loss gener ff cluster pair speci x ff speci z ff topolog x y z howev also case must also possess cluster ff contradict assumpt thu must exist pair speci speci z ff topolog x y z impli cannot relaxedaccord local consensu henc candid relaxedaccord local consensu contain cluster intersect cluster set contain proper subset cluster intersect set cluster exist tripl a b c unresolv topolog strict consensu tree resolv topolog agre topolog henc strict consensu relaxedaccord local consensu consequ relaxedaccord local consensu construct on time use algorithm need verifi tree construct correct relaxeddiscord local consensu relaxeddiscord local consensu rdlc problem requir tripl tree agre must topolog preserv consensu tree leav unresolv maxim set tripl disagre previous show rdlc exist show uniqu construct rdlc accomplish defin set bcg set root tripl pass algorithm aho et al comput tree if exist requir form everi tripl set resolv minimum number addit tripl outsid set algorithm take opn time case p on use algorithm would result run time on obtain speedup on algorithm which includ verif construct relaxeddiscord tree use fact tree necessarili exist algorithm howev take advantag idea begin briefli describ algorithm work assu algorithm aho et al describ algorithm determin famili constraint least common ancestor relat satisfi within singl root tree describ simpl algorithm give case constraint given root resolv tripl z input algorithm work topdown figur cluster children root recurs algorithm maintain disjoint set initi leav singleton set root tripl x y z algorithm union set contain x indic x must lie child root algorithm never union set unless forc recurs call includ constraint speci entir contain compon discov previou call speci seen compon either initi recurs call algorithm determin constraint cannot simultan satisfi simpl algorithm worst case behavior opn p lca constraint underli set n element leav final tree improv algorithm rdlc describ algorithm solv rdlc on time sinc consist tripl agre clear tree produc assu algorithm refin tree follow sens child root as well repres cluster union cluster repres children root let ff cluster child root let fi cluster child root ff fi union cluster children root fact ff fi nonempti ff fi also union cluster children root show except one special case ff fi fact cluster exactli one child root fi y z ff fi y z x form tripl within henc z would lie child root thu case ff fi cluster child root case ff occur one child root one child root follow lemma show lemma let tree leaf set s let ff ff k cluster defin children root l cluster defin children root case ff occur one one j proof suppos not let ff ff fi j sinc ff impli contradict sinc fi j fi j cluster defin children root henc disjoint case ff handl follow identifi lca say u speci similarli lca say v speci gamma fi clearli u descend node defin fi v descend node defin ff node path in start node defin fi end node u let cluster defin children not path node path similarili identifi cluster defin children node path in start node defin ff node v union pair x y whenev x lie ff fl whenev lie get partit compon turn exactli cluster present children root character highlevel descript algorithm construct given follow rdlc construct algorithm pair maxim cluster ff recurs comput tree ff fi make root child root cluster ff fi ff comput partit recurs comput tree compon partit make root tree children root run time analysi note algorithm requir explicit verif construct tree sinc fact know tree exist simpli comput mimick effici algorithm would creat n recurs stage show stage implement prove on bound case handl on time follow build graph vertic label speci ff fi connect vertic ff fl path j vertic find connect compon graph on time connect compon comp find homeomorph subtre whose leaf set comp recurs subtre task common case describ discuss case handl case import wast time empti intersect consid speci turn label intersect speci lie in thu identifi n nonempti intersect let ff fi one intersect need find homeomorph subtre ff fi leaf set show time proport number leav ff fi assum preprocess least common ancestor queri also note know lefttoright order leav well given leav lefttoright order also known one induc overal lefttoright order lemma reconstruct topolog tree linear time exactli need show one stage recurs accomplish on time overal time algorithm on clearli case handl linear time occur one pair children polynomi time algorithm arbitrari local consensu rule show section polynomi time algorithm construct local consensu tree begin discuss case f partial local consensu function lemma aho et al let multiset k root tripl leaf set s n determin okn log n time tree exist jt homeomorph a algorithm given problem address case tripl resolv case faster algorithm obtain lemma henzing king warnow let multiset k resolv root tripl leaf set s n determin minfok whether tree exist jfa b cg homeomorph root tripl if tripl exist a theorem let f arbitrari partial local consensu function set k evolutionari tree s determin local consensu tree exist construct okn time proof given f tripl a determin form f ja for tripl f ja restrict form okn time previou lemma determin partial local consensu tree exist construct doe on time total time therefor bound cost comput tripl partial local consensu tree construct okn total local consensu tree comput even faster lemma kannan lawler warnow given oracl answer queri what form jfa b cg speci set fa b cg construct on tree consist oracl queri if exist orn log n time tree degre bound r theorem let f total local consensu function given set k root tree n speci construct okn time flocal consensu tree f exist f alway return resolv subtre comput f okn log n time proof implement oracl determin form homeomorph subtre f tripl a b c first preprocess tree answer least common ancestor lca queri constant time use then answer queri need ok time need on queri on addit work total cost okn gener case f degre bound r total cost okrn log n f alway return resolv subtre f binari total cost okn log n discuss conclus sever approach taken handl problem resolv multipl solut one approach find maximum subset induc homeomorph subtre subtre call maximum agreement subtre primari disadvantag approach return evolutionari tree entir speci set howev connect problem one local consensu method tree produc relax discord local consensu method contain maximum agreement subtre homeomorph subtre hard see approach take here requir resolut inconsist repres singl evolutionari tree entir speci set classic problem area tree compat problem also call cladist charact compat problem tree compat problem say set tree compat tree exist everi tripl s resolv resolv a problem solv linear time weak approach practic mani data set incompat therefor necessari abl handl case pair tree resolv tripl differ approach type strict consensu median tree problem model state term unroot tree instead cluster charact ie bipartit speci set use repres tree use charact encod consensu tree measur fit input strict consensu seek tree charact appear everi tree input median tree hand defin metric root tree defin cardin symmetr differ charact set given input tree median tree minim p median tree comput polynomi time nice character term charact encod notion relat version local consensu problem relev local consensu tree alway contain least much inform tree work repres paper extend sever direct note local consensu function local consensu tree set k tree comput time polynomi k mani local consensu tree construct okn time r design analysi comput algorithm formal theori consensu median procedur ntree mitochondri dna sequenc primat tempo mode evolut optim algorithm compar tree label leav optim evolutionari tree comparison spars dynam program numer method infer evolutionari tree effici algorithm infer evolutionari tree determin evolutionari tree maximum agreement subtre set evolutionari tree metric effici algorithm fast algorithm construct root tree constraint complex median procedur binari tree comput maximum agreement subtre fast algorithm find nearest common ancestor tr