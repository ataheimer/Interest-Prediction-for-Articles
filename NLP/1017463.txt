t selfstabil clock synchron presenc byzantin fault a initi studi bound clock synchron sever fault model propos lamport melliarsmith realist aspect problem synchron clock presenc fault consid one aspect clock synchron ongo task thu assumpt processor never fail optimist cope realiti suggest selfstabil protocol stabil long enough period less third processor faulti anoth aspect clock valu processor bound singl transient fault may caus clock reach upper bound therefor suggest bound clock wrap around appropriatew present two random selfstabil protocol synchron bound clock presenc byzantin processor failur first protocol assum processor common puls second protocol not new type distribut counter base chines remaind theorem use part first protocol b introduct distribut system often necessari keep logic clock processor synchron system physic clock may drift messag could vari deliveri time moreov processor may faulti mani case type failur predict advanc handl situat worst type failur must consid name byzantin fault lsp presenc byzantin fault processor exhibit arbitrari malici two face behavior problem keep clock synchron presenc byzantin fault extens studi eg hs lm ms dh st wl rsb lamport melliarsmith lm first present problem show f processor suffici toler f byzantin fault necess f processor toler f fault later prove dh weaker fault model call authent byzantin allow protocol toler number faulti processor hs failur model reintegr repair processor possibl less half processor faulti mani protocol problem assum clock initi synchron thu focu keep synchron presenc clock drift problem ensur clock initi synchron address in eg st wl protocol mechan assum allow nonfaulti processor begin protocol within bound time period other mechan essenti process support part tamu engin excel fund nsf presidenti young investig award ccr depart mathemat comput scienc bengurion univers beersheva israel email shlomicsbguacil z depart comput scienc texa am univers colleg station assum wake distinguish initi state uniqu perform initi action includ commun other work weaken assumpt made design clock synchron protocol presenc byzantin fault goal protocol cope sever and realist fault model tradit byzantin fault model lsp initi protocol toler byzantin fault design flight devic need extrem robust devic tradit assumpt could violat reason assum period execut less one third processor faulti happen short period third faulti perhap experi weaker fault byzantin fault happen messag sent nonfaulti processor lost one instant time paper present selfstabil protocol overcom problem temporari violat assumpt view leav system arbitrari initi state protocol resum selfstabil protocol work correctli start initi system state thu even system lose consist due unexpect temporari violat assumpt made eg onethird faulti unexpect messag loss system synchron clock subsequ assumpt hold eg less third experi byzantin fault origin dijkstra defin in dij protocol selfstabil if start arbitrari system state system converg consist global state realiz task selfstabil protocol resili transient fault fault caus state processor chang arbitrarili new state processor resum oper accord program perman fault fault caus processor perman misbehav protocol toler hybrid fault resili transient perman fault eg dw gp consid nap omiss fault respect interest clock synchron protocol toler hybrid fault work arbitrari initi configur toler less third processor exhibit perman byzantin fault realist assumpt clock synchron protocol bit clock unbound possibl applic howev context selfstabil protocol transient fault could caus system reach upper bound clock onc thu anoth aspect problem consid fact clock bound paper present two random selfstabil clock synchron protocol work presenc byzantin fault protocol work bound clock first assum exist common puls second make assumpt expect stabil time protocol exponenti n drawback number processor larg howev addit theoret interest believ protocol could practic interest least number backup processor small one contribut paper interest usag chines remaind theorem implement distribut counter counter use acceler first protocol remaind paper organ follow next section formal assumpt requir protocol section present clock synchron protocol assumpt common puls section present protocol assum exist common puls conclus section distribut system consist set processor commun send messag other messag bound delay processor bound physic clock constantli incr ment wrap around appropri physic clock differ processor run approxim rate processor also bound logic clock comput function current state physic clock valu goal logic clock nonfaulti processor becom subsequ remain close other continu progress reason rate wrap around appropri consid two type time behavior system synchron semisynchron model processor take step either receiv messag physic clock reach predetermin valu addit synchron model common puls period occur simultan processor caus take step proceed formal processor p model state machin associ processor physic clock take integr valu pc gamma pc state contain distinguish timer variabl take valu pc gamma nil indic processor want take step next time physic clock given valu transit take current state processor current valu physic clock messag receiv if ani produc new state processor set messag sent messag system hold messag sent yet receiv configur system set processor state one per processor set physic clock valu one per processor state messag system execut altern sequenc configur event c delta semisynchron execut event happen real time take one configur next two type event one type tick processor physic clock caus increas mod noth els chang requir real time elaps two success tick processor fix ae type event step processor processor take one step real time step processor may may receiv messag real time elaps send receiv messag must rang d gamma ffl ffl fix ffl fix set faulti processor size f n f processor take step nonfaulti succeed configur must correctli reflect processor transit function act messag receiv state physic clock preced configur thu chang processor state messag system remov messag receiv ad messag sent processor take step faulti chang state arbitrarili add arbitrari messag from itself messag system synchron execut addit constraint exist valu that i everi processor p receiv special puls messag from dummi processor time delta ie processor take step puls puls occur regularli period requir everi processor p exist function clock that given state p valu p s physic clock return valu rang lc gamma fix lc logic clock p given particular execut c denot clock t valu function clock appli p s state physic clock valu c j j configur execut whose real time occurr largest exceed t requir exist finit time follow two condit hold clock agreement exist nonfaulti processor p clock valid exist delta exist real time i clock constant chosen conveni constant larger suffici note constant condit hold arbitrari configur sinc everi two clock valu lc apart clock agreement state differ two nonfaulti processor clock fl clock valid state amount logic clock time elaps delta real time linear function delta synchron protocol first describ protocol synchron system nonfaulti processor access period common puls puls trigger processor synchron clock time two success puls appear import paramet problem case two success puls farther apart time requir run byzantin agreement protocol follow scheme solv problem everi puls start new version byzantin agreement agre common clock valu howev puls order round trip messag delay apart scheme cannot work assum puls order round trip delay apart recal time two success puls nonfaulti processor send messag updat logic clock puls occur assum long enough puls take place messag sent nonfaulti processor previou puls present system whenev nonfaulti processor p trigger puls p send messag clock valu neighbor p wait receiv clock valu processor p wait period ffl longer bound messag delay account clock drift period p receiv one messag neighbor say q p use latest valu arriv q thu end period p set least n gamma f logic clock valu one valu nonfaulti processor includ p p use set logic clock receiv order choos clock valu formal descript protocol appear figur describ protocol inform protocol processor p work follow valu p s clock appear less set receiv logic clock p assign clock otherwis case valu p s clock appear least n gamma f time distinguish case p s clock valu equal case equal case p increment clock modulo number clock valu lc case subdivid two case accord state p previou puls p increment clock and result case otherwis case p increment clock to case p toss coin assign result clock protocol guarante with probabl system eventu reach global state nonfaulti processor clock valu global state reach clock synchron everi puls everi nonfaulti processor p receiv messag least processor contain clock valu ident clock valu moreov puls nonfaulti processor set clock alway follow puls everi nonfaulti processor increment clock valu set thu case appli main idea protocol ensur enough nonfaulti processor clock valu valu increment prove sequel puls one clock valu nonfaulti processor increment rest valu chang zero ensur first puls set clock valu nonfaulti processor contain two element moreov two element inde exist one first glanc seem suffici coin toss need valu increment eventu wrap around time clock nonfaulti processor howev describ infinit execut e use coin toss clock never becom synchron consid system four processor p p exhibit byzantin behavior let clock valu p respect first configur e first puls p send clock valu p p clock valu p thu p receiv clock valu vector receiv processor find processor clock valu name clock valu increment clock valu one to time p p find two clock valu valu two valu assign clock henc configur clock valu respect obtain p continu send clock valu receiv clock valu vector receiv receiv similarli p processor find processor clock valu assign clock p assign reach configur clock valu ident clock valu first configur therefor infinit execut nonfaulti processor never agre clock valu possibl overcom problem use coin toss puls nonfaulti processor clock valu clock valu valu processor toss coin decid whether assign clock lead possibl scenario that probabl occur coin toss result caus nonfaulti processor simultan assign clock puls occur broadcast clock collect clock valu elaps physic clock case last increment els case clock case last increment trueg els case last increment els case clock toss last increment true els last increment fals figur synchron protocol p correct proof synchron protocol throughout proof say processor p increment clock certain puls p assign last increment true puls otherwis say assign clock lemma nonfaulti processor p p j increment clock puls p immedi p clock proof assum toward contradict clock p henc p p find least n gamma f clock valu equal x least n gamma f belong nonfaulti processor thu p j also receiv n gamma f clock valu equal x henc p j receiv clock valu equal y sinc n f hold contradict possibl p j receiv least n gamma f clock valu equal y lemma impli straightforward manner correct next two corollari corollari everi puls set clock valu nonfaulti processor contain two element case two valu one corollari puls p nonfaulti processor p increment clock valu result immedi follow p clock valu nonfaulti processor puls p follow first puls nonfaulti processor p increment clock without toss coin p nonfaulti processor clock valu proof variabl last increment assign everi puls thu sinc p follow first puls inde increment q puls p thu lemma nonfaulti processor clock valu q p next theorem use schedulerluck game dim dim analyz random pro tocol schedulerluck game two competitor schedul adversari luck goal schedul prevent protocol reach safe configur goal luck help protocol reach safe configur synchron protocol configur safe nonfaulti processor logic clock equal last increment true system schedul choos messag delay clock drift execut within predefin limit time processor activ schedul toss coin luck may interven determin result coin toss prove dim dim if start possibl configur c luck strategi win schedulerluck game within intervent expect time t system reach safe configur within expect time main observ use proof fact coin toss result differ desir result accord luck strategi configur reach new game begin theorem expect lc delta ngammaf puls system reach configur valu everi nonfaulti processor clock proof proof use lemma dim theorem dim present strategi luck win schedulerluck game n gamma f intervent within lc time strategi luck wait first puls elaps thereaft luck wait till puls p nonfaulti processor clock valu receiv clock valu occur within next lc puls if occur then least one nonfaulti processor assign clock success puls imposs case puls nonfaulti processor either toss coin assign without toss luck interven n gamma f time fix coin toss result nonfaulti processor otherwis nonfaulti processor p neither toss coin assign without toss luck interven fix coin toss result less f note p p s clock equal thu processor assign without toss coin lemma fact nonfaulti processor toss coin p hold follow p clock valu nonfaulti processor therefor next puls case reach luck could interven fix n gamma f coin toss result ensur desir global state reach theorem system reach configur valu everi nonfaulti processor clock expect time lc delta ngammaf easi see success puls nonfaulti processor clock valu thu clock agreement requir hold clock nonfaulti processor increment everi puls puls constant time apart clock valid requir also hold note clock valu could multipli if known time differ two success puls order yield clock valu reflect real time otherwis valu clock valid requir encod acceler protocol protocol converg expect puls certainli time complex protocol cannot use practic howev lc n f small expect number puls requir reason small instanc expect number puls use observ acceler protocol achiev synchron clock valu rang expect number puls less synchron occur within expect number puls less defin chines remaind counter use chines remaind theorem appear kn p theorem let r posit integ rel prime pair ie r integ exactli one integ u satisfi condit u m u j u use theorem case let p j seri prime number jth prime delta run j parallel version protocol ith version run protocol lc messag carri valu j clock one clock valu version comput new clock valu version use valu receiv particular version independ comput version thu ith version converg within expect puls therefor expect time version synchron less p upper bound expect sinc correspond scenario version start synchron everi appli chines remaind theorem show everi combin valu map one one number rang wellknown techniqu could use order convert represent map eg garner method cf p kn chines remaind theorem could use implement distribut counter base number present method suggest st one possibl use memori commun effici distribut counter let dc distribut counter maintain set processor trigger common puls increment counter mod p everi trigger need store entir bit clock send messag indic carri when counter wrap around thu counter increment commun processor need valu counter scan commun requir semisynchron protocol section drop assumpt common puls present selfstabil random protocol semisynchron system due space constraint formal descript protocol full correct proof exclud section reason think n f small singl processor effici comput task addit processor ad ensur reliabl let reliabl fn ratio number faulti processor total number processor reach reliabl number processor need and thu gener term blowup hardwar cost four improv reliabl blowup would asymptot need infinit blowup reach reliabl thu devic would use rel small number processor protocol stabil rel short time protocol use faulttoler averag function first introduc dl solv approxim agreement later use clock synchron wl given multiset valu processor appli function discard f highest f lowest valu take midpoint remain valu shown function use context protocol dl wl approxim halv rang valu held nonfaulti processor situat bound clock notion highest lowest must appropri modifi real difficulti directli appli previou result analysi show rang cut half depend nonfaulti processor work approxim multiset round multiset differ arbitrarili valu correspond faulti processor valu correspond nonfaulti processor must close allow error introduc clock drift uncertain messag delay round structur achiev action processor roughli synchron time wl protocol due assumpt initi synchron distinguish initi state sinc protocol selfstabil cannot reli either assumpt thu use faulttoler averag function obviou manner processor start arbitrari inform collect clock valu arbitrari time would ensur function appli processor round instanc p could appli function multiset subsequ q could appli function multiset reflect p s new valu instead p s old valu achiev sort approxim round appli faulttoler averag function first use random bring clock valu nonfaulti processor close other achiev nonfaulti processor collect approxim multiset nonfaulti processor stage midpoint averag function shown cf wl approxim halv nonfaulti clock valu thu overcom ongo effect clock drift uncertainti messag delay describ protocol processor p two synchron procedur first call averag procedur second jump procedur averag procedur execut valu clock rang greater smaller ffi time elaps sinc previou time clock valu rang jump procedur execut j time elaps sinc previou execut jump procedur p current rang dedic execut averag function p measur j use physic clock roughli speak jump procedur caus clock nonfaulti processor within small rang averag procedur keep clock nonfaulti processor small rang approxim halv rang time clock valu wrap around synchron procedur processor p start request clock valu execut averag procedur processor measur d order make sure request clock valu arriv destin respons return proce decid new clock valu thu execut averag procedur take period time defin symmetr clock clock clock procedur p find clock valu within small rang ffi clock p elimin f valu side symmetr clock valu then jump procedur p choos one clock valu random reduc clock valu list averag procedur p choos midpoint reduc clock valu list procedur less processor found within ffi clock p choos randomli one clock valu instanc collect valu symmetr clock valu elimin correct proof sketch semisynchron protocol period time jump period nonfaulti processor execut averag procedur period choos n gamma ft j next lemma prove choic yield exist period length ae jump period lemma everi time jump period least j long proof processor measur time use physic clock whose drift rate real time ae thu processor measur period time physic clock real time elaps measur least t ae t ae way chosen everi period length processor execut averag function onc processor measur d make sure request clock valu arriv destin respons arriv decid new clock valu thu time averag function execut processor period ae henc total time averag processor period n gamma ft j ae ae therefor total non averag time least n gamma ae pigeon hole principl least one jump period length safe configur system configur nonfaulti processor clock within ffi other moreov case processor middl collect clock valu clock valu transit sent nonfaulti processor within rang too use follow assumpt correct proof assumpt assumpt n lemma jump period length j ae probabl least n ngammaf system reach safe configur sketch proof prove lemma present sequenc random choic result forc system reach configur clock nonfaulti processor less ffi apart sequenc random choic result probabl least n ngammaf occur let c configur begin jump period without loss gener assum number faulti processor f maxim possibl violat inequ n f let c first configur choos period everi nonfaulti processor p luck count number nonfaulti processor clock within clock configur c nonfaulti processor least clock valu call anchor claim anchor processor r apart assum toward contradict two nonfaulti anchor processor p q clock valu r apart thu p surround processor q surround differ nonfaulti case fewer faulti processor one could assum nonfaulti processor onli behav like nonfaulti processor processor therefor total number nonfaulti processor least n gamma contradict note possibl anchor processor exist case luck choos one nonfaulti processor anchor processor luck choos singl anchor processor anchor processor everi nonfaulti processor execut jump procedur twice luck use follow strategi everi time processor p j choos clock valu valu clock possibl choic ie either find reduc clock valu list valu chosen otherwis valu clock j chang let c first configur reach c processor execut jump procedur least twice result accord strategi luck let e execut start c end c sinc jump period everi nonfaulti processor choos clock valu least everi period length occur c show c nonfaulti processor within r other first show nonanchor processor p assign valu as clock p s clock either first execut jump procedur second one everi processor collect clock valu everi execut jump procedur particular nonanchor processor p j receiv valu clock second execut jump procedur next show that second execut jump procedur p j choos valu as clock choic p j restrict subset clock valu p j read p j find valu within ffi rang clock j sinc p j nonanchor processor hold c less processor within ffi rang clock j moreov nonfaulti processor assign clock valu within rang clock j sinc everi nonfaulti processor p k chang clock valu use jump procedur assign clock valu with ffl rang clock a everi nonfaulti processor p k chang clock valu use jump procedur rate drift clock p j ae thu differ clock j clock k shorten j r c p j cannot consid p k clock ffi rang clock j assign clock j valu clock a prove c nonanchor processor within ffl ae as clock anchor processor assign clock valu clock r apart c thu r fact nonfaulti processor within small rang use defin new anchor processor nonfaulti processor left remov f nonfaulti processor highest clock valu mod lc f nonfaulti processor smallest valu mod lc from c everi processor execut jump procedur least twice luck continu follow processor p process collect clock valu c chang clock first execut jump procedur execut jump function luck interven fix result clock clock processor alreadi set clock valu s clock sinc c prove possibl result jump function obviou processor find processor within ffi clock sinc choic restrict also clear first set processor execut jump procedur use clock valu c base decis new clock valu moreov sinc luck interven fix result valu clock reduc list everi processor use new clock valu includ either clock clock processor assign clock clock henc first configur c follow first two execut jump function processor follow c nonfaulti processor within n aeae other which assumpt less ffi follow c processor wait answer process collect clock chang clock valu thu d safe configur reach length execut j reach j c addit configur reach thu safe configur reach follow ae c assumpt ae thu processor could choos six time rang thu total number intervent lemma configur execut start safe configur clock valu nonfaulti processor within ffi other main observ made proof lemma start safe configur everi processor either execut jump averag procedur find clock valu within ffi clock valu thu new clock valu chosen jump averag rang clock valu nonfaulti processor averag procedur approxim halv rang clock valu nonfaulti processor whenev pass zero clock valu theorem expect ot n ngammaf stabil conclud remark extens research done find effici clock synchron protocol presenc byzantin fault work consid sever and realist model fault ie one take account transient fault well byzantin fault arbitrari corrupt state possibl often case transient fault longer reason approxim unbound clock bound clock matter larg consequ clock take bound number valu and wrap around appropri assum paper present two random selfstabil protocol synchron bound clock presenc f byzantin processor failur n f believ observ definit type fault consid type clock name bound reflect realiti open new direct research protocol design fault toler model robust exist clock synchron protocol therefor protocol might prefer system implement protocol cope byzantin fault acknowledg mani thank brian coan injong rhee swami natarajan help discuss r self stabil system spite distribut control on possibl imposs achiev clock synchron uniform dynam self stabil leader elect analyz expect time schedulerluck game reach approxim agreement presenc fault waitfre clock synchron unifi selfstabil faulttoler faulttoler clock synchron art comput program synchron clock presenc fault the byzantin gener problem inexact agreement accuraci precis grace degrad faulttoler clock synchron distribut system optim clock synchron residu arithmet applic comput technolog a new faulttoler algorithm clock synchron tr synchron clock presenc fault reach approxim agreement presenc fault possibl imposs achiev clock synchron optim clock synchron new faulttoler algorithm clock synchron faulttoler clock synchron distribut system waitfre clock synchron unifi selfstabil faulttoler art comput program volum rd ed inexact agreement byzantin gener problem selfstabil system spite distribut control analyz expect time schedulerluck game uniform dynam selfstabil leader elect extend absrtact faulttoler clock synchron ctr ariel daliot danni dolev selfstabil byzantin agreement proceed twentyfifth annual acm symposium principl distribut comput juli denver colorado usa