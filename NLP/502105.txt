t improv implement binari univers oper a present algorithm implement binari oper of type unari loadlink ll storecondit sc oper perform algorithm evalu accord sensit measur distanc oper graph induc conflict guarante influenc step complex other sensit implement ologast n n number processor system is oper logast n apart graph induc conflict delay other constant sensit achiev oper use implement heap arraybas link listsw also prove problem solv o step use binari llsc oper requir olog logast n oper unari llsc oper use indic nonconst gap unari binari llsc oper b introduct algorithm nonblock processor delay processor make progress nonblock algorithm avoid perform bottleneck due processor failur delay asynchron share memori system nonblock algorithm requir use univers oper loadlink ll storecondit sc eas program conveni write nonblock algorithm use univers oper access sever memori word atom howev exist commerci architectur provid unari oper access singl memori word multiword oper implement use unari univers oper eg implement effici effici implement evalu isol ie interfer oper contend memori word howev provid indic implement behavior presenc content ie oper compet access memori word clearli hot spot ie memori word content high implement oper tri access word delay long time one even argu case oper delay even support hardwar howev hot spot delay far away oper paper propos evalu implement sensit measur distanc hot spot influenc perform oper roughli state sensit longest distanc one oper anoth oper influenc perform eg chang number step need order complet oper concentr implement binari oper unari llsc binari oper induc conflict graph node repres memori word edg two memori word belong data set oper ie pair memori word access oper hot spot correspond node high degre requir two oper whose distanc conflict graph larger sensit interfer is step complex whether execut parallel not present algorithm implement arbitrari binari oper unari sc oper sensit olog n algorithm use llsc conveni sinc support sever contemporari architectur eg algorithm extend reli unari univers oper particular o implement llsc compareswap employ core algorithm implement binari oper manner similar known algorithm processor lock word data set binari oper appli oper unlock data set oper help complet thu ensur algorithm block new featur algorithm processor may lock data set two directionseith start lowaddress word start highaddress word sensit core algorithm depend orient conflict graph accord lock direct two common data structuresan arraybas link list heapw priori determin lock direct induc constant sensit gener howev processor dynam decid lock direct achiev encapsul core algorithm decis algorithm coordin order processor lock data set lowaddress word first highaddress word first first present decis algorithm base determinist coin toss techniqu cole vishkin simplifi case conflict graph path then show synchron method break conflict graph arbitrari topolog path adapt determinist coin toss techniqu appli combin previou algorithm implement arbitrari binari oper unari llsc olog n sensit also show problem solv o step use binari llsc oper requir olog log n step unari oper of type use proof adapt lower bound linial show messag pass model maxim independ set nring found less omegagammaan n round lower bound indic implement binari llsc unari oper incur nonconst overhead follow origin public work afek merritt taubenfeld touitou present algorithm implement kword object unari oper ation algorithm waitfre guarante everi oper eventu termin algorithm use algorithm idea implement addit employ base case recurs construct herlihi moss introduc transact memori hardwarebas scheme implement arbitrari multiword oper three scheme present softwar implement transact memori singleword atom oper isra rappoport shavit touitou present nonblock implement arbitrari multiword oper use unari llsc anderson moir give waitfre implement kcompareswap ksc shavit touitou present simul result indic algorithm perform well practic isra rappoport analyz step complex oper anderson moir measur step complex kcompareswap ksc oper analysi three implement show sensit content distant oper exampl two oper execut two end link list increas other step complex turek shasha prakash show gener method transform concurr implement data structur nonblock one method employ compareswap process block due lock held anoth process help block process releas lock help continu recurs block process also block anoth process barn present gener method construct nonblock implement concurr data structur method word need oper cach privat memori thu oper access data structur concurr contend method similar softwar transact memori sensit high algorithm use help decreas sensit increas parallel minim distanc oper help herlihi introduc gener method convert sequenti data structur share waitfre one herlihi method extens suggest alemani felten allow parallel concurr oper inher sequenti anderson moir present univers construct allow oper access multipl object atom implement use multiword oper employ effici implement certain larg share object save copi allow parallel nonblock implement multiword oper induc solut wellknown resourcealloc problem solut short wait chain small failur local addit discuss relat two problem appear preliminari asynchron sharedmemori model sharedmemori model processor commun appli memori access oper in short oper set memori word processor p model possibl infinit state machin state set q contain distinguish initi state q i configur vector local state processor valu memori word j initi configur processor local initi state memori word contain default valu oper type defin number input output argument allow valu function depend input sharedmemori state processor state one hand output argument new state processor memori hand oper instanc oper type data set oper set memori word access exampl unari sc defin follow return valu scm new write success sc sinc previou llm new return success els return failur event comput step singl processor denot index processor event processor determin memori oper perform accord local state determin next local state accord valu return oper oper atom is oper seem occur certain point two oper occur point therefor comput system captur sequenc configur configur obtain previou one event singl processor detail execut segment ff finit infinit sequenc everi configur oe k event applic oe k result c k is oe result appli p s transit function p s state c k appli p s memori access oper memori c k execut execut segment c c initi configur constraint interleav event differ processor manifest assumpt processor asynchron bound rel speed implement highlevel oper type h lowlevel oper type l procedur use oper l intuit processor distinguish h implement l assum processor p invok procedur implement oper op termin let oe f oe l first last event respect execut processor p procedur op interv op execut segment oper termin interv infinit execut segment two oper overlap interv overlap invoc oper may result differ interv depend context execut exampl two interv oper may differ even return differ valu first execut isol second overlap oper let ff interv p step complex ff denot stepff number event p ff op op figur simpl conflict graph execut fi lineariz total order implement oper fi preserv order nonoverlap oper respons satisfi semant h given respons previou oper total order implement nonblock point processor pend oper complet within bound number step sensit conflict graph execut segment ff repres depend data set oper ff undirect graph denot g ff node g ff repres memori word edg two node j correspond oper data set fm whose interv overlap ff g ff may contain parallel edg ff contain sever oper data set exampl let ff finit interv oper opm overlap show g ff next consid conflict graph interv oper op measur distanc edg repres op oper delay execut op maximum distanc measur interv implement determin sensit detail assum ff interv oper op let op oper op connect compon g ff distanc op op ff number edg shortest path g ff whose endpoint edg repres op op intuit sensit measur minimum distanc guarante two oper interfer other below say oper op interfer oper op step complex op same whether op execut parallel not definit modifi sensit depend complex measur eg set memori word access earlier version work defin content graph execut node repres oper edg repres memori word data set dual conflict graph content graph captur depend oper somewhat accur conflict graph easier work with interv ff oper op sensit distanc interv ff op exactli one oper ie edg g ff distanc edg repres op is step complex op increas singl oper ad ff distanc op sensit interv ff maximum ff sensit distanc s mean step complex op increas singl oper ad ff distanc maximum exist sensit sensit implement maximum sensit interv sensit captur noninterfer oper follow sens sensit implement distanc two oper conflict graph s step complex or measur consid oper whether execut parallel not relat complex measur disjointaccess parallel requir oper complet constant number step oper contend memori word sensit strengthen notion allow evalu behavior implement also presenc content afek et al suggest two complex measur algorithm dlocal step complex number step perform interv ff bound function number oper within distanc g ff algorithm dlocal content two oper access memori word distanc conflict graph joint interv d clearli sensit d impli dlocal step complex howev convers true exampl suppos data set oper op contain hot spot m access oper suppos also path oper length sensit allow oper path influenc op perform local step complex op may still help distant oper path local content orthogon sensit local step complex evalu addit either them howev oper access memori word associ oper help dlocal content follow sensit the content local algorithm discuss end section dwork herlihi waart suggest measur step complex algorithm take content account assum concurr access memori word penal delay respons good complex measur evalu solut specif problem howev implement multiword oper inevit result concurr access word creat hot spot complex measur propos sensit appropri evalu multiword implement measur influenc hot spot leftright algorithm gener scheme implement multiword oper oper lock pair memori word execut oper help stuck oper avoid block section introduc variant scheme leftright algorithm oper lock memori word differ order show sensit live leftright algorithm depend orient conflict graph induc lock order overlap oper end section discuss data structur oper inher asymmetri data structur leftright algorithm directli appli achiev constant sensit next section show break symmetri gener situat govern lock direct reduc sensit overview known scheme implement multiword oper unari oper requir processor go follow stage lock lock memori word execut appli oper memori word unlock unlock memori word oper assign uniqu identifi memori word lock oper oper id written word word unlock contain memori word lock oper oper modifi memori word unlock oper block find word need lock anoth block oper case processor execut block oper help block oper figur scenario high sensit order help oper detail publish invok state maintain execut help impli one processor may execut oper initi processor processor invok oper execut processor processor help complet although one processor perform oper advanc processor point execut perform oper execut processor effect block oper help either lock stage alreadi execut stage unlock stage oper execut unlock stage alreadi lock word oper lock data set never block again therefor oper help block oper pass lock stage guarante block contrast oper still lock stage block third oper turn block fourth oper on therefor help block oper lock stage may continu transit nonblock implement guarante oper eventu termin transit help stop yet sensit high illustr next exampl exampl consid scenario n overlap oper op data set op fm assum everi oper op lock lowaddress word tri lock highaddress word op delay lock op op help op sinc highaddress word op lock recurs help op etc thu sensit simpl implement least n gamma exampl oper symmetr tri lock memori word order lowaddress word first main idea leftright algorithm implement oper binari asymmetri introduc oper lock memori word two direct either left rightlowaddress word first right lefthighaddress word first exampl consid exampl again assum oddnumb oper op lock lowaddress word first evennumb oper op address word first op for odd i lock lowaddress word find highaddress lock anoth oper which must op i op i alreadi lock data set therefor op help op i execut unlock stage oper oper decid lock direct lock stage oper termin unlock stage reset sharedmemori area use decis algorithm thu two new stage decis postdecis encapsul algorithm section focu lock unlock stage leav decis postdecis stage algorithm next section pseudocod simplifi code descript separ sharedmemori area use lock unlock stage size area size data area memori word lock area correspond memori word data area algorithm use share array opdetail initi processor publish oper descript oper start initi processor also set oper id opid use later stage opid compos id initi processor timestamp gener timestamp function return uniqu id time invok algorithm follow gener scheme discuss earlier except lock done either left right right left oper discov word lock anoth oper help block oper execut stage unlock word then oper tri again pseudocod appear algorithm lock unlock stage execut sever processor behalf oper therefor synchron need ensur error caus concurr processor execut oper algorithm present detail share procedur use lock unlock user respons avoid synchron error execut stage local variabl tmp use procedur hold last valu read share memori main synchron mechanismguarante advanc execut processor actual make progressi timestamp part oper id field written initi processor begin oper clear begin unlock stage oper valid timestamp set invalid timestamp set execut processor find oper invalid it timestamp set skip directli unlock stage ensur memori word unlock oper lock oper similar consider appli unlock word memori word initi lock oper contain id procedur lock lock two memori word order given paramet singl memori word lock celllock attempt lock word oper algorithm leftright algorithm code processor p record lowword highword data set ts timestamp direct lock direct share state opdetailsn procedur atom write opdetailsi publish ts decidem decid lock direct helpopid help procedur helpopid lock stage opdetailsopidpiddirect left locklow high opid left right els lockhigh left opid right left executionlow high opid execut stage unlocklow high opid unlock stage postdecisionlow high opid clean memori still valid word lock anoth oper procedur reread word word lock oper procedur return true word lock anoth oper execut processor help block oper tri again oper becom invalid procedur return fals help anoth oper block oper invok help block opera tion id argument block oper becom execut processor block oper goe stage procedur unlock invalid oper reset ts field prevent execut processor lock word again then unlock two memori word cellunlock unlock singl word still lock oper success sc check fail word alreadi unlock anoth execut processor procedur valid compar timestamp pass oper id timestamp ts field oper entri opdetail oper valid equal algorithm leftright algorithm share procedur processor p procedur lockx y opid celllockx opid celllocki opid procedur celllockaddr opid tri lock lock tmp opid return true els helptmp validateopid return fals check oper end procedur validateop opdetailsoppidt opt return true els return fals procedur unlockx y opid invalid oper cellunlockx opid unlock word cellunlocki opid procedur cellunlockaddr opid procedur decidem function decid make sure first execut processor return decis which left unspecifi now write decis oper detail mention befor respons user avoid synchron error execut stage user use timestamp oper may add state inform necessari exampl implement oper sc need check write oper still valid manner similar celllock function need point decis stage execut initi processor proof correct proof algorithm lineariz follow gener scheme eg lock unlock shown behav correctli thu show data set oper lock execut stage unlock oper termin execut processor return celllock either memori word lock oper oper invalid oper becom invalid execut processor reach unlock stage previous complet lock stage therefor first execut processor return celllock word lock oper prove next lemma lemma data set oper op lock first execut processor op complet lock stage procedur cellunlock check word first thu word unlock execut processor oper lock it impli follow lemma lemma data set oper op remain lock first execut processor op reach unlock stage next lemma prove execut processor unlock memori word execut processor lock again lemma data set oper op remain unlock first execut processor op reach unlock stage proof execut processor op start unlock stage initi timestamp field opdetail thu invalid op perform llm scm anoth execut processor op tri lock afterward valid op perform llm find oper valid valu read execut processor tri lock again thu lock field lock word written order unlock it impli two thing first sc cellunlock fail anoth execut processor unlock m second execut processor lock again progress sensit live properti algorithm sensit depend orient conflict graph accord lock direct figur reduc sensit help direct let ff interv oper op help graph ff h ff mix graph repres help among oper overlap ff node h ff memori word access oper overlap ff edg e node constitut data set oper ff direct e oper ff data set fm direct e oper ff data set fm otherwis e undirect h ff partial orient version g ff conflict graph ff lemma let fi execut leftright algorithm oper complet help graph interv fi contain either undirect edg direct cycl proof must point fi oper complet let ff interv block oper op fi leftright algorithm op block lock data set sinc op termin block oper block anoth block oper sinc number processor finit processor one pend oper number block oper fi also finit therefor cycl block oper op algorithm block oper help block oper two oper block help other impli data set lock differ direct undirect edg h ff l three oper block help other direct cycl h ff next analyz sensit algorithm consid two oper op data set fm op data set fm g assum help graph edg direct edg also direct see figur op help op code celllock lock op howev op lock lock pass lock stage thu op help op execut unlock stage argument gener next lemma lemma let ff interv oper op let op j overlap oper direct path memori word op memori word op j h ff exist anoth interv op ff overlap oper except op j proof let op set oper op help direct path op oper op impli direct path memori word oper op memori word op j h ff sinc direct path memori word op memori word op j h ff thu oper op help op j argu lemma construct execut ff without op j ff op perform sequenc step ff moreov oper op lock word order ff ff execut leftright algorithm let op k first oper op lock word ff ff algorithm happen anoth oper hold lock word howev add new oper ff onli omit op j sequenc lock op k s lock ff ff thu word unlock ff also unlock ff op k succe lock word perform sequenc step ff ff length direct path h ff bound d oper distanc d or more increas number step taken oper lemma lemma let ff interv leftright algorithm length direct path h ff d sensit ff data structur constant sensit discuss two data structur memori access pattern oper structur therefor lock direct determin priori obtain constant sensit link list link list implement insid array data set oper i i let lock direct oper determin pariti lowaddress word is lock direct oper access i left even right odd clearli neighbor oper conflict graph lock opposit direct therefor maximum length direct path one lemma implement nonblock lemma sensit two v v b figur binari oper heap v g even depth heap isra rappoport present implement heap support bubbl bubbl use unari binari sc oper implement data set binari oper alway parent node one children order implement binari oper use leftright algorithm let lock direct oper pariti depth higher node lock clearli oper data set lock direct see length direct path two let v g v f v v b four node heap v g parent node v f v f parent node v v b see figur two kind path form contend oper first kind depth monoton eg case neighbor oper lock opposit direct henc direct path v v g v b v g form second kind depth monoton eg case neighbor oper lock direct determin depth v f direct path form v v b therefor longest direct path length one lemma algorithm nonblock lemma sensit two decis algorithm access pattern known advanc processor dynam decid lock direct section present algorithm choos lock direct gather inform memori access pattern minim sensit simplic separ sharedmemori area use decis stage size area size lock area or data area memori word decis area correspond word lock data area op op figur lock direct highaddress word equal lowaddress word op op figur lock direct lowaddress word equal consid simpl exampl data set op fm data set op assum data set intersect the highaddress word op lowaddress word op lock direct op op differ order avoid direct path see figur the lowaddress word op lowaddress word op lock direct op op equal order avoid direct path see figur similarli the highaddress word op highaddress word op exampl lead us concentr monoton path highaddress word one oper lowaddress word anoth oper as figur situat want neighbor oper lock differ direct as much possibl first describ algorithm restrict case singl monoton path handl gener case decompos arbitrari conflict graph monoton path monoton path oper op initi processor id pid data set op oper lower indic op call downstream neighbor oper higher indic op call upstream neighbor thi situat similar one depict figur assum oper choos lock direct accord follow rule smaller pid upstream neighbor pid i op decid left otherwis op decid right edg oper upstream neighbor decid left rule direct path correspond ascend descend chain pid exampl oper decid left pid appear ascend order key insight length longest chain ascend descend pid depend rang pid rang pid reduc ensur adjac oper differ pid rule guarante short direct path reduc rang pid use determinist coin toss techniqu cole vishkin symmetri break algorithm synchron ring adapt monoton path asynchron system colevishkin algorithm work phase phase rang reduc logarithm factor rang small rang reduc rule appli although new pid uniqu more fact pid adjac oper differ ensur oper decid lock direct see below order perform k rang reduct phase oper know pid k oper oper without k neighbor decid left call edg oper algorithm guarante altern propertyadjac pid equal assum pid phase k rang lg altern properti length ascend descend sequenc pid l howev sinc may chain l oper lock direct monoton path simplifi descript assum a oper start togeth b oper wait lock stage oper finish lock stage later remov assumpt first describ singl phase algorithm reduc rang pid olog n memori oper appli idea repeatedli reduc rang olog n use olog n memori oper singl phase oper begin phase write pid lowaddress word sinc oper start togeth memori word written togeth sinc oper wait oper finish lock stage memori word overwritten oper choos direct pid induc pointer consecut word path pid lowaddress word lead oper detail record highaddress word oper found edg oper may also decid accord pariti distanc end path figur reduct pid singl phase assum op read three pid it pid i i denot respect binari represent processor pid string length dlog ne bit number dlog ne gamma go least signific bit signific bit let j index least signific rightmost bit binari represent pid i pid i repres binari string length dlog log ne concaten binari represent j b j valu jth bit pid i note length pid dlog log ne similar manner op comput pid exampl consid figur exampl pid i pid pid i index rightmost bit differ valu pid i thu pid i index rightmost bit pid i differ valu pid sinc memori word modifi decis stage op op i use pid i impli singl phase consistentth new pid comput oper op equal new pid comput op downstream neighbora state next lemma lemma op op i neighbor oper path calcul valu pid i thu refer pid i without mention processor calcul it describ pid i compos bit part denot pid ibit index part denot pid iindex pid thu pid i pid i bit posit pid contradict fact pid iindex rightmost bit pid i pid i differ prove follow lemma lemma op op i neighbor oper path pid i pid sinc initi pid distinct lemma impli consecut valu pid equal prove altern properti multiphas algorithm describ idea appli repeatedli reduc pid three bit long guarante longest monoton sequenc pid contain eight oper denot n dlog ne let j fn smallest integ j j n note oper start write pid lowaddress word read upstream memori word edg oper without neighbor choos left without calcul let pid read op pid i pid i iter oper comput pid k j pid kgamma j pid everi j singlephas algorithm section lemma immedi impli algorithm consist lemma op op i neighbor oper path calcul valu pid k i everi k altern properti prove induct appli lemma everi iter lemma op op i neighbor oper path pid i pid proof proof induct phase local comput denot k fn base case assumpt induct step assum lemma hold phase k everi consecut pair pid k differ valu sinc iter onephas algorithm lemma impli pid k i pid repres less three bit thu repres three bit howev x show iter pid length strictli reduc fn iter length three show everi valu pid fngamma three bit long thu eight consecut oper ascend descend pid fn valu rang pid reduc oper choos lock direct compar pid pid upstream neighbor follow rule edg oper without neighbor decid left consecut oper decid left eight consecut oper decid right prove follow theorem theorem length direct path gener topolog order appli rang reduct techniqu previou section gener topolog disentangl arbitrari combin overlap contend oper collect monoton path achiev thi oper first check whether data set may creat nonmonoton path doe oper stall help oper otherwis appli algorithm monoton path explain idea further need defin monoton path precis assum memori word l form undirect path conflict graph memori word local minimum local maximum local minimum creat two oper lowaddress word as figur local maximum creat two oper highaddress word path monoton contain local minima maxima decis stage oper preced separ mark stage mark stage oper check memori access pattern tri lock memori word detect local minima maxima avoid nonmonoton path one oper form local minimum local maximum continu other stall mark stage maintain variant conflict graph share memori node mark memori word word either mark low lowaddress word oper mark high highaddress word oper word mark low high lowaddress word one oper high address word anoth oper mark memori word data set oper stall oper start tri mark lowaddress highaddress word mark succe oper data set monoton path oper decid lock direct manner similar section mark fail oper data set creat nonmonoton path oper stall help oper word two special fieldsfor low mark high mark oper mark word write id instead lowhigh field mark fail relev field oper succe mark low field lowaddress word tri mark high field highaddress word oper unmark data set unlock it word cannot mark high twice low twice impli two overlap oper highaddress word lowaddress address word one succe mark word stall consequ local minima maxima avoid nonmonoton path oper mark memori word low even word alreadi mark high anoth oper respect mark differ lock sinc word lock two differ oper mark two differ oper two problem aris due dynam natur conflict new oper join end mark path lock stage start edg oper may help upstream oper find end path increas sensit lock stage oper may unmark data set anoth oper data set may take place yield inconsist downstream oper use first oper pid local comput downstream oper use second oper pid problem handl mechan oper find end path prune path place special end symbol low field last word path oper later mark last word low henc new oper append end path oper unmark data set replac id end low field lowaddress word word mark high ie downstream neighbor way path cut word data set unmark new oper abl mark word confus downstream oper high field unmark low field mark end field clear set pseudocod memori word contain two field mark low high may contain oper id end initi binari intersect field ad record contain oper detail field set oper intersect ie highaddress word alreadi mark high anoth oper part anoth monoton path intersect field clear begin mark stage set oper clear oper termin oper hold local array idarray pid upstream oper collect local comput as monoton path algorithm section tmp variabl contain last valu read low highlevel function function local variabl clear code highlevel procedur decis postdecis stage appear algorithm algorithm detail code synchron access share data structur oper start initi local variabl see code clear intersect field then oper tri mark lowaddress word use first mark fail first oper help oper whose id mark word low word unmark tri again mark succe oper continu advanc next memori word oper extract initi processor id oper id current word read highaddress word record opdetail array next word monoton path oper also store initi processor id idarray local comput oper mark highaddress word use next high low field empti oper tri mark high field word put end mark low field success oper mark end path return left high field empti low field not tri mark high field word success continu upstream word otherwis intersect anoth path oper set intersect flag unmark lowaddress word help oper written high field word start again intersect oper first unmark lowaddress word oper help continu help upstream oper oper op use next access upstream word paramet pass next address last word access op current address op j id oper whose highaddress word is henc op help op j mark highaddress word note op find op j intersect op act discov end path sinc op j go unmark lowaddress word oper unmark lowaddress word unmarklow highaddress word unmarkhigh procedur unmarklow replac id end low field low address word high field lowaddress address word ie downstream neighbor otherwis clear low field algorithm gener algorithm decis postdecis stage local id myopid id oper execut local id lastopid id last oper read local id idarrayfn local comput reduc id local addr current prev current previou address local int index index idarray local addr tmp persist use advanc procedur decisionm opdetailsopidpidintersect lowaddress word advanc next word tmplow tmp set first insid current nextprev current opid return left edg oper return accord local comput idarray monoton path algorithm procedur firstaddr opid repeatedli tri mark lowaddress word marklowaddr opid return els helpaddrlow procedur nextprev addr opid repeatedli tri mark upstream word markendaddr opid return true edg oper markhighaddr opid return fals continu next word path setintersectionaddr opid intersect oper initi processor unmarkwordprev unmark lowaddress word get opid intersect oper restart oper get new timestamp clear intersect flag els return true initi processor validateopid return true edg oper procedur postdecisionm algorithm gener algorithm lowlevel procedur decis stage procedur marklowaddr opid tmplow opid return true mark success els tmplow return fals mark anoth oper procedur markendaddr opid checkintersectionopid intersect scaddropid end mark end tmphigh opid return true mark success els tmphigh return fals mark anoth oper procedur markhighaddr opid checkintersectionopid intersect tmphigh opid return true mark success els tmphigh return fals mark anoth oper procedur checkintersectionopid scopdetailsopidpidintersect tmp touch intersect flag els return fals procedur setintersectionaddr opid scopdetailsopidpidintersect true return opdetailsopidpidintersect algorithm gener algorithm lowlevel procedur postdecis stage procedur unmarklowaddr opid tmplow opid downstream oper end mark low els scaddr els return procedur unmarkhighaddr opid tmphigh opid tmplow end edg oper end mark els scaddr tmplow unmark high field els return proof correct proof correct concentr properti mark stage prove data set oper mark first execut oper enter lock stage unmark first execut processor complet oper oper mark lowaddress word first tri mark highaddress word first call next nonintersect oper return next mark word pass paramet intersect oper restart return next all therefor highaddress word mark first call next return impli next lemma lemma data set oper op mark first execut processor op enter lock stage word unmark postdecis stage reach initi processor find oper intersect in next restart oper impli next lemma lemma data set oper remain mark oper complet next prove data set oper remain unmark oper complet problem may occur execut processor set intersect flag execut processor mark highaddress word setintersect write high markhigh readintersect figur illustr proof lemma case lemma intersect flag oper set highaddress word mark proof three procedur access high fieldmarkend markhigh unmarkhigh procedur unmarkhigh mark unmark word therefor markend markhigh mark previous unmark oper consid markhigh proof appli markend synchron structur let highaddress word oper op consid memori access setintersect markhigh call checkintersect expand setintersect markhigh h scmhigh case suppos mark high mintersect set that is preced h scmhigh markhigh h reach readmintersect markhigh h return henc h preced scmintersect setintersect s sinc llmhigh markhigh h return preced readmhigh setintersect s return non valu see figur therefor interven write mhigh llmhigh match scmhigh markhigh sc fail case suppos mintersect set mark high that is h preced s scmintersect setintersect s succe scmintersect markhigh preced llmintersect setintersect s see figur sinc llmhigh markhigh return readmhigh setintersect s return non valu interven write mhigh llmhigh match scmhigh markhigh sc fail setintersect write high markhigh figur illustr proof lemma case lemma data set oper op remain unmark op termin proof lowaddress word op mark initi processor op processor start execut op thu execut processor op mark unmark prove lemma lowaddress word op assum highaddress word op op termin postdecis stage op invalid it ts field reset data set unmark unmarkword op termin sinc intersect in next intersect flag set oper invalid initi processor lemma memori word mark intersect flag set therefor prove unmark highaddress word mark op invalid markend markhigh mark highaddress word proof lemma consid markhigh assum way contradict markhigh mark unmark op invalid sinc markhigh valid oper mark op invalid valid scmhigh oper markhigh moreov oper markhigh read mlow mhigh lemma mark first execut processor op reach lock stage unmark oper invalid thu mark write mhigh llmhigh match scmhigh markhigh sc fail analysi algorithm lemma monoton path exist lock stage proof data set oper mark first execut process enter lock stage lemma remain mark first execut process complet postdecis stage lemma memori word mark low twice mark high twice differ oper code marklow markhigh markend thu two oper low address highaddress word cannot lock stage togeth is local minima maxima monoton path exist lock stage lemma let op downstream neighbor op i assum op op i decid local comput last fn entri idarray first fn entri idarray i proof lemma data set op op i monoton path op i read differ valu memori word j oper unmark j read j without loss gener let op oper read j unmark argu op j exit edg oper induct distanc conflict graph contradict assumpt op op i decid local comput prove lemma base case distanc data set op op mark j end word op edg oper claim prove anoth oper op mark j end word sinc lowaddress word mark highaddress word also mark op thu op j mark data set therefor stall claim follow induct step assum lemma hold distanc j assum distanc l op read end j op edg oper claim follow sinc j unmark op read it oper op write mark end op it claim follow induct hypothesi otherwis op find op invalid therefor next return true op exist edg oper decis algorithm monoton path gener decis algorithm differ mark phase lemma impli new pid comput oper op equal new pid comput op downstream neighbor sinc algorithm local comput theorem impli lemma length direct path nonedg oper eight end path fn oper edg oper new oper join end path mark low field last word sinc contain end therefor edg oper help oper distanc smaller equal fn lemma edg oper help upstream oper distanc larger theorem sensit decis stage lock stage olog n proof sensit decis stage fn sinc oper advanc fn word path conflict graph contain highaddress word direct path length nine lock stage oper lock right left decid local comput contradict lemma direct path length lock stage oper lock left right edg oper path distanc larger fn end path lemma contradict lemma lemma sensit lock stage fn algorithm guarante local content defin two oper may access entri opdetail differ oper processor although far away conflict graph happen sinc opdetail array index processor id easili fix index opdetail oper id as done step complex implement binari llsc section prove omegagamma log n lower bound number step requir implement binari sc oper use unari oper lower bound prove show problem solv o oper use binari llsc requir omegagammaequ log n oper unari oper of type use separ problem variant maxim independ set mi problem defin follow set n processor organ virtual ring processor assign initi memori word get input address memori word clockwis neighbor next everi processor termin either member nonmemb requir that a two consecut processor member b nonmemb processor least one neighbor halt member problem trivial solv binari synchron oper sc processor loadlink loadlink next tri sc pid atom next p succe exist member otherwis exist nonmemb next show maxim independ set algorithm use unari oper execut processor perform least omegagammaast log n oper linial prove omegagammaat n round requir solv mi problem messagepass model modifi proof sharedmemori model get smaller bound linial use fact messagepass model round t processor know address pid processor distanc it true sharedmemori model assum comput proce round round processor perform singl memori oper processor know address neighbor round round processor access memori word processor distanc k it know address k neighbor howev next lemma prove best may happen lemma round t processor ring know pid address processor distanc itself proof lemma prove induct t round number base case round processor know receiv input is address two word is know address clockwis neighbor induct step assum lemma hold round t prove lemma induct assumpt round processor p know pid address processor distanc it thu round processor p access singl processor distanc it is learn pid address processor know therefor know pid address processor distanc it rest proof close follow linial first argu algorithm find maxim independ set ring convert color algorithm one oper processor decid membership check decis right neighbor decid nonmemb pick color decid member neighbor decid nonmemb pick color otherwis pick color let v set vector v v mutual distinct processor id color algorithm map c v fg construct graph b xn whose set node v edg b xn form v node regular graph degre map color b xn see thi suppos c map v color color algorithm ring fail label happen contain segment u v result linial chromat number b xn n therefor color xn three color must x omegagamma n is log n impli omegagammaat log n step need order solv mi problem togeth o algorithm solv mi problem use binari llsc prove follow theorem theorem implement binari llsc oper unari oper must omegagamma log n step complex discuss paper defin sensit implement binari oper unari oper sensit distanc term intersect data set two concurr oper guarante interfer other clearli sensit implement low oper execut concurr less interfer context say one oper interfer oper one delay other howev notion interfer modifi exampl one add requir set memori word access oper chang execut concurr anoth oper present algorithm implement binari oper of type unari sc oper sensit olog n algorithm employ symmetri break algorithm base determinist coin toss practic purpos simpl nondeterminist symmetri break techniqu could employ howev care taken avoid deadlock scheme interestingli core algorithmlock memori word two directionsi similar leftright dine philosoph algorithm cf pp problem n philosoph sit around tabl fork pair philosoph time time philosoph get hungri pick two fork side order eat leftright dine philosoph algorithm philosoph sit oddnumb place first pick left fork philosoph sit evennumb place first pick right fork implement link list guarante short wait chain mani philosoph hungri also prove implement binari llsc unari oper incur nonconst overhead step complex lower bound tight sinc step complex waitfre extens algorithm least olog n acknowledg author thank shlomo moran lihu rappoport gadi tauben feld help comment previou version paper r disentangl multiobject opera tion perform issu nonblock synchron sharedmemori multiprocessor univers construct multiobject oper primit asynchron list compress perform spin lock altern sharedmemori multipro cessor univers oper unari versu binari method implement lockfre data structur local failur distribut synchron determinist coin toss applic optim parallel list rank univers oper unari versu binari alpha architectur handbook content share memori system synergi nonblock synchron oper system structur methodolog implement highli concurr data object transact memori architectur support lockfre data structur correct condit concurr object effici waitfre implement concurr prioriti queue local distribut graph algorithm distribut algorithm powerpc architectur specif new famili risc processor hot spot softwar transact memori alpha axp architectur lock without block make lock base concurr data structur algorithm nonblock tr determinist coin toss applic optim parallel list rank lineariz correct condit concurr object waitfre synchron local distribut graph algorithm perform issu nonblock synchron sharedmemori multiprocessor lock without block alpha axp architectur methodolog implement highli concurr data object transact memori method implement lockfre shareddata structur powerpc architectur primit asynchron list compress disjointaccessparallel implement strong share memori primit synergi nonblock synchron oper system structur local failur distribut synchron univers oper disentangl multiobject oper extend abstract content share memori algorithm univers construct larg object distribut algorithm perform spin lock altern sharedmoney multiprocessor effici waitfre implement concurr prioriti queue