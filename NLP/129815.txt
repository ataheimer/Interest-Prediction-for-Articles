t controlflow normal algorithm complex a singl method normal controlflow program facilit program transform program analysi automat parallel present previou method result program whose control flowgraph reduc program normal techniqu satisfi stronger condit reduc therefor simpler syntax structur previou method particular controlflow cycl normal singleentri singleexit loop goto elimin furthermor method avoid problem code replic characterist nodesplit techniqu restructur obviat control depend graph sinc afterward control depend relat manifest syntax tree program transform effect normal present complex method studi b introduct problem consid normal controlflow program goal facilit program transform program work support part nation scienc foundat grant no nsf mip us depart energi grant no defg er offic naval research grant no onr nk us air forc offic scientif research grant no afosrfc donat ibm corpor analysi automat parallel sever way techniqu make process easier first reduc number syntact construct must treat system analysi transform lessen complex mani compil algorithm often driven structur program program structur highli regular number case condit must consid analyz parallel program simpli decreas second convert controlflow cycl singleentri singleexit loop elimin branch instruct may dramat consequ compil exampl loop contain exit branch difficult parallel sinc number iter perform unknown prior execut likewis goto may use creat cycl controlflow hidden loop may caus loss parallel loop describ miss techniqu parallel appli loop also controlflow loop sometim entir subroutin may disturb cycl similarli use goto make program transform analys difficult ineffici gener reason simpl composition controlflow lost term semant may say absenc goto direct semant may given wherea presenc continu semant need increas complex continu semant translat increas complex program analysi model semant eg abstract interpret dataflow analysi third techniqu obviat control depend graph much effort spent tradit parallel compil treatment control depend argu controlflow program properli normal control depend relat manifest syntax tree normal program need separ represent depend similarli method make unnecessari perform interv analysi part dataflow analysi normal intern structur program obviou trivial may therefor use simplifi implement dataflow analysi sinc patholog flowgraph exist unnorm program may aris sever way first unstructur program written languag common lisp fortran pascal c second compil may produc unstructur code appli classic program transform tail recurs elimin exampl see figur transform recurs split result even complex output tail recurs elimin wish compil work alway normal program may appli normal follow transform lot work done normal controlflow program techniqu result program reduc defun f lambda begin cond null x y f car x y figur sampl recurs lisp program defun f lambda begin cond null x set r y go return r figur tail recurs elimin control flowgraph howev method normal present result program highli regular produc method word condit much stronger reduc satisfi control flowgraph result method furthermor previou method controlflow normal result excess code replic show code replic necessari method elimin irreduc condit rare even unstructur program present normal method normal work transform program system simultan equat whose unknown repres continu associ program label solut system equat normal form program effect detect loop elimin patholog syntact construct program contain william ossher prove elimin necessari suffici obtain structur form program theorem bohm jacopini say may transform program anoth one follow three control structur use assign condit ffl iter howev theorem construct give method deriv program techniqu present exactli simpl effici way normal controlflow program consist transform program anoth equival one three forego control structur use input languag treat lisplik syntax includ branch instruct goto label toplevel procedur appli method fortran lelisp appli common lisp c output languag contain singleentri singleexit loop neither goto label repres normal form program denot semant semant program languag precis mathemat specif mean program languag idea approach defin function map syntact construct algebra one method base scott strachey work use defin languag like algol pascal clu input languag contain branch instruct simpl jump make semant program complex lose composition semant command must switch direct semant semant continu theori continu develop c wadsworth l morri independ notion origin tail function mazurkiewicz continu continu power tool allow us give straightforward mean branch except error allow us regain degre composition lose branch continu instruct function which appli store give final result program execut begin instruct i result new store state memori usual continu associ point program approach point repres program label author provid interest reader denot semant continu primit express languag languag describ follow section abstract cste cste constant command express lambda proc lambda express while cmd unop unari oper gamma not biop binari oper and purpos simplic grammar includ scalar variabl normal method present appli fortran lisp program mean restrict treatment scalar data requir restrict upon side effect alias continu equat procedur p may give syntact represent continu associ program label call x figur illustr sampl lisp program obtain program system continu equat figur x sourc continu it contain solut system resolut x x x x continu associ label respect unknown system control structur use system three propos bohm jacopini solut system repres normal form procedur next section present method choos solv system gaussian eliminationlik resolut straightforward gaussian eliminationlik resolut method may use solv system continu equat method yield solut defun h lambda i j begin if go set j set j k i figur sampl lisp program figur continu equat program figur number equat or unknown solut present refin method see later paper refin improv complex consider gaussian elimin method consist substitut elimin unknown appear system want satisfi two criteria first minim code size accomplish factor second convert everi controlflow cycl loop accomplish derecursiv solv system style gaussian elimin perform transform along way give normal form program transform look continu equat built may remark contain branch regular structur gener equat follow form true fals part statement may contain state ment statement may absent altogeth let us present transform use solv system precalcul effect subtransform use transform present rest paper put boolean express condit statement new temporari variabl temporari defin program exampl follow statement becom precalcul pred exp if pred begin cmd distribut like precalcul subtransform use transform present rest paper rewrit statement contain continu variabl sequenc two statement first contain condit captur temporari variabl by precalcul second one contain continu variabl control temporari variabl condit save temporari variabl avoid multipl comput it also guarante correct result sinc argument may affect cmd exampl let us consid equat x distribut equat pred exp if pred begin cmd if pred x factor one unknown may appear sever time singl equat avoid increas code size elimin process factor equat two differ factor may use factor unknown factor boolean express factor selector variabl factor boolean express consist assembl condit boolean express govern one unknown use distribut replac equat one unknown appear onc consid continu equat whose form is x j guard boolean express or exp not true rewrit equat pred exp if pred cmd cmd if or pred not pred equival pred exp if pred cmd cmd add anoth nest level anoth unknown x k begin if exp begin cmd x j x j guard or exp and not exp not exp x k guard and not rewrit equat as pred if pred begin set pred exp if pred begin cmd if and not pred build select tree if and not pred order unknown appear insid x increas order number appear case x k appear insid x x j appear twice thu x k treat first select tree case number appear unknown same taken order appear insid equat heurist order allow us creat boolean express manag size case sever nest level factor selector express consist replac unknown assign selector variabl singl integ valu associ unknown case statement ad send control appropri continu consid continu equat abov add variabl selector assign valu unknown equat x j replac set selector rewrit equat begin cmd set selector if selector x j add anoth nest level anoth unknown x k begin if exp begin cmd x j rewrit equat use selector variabl follow begin if exp begin cmd set selector begin cmd set selector if selector x j if selector x k cours order place unknown select tree irrelev sinc guard case simpli test valu selector compar two method measur respect cost run experi normal scientif comput perfect club see figur section derecursiv derecursiv like hecht transform consist make loop explicit selfrecurs equat form intuit equat loop whose entri instruct label x whose condit iter condit lead x case iter loop exp becom fals case perform begin form associ fals part if fix point equat is begin cmd set pred exp if pred cmd cmd pred semant statement iter begin form contain insid form pred fals semant repeat therefor suppos loop bodi perform least onc consid equat anoth level nest begin if exp begin cmd x k must studi boolean express guard continu insid equat x j guard exp x k guard and not final x guard and not exp not exp latter condit repres exit condit loop induc continu pred if pred cmd begin set pred if pred cmd cmd and not pred not pred if pred x j begin if pred x k substitut elimin t consist substitut unknown continu system elimin equat system howev hecht perform unknown singl use system transform constrain condit sinc replac unknown anywher appear system ie unknown may replac sever differ perform check unknown elimin nonrecurs which case derecursiv first equat appear factor to avoid sever substitut unknown singl equat system figur elimin x system figur substitut x j x elimin system obtain follow equival system begin cmd x k applic transform reduc number n unknown system n gamma exampl resolut system continu equat result program figur present figur solv system use transform present abov may begin resolut elimin x appear equat x x equival system elimin figur next step may elimin x result system equival system figur sinc x recurs want appli derecursiv transform creat correspond loop elimin transform replac elimin unknown system result system figur figur respect point x appear twice x need factor x result system shown figur final substitut elimin x obtain normal form figur structur origin program build continu equat attempt preserv much possibl origin structur program say input procedur contain control construct alreadi normal by normal mean neither branch instruct leav construct branch instruct enter it construct preserv re normal figur loop alreadi normal associ figur elimin x system figur pred if not pred not pred figur derecursiv x system figur begin while begin set j k set pred if not pred not pred x figur elimin x system figur pred if not pred while begin set j k set pred if not pred pred figur factor x system figur defun h lambda i j begin pred if not pred begin while begin pred if not pred not pred figur normal form program figur continu equat system figur treat assign statement now look program figur loop exit insid it case loop first rewritten term goto if shown figur convert normal form order resolut system figur abov elimin unknown arbitrari order easi see qualiti normal form program term code size depend upon order unknown elimin system give idea import order let us take previou system equat figur tri elimin unknown differ order let us choos follow order resolut system elimin x figur variabl x x occur equat x elimin x lead equival system figur x recurs derecursiv substitut obtain system figur final elimin x obtain normal program figur cours program figur semant equival second one contain replic code bodi loop restrain strictli code depend upon it ie code insid loop bodi need be defun f lambda j b n begin set while begin set b j figur program contain normal control structur figur continu equat system program figur defun g lambda j b n begin set while begin set b j set b j figur program contain nonnorm control structur defun g lambda j b n begin set if g n go g set b j figur equival form program figur figur elimin x system figur figur elimin x system figur while begin set pred if not pred not pred x figur elimin x system figur defun h lambda i j begin while begin pred if not pred not pred figur normal form program figur observ order resolut import impact run time resolut process code replic order resolut propos follow first sort extend topolog order node graph associ equat second move loop header order appear unknown repres bodi note algorithm slightli differ classic method interv analysi normal method make use strongli connect compon topolog sort acycl continu flowgraph solv system continu next section describ elimin order unknown graph topolog sort graph e associ system equat repres control flowgraph program defin take node unknown system creat edg unknown x j appear insid equat x jn number node edg exampl graph associ system equat figur figur topolog order node graph label node integ cours graph must acycl order meaning sinc gener input graph contain cycl order node first elimin back cross edg graph sort result graph topolog order call extend topolog sort graph visit graph node depthfirst order complex combin algorithm kept on figur x singl loop header bodi consist unknown x x extend topolog order next step figur graph associ system figur reorder loop header x must appear x x the two unknown bodi order resolut use previou exampl follow order algorithm find order resolut input list h loop header list b h label bodi loop header h list l unknown order extend topolog order output order list unknown unknown x l ffl delet x l insert immedi unknown constitut bodi loop design x unknown given b x algorithm resolut system input order list unknown l output sourc label whose equat repres normal form program select first unknown x l x selfrecurs ffl derecursiv x appli x j x element unknown set ffl factor occurr x x j ffl substitut x x j appli l nonempti goto exampl let us consid irreduc program figur give detail transform perform continu equat system present system figur associ continu graph figur two nest loop graph whose header order resolut normal form rel order figur defun g lambda i j x begin if set x i set if x i begin if x go set j set j figur irreduc program figur continu equat program figur figur continu graph system figur defun g lambda i j x begin while begin pred if not pred while begin pred x i if pred begin set pred x j and pred pred and not pred and pred not pred if and pred or pred not pred figur normal form irreduc program figur complex section analyz complex normal method count number transform necessari solv system continu equat complet time space complex studi would involv us detail data structur beyond scope paper howev analysi reveal import aspect complex normal algorithm extend complet one consid cost appli individu transform chosen represent program let system continu equat e graph associ s n let jn repres set node enter node or altern set unknown whose equat appear dj i degre multipl edg j i ie number time appear equat j n total number substitut perform resolut pro cess n f repres number factor n number derecur sivat number substitut show number substitut perform resolut exceed number unknown n system case g reduc theorem g reduc equat substitut system s proof let mean appear at least onc equat k want substitut unknown system seen algorithm substitut equat k k factor occur equat k sever case may appear substitut system case appear sever equat system may insid loop whose header h may repres header loop final may neither two case let sourc node graph case simplest case sever predecessor neither loop header insid loop accord resolut order chosen predecessor treat itself come substitut i appear equat nearest domin h factor h appear h substitut onc case loop whose header h h distinct case order chosen fact g reduc predecessor loop except treat itself come substitut i appear equat h fact h domin i factor h appear system therefor replac substitut case loop header accord resolut order describ earlier treat everi node insid loop header let h header innermost loop contain loop or s loop treat i therefor selfrecurs variabl appear reduc everi controlflow cycl g uniqu loop header domin everi node bodi loop also equat h or s derecursiv factor h substitut system sinc n equat system nin irreduc graph method may replic code worst case without preliminari factor number substitut unknown bound number predecessor theorem g irreduc unknown substitut n time proof first step elimin first unknown substitut worst case time second time substitut ngamma time sinc first substitut one unknown definit elimin system on elimin unknown number substitut note bound conserv assum control flowgraph program cliqu number factor look algorithm resolut section see factor appli predecessor x j x substitut x factor cours unnecessari x occur equat must note appli one singl step factor x j effect reduc instanc occurr x j one the degre edg x j everi occurr x j number instanc variabl insid equat bound n singl factor step abl reduc instanc one worst case factor necessari everi substitut therefor n f n number derecursiv derecursiv perform everi time node occurr number derecursiv depend upon number loop header entir graph worst case everi node graph loop header conserv bound summari number transform perform case reduc flowgraph order number continu equat system cours studi complex take account size continu equat time necessari substitu tion find within equat unknown substitut factor cost collect simplifi boolean condit applic normal process normal method present put sever use project author involv paf miprac paf experiment fortran parallel develop univers pari franc paf normal method two applic first convert everi cycl explicit implicit loop transform loop whenev possibl final doall loop depend permit it word even programm write loop use goto write unstructur loop made elig parallel normal second purpos vector order vector statement condit execut loop one must attach boolean variabl mode vector statement controlflow normal may accomplish easili program miprac multilingu compil share memori machin implement univers illinoi applic normal method much ambiti first allow us write genuin multilingu compil miprac accept program common lisp c scheme fortran togeth four languag contain mani control structur do dolist dotim loop cond block return break case switch exit for while goto continu if paus normal three controlstructur remain begin if while moreov intermedi form properli structur word multilingu miprac mean program variou languag simpl structur represent miprac intermedi form accomplish normal second applic simplifi program analysi effect normal allow program requir continu semant becaus goto convert program may given direct semant ex ampl program goto might mean function type normal program would mean function type store store simplif show write analysi program well wherea abstract interpret unnorm program might function type where store abstract memori abstract interpret normal program could function store make analysi simpler implement effici reader may contrast interprocedur analysi continu use direct semant appli program whose procedur bodi normal third applic simplifi program transform restructur express need concern branch middl of middl express control flow express orderli way reader may look harrison work see difficulti may encount program transform exitloop parallel recurs split perform code structur controlflow normal effect make while do loop transform applic iter structur replac arbitrari controlflow cycl singleentri singleexit loop reduc number differ syntact structur program point normal quit differ program point program text known user problem fairli easili solv observ express normal program come exactli one express sourc map transform program origin sourc welldefin maintain state section compar run experi perfect code factor use boolean express selector expr sion measur number boolean express selector express gener code replic result without factor see figur column ebn give number express present program normal column eanf give number express program normal factor column bexp give number boolean express ad factor column sexp give number selector express a selector express assign selector variabl ad factor column bexpeanf give ratio count likewis ratio sexpeanf column ean give number express program normal without repres growth code factor perform ebn growth code normal factor note factor use neither boolean selector express ad program normal izat factor boolean express requir everi predic guard condit statement store temporari variabl see transform distribut abov temporari variabl necessari factor selector express perform reason ebn code differ valu factor perform use selector express versu use boolean express averag ratio boolean express bexp creat total number express program eanf averag ratio selector express sexp creat total number express program eanf compar gf g may see gf alway smaller g except factor trfd selector express boolean express creat reason size code gf neg due fact normal process simplifi sourc code produc compact form code for exampl label goto sourc code elimin nb miprac fortran c cl frontend translat everi loop use goto label therefor column ebn includ label goto ad frontend account much neg code growth clear look measur factor selector express result less code growth factor boolean expr sion although case growth seem manag main reason small number boolean express use heurist order allow us creat boolean express manag size case sever nest level miprac use phase boolean express simplif rather factor selector express use excess boolean express creat appear howev boolean express gener normal small enough simplif would major expens posit work sever techniqu exist structur flowgraph techniqu consist modif elimin goto statement ad controlflow variabl copi code creat call procedur ad level iter may appropri case howev program produc often less regular produc method often contain replic code none present simpl comprehens algorithm normal control flowgraph present below limit overview method howev emphas kennedi method sinc recent closest method bohm jacopini present two normal method flow diagram decompos flow diagram base diagram three type two type method like our add boolean variabl replic code motiv first singl represent sourc code written three differ languag and second uniform represent loop goto break them code ebn eanf bexp ean bexpean gf g mdg migrat total figur factor boolean express code ebn eanf sexp ean bexpean gf g migrat total figur factor selector express even normal reduc flowgraph furthermor author present simpl algorithm rather describ method patternmatch flowgraph could complex costli implement knuth floyd studi program transform elimin goto statement without introduc new variabl modifi sequenc program comput first possibl elimin goto introduc procedur sometim quit clean solut except procedurecal overhead may import program involv mani loop iter second possibl write flowchart accord bnf defin method replic code normal reduc flowgraph author declar method suffic elimin goto program peterson kasami tokura defin wellform program program loop condit statement properli nest singl entri obtain program use node split transform may replic code procedur call case code replic big method replic code normal reduc flowgraph no bound given size result program result program multipleexit loop branch exit sever nest control structur ashcroft manna introduc two transform translat program goto program without first one add temporari variabl second add logic variabl program first method replic code normal reduc flowgraph method result loop multipl exit baker concentr make program understand rather elimin goto statement entir goto statement gener give clearer descript controlflow syntact restrict impos upon input program well algorithm divid two step locat loop flowgraph ad branch statement first step use classic notion domin build depthfirst span tree flowgraph second step algorithm add branch statement basic form program gener first step algorithm extend handl irreduc graph shortcom baker method first goto remain second loop may left multipl exit third number control form greater method result syntax still fairli complex allen kennedi method convert control depend data depend call convers primari goal transform transform program purpos vector take everi loop program transform statement guard one beyond goal transform may use applic code structur goto elimin convers perform three step first step analyz branch code classifi goto figur program cycl either exit branch backward branch forward branch second step branch reloc last step branch remov exit branch defin one termin loop forward branch defin one whose target loop nest level preced target lexic backward branch defin one whose target loop nest level follow target lexic branch reloc move branch loop branch target loop nest level branch remov elimin forward branch attach guard express target convers goal similar normal method shortcom present along differ work exampl use taken allen kennedi paper written fortranlik syntax normal form also written syntax order make differ appar first problem convers backward branch improperli identifi whose target preced lexic thu program figur treat refer paper cycl convers algorithm detect goto backward branch follow care controlflow code loop program program obtain convers figur method factor perform sinc two differ path could taken arriv label final normal form shown figur written fortranlik syntax facilit comparison second problem convers adhoc treatment irreduc program let us take exampl program figur transform convers program figur boolean variabl use record branch taken reach statement loop bodi result program contain goto cycl controlflow replac structur loop subsequ transform not describ refer paper must use replac backward branch loop contrast method produc program figur use uniform treatment reduc irreduc flowgraph sinc flowgraph irreduc code replic notic convers introduc addit loopcarri depend on variabl bb goto elimin not bb and br not bb and br and y goto figur program figur convers pred not pred andpr y figur normal form program figur present program figur depend may inhibit parallel loop third problem convers extra gener boolean express guard statement program program figur equival convers one figur now look normal form figur correspond program figur see latter form straightforward dataflow analysi would accur two reason first statement guard condit therefor may easili conclud definit array b reach program wherea program figur necessit deeper analysi account boolean guard arriv conclus second easi see control structur program figur definit variabl x statement reach last definit statement figur exampl irreduc code y goto figur convers program figur pred not pred andnot pred repeat pred figur normal form program figur figur reachabl use not br not br not br not br andnot br ornot br andnot br figur convers program figur previou definit x again convert code deeper analysi necessari perhap conserv decis would taken relat applic gaussian elimin like method sever problem close relat controlflow normal make use gaussian elimin resolut includ global flow analysi shortest path problem convers finit automata regular express fundament framework problem build system equat base region flowgraph solv system use gaussian resolut follow give overview method allen cock interv analysi hecht ullman analysi tar jan interv analysi final graham wegman analysi latter three improv first one literatur algorithm not pred not pred notnot pred and pred figur normal form program figur call elimin algorithm ryder paull present comparison four algorithm are gener describ specif implementa tion therefor difficult see common point differ goal give present algorithm describ complex perform want emphas follow four algorithm method program normal rather present show reader gaussian eliminationlik solut system wide use similar problem sever improv complex studi algorithm use global dataflow analysi e repres number edg flowgraph assum order on n number node flowgraph allen cock method method known interv analysi introduc allen cock treat irreduc graph adjust handl them equat use quit differ our repres dataflow equat program describ reach definit variabl program allen cock algorithm consist iter three phase partit algorithm find singl entri region depend graph elimin dataflow equat final propag elimin process turn applic success substitut loopbreak transform latter transform equival derecursiv transform describ earlier paper unknown system elimin natur order node graph ad interv propag backsubstitut perform propag global dataflow side effect region appli consist find variabl correspond substitut interv head variabl solut reduc equat process reduc system smaller one produc on solut hecht ullman method algorithm also applic reduc graph take input system equat analog one describ allen cock algorithm depend graph ie control flowgraph elimin process direct region graph much allen cock algorithm consist appli transform describ paper earlier region search common factor reduc equat allow save calcul improv provid complex on log n rather on allen cock complex tarjan method tarjan method use differ notion interv method sens repres loop control flowgraph calcul interv implicit order aris allen cock method order use calcul reduc equat clear order follow one depthfirst order graph resolut like hecht method base upon transform shown abov transform composit two previou one method appli reduc flowgraph graph algorithm requir time onffn ff invers ackerman function simpler algorithm run on log n exist graham wegman method algorithm close tarjan interv analysi handl irreduc graph without need elimin irreduc notion interv call sset repres loop flowgraph sset defin number node depend graph associ equat number perform use depthfirst order elimin process perform use three transform similar hecht ullman algorithm name applic transform restrict node one predecessor consist loopbreak derecursiv frame work consist substitut node sever successor transform necessari elimin node k successor substitut perform way hecht ullman algo rithm term substitut success rather substitut entir right hand side equat onc allen cock algorithm final elimin node successor algorithm run time on log n conclus algorithm present refin gaussian elimin like algorithm two relationship work describ our first method use gaussian elimin method similar respect our second solv dataflow analysi problem much difficulti come irregular structur underli control flowgraph use method like our structur made regular result analysi algorithm made simpler normal program anticip much comput dataflow solut program solv dataflow problem much effici further normal process perform program simplif affect forward backward dataflow problem solv program backward flowgraph normal program also normal wherea flowgraph mere structur may unstructur edg revers final even though closur may still requir loop especi nonfast problem simpler nonnorm program conclus paper present algebra framework normal controlflow framework made easi us prove transform preserv semant program applic varieti languag power exist method sever respect first method base upon nodesplit convers branch instruct remain transform code replic may occur even normal program whose flowgraph reduc method elimin branch instruct replic code elimin irreduc rare condit even unstructur program second previou method result program reduc flow graph method yield program whose control flowgraph highli structur yet particular controlflow cycl normal singl entri singleexit loop loop may transform convent loop induct variabl recognit make method particularli help automat parallel highli regular loop structur essenti simplifi forward backward dataflow analys transform program one obviou trivial intern structur third method make separ represent control depend unnecessari program normal method control depend are effect repres directli syntax tree sinc condit structur contain express control sinc analysi control depend central work parallel program signific simplif work implement paf parallel fortran program written univers pari miprac multilingu parallel program univers illinoi miprac measur hand exampl ratio total normal time total compil time approxim total compil time includ pars normal interprocedur analysi intraprocedur dataflow analysi restructur averag compil time exampl second expect ratio decreas time measur take account addit pass miprac current implement acknowledg wish thank luddi harrison help idea suggest improv paper also thank anonym refere comment earlier draft paper r design analysi comput algorithm theori pars overview ptran analysi system multiprocess program data flow analysi procedur convers control depend data depend restructur de programm fortran en vue de leur parallelis normal program control flow controlflow normal algorithm complex iti translat goto program while program translat program schema whileschema algorithm structur flowgraph flow diagram algebra network rout problem kap advanc sourcetosourc vector s mark iia supercomput shortest path fast usual linear algorithm global flow analysi flow analysi comput program effici algorithm shortest path spars network structur program goto statement note avoid go statement structur advanc vector pipelin processor prove algorithm tail function mathemat semant algol advanc compil optim super comput capabl perfect club report combinatori algorithm theori practic increment data flow analysi base unifi model elimin algorithm elimin algorithm data flow analysi denot semant clu denot semant represent event nerv net finit automata denot semant schottstrachey approach program languag theori fast algorithm solv path problem paf un paralleliseur automatiqu pour fortran denot semant program languag fast algorithm elimin common subexpr sion convers unstructur flow diagram structur optim supercompil supercomput tr advanc compil optim supercomput elimin algorithm data flow analysi automat recognit induct variabl recurr relat abstract interpret fast usual linear algorithm global flow analysi effici algorithm shortest path spars network algorithm structur flowgraph fast algorithm solv path problem structur program italicgo toital statement program data flow analysi procedur denot semant program languag capabl while repeat exit statement flow diagram ture machin languag two format rule algorithm shortest path denot semant flow analysi comput program increment data flow analysi convers control depend data depend theori pars translat compil design automat parallel symbol numer program optim compil lexic scope lisp denot semant clu optim supercompil supercomput ctr j a bergstra t b dinesh j field j heer toward complet transform toolkit compil acm transact program languag system topla v n p sept fubo zhang erik h dholland use hammock graph structur program ieee transact softwar engin v n p april m g j van den brand p klint c verhoef revers engin system renovationan annot bibliographi acm sigsoft softwar engin note v n p jan todd a proebst scott a watterson krakatoa decompil java dose bytecod reveal sourc proceed rd confer usenix confer objectori technolog coot p june portland oregon johan janssen henk corpora make graph reduc control node split acm transact program languag system topla v n p nov larri carter jeann ferrant clark thomborson folklor confirm reduc flow graph exponenti larger acm sigplan notic v n p januari baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slice acm sigsoft softwar engin note v n march peng zhao jo nelson amar ablego function outlin partial inlin framework research articl softwarepractic experi v n p april j koehler r hauser s sendal m wahler declar techniqu modeldriven busi process integr ibm system journal v n p januari