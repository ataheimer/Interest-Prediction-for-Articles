t fast prioriti queue cach memori a cach hierarchi preval today high perform processor taken account order design algorithm perform well practic paper advoc adapt extern memori algorithm purpos idea practic issu involv exemplifi engin fast prioriti queue suit extern memori cach memori base ikiway merg improv previou extern memori algorithm constant factor crucial transfer cach memori run cach hierarchi workstat algorithm least two time faster optim implement binari heap ari heap larg input b introduct mainstream model comput use algorithm design last half centuri assum sequenti processor unit memori access cost howev mainstream comput sit desktop increasingli deviat model last decad particular usual distinguish least four level memori hierarchi file multiport regist access parallel everi clockcycl firstlevel cach still access everi one two clockcycl parallel port achiev high throughput pipelin therefor instruct level parallel superscalar processor work best instruct use regist onli current firstlevel cach quit small kb order abl keep chip close execut unit secondlevel cach consider larger also order magnitud higher latenc offchip size mainli constrain high cost fast static ram main memori build high densiti low cost dynam ram includ overhead cach miss memori latenc translat logic virtual physic memori address main memori access two order magnitud slower first level cach hit machin separ cach data code disregard instruct read long program remain reason short although technolog detail like chang futur physic principl impli fast memori must small like expens slower memori live memori hierarchi talk sequenti algorithm larg input gener approach paper model one cach level main memori singl disk singl processor variant extern memori model model assum intern memori size access extern memori transfer block size b use word pair cach line memori block cach intern memori main memori extern memori io cach fault synonym context indic otherwis formal limit compar extern memori cach fix replac strategi anoth paper show rel littl influenc algorithm kind consid nevertheless henceforth use term cach memori order make clear differ model despit farreach analog extern memori cach memori number addit differ note sinc speed gap cach main memori usual smaller gap main memori disk care also analyz work perform intern ratio main memori size first level cach size much larger disk space intern memori therefor prefer algorithm use cach econom possibl final also discuss remain level memori hierarchi inform order keep analysi focuss import aspect section present basic algorithm sequenc heap data structur prioriti queue algorithm analyz section use extern memori model thetam k thetamb constant perform insert deletemin use irb log mo key comparison anoth paper show similar bound hold cach memori away associ cach k reduc ob a section present refin take level memori hierarchi account ensur almost optim memori effici amort work perform oper depend current queue size rather total number oper section discuss implement algorithm sever architectur compar result prioriti queue data structur previous found effici practic name binari heap ari heap relat work extern memori algorithm well establish branch algorithm eg extern memori heap teuhola wegner fish spear data structur need thetab less io tradit prioriti queue like binari heap buffer search tree first extern memori prioriti data structur repres total order set support insert element delet minim element queue reduc number io anoth factor thetalog lower bound oib log mb im io oper amort use fullfledg search tree implement prioriti queue may consid wast heaplik data structur brodal katajainen crauser et al fadel et al directli gear prioriti queue achiev asymptot bound one even per oper amort sens sequenc heap similar particular consid simplif reengin improv arrayheap howev sequenc heap ioeffici factor three or more need factor two less memori algorithm merg k sort sequenc one sort sequenc kway merg io effici subroutin use sort extern cach memori basic idea sequenc heap adapt kway merg relat dynam problem prioriti queue let us start simpl case km insert take place size buffer fit fast memori data structur could consist k sort sequenc length m use kway merg delet batch smallest element k sort sequenc next delet serv buffer constant time allow arbitrari mix insert delet maintain separ binari heap size hold recent insert element delet check whether smallest element come insert buffer buffer full sort result sequenc becom one sequenc kway merg point sequenc heap earlier data structur almost ident differ relat question handl km element cannot increas beyond sinc insert heap would fit fast memori cannot arbitrarili increas k sinc eventu kway merg would start incur cach fault sequenc heap use approach make room merg k sequenc produc larger sequenc size km question aris handl larger sequenc adopt approach use improv arrayheap employ r merg group g hold k sequenc size mk igamma group g overflow sequenc merg result sequenc put group g i group equip group buffer size allow batch delet sequenc smallest element buffer delet batch size m store delet buffer fig summar data structur enough inform explain delet work deletemin smallest element delet buffer insert buffer compar smaller one delet return empti delet buffer refil group buffer use rway merg kmerg kmerg kmerg rmerg insert heap mk buffer group group buffer mt group buffer delet buffer fig overview data structur sequenc heap refil group buffer less element refil sequenc group if group nonempti deletemin work correctli provid data structur fulfil heap prop erti ie element group buffer smaller element delet buffer and turn element sort sequenc smaller element respect group buffer maintain invari main difficulti implement insert insert new element insert insert heap size reach element sort eg use merg sort heap sort result merg concaten delet buffer group buffer smallest result element replac delet buffer group buffer remain element form new sequenc length m new sequenc final insert free slot group g free slot initi g empti merg sequenc singl sequenc size km put g strategi use recurs necessari group gr overflow r increment new group creat sequenc move one group other heap properti may violat therefor g g empti group buffer i merg put g latter measur one differ improv array heap invari maintain merg new sequenc group buffer measur almost halv number requir io cach memori speed intern comput matter also crucial implement oper kway merg propos use loser tree variant select tree data structur describ knuth section k nonempti sequenc consist binari tree k leav leaf store pointer current element sequenc i current key sequenc perform tournament winner pass tree key loser index leaf store inner node overal winner store addit node root use data structur smallest element identifi replac next element sequenc use dlog comparison less heap size k assum would requir address calcul memori refer similar need binari heap noteworthi differ memori locat access loser tree predict case delet binari heap instruct schedul compil place access well data need thu avoid pipelin stall particular combin loop unrol analysi start analysi number io term b paramet arbitrari sequenc insert deletemin oper insert deletemin continu number key comparison measur intern work discuss k chosen extern memori cach memori respect adapt memori effici mani access rel small queue postpon section need follow observ minimum interv tree empti oper sever place lemma group g overflow everi mk proof complic slot group g use invalid group buffer nevertheless group g g contain k sequenc each happen insert taken place particular sinc room insert insert buffer simpl upper bound number group need corollari log k upsilon group suffic analyz number io base assumpt follow inform kept intern memori insert heap delet buffer merg buffer size m group buffer r loser tree data group gr grgamma we assum kb unit memori suffic store block k sequenc current access loser tree inform itself correspond amount space share remain r gamma group data merg r group buffer theorem log k io suffic perform sequenc insert deletemin sequenc heap proof let us first consid io perform element move follow canon data path first insert insert buffer written sequenc group g batch manner ie charg b io insert element involv empti group arriv group gr empti oper involv one batch read one batch write ie charg r gamma b io tree empti oper eventu read group buffer r charg b io thi all get charg rb io insert remain shown remain io contribut lower order term replac io done canon path element travel group grgamma b io must charg write group buffer later read refil delet buffer howev b io save element move group gr pay charg element travel group buffer r gamma addit save compar canon path also pay cost swap loser tree data group g latter cost kb divid among least remov one batch group buffer becom invalid must merg group buffer put back group g caus direct cost omb io must charg cost oimb io element thrown back oi step path delet buffer although element may move r group need charg ormb io small sinc mean shortcut origin taken element compar canon path miss remain overhead charg mk gamma k j gamma insert fill group g igamma sum group insert get addit charg similarli invalid group buffer give charg ok per insert need olog insert new sequenc loser tree data structur done tree amort insert amort mk lemma accept ob io per oper would suffic swap insert buffer plu constant number buffer block one loser tree k sequenc buffer intern memori element move canon path get overal charg olog km overal get charg rboklogkm per insert estim number key comparison perform believ good measur intern work sinc effici implement prioriti queue comparison model number close number unpredict branch instruct wherea loop control branch usual well predict hardwar compil number key comparison also proport number memori access two type oper often largest impact execut time sinc sever limit instruct parallel superscalar processor order avoid notat overhead round also assum k power two divis mk rgamma gener bound would larger small addit term theorem assumpt theorem ilog dlog re log m m molog kk key comparison need averag case input log m replac o proof insert insert buffer take log comparison worst o comparison averag everi deletemin oper requir comparison minimum insert buffer delet buffer remain comparison charg insert analog way proof theorem sort insert buffer eg use merg sort take log comparison merg result delet buffer group buffer take comparison insert sequenc loser tree take olog comparison empti group take r gamma log k ork comparison per element element remov insert buffer take log comparison need count sinc save comparison them similarli refil group buffer r alreadi account conserv estim group empti cost group gr degre imk comparison per element suffic use similar argument proof theorem shown insert sequenc loser tree lead charg olog km comparison per insert invalid group buffer cost olog kk comparison per insert sum charg made yield bound proven extern memori one would choos anoth paper show k factor ob a ffi smaller away associ cach order limit number cach fault ffi time number io perform extern memori algorithm requir togeth small size mani first level cach tlb explain ranslat lookasid buffer store physic posit recent use virtual memori page may live quit small k observ main reason pursu simpl variant array heap describ need singl merg group sequenc merg group would factor r larger howev refin memori manag sequenc heap implement memori effici way repres sequenc group singli link list memori page whenev page run empti push stack free page new page need alloc pop stack necessari stack maintain extern except singl buffer block use page size p extern sequenc sequenc heap r group n element occupi n kpr memori cell togeth measur describ keep number group small becom n kp log k nm page size particularli easi implement sinc also size group buffer insert buffer long guarante asymptot optim memori effici ie memori requir mani oper small queue let n denot queue size ith oper execut earlier algorithm number io bound o ii log k n m certain class input ii log k n m consider less log k im howev believ applic requir larg queue all differ larg enough warrant signific constant factor overhead algorithm complic therefor chosen give detail analysi basic algorithm first outlin adapt yield refin asymptot bound here similar new sequenc insert group g free slot first look two sequenc g whose size sum less mk element found sequenc merg yield free slot merg cost charg deletemin caus sequenc get small g empti contain least mk element io involv charg element insert g least size mk igamma similarli tidi up shrink queue r group total size queue fall mk group gr insert result sequenc group grgamma if free slot group grgamma merg two sequenc first regist instruct cach realist case r group therefor instruct cach regist file like larg enough effici support fast rway merg routin refil delet buffer keep current key stream regist second level cach far analysi assum singl cach level still assum level first level cach second level cach may influenc first note group buffer loser tree group buffer like fit second level cach second level cach may also larg enough accommod group g reduc cost b io per insert get interest use second level cach assum bandwidth suffici high bottleneck look input delet insert buffer rare eg sort choos size second level cach insert high local log cach line current access fit first level cach oper delet buffer group buffer use random access high bandwidth disk sequenc heap data structur view classic extern memori algorithm would simpli use main memori size measur section indic larg binari heap insert buffer may slow match bandwidth fast parallel disk subsystem case better modifi sequenc heap ooptim cach main memori use special extern memori implement larger group may involv buffer disk block explicit asynchron io call perhap prefetch code random support parallel disk also number io may reduc use larger k insid extern group degrad perform loser tree data structur much insert anoth heap level ie split high degre group sever low degre group connect togeth suffici larg level group buffer anoth merg data structur delet nonminim element perform maintain separ sequenc heap delet element deletemin smallest element main queue deletequeu coincid discard herebi insert delet cost one comparison befor charg delet cost one insert two deletemin note latter much cheaper insert memori overhead kept bound complet sort queue whenev size queue delet element exce fraction size main queue sort oper delet key discard result sort sequenc put group gr sequenc delet heap empti then implement experi implement sequenc heap portabl c templat class arbitrari keyvaluepair current sequenc implement singl array perform sequenc heap mainli stem effici implement kway merg use loser tree special routin way way way merg binari heap insert buffer import optim turn roughli order make live compil use sentinel ie dummi element end sequenc heap save special case test loop unrol choos competitor author new code want demonstr use experimen talli great care must taken choos compet code use one best known algorithm least equal well tune chosen implicit binari heap align ari heap recent studi two algorithm outperform pointer base data structur splay tree skew heap factor two although latter two perform best older studi least need code insert buffer binari heap code perhap even care remain compon binari heap part code took care assembl code contain unnecessari memori access redund comput reason instruct schedul also use bottom heurist deletemin element first lift minpath root leaf leftmost element put freed leaf final bubbl up note binari heap heurist perform log comparison insert plu deletemin averag close lower bound flat memori hard find comparison base algorithm perform significantli better averag case input small queue binari heap factor two faster straightforward nonrecurs adapt textbook formul use cormen leiserson rivest align ari heap develop end use basic approach binari heap particular bottom heurist also use main differ data get align cach line complex index comput need sourc code avail electron httpwwwmpisbmpg desandersprogram basic experi although program develop tune sparc processor sequenc heap show similar behavior recent architectur avail measur run code sparc mip alpha intel processor even turn singl paramet set work well machin figur respect show result measur use random valu maxim heap size n oper sequenc insert deletemin insert deletemin insert deletemin n execut normal amort execut time per insertdeleteminpair tn divid log n sinc algorithm flat memori execut time c log n o constant c would expect curv hyperbol form converg tune k m perform improv around possibl eg ultra pentiumii better tinsertlog bottom binari heap bottom align ari heap sequenc heap fig perform sun ultra desktop workstat mhz ultra processor stlevel cach use sun workshop c option fast o tinsertlog bottom binari heap bottom align ari heap sequenc heap fig perform mhz mip r processor compil cc r tinsertlog bottom binari heap bottom align ari heap sequenc heap fig perform mhz decalpha processor compil g o tinsertlog bottom binari heap bottom align ari heap sequenc heap fig perform mhz intel pentium ii processor compil g o constant larg n valu shown averag least trial more small input avoid problem due limit clock resolut order minim impact process virtual memori manag warmup run made measur program run almost unload machin sequenc heap show behavior one would expect flat memori cach fault rare influenc execut time much section see decreas time per comparison quit strong input machin binari heap equal fast slightli faster sequenc heap small input heap still fit second level cach perform remain rather stabl even larger queue perform degrad acceler time per comparison grow linearli log n easi explain whenev queue size doubl anoth layer heap fit cach contribut constant number cach fault per deletemin sequenc heap time faster binari heap consid differ larg enough consider practic interest furthermor care implement algorithm make unlik perform differ revers tune use differ compil both binari heap sequenc heap could slightli improv replac index arithmet arithmet address offset would save singl registertoregist shift instruct per comparison like littl effect superscalar machin furthermor satisfactori perform binari heap small input show larg input time spent memori access overhead code detail littl influenc thi ari heap measur figur larg agre import observ lamarca ladner sinc number cach fault halv compar binari heap ari heap robust behavior larg queue still sequenc heap anoth factor faster larg heap sinc reduc number cach fault even more howev rel perform binari heap ari heap seem complic issu although main concern paper would like offer explan although bottom heurist improv binari heap ari heap binari heap profit much more now binari heap need less instead comparison ari heap concern instruct count ari exampl older studi heap loser tree may look bad compar pointer base data structur compil gener integ divis oper halv index integ multipl array index heap save memori write instruct need complic index comput appar alpha highest clock speed machin consid save write instruct shorten critic path index comput done parallel slow memori access spill code machin balanc turn direct partic ular intel architectur lack necessari number regist compil gener larg number addit memori access even larg queue handicap never made for confus effect jump execut time ari heap sparc n noth like observ machin effect hard explain cach effect alon sinc input size alreadi well beyond size second level cach suspect problem virtual address translat also haunt binari heap earlier version long oper sequenc worst case analysi predict certain perform degrad number insert much larger size heap n howev fig seen contrari true random key tinsertlog fig perform sequenc heap use setup fig use differ oper sequenc insert deletemin insert deletemin insert deletemin g essenti get heapsort overhead maintain useless group delet buffer fig use famili instanc n heap grow shrink slowli almost two time faster n reason new element tend smaller old element the smallest old element long remov befor therefor mani element never make group g let alon group larger sequenc sinc work perform empti group work save similar local effect observ analyz fishspear data structur binari heap ari heap properti they even seem get slightli slower local effect cannot work instanc come close worst case discuss sequenc heap may current fastest avail data structur larg comparison base prioriti queue cach extern memori particularli true queue element small need delet arbitrari element decreas key implement approach particular kway merg loser tree also use speed sort algorithm cach memori case sequenc heap still look promis need experi encompass wider rang algorithm usag pattern decid algorithm best exampl monoton queue integ key radix heap look promis either simplifi averag case effici form known calendar queue adapt extern memori radix heap cach memori order reduc cach fault outlin algorithm adapt multipl level memori parallel disk share memori multiprocessor also possibl achiev moder speedup parallel eg one processor insert delet buffer one group refil group buffer processor collect work empti group acknowledg would like thank gerth brodal andrea crauser jyrki katajainen ulrich meyer valuabl suggest ulrich rude univers augsburg provid access alpha processor r buffer tree new techniqu optim ioalgorithm simpl random mergesort parallel disk calendar queue fast o prioriti queue implement simul event set problem introduct algorithm perform ledasm effici prioriti queue extern memori extern heap combin effect buffer prioriti queue algorithm comput architectur quantit ap proach empir comparison priorityqueu event set implementa tion superscalar alpha processor outoford execut art comput program sort search influenc cach perform heap influenc cach perform sort first draft report edvac tpie user manual refer extern memori algorithm algorithm parallel memori i two level memori extern heapsort tr empir comparison priorityqueu eventset implement calendar queue fast prioriti queue implement simul event set problem extern heapsort bottomupheapsort new variant heapsort beat averag quicksort if italicnital small fishspear prioriti queue algorithm influenc cach perform heap simpl random mergesort parallel disk influenc cach perform sort worstcas externalmemori prioriti queue buffer tree access multipl sequenc set associ cach experiment studi prioriti queue extern memori extern memori algorithm ctr peter sander present data experi algorithm experiment algorithm algorithm design robust effici softwar springerverlag new york inc new york ny roman dementiev peter sander asynchron parallel disk sort proceed fifteenth annual acm symposium parallel algorithm architectur june san diego california usa jame d fix setassoci cach perform search tree proceed fourteenth annual acmsiam symposium discret algorithm januari baltimor maryland joonsang park michael penner viktor k prasanna optim graph algorithm improv cach perform ieee transact parallel distribut system v n p septemb bernard m e moret david a bader tandi warnow highperform algorithm engin comput phylogenet journal supercomput v n p may gerth stlting brodal rolf fagerberg kristoff vinther engin cacheoblivi sort algorithm journal experiment algorithm jea