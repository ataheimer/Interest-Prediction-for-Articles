t optim queri object updat a objectori databas oodb provid power data abstract model facil usual lack suitabl framework queri process optim even though increas number recent propos oodb queri optim actual focus queri optim presenc object ident destruct updat featur often support realist oodb languag paper present formal framework optim objectori queri presenc side effect queri may contain object updat place form present languag extens monoid comprehens calculu express objectori featur give formal mean extens method base denot semant often use give formal mean imper program languag semant languag extens express term monoid calculu without need fundament chang basic framework method maintain referenti transpar allow us meaning queri optim also practic optim oodb queri sinc allow optim techniqu appli regular queri use minim chang oodb queri updat b introduct one key factor oodb system success compet relat system well meet perform requir mani nontradit applic develop effect queri optim even though mani aspect oodb queri optim problem benefit the alreadi success relat queri optim research mani key featur oodb languag make problem uniqu hard solv featur includ object ident method encapsul userdefin type constructor larg multimedia object multipl collect type arbitrari nest collect nest queri express increas number recent propos oodb queri optim focus handl nest collect ow col other convert path express join km cd other unnest nest queri cmb cma other focus handl encapsul method dgk howev propos queri optim presenc object ident destruct updat featur often support realist oodb languag earlier work fm fmb fma propos effect framework solid theoret basi optim oodb queri languag calculu call monoid comprehens calculu alreadi shown captur featur odmg oql cat good basi express variou optim algorithm concis includ queri unnest feg translat path express join feg paper extend framework handl object ident object updat object complic queri optim objectori program base sideeffect is modif object store even though modern oodb provid declar queri languag associ access data queri languag allow invok method includ perform side effect object creation itself common oodb queri side effect sinc insert new object class extent consid exampl follow oql queri select personenameeaddress e employe creat new person employe even though queri seem free side effect first glanc not modifi extent class person insert new person queri part anoth queri queri scan extent class person extent would modifi accordingli use outer queri therefor semant queri must reflect fact person extent modifi execut queri failur may result incorrect optim may lead invalid execut plan problem assign semant objectori queri becom even wors allow object state modif arbitrari place queri like oodb languag do exampl oql queri select esalari esalari e employe esalari give rais employe earn semant queri reflect fact salari modifi iter situat queri mix freeli updat occur frequent oodb languag o ag support set iter embed comput complet program languag even though languag begin disappear favor declar languag oql surg interest provid comput power exist declar queri languag without sacrif perform consid exampl follow o queri taken ld d divis e employe suchthat edivisiond f totpay type queri allow kind c code insid forloop includ code modifi databas earlier research queri optim ld shown queri form hard optim anoth problem consid set bag combin side effect result may unpredict due commut exampl follow o queri e employe valu x end execut program would depend way employe scan understand extent problem consid function fn contain assign xn bodi return n valu x execut ff fg sinc fx is ff fg equal ff fg given side effect may appear place program prove equival oodb express becom hard make task express verifi optim rule difficult accomplish exampl well known transform x x term x y valid sinc x may queri perform side effect order execut side effect would chang transform appli thu chang semant program one way patch error attach guard transform rule prevent execut term x contain side effect unfortun approach conserv may miss optim eg side effect x interfer other furthermor fundament problem algebra oper side effect exampl x cannot appear valid translat declar queri sinc declar queri defin execut order consequ optim realist oodb queri languag need address problem object ident properli handl implicit explicit side effect due use object ident also highli desir use exist optim techniqu minim chang possibl so necessari captur handl object ident framework regular queri side effect unfortun extens difficult incorpor exist optim framework understand level difficulti consid follow equal predic personsmithpark predic must evalu fals sinc left object differ ident right one hand given function gx comput predic xx function call gpersonsmithpark av return true unfold call g get previou fals express consequ substitut bodi function definit function call valid transform more goal give formal mean oodb queri side effect importantli provid equat theori allow us meaning queri optim highli desir theori seamlessli incorpor monoid comprehens calculu possibl discov new monoid captur mean object ident anoth goal is whenev object updat queri would like queri treat way current treat basic optim without object extens approach paper present framework incorpor impur featur name object ident monoid comprehens calculu accord earlier discuss import give semant extens preserv referenti transpar referenti transpar abl substitut equal subexpress context larger express give equal result rea queri languag lack properti transform rule queri optim would depend context express appli research program languag often use formal method denot semant solv problem denot semant approach impur featur languag captur pass state here object store oper program piec program updat state state propag is otherwis modifi reflect updat say the state modifi mean new copi state creat approach may becom quit ineffici destruct updat matter small is new object store ie entir databas must creat obvious techniqu unaccept databas applic solut problem allow state manipul small number primit preserv referenti transpar effici implement well specif even though primit defin pure function way implement perform destruct updat state way deriv effici program and importantli maintain referenti transpar allow us meaning queri optim catch here solut work state singlethread sch roughli speak state singlethread program program undo state modif point is strict sequenc state updat program case state replac access right singl global variabl state oper made caus side effect preserv oper properti follow exampl non singlethread program assum x x statement assum execut statement local is state modif use exclus discard thu valu x complet program respect sinc bind x discard use yx statement requir local copi state execut probabl form stack state handl nest assum statement sinc need backtrack previou state complet execut rollback databas transact anoth exampl non singlethread oper two common way guarante singlethreaded first allow state manipul languag detect violat singlethreaded perform semant analysi ie kind abstract interpret sch use linear type system ss detect violat typecheck second approach adopt framework restrict syntax languag way state guarante alway singlethread anoth seriou problem mention denot semant approach pass state oper program need sequenti oper restrict good idea commut oper sinc may miss optim opportun exampl rang r assign x r evalu scan r two way one set x end depend way r scan solut valid consid optim address problem gener possibl solut gener altern first stage optim select best one end by perform cost analysi even though approach may gener exponenti number solut appli constant data practic so provid queri contain larg number union oper altern solut correspond typic differ final databas state end one solut chosen optim collect semant queri queri collect possibl correct answer decid consid solut instead report error one solut exist use program fall categori consid altern queri optim necessari prove program equival such prove ff fg equal ff fg plan gener phase ie optim complet select altern framework inspir ohori work repres object ident use monad oho contribut mix state transform set bag appli theori databas queri languag satisfi strong normal properti normal remov unnecessari state transform thu make approach practic optim program objectori calculu import contribut work develop method map program state transform cannot remov normal imper loop much way one could express program use regular imper languag c result program effici written hand rest paper organ follow section describ earlier result monoid comprehens calculu section describ object extens monoid calculu section propos new monoid captur object ident side effect section describ framework handl object ident use denot semant section address practic consider build optim base framework section present prototyp implement framework final section extend framework captur databas updat discuss theori appli solv view mainten problem background monoid comprehens calculu section summar earlier work monoid calculu formal treatment present elsewher fm fmb fma monoid calculu base concept monoid abstract algebra monoid type pair phi z phi phi associ function type theta t ie binari function take two valu return valu call accumul merg function monoid z phi type call zero element monoid left right ident phi is zero element satisfi z phi phi everi x sinc accumul function uniqu identifi monoid often use accumul name monoid name exampl monoid includ f g set ffgg bag list max integ fals true boolean monoid integ boolean call primit monoid construct valu primit type set bag list monoid call collect monoid collect monoid phi z phi requir addit definit unit function u phi which along merg zero allow us construct possibl valu type exampl unit function set monoid x fxg is take valu x input construct singleton set fxg output list monoid commut ie satisfi x phi y addit max idempot ie satisfi x phi monoid comprehens monoid phi take form phif e j r g express e call head comprehens term r term sequenc call qualifi either gener form v e v rang variabl e express the gener domain construct collect filter p p predic use shorthand f e j r g denot set comprehens f e j r g monoid comprehens defin follow reduct rule omega collect monoid possibl differ phi ae u phi e phi collect monoid e otherwis d rule d d reduc comprehens leftmost qualifi filter rule d d reduc comprehens leftmost qualifi gener letstat d bind v e use bind everi free occurr v phif e j r g calculu semant wellformed requir comprehens idempot commut monoid gener idempot commut monoid exampl valid monoid comprehens sinc map set monoid which commut idempot list monoid which neither commut idempot fx j x ff gg g valid sinc commut requir easili check compil time restrict set monoid comprehens equival set monad comprehens bl captur precis nest relat algebra fmb oql express direct translat monoid calculu exampl oql queri select distinct hotelpric hotel select h c citi h chotel exist r hotelroom rbed hotelnam select tname state sattract translat follow comprehens f hotelpric hotel f h c citi h chotel cnamearlington g f rbed num r hotelroom g use shorthand x j u repres bind variabl x valu u mean construct given follow reduct eux express e u substitut free occurr x ie eux equival let addit syntact sugar allow irrefut pattern place lambda variabl rang variabl variabl bind pattern like compil away use standard pattern decomposit techniqu pj exampl equival f afst asndfst retriev firstsecond element pair anoth exampl x function take three paramet return sum equival a afst asndfst monoid calculu put canon form effici rewrit algorithm call normal algorithm evalu canon form gener produc fewer intermedi data structur initi unnorm program moreov normal algorithm improv program perform mani case gener mani optim techniqu alreadi use relat algebra fuse two select one select follow import rule normal algorithm reduct n pred j r idempot phi n sound normal rule prove use definit monoid comprehens fm rule n flatten comprehens contain gener whose domain anoth comprehens it may requir variabl renam avoid name conflict rule n unnest existenti quantif exampl previou oql queri normal into cnamearlington rbed num snametexa tnamehnam g appli rule n unnest two inner set comprehens rule n unnest two existenti quantif object monoid calculu section monoid calculu extend captur object ident extend calculu call object monoid calculu exampl one valid objectori comprehens first creat list contain two new object new new then variabl x rang list state x increment one by x x x refer object x x return state object x result comput list objectori comprehens translat state transform propag object heap which contain bind object ident object state oper express chang oper creat new object modifi state object translat captur precis semant object ident without need extend base model also provid equat theori allow us valid optim objectori queri introduc new type constructor objt captur object state repres valu type addit extend monoid calculu follow polymorph oper oho in style sml pau ffl new type objt oper news creat new object state s ffl type objt t oper e derefer object e it return state e ffl type objt t bool oper e chang state object e return true mani objectori languag differ way construct manipul object exam ple oql use object constructor creat object requir explicit object dereferenc oper languag featur easili express term primit mention abov give formal semant primit better choic sinc deal detail object class inherit etc optim real objectori languag though detail address properli objectori oper may appear place monoid comprehens follow exampl comprehens object oper call object comprehens recal v j e defin new variabl name v synonym valu e e e chang state object whose oid equal valu e result e true first exampl indic differ object distinct second exampl indic object may equal state ninth exampl comput cardin set f indic duplic set count last exampl interest one sinc order set f g mani result permut set name f g f g f g f g f g f g consid result valid optim construct plan end gener one result onli practic exampl queri edepart emanagerdepart g set depart employe depart employe manag state transform monoid one way handl side effect denot semant map term comput valu type function type t theta s type state side effect take place is term type map function take initi state type input gener valu type new state denot semant function type theta s call state transform wad wad term perform side effect state transform map differ state reflect chang otherwis state remain unchang exampl constant integ map state transform s s propag state is note new state comput valu well may depend input state way side effect captur pure function map state new state unfortun add side effect calculu program may multipl interpret mainli due commut monoid result nondeterminaci highli desir captur interpret let optim select best one end handl type nondetermin function way given input state state transform must abl return multipl valu multipl state word must abl return multipl valuest pair consequ state transform type sett theta s captur possibl interpret program transform state transform phit type state type show shortli given monoid phi type alway defin primit monoid phi state transform phit contrast monoid describ earlier monoid must higherord monoid ie instanc monoid function definit phi describ import prove correct variou transform rule safe skip reader interest proof first present simpl definit work well noncommut nonidempot monoid extent captur monoid transform monoid state transform monoid monoid phi z phi primit monoid phi z phi defin follow is z phi function that appli state type s construct valu fz phi sg merg function phi propag state first state transform second merg result valu use phi easi prove n state monoid comprehens simpli monoid comprehens state transform monoid exampl f s fv sg j v g s s f sg state type suppos state integ count list element follow state comprehens increment element list use state count list element f s fv s state transform monoid phi effect must properti monoid phi otherwis may introduc semant inconsist is phi commut idempot must phi captur properti redefin phi behav way phi f g defin follow ae phi commut f g otherwis ae g is phi commut oe phi oe two interpret one propag state oe oe oe oe thi contribut factor g phi idempot element x remov x phi evalu exampl integ state count set element have fz phi sg els g propag state right left equal ffg g is counter count list element onc even though appear twice prove appendix theorem that extens phi valid monoid also compat phi monoid ie phi commut andor idempot phi captur object far discuss state type s be inde type wish captur databas updat exampl state would entir databas here though interest captur object ident state state transform captur object ident view pair l n oho valu l call object store map object type ie instanc type objt valu type is map oid object state integ n counter use comput next avail oid four primit manipul state follow type lookup ref n map integ n oid refer object type emptystor initi object store valu without object ext l o v extend object store l bind oid state valu v lookup l o access object store l retriev state object oid o exampl lookup int ext int l ref int ref int return state object of type objint oid abov primit satisfi follow equival ext ext lookup lookup figur present denot semant import construct monoid calculu without object extens ie without new without object extens state figur denot semant monoid calculu use state transform propag is chang semant object extens form nonstandard interpret given later equat semant bracket give mean syntax enclos bracket term pure monoid comprehens calculu type domain typecorrect term object monoid calculu monotyp a nonfunct type gener e type t type e denot defin follow recal also state type pair l n conveni use notat l n whenev either compon l n need access rule s figur handl function term exampl translat fv fv g sg appli state s rule s assum callbyvalu interpret rea e ee evalu e appli rule s s translat monoid comprehens rule s use monoid comprehens monoid phi propag state everi element collect u notic comprehens head state transform state transform merg use phi comprehens valid type collect u sinc monoid phi compat monoid phi higherord comprehens necessari sinc term u may modifi object store time new object construct case though state propag chang chang follow rule appli elimin state propag the correct rule straightforward omit follow rule give denot semant object extens oper new take avail oid n use oid new object state e addit object store extend bind ref n state valu rule s instead destruct chang object store extend store new bind oid left part valu right part rule s simpli look object store request oid appendix provid proof theorem theorem indic that state modif oper calculu output state input state canon form deriv normal similar canon form get pure monoid calculu theorem basic guarante that even though state transform sequenti oper program perform state modif normal algorithm remov unnecessari state transform follow exampl translat normal term object monoid calculu where state l n interest exampl increment element set integ of type setobjint set cardin express help counter x support bag set object without inconsist exampl ffnew newgg valid express equal ffnew newgg similarli assign freeli move insid set construct translat object comprehens effici program seen previou section objectori comprehens express term basic monoid comprehens calculu use denot semant rule figur result program usual ineffici sinc manipul state even state use all ineffici reduc help normal algorithm algebra equal object primit rule o o fact part result program normal firstord program look similar program one might write use four object primit directli section focus effici execut program cannot reduc firstord program normal algorithm translat object monoid calculu basic calculu consid possibl altern due commut oper absolut necessari prove program equal normal complet algebra equal use check program equival optim safe discard one altern follow function choos select random altern practic choic made help cost function given program p object calculu initi state system evalu choosenormalizep is p first translat normal final altern select which pair valu state choos function defin follow rule figur guarante alway least one choic case miss rule choos altern state monoid comprehens state monoid comprehens cannot remov normal algorithm effici implement comprehens crucial consid system perform default implement state monoid comprehens loop creat state transform ie function iter compos state transform use merg function state transform monoid approach obvious ineffici would like find better algorithm evalu state comprehens faster one possibl solut actual compil comprehens loop updat like one found imper languag particular choos phif s e j v r g translat follow loop in pascallik syntax initi state re z phi initi result valu v r retriev one possibl valuest pair re re phi xfst updat result xsnd updat state return exampl previous shown set cardin translat follow state monoid comprehens map follow loop re r f re maxr lookupl refn return re l n even though loop right function still ineffici sinc manipul object store l everi step loop result program implement effici store global array object primit program directli manipul global array rule s s singlethread sinc object creation undon point rule s enforc singl array pointer fetch state first use lookup return pointer l consequ alway one pointer store therefor store implement global store updat inplac destruct updat primit oper object store done destruct specif let store global array mention whose domain element type eg store defin void c object primit implement follow lookup implement s evalu statement order return e exampl lookup ext ext s x a implement result program state transform evalu effici real objectori program exampl previou loop correspond set cardin becom re r f re maxresstoren return use global array implement object primit implement alreadi built prototyp implement framework translat oodb queri shown paper gener program sourc code avail at httpwwwcseutaedufegarasoid follow exampl illustr translat five object queri system notat use exampl littl bit differ use theoret framework execut statement sequenc return valu v loopiteratex execut statement valu x x accessn return valu storen updaten v evalu storen v everi object queri type translat express type theta void theta int valu return valu void valu correspond state ignor int valu new oid counter we assum valu oid counter execut queri equal n exampl object queri e contain object oper translat would pairepairnulln pair construct pair two valu null type void assignr loopiteratee assignresmaxresplusaccessn assignspairblockupdatenplusaccessnenullsnd assignestructbindnameprojectderefenam assignr loopiterateeemploye assignresplusresifgtprojectaccessesalari assignsifgtprojectaccessesalari bindsalarytimesprojectaccessesalari snd figur denot semant databas updat first queri new assign storen the store next avail oid set n n return old valu n second queri execut storex storex third queri correspond f x gener block contain storen the old valu storen the new valu execut sequenc fourth queri gener state monoid comprehens which turn translat loop return sum element e last queri give rais employe earn return number employe got rais for simplic assum employe name salari onli databas updat view mainten monoid state transform also use express destruct databas updat term basic algebra way databas updat queri optim singl framework let db current databas state let db type typic db aggreg persist object applic follow analysi previou section want translat updat monoid algebra way propag state ie entir databas singlethread databas updat captur use state transform propag occasion chang entir databas is updat captur pure function map exist databas new databas make approach practic defin set updat primit express updat similar one object updat primit even though pure interpret effici implement approach requir signific extens formal framework normal queri optim use improv perform databas updat express use follow comprehens qualifi feg qualifi path u destruct replac valu store path u qualifi path u merg singleton u path qualifi path u delet element path equal u qualifi fundament construct sinc two defin follow path u j path u phi u phi path path u j path phif j apath ug exampl comprehens chotel num g insert new hotel arlington increas total number hotel denot semant express e may contain updat ae bind list bind rang variabl current databas state rule s s figur need slightli modifi includ bind list ae everi map exampl rule s figur map rule s figur rule s figur though map rule s figur chang ae includ bind v the rang variabl v the gener domain bind list ae use rule s give semant updat qualifi express reconstruct databas state copi compon except one reach path replac v defin follow aev type phi t type path possibl empti path a sequenc project express sdbaev replac occurr db aev s second rule appli state collect type third rule appli state record second rule use condit forc comprehens reconstruct collect valu replac element v bound updat new valu e exampl point updat chotel previou exampl bind list ae bind c dbciti case predic guarante hotel citi c ie arlington chang one implement ppath ae v path v destruct modifi part databas reach path v better that explain introduct motiv use denot semant simpli give formal mean destruct construct use semant actual translat construct and importantli use translat queri optim so need defin invers function is ppath ppath function need translat updat program optim invers function is need gener destruct updat optim given reconstruct state s say copi except number place new valu v use instead is gener list destruct updat form path v composit ppath construct state function ie defin follow list concaten exampl return chotel e origin updat approach first semant program given term state transform ppath state reconstruct expand then normal queri optim take place elimin unnecessari updat final reconstruct state transform number destruct updat databas use ie leav futur work demonstr framework effect framework handl object updat optim framework destruct updat also use handl view mainten problem gm ckl gener form view function f databas state db valu domain materi view v fdb store view f databas compon v recogn case v use directli instead comput possibl expens view f queri becom easier queri normal unnest sinc unnest flatten queri databas updat new databas becom udb u function interpret updat thu view mainten problem equival express fudb term materi view v thi view recognit problem mention abov transform updat primit fudb appli v instead db easili attain express state transform term updat primit normal result form way fudb comput new materi view term old one v appli techniqu use databas updat new materi view fudb gener effici use destruct updat v plan show futur research framework requir minim extens basic framework practic effect well conclus present formal framework handl object updat oodb queri optim even though framework appli monoid comprehens calculu adapt work optim framework mani type object manipul construct express term basic languag construct use denot semant consequ queri optim applic basic languag construct use minim chang remov ineffici due composit way translat program denot semant if addit implement object store primit use side effect result program evalu effici program written hand acknowledg author grate david maier help comment paper work support part nation scienc foundat grant iri ii r rational design persist queri process facil databas program languag comprehens syntax object databas standard odmg gener framework optim objectori queri effici evalu aggreg bulk type nest queri object base recurs algebra queri optim nest relat support multipl view mainten polici queri optim revel uniform calculu collect type experiment optim oql queri unnest objectori databas algebra framework physic oodb design toward effect calculu object queri languag optim object queri use effect calculu mainten materi view problem advanc queri process object base use access support relat transformationbas approach optim loop databas program languag repres object ident pure function languag key method nest relat databas manag system ml work programm peyton jone element function program detect global variabl denot specif extend function databas languag updat complet comprehend monad essenc function program tr detect global variabl denot specif recurs algebra queri optim nest relat comprehend monad advanc queri process object base use access support relat rational design persist queri process facil databas program languag o queri optim revel overview repres object ident pure function languag ml work programm element function program transformationbas approach optim loop databas program languag gener framework optim objectori queri essenc function program comprehens syntax toward effect calculu object queri languag support multipl view mainten polici queri unnest objectori databas optim object queri use effect calculu key method nest relat databas manag system extend function databas languag updat complet algebra framework physic oodb design ctr hiroaki nakamura increment comput complex object queri acm sigplan notic v n p g m bierman formal semant analysi object queri proceed acm sigmod intern confer manag data june san diego california leonida fegara david maier optim object queri use effect calculu acm transact databas system tod v n p dec