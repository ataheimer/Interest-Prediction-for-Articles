t unifi approach goaldirect evalu a goaldirect evalu embodi icon snobol built notion backtrack gener success result therefor alway someth challeng specifi implement articl address challeng use comput monad partial evaluationw consid subset icon specifi monad semant list monad consid spectrum monad also fit bill relat other exampl deriv continu monad church encod list monad result semant coincid gudeman continu semant iconw compil icon program special interpret ie use first futamura project use typedirect partial evalu variou back end includ runtim code gener gener ml code c code ocaml byte code bindingtim analysi partial evalu continuationbas interpret automat give rise c program coincid result proebst optim compil b introduct goaldirect languag combin express yield multipl result backtrack result gener one time express either succeed gener result fail express fail control pass previou express gener next result ani so control pass back origin express order tri whether succeed time goaldirect program specifi order subexpress retri thu provid programm succint power controlflow mechan wellknown goaldirect languag icon backtrack languag featur complic semant impl mentat gudeman give continu semant goaldirect languag continu also use implement languag control structur similar goaldirect evalu prolog proebst townsend implementor icon compil java observ continu compil ecient code nevertheless dismiss they notori dicult under stand target languag directli support them p instead compil base translat scheme propos proebst base fourport model use describ control flow prolog icon express translat flowchart languag condit direct indirect jump use templat subsequ optim which amongst thing reorder code perform branch chain necessari produc compact code refer implement icon compil icon byte code byte code execut interpret control control flow keep stack express frame articl present unifi approach goaldirect evalu consid spectrum semant small goaldirect languag relat deriv semant gudeman instanti one gener semant base comput monad unifi approach enabl us show equival dierent semant simpli systemat furthermor abl show strong conceptu link dierent semant continu semant deriv semant base list stream result churchencod list stream respect link semant implement semanticsdirect compil use partial evalu particular bindingtim analysi guid us extract templat special interpret templat similar proebst partial evalu give rise similar flowchart program demonstr templat good ideathey intrins semant icon provabl deriv rest paper structur follow section first describ syntax monad semant small subset icon instanti semant variou monad relat result semant other present equival proof two them section describ semant direct compil goaldirect languag section conclud semant subset icon intuit explan goaldirect evalu given term list listmanipul function consequ introduc subset icon treat paper defin monad semant term list monad show also stream monad two dierent continu monad use give exampl prove equival result monad use monad morphism subset icon program languag consid follow subset icon intuit icon term either fail succe valu succe subsequ resum case either succeed fail process end express fail inform succe valu succe sum subexpress e e call succe valu e subsequ resumpt yield rest integ valu e point succe valu e larger valu produc result produc result e gener nest exampl icon term gener result express concaten result function languag scheme ml haskel achiev eect icon term use function map concat exampl defin fun ml evalu concat map to list integ produc icon term monad semant comput monad introduc structur denot semant basic idea parameter semant monad mani languag ex tension ad store except carri simpli instanti semant suitabl monad further correspond join figur monad oper type standard monad oper unit join l join l l special oper sequenc empti empti l empti l append l figur list monad proof semant aris instanti dierent monad conduct modular way use concept monad morphism monad also use structur function program term program languag monad describ unari type constructor three oper unit map join type display figur oper socal monad law hold section give denot semant goaldirect languag describ section anticip semanticsdirect compil partial evalu describ semant term ml eect defin interpret semant int parameter monad m m repres sequenc valu type xjoin els append unit i to i figur monad semant subset icon monad sequenc order handl sequenc structur need addit three gener monad oper display figur add three oper empti append here empti stand empti sequenc empti discrimin function that given sequenc two addit input return first input sequenc empti return second input otherwis append append two sequenc straightforward instanc monad sequenc list monad l display figur list join sometim also call flatten or ml concat monad semant monad semant goaldirect languag describ section given figur explain semant term list monad liter interpret express yield exactli one result consequ map singleton list i use unit semant to given term bind function type int int int list type function bind l list list list ie take two list contain valu type function map list valu type eect definit bind l f xs ys map f x ys x xs flatten result list list step found exampl end section eect goaldirect evalu achiev ml use list spectrum semant follow describ four possibl instanti semant given figur semant correspond directli interpret thu creat four dierent interpret listbas interpret instanti semant list monad figur yield listbas interpret eager languag ml listbas interpret alway comput result behavior may desir situat first result interest or matter whether exist result consid exampl condit examin whether given express yield least one result fail altern use lazi streambas interpret implement list monad figur lazi languag result monad finit lazi list correspond interpret gener one result time eager languag eect achiev explicitli implement data type stream ie finit list built lazili thunk use delay comput definit correspond monad oper straightforward continuationbas interpret gudeman give continuationbas semant goaldirect languag deriv semant instanti monad semant continu monad c defin figur typeconstructor c continu monad defin r r r call answer type continu conceptu link list monad continu monad answer type list list made church encod higherord represent list propos hugh hugh observ construct partial appli concaten function ys xs ys rather list xs list append constant time result represent empti list correspond function append ele ment ie ident wherea function append singl element standard monad oper unit join special oper sequenc empti c empti c xs ys append c figur continu monad repres partial appli con function con churchencod data type mean abstract selector function case con result represent list type inde correspond c answer type notic nil con list represent yield empti c unit c respect similarli remain monad oper correspond usual list oper figur display definit oper inlin result express reduc interpret explicit success failur continu tailrecurs implement continuationbas interpret icon use explicit success failur continu result interpret icon express type int first argument success continu second argument failur continu note success continu take failur continu second argument failur continu determin resumpt behavior icon term success continu may later appli c els figur continu semant failur continu gener result correspond continu monad c standard monad oper continu monad display figur sequenc oper empti empti c xs ys append continu monad figur conceptu link list monad present continu monad link stream monad church encod data type stream x fact second compon stream thunk suggest one give selector function type int result type end x xs int choos result type selector function yield type continu monad answer type interpret defin semant start point semanticsdirect compil describ section figur display definit monad oper inlin result express reduc basic monad oper c c semant base c c dier definit leq handl jto c els figur semant success failur continu correct far relat variou semant present section con ceptual four dierent interpret present section creat instanti one parameter semant dierent monad formal correspond proof conduct modular way build concept monad morphism n two monad h m n monad morphism preserv monad oper ie follow lemma show semant result two dierent monad instanti relat defin monad morphism two sequenc monad question n monad sequenc specifi section h monad morphism n everi icon express e strengthen definit monad morphism somewhat consid sequenc preserv monomorph also preserv monad oper specif monad sequenc proof induct structur e lemma eect shown induct use lemma show listbas interpret section continuationbas interpret section alway yield compar result proposit let show c l defin show unit l x xs empti l show express e proof show h l c defin unit c x h xs monad morphism l c function show h ident function list proposit follow immedi lemma conclus take intuit listbas semant subset icon start point defin streambas semant two continu semant init semant defin instanti monad semant list monad semant defin stream monad two dierent continu monad respect modular monad semant allow us relat semant relat correspond monad conceptu formal best knowledg conceptu link listbas monad continu monad via church encod observ befor known continu compil ecient code rel easili follow section show partial evalu su cient gener ecient code continu semant deriv section semanticsdirect compil goal partial evalu special sourc program two argument fix static argument s result residu program must yield result appli dy namic argument origin program appli static dynam argument ie p interest partial evalu due use semanticsdirect com pilat sourc program p interpret static argument term domain p p compil version repres implement languag p often possibl implement interpret function languag base denot semant start point function interpret implement denot semant figur sourc languag interpret shown figur section present icon interpret written ml section use typedirect partial evalu special interpret icon term yield ml code c code ocaml byte code output partialevalu techniqu could appli yield essenti result structur struct datatyp icon icon plu icon icon leq icon icon icon icon icon figur abstract syntax icon term typedirect partial evalu use typedirect partial evalu compil icon program ml standard exercis semanticsdirect compil use typedirect partial evalu typedirect partial evalu approach olin special higherord program use normal function map valu trivial special program dp d text the target program input typedirect partial evalu bindingtim separ program static dynam primit separ implement ml sourc program conveni wrap functor parameter structur dynam primit functor instanti evalu primit for run sourc program residu primit for special sourc program special icon term use typedirect partial evalu case dynam primit oper addit add integ comparison leq fixedpoint oper fix condit function cond quot function qint lift static integ dynam domain signatur primit shown figur residu primit let partial evalu produc function gener ml program meaning variabl name parameter interpret shown figur main function eval take icon term two continu re re yield result type re intend special interpret static icon term keep continu paramet k f dynam consequ residu program parameter two continu if continu also consid static residu program would simpli list gener integ signatur type tunit type tint type tbool type re val qint int tint val add tint tint tint re val fix tint re tint re tint re figur signatur primit oper output typedirect partial evalu text residu program residu program long betaeta normal form is contain beta redex fulli etaexpand respect type exampl follow result special interpret respect icon fix fn loop fn cond leq i qint fn loop add i qint qint struct fun loop i pfix fn walk pcond pleq i j fn _ walk padd i pqint fun select i pcond pleq i j fn _ k j f f fun sum i fun eval lit i eval toe eval e fn eval e fn j loop i eval pluse eval e fn eval e fn j sum i eval leqe eval e fn eval e fn j select i eval ife e eval e fn _ fn _ eval e k f fn _ eval e k f figur parameter interpret avoid code duplic result special interpret figur may exponenti larg due continu paramet k duplic claus if exampl special interpret icon term yield follow residu program context cond leq qint qint code duplic wellknown problem partial evalu equal wellknown solut bind continu residu program use introduc new primit save two argument k g appli g two copi continu k signatur re val save succ succ succ re re final claus interpret modifi save continu paramet proce follow fun eval lit i eval ife e save k fn k k eval e fn _ fn _ eval e k f fn _ eval e k f special new interpret icon term yield follow residu program context add occur onc save fn v fn resum k add qint v fn resum fn k_ k_ cond leq qint qint two copi continu paramet k bound k k continu use twice bodi second lambda order prevent code duplic pass one copi continu paramet actual enough translat c introduc section use two dierent name variabl case k_ k_ determin ifbranch insid continu appli gener c program residu program long betaeta normal form type tint tunit re re tunit re re impos restrict residu program must take two argument success continu re failur continu re must produc valu type re also consid type primit may occur residu program see valu type re result appli success continu k integ n function type tunit re appli failur continu f appli primit cond boolean two function type tunit re appli primit fix function two argument loop n re tint integ insid function pass fix appli function loop n integ appli primit save two argument first function two argument vn tint resumen tunit re second function pair argument k type tint tunit re re insid first function pass save appli function resumen insid second function pass save appli one function n integ function type tunit re similar analysi appli valu type tint aris evalu integ n variabl variabl vn appli add two argument type tint result observ residu program special icon interpret use typedirect partial evalu restrict grammar figur the restrict variabl loop n vn resum n must occur insid function bind cannot express use contextfre grammar problem develop express grammar ml datatyp use datatyp repres output typedirect partial evalu thu essenti use type system ml theorem prover show follow lemma lemma residu program gener appli typedirect partial evalu interpret figur gener grammar figur idea gener grammar residu program studi by eg malmkjr use runtim special tempo gener code templat f cond e fn s fn s fix fn loop n fn s e loop n e save fn vn fn resumen resum n vn add e e leq e e figur grammar residu program simpl structur output program allow view program flowchart languag choos c concret exampl languag figur show translat residu program c program translat replac function call jump except call resum n which occur result compil ifstat name function uniqu determin correspond label jump to jump resum n end two dierent place correspond two copi continu use boolean variabl gate n distinguish two possibl destin call loop n kn pass argument name formal paramet known i n vn respect therefor argument pass assign variabl jump translat condit new label l must gener entir translat term must wrap context defin label succ fail correspond initi continu statement follow label succ allow jump resum translat figur gener c program success print produc integ one one lemma eect translat residu ml program c semant preserv would requir give semant c subset ml present figur show equival exampl consid icon exampl translat follow c program loop i goto l goto fail goto succ succ printfd valu goto resum goto succ resum s f cond e fn s fn e e goto l l s fix fn loop n fn s e goto loop save fn vn fn resumen s succn s resumen goto resum gate goto resum figur translat residu program c statement qint figur translat residu program c express resum goto loop succ printfd valu goto resum c target program correspond target program proebst optim templatebas compil eect automat gener flowchart program denot icon term gener byte code previou two section develop two compil icon term one gener ml program one gener flowchart program section unifi two compos first compil third author automat runtim code gener system ocaml compos second compil handwritten compil flow chart ocaml byte code runtim code gener ocaml runtim code gener ocaml work deforest composit tradit typedirect partial evalu compil ocaml byte code deforest standard improv runtim code gener such remov need manipul text residu program special time result instead gener ml term runtim code gener allow typedirect partial evalu directli gener execut ocaml byte code special icon interpret figur icon use runtim code gener yield residu program bytecod instruct function implement closur call implement tailcal compil residu ml program use ocaml compil yield bytecod instruct compil flow chart ocaml byte code modifi translat figur produc ocaml bytecod instruct instead c program result embed icon ocaml use yield bytecod instruct function implement label block call implement assign if argument pass follow jump style target code promot steel first compil scheme conclus translat continuationbas denot semant interpret written ml use typedirect partial evalu enabl standard semanticsdirect compil icon term ml compil residu program c yield flowchart program correspond produc proebst icon compil conclus issu observ list monad provid kind backtrack embodi icon specifi semant icon parameter monad consid altern monad proven also provid fit semant icon inlin continu monad particular yield gudeman continu semant use partial evalu special interpret respect icon program therebi compil program use first futamura project use combin typedirect partial evalu code gener either ml c ocaml byte code gener code c particular yield result similar proebst compil gudeman show continu semant also deal addit control structur state expect diculti scale codegener accordingli monad list hand oer enough structur deal eg state possibl how ever creat rich enough monad combin list monad monad state monad observ tradit in partial evalu gener success continu avoid code duplic proebst present problemat compil also studi result defunction continu a la reynold obtain stackbas specif correspond runtim architectur acknowledg thank due anonym refere comment andrzej filinski discuss work support esprit work group appsem httpwwwmdchalmerssecsresearch semanticsappsem r compil continu understand control prolog program implement prolog function program calculi lambdaconvers tutori note partial evalua tion gener approach runtim special applic c repres layer monad icon program lan guag implement icon program languag denot semant goaldirect languag repres control presenc firstclass continu prolog featur function settingaxiom implement revers partial evalu automat program gener combin monad optim ml runtim code gener abstract interpret partialevalu algo rithm comput lambdacalculu monad simpl translat goaldirect evalu new implement icon languag definit interpret higherord program languag phd thesi two price one compos partial evalu compil steel jr comprehend monad monad function program easi implement pil prolog lisp tr novel represent list applic function revers implement icon program languag comput lambdacalculu monad repres control presenc firstclass continu denot semant goaldirect languag compil continu partial evalu automat program gener tutori note partial evalu optim ml runtim code gener gener approach runtim special applic c repres layer monad icon programmng languag definit interpret higherord program languag typedirect partial evalu semanticsbas compil combin monad monad function program ctr mitchel wand dale vaillancourt relat model backtrack acm sigplan notic v n septemb dariusz biernacki olivi danvi chungchieh shan static dynam extent delimit continu scienc comput program v n p may