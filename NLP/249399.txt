t bound queri approxim a paper investig comput complex approxim sever npoptim problem use number queri np oracl complex measur result show tradeoff close approxim number queri requir approxim factor kn log log_kn n queri np oracl use approxim maximum cliqu size graph within factor kn howev approxim cannot achiev use fewer log log_kn n c queri oracl unless constant depend k result hold approxim factor kn geq belong class function includ integ constant function log n loga n na similar result obtain graph color set cover npoptim problem b introduct approxim npoptim problem central theme studi algorithm comput complex theori npoptim problem decis version npcomplet henc equival decis problem howev approxim optim problem may vari greatli npoptim problem effici algorithm find good approxim solut other algorithm exist unless standard intract assumpt violat eg polynomi hierarchi collaps recent arora lund motwani sudan szegedi alm show problem find largest cliqu graph latter categori follow seri breakthrough result as bfl fgl show exist constant ffl determinist polynomi time algorithm approxim maximum cliqu size g graph g n vertic within factor n ffl unless result strongli suggest effici algorithm find good approxim maximum cliqu problem resolv question comput complex approxim maximum cliqu size graph particular clear comput resourc suffici andor necessari comput approxim maximum cliqu size use tradit resourc bound measur eg time space random bit altern paper use number queri npcomplet oracl complex measur krentel kre use measur show maximum cliqu size complet polynomi time function use olog n queri denot pf np olog n sinc krentel origin work mani connect bound queri class standard complex class discov abg ag bei bei ck gkr wag ww mani circumst result show one cannot decreas number queri need solv problem even singl queri unless collaps exampl hoen nickelsen hn show determin mani formula f satisfi dlogr e queri suffici necessari unless naiv binari search determin number satisfi formula use queri np oracl number queri need dlogr dlog r answer rang r tree prune techniqu show polynomi time machin determin number satisfi formula use one fewer queri oracl unless thu algorithm use fewest queri simpli naiv binari search algorithm paper show approxim sever npoptim problem also properti first part paper focu complex approxim size maximum cliqu graph order state result paper correctli need precis term approxim let g denot size maximum cliqu graph g say number x approxim g within factor kn gkn x g result show tradeoff close approxim number queri need solv approxim problemclos approxim requir queri exampl approxim g within factor use log log n queri factor upper bound lower bound unless log log n log log log log n gamma log log k log log log n log log n gamma log log log n log log n gamma log log log a log log gamma log ffl tabl upper lower bound approxim maximum cliqu size np n number vertic graph g contrast comput g exactli done log n queri n queri unless moreov show function use fewer log log n gamma log ffl queri oracl approxim g within factor unless here ffl constant given corollari alm gener result show nice approxim factor kn g approxim within factor kn use log log kn n queri fewer log log kn queri oracl unless corollari show differ log ffl upper lower bound natur interpret tabl summar result common approxim factor make observ result first sinc ffl constant larg enough constant k log log k would exceed log ffl henc k upper bound approxim g within factor k strictli less lower bound approxim within factor henc larg k problem approxim within factor k strictli lower complex term number queri approxim within factor unless similarli approxim within factor log n lower complex approxim within constant approxim within factor n k even lower complex believ first result show tradeoff complex close approxim contrast garey johnson gj show g approxim within constant factor p approxim within constant factor p contradictori theorem certainli differ flavor next section state lemma definit notat need prove result section show uniform binari search routin provid upper bound mention prove lower bound result start section simpl proof show function pf x oracl x approxim within factor unless go proof gener lower bound result section discuss result extend np optim problem eg chromat number section ponder upon valu constant ffl final section combin techniqu result lund yannakaki ly hard approxim set cover problem deriv upper lower bound queri complex approxim minimum set cover size preliminari definit everi graph g let jgj denot number vertic graph let g denot size largest cliqu g say function ag approxim maximum cliqu size within factor kn graph g n vertic gkn paper use altern condit gkn ag kn delta g find unintuit consid ag approxim g exist cliqu size ag g howev result paper still hold altern definit prove lower bound need result arora et al alm show exist ffl maximum cliqu size cannot approxim within factor n ffl determinist polynomi time unless number vertic graph construct yield next lemma exist constant s b d d given boolean formula f variabl construct polynomi time graph g vertic constant b fix remaind paper particular interest ratio b gamma sd equal ffl mention lemma prove intract n ffl approxim first assum polynomi time algorithm approxim g within n ffl take boolean formula f let number variabl f construct g describ lemma use polynomi time algorithm obtain approxim x g sinc n ffl approxim within factor t algorithm must guarante x b t hand f sat x definit let pf xqn class function comput polynomi time oracl ture machin ask qn queri oracl x sinc queri adapt queri string may depend answer previou queri upper bound first examin upper bound complex approxim npoptim problem term bound queri class gener idea use queri sat narrow rang optim solut exist exampl graph g n node g n comput g exactli use binari search log n queri form is g greater x hand approxim g within factor need find number x x g x thu first partit number n interv ne g interv simpli use factor approxim g thu strategi use binari search left endpoint interv determin interv contain g sinc dlog ne interv need dlog dlog nee queri sat perform binari search gener case want find approxim g within factor kn l log kn n interv form kn binari search would use l log l log kn n mm queri sat thu follow lemma lemma let kn polynomi time comput function exist function pf sat dlogdlog kn nee approxim g within factor kn graph g n vertic lemma state maximum cliqu size problem obvious hold npoptim problem solut integ rang n note matter kn integ check whether g greater x still np question x fraction number determin g contain interv kn kn i output dkn e approxim g also drop ceil notat deriv readabl upper bound complex approxim g common approxim factor see tabl binari search strategi use find approxim g may seem naiv howev shall see later upper bound differ lower bound addit constant case improv upper bound exist polynomi time algorithm give approxim solut within factor fn then strategi first use polynomi time algorithm obtain approxim x know solut x x delta fn now find approxim within factor kn divid number x x delta fn interv x case number interv l log kn fn lemma lemma let kn polynomi time comput function suppos exist polynomi time algorithm approxim g within factor fn exist function pf sat dlogdlog kn fnee approxim within factor kn graph g n vertic again note lemma appli npoptim problem whose solut rang n lemma may seem somewhat useless sinc best known polynomi time algorithm approxim size maximum cliqu within factor onlog n bh use new strategi outlin abov would reduc number queri need find factor approxim g loglog would save us one queri variou valu n howev follow corollari lemma allow us gaug qualiti lower bound result corollari function pf sat log log kn ngammalog ffi approxim g within factor kn polynomi time algorithm approxim g within factor n ffi corollari give us natur interpret differ upper bound log log kn n lemma lower bound log log kn gamma log ffl theorem differ log ffl reflect fact know exist polynomi time algorithm approxim g within factor n ffi thu improv either upper lower bound possibl moreov observ lemma use appli npoptim problem set cover set cover problem given finit collect c subset ng ask find size smallest subcollect ng sinc size smallest set cover approxim within factor follow lemma lemma let kn polynomi time comput function exist function pf sat dlogdlog kn ln nee approxim size minimum set cover within factor kn now compar lemma lemma obtain quantit differ complex approxim g complex approxim size minimum set cover qualit differ exampl allow make log logln queri sat approxim minimum set cover within factor howev use number queri approxim within factor n logln n thu conclud approxim set cover within factor complex approxim g within factor n logln n comparison possibl take quantit view complex approxim term number queri note exist good polynomi time approxim algorithm problem greater effect complex approxim problem complex find exact solut exampl suppos np optim problem solut rang n without help approxim algorithm would need log n queri find exact solut log log n queri find factor approxim now suppos given polynomi time algorithm guarante factor approxim find exact solut would still need logn queri howev need one queri log log approxim within factor upper bound proven section use naiv binari search strategi determin interv contain optim solut one might suspect clever algorithm could use substanti fewer queri oracl rest paper show unless intract assumpt violat eg polynomi time algorithm reduc number queri addit constant result give us rel lower bound number queri need approxim maximum cliqu size graph also abl extend techniqu determin queri complex approxim chromat number graph minimum set cover lower bound promis problem cliqu arithmet prove lower bound result need introduc definit notat number formula ff satisfi ie sat definit let rt polynomi bound polynomi time function defin p rt follow promis problem given sequenc boolean formula f f variabl promis technic size input promis problem jf j size otrt boolean formula restrict one variabl occur constant number time simplifi notat follow lemma count queri function rather jf j follow lemma provid tight lower bound complex p r proven use selfreduc sat tree prune techniqu hn includ proof sake complet rt logarithm bound polynomi time comput function exist oracl x polynomi time function solv p rt use fewer queri x proof let polynomi time oracl ture machin solv p r use qt queri x know log n entir oracl comput tree input f polynomi bound search determinist fact oracl comput tree rt leav sinc x dlog xe x one leav repres correct comput contain valu sat howev rt possibl answer sat rang rt so one possibl answer call z appear leaf moreov one leav contain correct answer z sat thu construct polynomi time ture machin input f print number z rt z sat show given boolean formula f consid disjunct selfreduct tree node tree formula children node two formula obtain instanti one variabl formula f root tree tree height exponenti size howev examin rt level tree time now let rt path tree suppos f i sat sinc f i child f assum thu promis condit p rt hold use find number z z sat replac subtre root f z subtre root f z f z sat f z sat promis condit f z sat f z sat z would equal sat construct thu f z sat iff f z sat shorten path repeat process path order path tree length less rt now origin formula f satisfi iff one leav in variabl instanti evalu true sinc final tree polynomi bound check everi leaf exhaust proof follow need construct graph maximum cliqu size occur restrict interv assist construct defin two oper graph phi andomega also use k denot complet graph vertic definit given two graph g g graph construct take disjoint union vertic g g edg h edg g g plu edg u v vertex u g v g so everi vertex g connect everi vertex g given two graph g g graph construct replac vertex g copi g furthermor edg u v g vertex copi g replac u connect everi vertex copi g replac v note thatomega commut higher preced phi lemma let g g two graph simpl lower bound first lower bound result show oracl x function pf x approxim g within factor unless thi start assumpt function f pf x approxim g within factor show use function solv promis problem p use one queri x then construct start input promis problem p pair boolean formula f f variabl use reduct lemma construct two graph g g vertic suffici larg b consid effect satisfi f f h f sat f sat ident graph composit garey johnson cover garey johnson pictur cliqu compos graph three point connect edg hand final promis condit promis problem case restrict valu h nonoverlap interv interv separ factor thu factor approxim h tell us formula satisfi exampl given approxim x guarante within factor x delta b know f f satisfi approxim achiev use one queri x solv promis problem p pf x gener construct section prove gener theorem lower bound approxim size maximum cliqu graph first defin class approxim factor definit call function k n r nice approxim factor comput polynomi time follow hold n n log log km log n log kn pleas note kn nice kn equal n a log n log n constant natur interpret third condit follow consid function kn function fn also relat kn by third condit satisfi fn increas fn constant fn decreas converg limit eg thu fn decreas almost everywher must converg limit henc third condit satisfi fn altern increas decreas infinit often rule function approxim factor theorem let kn nice approxim factor unbound converg integr constant converg suffici larg constant then oracl x polynomi time function approxim g within factor kn use log log kn fewer queri x unless logffl proof gener strategi proof reduc promis problem p r problem approxim maximum cliqu size graph h within factor kn provid us lower bound complex p r assum lower bound complex approxim h so begin input promis problem p r boolean formula f variabl the actual valu r chosen later convert formula graph g vertic accord construct describ lemma valu g restrict by choos gap size g simpl exampl abov g proof valu g r depend t howev notat conveni make depend explicit moreov choos g whole number now given choic r g construct graph h follow first glanc appear polynomi time construct could doubl size succeed graph howev r turn logarithm bound jhj polynomi bound final let suppos exist polynomi time function approxim h within factor kn use log log kn queri x want show factor kn approxim h also tell us valu sat also want constrain choic g r log log kn abl approxim h within kn factor use log log kn queri x would impli make claim choic g r critic alreadi encount one constraint g r constraint aris analyz possibl valu h moment assum exactli z satisfi formula f sat f sat promis condit p r calcul h follow r estim size second term then bound size maximum cliqu h want show approxim h within factor g also allow us calcul sat assum provid function approxim h within factor g distinguish case z formula satisfi case z satisfi must have is upper bound h z formula satisfi must smaller factor g lower bound h z satisfi sinc condit satisfi constraint g r b similarli constraint would also have g henc restrict possibl valu h r disjoint interv separ factor g thu given number x guarante approxim h within factor kn kn g find largest z gx z b largest z equal import note approxim factor kn depend n size h size origin input furthermor valu n depend valu g thu simpl task choos g kn g recal summari must choos g r follow constraint hold recal use g gt interchang constraint gt r constraint kn gt constraint log log kn n gamma c main difficulti proof choos correct valu paramet exampl satisfi constraint pick larg valu r howev r larg constraint harder satisfi also satisfi constraint easili choos larg g larg g would forc us pick small r violat constraint let show follow choic satisfi constraint l log g note g r chosen integ import construct also sourc difficulti calcul reader may find proof easier follow substitut g two extrem possibl first show constraint hold choic r r log g t bgamma g gamma g remov log g isol b use fact g r r obtain follow henc constraint hold also use equat estim n term t construct know equat know r bgamma henc nice approxim factor monoton point henc larg enough t hold final show constraint hold sinc suffic show log log kn n ffl log kn substitut definit r care floor notat satisfi constraint showingffl log g log kn n ffl log next step rewrit ffl follow recal log log log ffl must less constraint show follow two inequalitiesffl log g log log log equat hold sinc gg gamma bound n now show equat hold first pick enough recal log log dkn consid ratio log kn log dkn e kx alway integ ratio kx grow monoton ratio converg eventu rise constant ffi fact suffici assum kx unbound function proof also work kx converg integr constant suffici larg constant proof work kx small fraction constant eg henc exclud case hypothesi theorem in case howev prove theorem result wors lower bound thu may assum suffici larg log log log use third nice properti kx suffici larg log log log n log kn log kn n thu equat true constraint satisfi larg enough tin preced theorem make addit assumpt kn beyond nice show equat hold will settl slightli wors lower bound prove similar result nice approxim function kn altern make assumpt ffl proof case nearli ident proof theorem except use fact ratio log kn log dkn e bound log log sinc kn n corollari let kn nice approxim factor then oracl x polynomi time function approxim g within factor kn use log log kn fewer queri x unless logffl corollari let kn nice approxim factor ffl oracl x polynomi time function approxim g within factor kn use log log kn fewer queri x unless logffl approxim chromat number result state far also hold mani npoptim problem npoptim problem solut rang n or even n upper bound number queri need approxim problem deriv easili techniqu section show lower bound hold need reduct sat new problem similar one cliqu lemma recent lund yannakaki discov reduct graph color relat problem ly repeat proof special attent must given differ may aris minim maxim see section thu could obtain result analog one theorem problem approxim chromat number graph section take altern approach prove lower bound use approxim preserv reduct maximum cliqu size problem chromat number graph ly howev reduct increas size graph proof produc best lower bound approach extend problem lund yannakaki show approxim properti similar graph color show cliqu partit cliqu cover bicliqu cover similar lower bound follow approxim preserv reduct due simon sim cliqu cover bicliqu cover reduct preserv approxim ratio within ffl ffl new problem size n offl hand abl obtain similar result fraction chromat number reason reduct preserv approxim ratio log n multipl factor follow let ffg g denot respect size largest independ set chromat number graph g next lemma applic result lund yannakaki lemma exist polynomi time transform g graph g n vertic prime p n p n properti furthermor proof proposit appendix lundyannakaki ly exist polynomi time transform g p r g graph p prime r r given graph g n vertic defin follow let find prime p n p n such prime exist bertrand theorem found easili sinc length input n log n let the follow theorem show deriv lower bound complex approxim chromat number graph use lemma abov theorem let kn nice approxim factor larg n oracl x polynomi time function approxim g within factor use log log kn fewer queri x unless proof reduc approxim cliqu size graph q approxim chromat number graph h h approxim use queri lower bound approxim q corollari would violat conclud given nice approxim factor kn suppos polynomi time algorithm ag approxim g within factor kn use log log kn queri x graph g n vertic let k simpl check k n also nice approxim factor proposit state lund yannakaki requir p r proof show fact suffici use proposit instead main theorem deal gener graph instead special graph produc reduct lemma given graph q n vertic approxim q within factor k n follow construct use lemma q complement q so know ffq construct graph h ad dummi vertic h final use algorithm comput approxim h within factor kn use log log kn log log queri x sinc ah factor kn approxim know lemma also know thu valu p n ah approxim q within factor sinc k n nice approxim factor corollari approxim q within lower bound log log k n log log final sinc log log kn comput ah use log log k n queri x thu algorithm exist decreas lower bound corollari queri decreas due part fact jhj jqj thu effici reduct cliqu size chromat number would yield tighter lower bound also specif approxim especi relationship kn kn explicit obtain slightli better lower bound reproduc proof theorem valu ffl lower bound result preced section depend valu constant ffl recal ffl use arora et al show polynomi time algorithm approxim g within factor n ffl unless note larger valu ffl indic better nonapproxim result turn provid tighter upper lower bound result previou section also recal bound queri class even improv one queri signific current exact valu ffl known howev weaken assumpt bpp np bellar goldwass lund russel bglr shown polynomi time algorithm approxim g within factor n gammao improv made bellar sudan bs show polynomi time algorithm approxim g within factor n gammao unless section use result obtain explicit lower bound number queri need approxim g stronger assumpt rp np prove lower bound result need adapt proof techniqu previou section work random function instead determinist function naiv approach would use straightforward modif lemma produc random reduct f sat cliqu size that difficulti approach random version lemma use random reduct polynomi mani time thu show lower bound violat care valu ffi make certain success probabl overal procedur remain high enough detail analysi possibl use techniqu develop rohatgi roh howev analysi made much simpler observ random reduct sat cliqu size achiev uniform probabl is random string z use correctli reduc instanc sat certain length follow let jf j denot length encod boolean formula f lemma exist constant s b d determinist polynomi time function f boolean formula f jf t random string z pt ff z produc graph vertic proof reduct implicit work zuckerman zuc includ proof sketch complet proof reduct f construct graph g formula f random string z random string z use choos dispers graph h allow f amplifi probabl bound choos dispers random step use f randomli chosen h inde dispers h use reduc formula f variabl graph g henc success probabl reduct independ particular formula f start point proof determinist reduct lemma probabilist checkabl proof sat report arora et al probabilist checkabl proof sat verifi v use c log n random bit look bit proof accept f sat p rob zfg c log nv verifi v input f variabl use construct feig goldwass et al fgl construct graph g construct vertex g repres one comput path verifi v for everi possibl random string everi sequenc answer bit proof edg ad two vertic proof contain answer bit agre comput path construct give approxim gap obtain better re sult decreas probabl v accept incorrect proof f sat without use mani addit random bit decreas achiev determinist cw lead lemma lose track valu b d altern zuckerman zuc point out decreas verifi error randomli key idea zuckerman construct use special graph call dispers first introduc sipser sip purpos dispers may defin bipartit graph c vertic left c vertic right left vertex degre everi set c left vertic connect least c right vertic valu constant c chosen later theorem zuckerman attribut sipser zuc theorem dispers randomli gener probabl choos neighbor left vertex randomli suppos dispers h use h construct new verifi v interpret left vertex h random string v right vertex h random string v v simul v randomli choos left vertex h use c log random bit let z z right vertic connect chosen left vertex time use z random string v everi simul v accept proof v accept proof complet simul use c log random bit look dc bit proof clearli f sat v alway accept fact v accept even h desir properti convers consid case f sat want show v accept probabl less c t c so suppos v accept probabl c t c then c left vertic caus v accept thu right vertic connect left vertic must caus v accept sinc h dispers properti mention abov least c right vertic must caus v accept contradict assumpt error probabl v thu f sat accept proof probabl less c t c construct graph g v describ abov sinc v use c log random bit look dc bit proof graph g vertic big cliqu size c f sat g small cliqu size c ratio size big cliqu size small cliqu express term n is substitut c log thu choos c larg enough recal c number bit proof verifi read calcul show effect c valu ffl final observ random step use reduct choos dispers h result bellar goldwass lund russel bglr use show lemma ratio b gamma produc verifi sat use bit proof follow zuckerman construct describ abov howev unabl exploit result bellar sudan bs use random sampl gener pseudorandom bit nevertheless give explicit lower bound queri complex approxim g theorem let kn nice approxim factor then oracl x polynomi time function approxim g within factor kn use log log kn fewer queri x unless proof prove theorem simpli follow proof theorem except use instead lemma reduc sat cliqu size sinc success probabl reduct independ formula f repeat use reduct decreas success probabl overal procedur again random step entir procedur randomli choos dispers graph h also case use tree prune procedur lemma look satisfi assign given boolean formula sinc procedur accept formula satisfi assign found never accept unsatisfi formula procedur may reject satisfi formula graph h turn dispers howev probabl happen small thu overal procedur rp algorithm sat final note equat theorem need show log g log kn n ffl log proof valu ffl known rewrit ffl asffl then beforeffl log g also need addit assumpt kn show log log log log dkn e log log log kn log dkn e log log henc delta log kn log dkn e let thu assumpt kn nice suffic use proof techniqu describ also extend result lower bound approxim chromat number corollari let kn nice approxim factor larg n oracl x polynomi time function approxim g within factor kn use log log kn fewer queri x unless lower bound set cover instanc set cover problem set system i ng ask find size smallest collect cover ng denot size minimum cover setcov discuss section upper bound set cover problem differ complex compar cliqu chromat number exist polynomi time algorithm approxim size minimum set cover within factor section deriv lower bound complex approxim size minimum set cover term number queri sat one difficulti aris appli techniqu minim problem illustr thi consid construct graph h section use reduct sat cliqu construct graph g formula f reduct special properti f sat equal import allow us put two copi g h knew g could larg m thu ensur larg enough gap case sat case f would use mt b copi g would make graph h big produc bad lower bound gener theorem equal possibl settl good upper bound exampl reduct sat cliqu guarante f sat b need put copi g h gener case would obtain lower bound log log kn reduct sat set cover ly give upper bound size minimum set cover origin formula unsatisfi thu must use follow lemma theorem lemma exist constant const l const l log exist set b subset c sequenc indic collect cover b j either c complement c cover b furthermor exist probabilist ture machin which input l in binari produc set system probabl g let subset c cm collect subset b chosen randomli independ ie x b c x c probabl one half show probabl collect suffic fix statement lemma probabl number differ j s l l thu probabl collect cover b bound l henc probabl item occur least secondli note probabl first l set cover b use fact gamma x e gammax x need quantiti greater henc need log sinc log hold larg enough l m therefor desir constant const found henc probabl satisfi item least sinc probabl satisfi item probabl satisfi item probabl satisfi least theorem given formula let instanc set cover describ below let n size then exist integ k depend size that klog n setcov klog last properti hold probabl least furthermor reduct appli number formula size probabl instanc set cover obtain properti abov proof proof theorem modif construct lund yannakaki ly rest proof assum reader familiar notat proof ly given formula carri construct section ly except use set bc specifi lemma build block use idea ly obtain sat impli setcov er sinc first l answer everi queri q cover point lemma then sinc jq theorem follow sinc l chosen log n ffl also note thu appli lemma furthermor note chosen one set system lemma use number reduct involv instanc size thu set system requir properti reduc instanc requir propertiesth consequ theorem exist random reduct sat set cover run time on polylog n reduct allow us duplic construct theorem set cover obtain follow lower bound theorem r function n larg enough kn n impli log log log km log log n log kn let instanc set cover then oracl x polynomi time function approxim size minimum set cover within factor kn use log log kn fewer queri x unless np rt imen polylog n proof proof analog proof theorem start promis problem p r r chosen later sinc construct time on polylog n need differ lower bound complex p r use proof techniqu lemma one show use fewer dlogr e queri oracl x np dt imen polylog n theorem import theorem random reduct sat set cover use repeatedli without decreas success probabl overal procedur r sequenc boolean formula variabl satisfi promis condit promis problem p r use theorem construct r instanc set cover size underli set sinc construct take time on polylog n ot polylog know probabl i klog m restrict attent case combin r instanc set cover singl instanc set cover let n size underli set defin phi andomega posit integ accomplish follow let two instanc set cover defin phi n g defin simpli phi repeat time proof theorem valu g construct chosen later note construct use g rgamma copi instead g rgamma copi r backward compar construct h theorem need make chang setcov small f sat larg f sat again backward compar cliqu then good approxim setcov ert solv promis problem p r howev approxim must within factor g instead g know setcov er interv log k log f sat construct exactli z satisfi formula f follow bound thu obtain lower bound approxim size minimum set cover assum np rt imen polylog n show exist r g satisfi follow constraint recal n size underli set respect valu express term t make notat simpler express g r term instead drop argument altogeth constraint gm r log m constraint kn gm constraint log log kn proof let n choos g r follow log g proof theorem choic r impli constraint hold nondecreas almost everywher follow kn gm constraint also hold final show constraint hold suffic show follow equat hold they analog equat theorem log kn equat satisfi larg sinc g equat prove follow start nice assumpt kn obtain log kn ln n log log n log kn log log n log recal n m larg m log m thu have log log n log log log log then use fact x log delta log x logdx have delta log log log log logdkn e log g log also know larg enough log log delta log therefor log g log g therefor equat hold complet proof updat sinc origin submiss paper addit connect bound queri class npapproxim problem discov chang chaa show approxim cliqu size actual complet certain bound queri class complet produc reduct npapproxim problem eg approxim chromat number approxim cliqu size addit bound queri class also use measur difficulti find vertic approxim cliqu size chab also crescenzi kann silvestri trevisan ckst shown find vertic largest cliqu cannot reduc find vertic approxim cliqu unless polynomi hierarchi collaps bound queri class also use measur hard optim problem ct compar variou kind approxim preserv reduct ckst acknowledg author would like thank richard beigel suresh chari mani help discu sion thank also go samir khuller martin kummer frank stephan proofread draft paper r connect bound queri class nonuniform complex polynomi ters set proof verif hard approxim problem probabilist check proof structur theorem depend quantit complex sat bound queri sat boolean hierarchi effici probabilist checkabl proof applic approxim approxim maximum independ set exclud subgraph improv nonapproxim result queri complex cliqu size maximum satisfi structur complex column machin model npapproxima tion problem reveng boolean hierarchi boolean hierarchi polynomi hierarchi closer connect structur approxim class approxim scheme preserv reduc applic approxim cliqu almost npcomplet comput intract guid theori npcomplet approxim algorithm combinatori problem complex optim problem algebra method interact proof system ratio optim integr fraction cover hard approxim minim problem save queri random approxim solut combinatori optim problem complic question maxima minima closur np boolean closur np tr ctr richard chang bound queri approxim boolean hierarchi inform comput v n p septemb