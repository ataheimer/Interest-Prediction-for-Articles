t type system higherord modul a present type theori higherord modul account mani central issu modul system design includ transluc applic gener modul firstclass valu type system harmon design element previou work result simpl econom account modular program main unifi principl treatment abstract mechan comput effect languag first provid complet practic formal critic issu modul system design b introduct design languag modular program surprisingli delic complex fundament tension concert project support nation scienc foundat grant number itrsysi languag technolog trustless softwar dissemin permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee popl januari new orlean louisiana usa acm desir separ program compon rel independ part need integr part form coher whole extent design modular mechan independ underli languag larg extent two insepar exampl languag poli morphism gener type abstract requir far complex modul mechan without them much work devot design modular program languag earli work clu modula famili languag particularli influenti much effort gone design modular program mechan ml famili languag notabl standard ml object caml numer extens variat design consid literatur despit or perhap of substanti effort field remain somewhat fragment clear unifi theori modular yet emerg sever compet design propos often seemingli odd one anoth decis often motiv pragmat consider engin use implement fundament consider semant type abstract relationship design decis complet clear clear account tradeoff them whether coher combin singl design goal paper provid simpl unifi formal modular program consolid elucid much work mention abov build substanti grow bodi work typetheoret account languag structur propos type theori higherord program modul harmon enrich design would suitabl foundat next gener modular languag design issu describ main technic featur languag use review central issu design modul system ml issu extend languag similar express power though tradeoff may differ differ languag control abstract modular achiev use signatur interfac mediat access program compon role signatur allow programm hide type inform select mechan control type propag transluc transpar opac limit case phase separ mllike modul system enjoy phase separ properti state everi modul separ static part consist type inform dynam part consist execut code obtain fulli express higherord modul support abstract essenti build phase separ principl definit type equival gener macqueen coin term gener creation new type correspond runtim instanc abstract exampl may wish defin functor symbolt that given paramet creat new symbol tabl natur symbol tabl modul export abstract type symbol dynam creat insert use subsequ retriev preclud use symbol one symbol tabl index anoth gener essentialeach instanc hash tabl must yield new symbol type distinct other even appli twice paramet separ compil one goal modul system design support separ compil achiev ensur interact among modul mediat interfac captur inform known client separ compil modul princip signatur princip express signatur modul captur known modul type check may use proxi modul purpos separ compil mani type check algorithm includ one given paper comput princip signatur modul modul firstclass valu modul ml second class sens cannot comput result ordinari runtim comput use treat modul firstclass valu store data structur pass ordinari function argument result hidden type introduc local hidden abstract type within scope requir type extern visibl compon avoid mention abstract type avoid problem often stumbl block modul system design sinc express languag best way avoid type variabl type system modul type system propos take account design issu consolid harmon design element previous seen dispar singl framework exampl rather regard gener abstract type altern nongen type make mechan avail languag support gener applic functor admit transluc signatur support separ compil abl accommod modul firstclass valu gener achiev simpl accumul featur rather isol key mechan that com bine yield flexibl express implement type system modul specif follow mechan crucial singleton propag type share handl singleton signatur variant aspinal stone harper singleton kind singleton provid simpl orthogon treatment share captur full equat theori type higherord modul system subtyp previou modul system provid abstract full equat theori support singleton consequ none provid optim propag type inform static modul equival semant singleton signatur depend compiletim notion equival modul ensur phase distinct respect defin modul equival mean equival static compo nent ignor runtim aspect subtyp signatur subtyp use model forget type share essenti part signatur match coerciv aspect signatur match drop field special polymorph valu omit here sinc requir coercion defin languag puriti impur type system classifi modul express pure effectfre impur effect form ensur proper enforc abstract impur modul incompar may compar equal modul nonproject may type compon project them follow impur modul also nonsubstitut may substitut modul variabl signatur abstract seal modul seal signatur impos type abstract regard impur word seal regard pro forma comput effect consist inform idea gener involv gener new type run time moreov ensur seal modul incompar nonproject suffici ensur proper semant type abstract total partial functor labstract level modul functor whose bodi pure said total otherwis partial follow applic pure total functor pure argument pure wherea applic pure partial functor pure argument impur partial functor natur gener mean abstract type result new instanc total functor applic mean equal argument yield equal type result gener functor obtain without resort gener stamp weak strong seal sinc seal induc comput effect partial functor may contain seal sub structur significantli weaken util total functor overcom limit distinguish two form effect static dynam two form seal weak strong weak seal induc static effect think occur type check strong seal induc dynam effect think occur execut dynam effect induc partial static effect preserv total existenti signatur manner similar shao type system care craft circumv avoid prob lem everi modul enjoy princip signatur howev requir impos restrict programm lift restrict propos use existenti signatur provid princip signatur none would otherwis exist show existenti signatur typetheoret illbehav typic omit equat miss restrict name form valuabl prevent programm write code whose typeabl would depend equat first place term e signatur modul let m ms ms context g gss figur syntax gener so restrict use wellbehav set style harper stone propos use elabor algorithm extern languag may incur avoid problem type system not packag modul modul system secondclass sens languag modul separ languag term howev follow mitchel et al russo provid way packag modul firstclass valu prior work packag modul typic given existenti type whose closedscop elimin construct make awkward program instead account type gener allow us employ natur openscop elimin con struct wherebi unpackag packag modul engend dynam effect featur combin natur form gener languag modular program would littl use absenc practic implement strategi previou attempt encount difficulti undecid incomplet type check contrast formal lead practic implement program languag rest paper structur follow section present core type system higherord modul includ intuit behind design brief descript decid typecheck algorithm section discuss program import weak strong form seal section explain avoid problem circumv use elabor algorithm section present simpl orthogon extens core system provid support packag modul firstclass valu fi nalli section compar system relat work section conclud technic develop begin technic develop present syntax languag figur languag consist four syntact class term type modul signatur which serv type modul languag explicitli includ higherord type constructor kind which ordinarili serv constructor type languag role constructor kind subsum modul signatur context bind modul variabl s signatur usual consid alphaequival express ident write captureavoid substitut express type three basic type languag product standard function type psst type function accept modul argument signatur return valu type possibl contain s usual appear free t write psst st thi convent use depend product signatur class well final modul contain exactli one type which say signatur t type extract typ m fullfeatur languag would support varieti addit type well term term languag contain natur introduct elimin construct recurs function product ad dition modul contain exactli one valu which say signatur t type t valu extract val m f appear free e write fix f sste lsse convent form function polymorph function built modul function ordinari function built use modul contain singl valu polymorph function built use modul contain singl type et signatur seven basic signatur languag atom signatur t type atom modul contain singl type atom signatur t type atom modul contain singl term atom modul written t e t respect we omit type label t atom modul clear context trivial atom signatur type trivial atom modul functor signatur p tot ss s p par ss s express type functor accept argument signatur return result signatur possibl contain s reason two differ p signatur distinguish total partial functor discuss detail below conveni take p without superscript synonym p tot appear free write pss s s structur signatur sss s type pair modul lefthand compon signatur righthand compon signatur refer lefthand com ponent usual appear free write singleton signatur sm use express type share infor mation classifi modul signatur t static equival m two modul consid static equival equal modulo term compon is type field must agre term field may differ singleton signatur t provid primit defin use basic singleton describ stone harper definit m the signatur contain modul equal signatur s given figur signatur sig type type u val end compil figur ml signatur exampl modul modul syntax contain modul variabl s atom modul usual introduct elimin construct p signatur except modul introduc stand may appear free appear free s omit introduct elimin construct provid singleton signatur singleton introduc elimin rule static semant judg equival s belong m vice versa remain modul construct strong seal written ms weak seal written ms modul seal either strongli weakli result opaqu opaqu mean client modul may depend detail implement expos signatur s distinct strong weak seal discuss detail below although higherord type constructor appear explicitli languag faith repres languag unseal modul contain type compon exampl kind t t t repres signatur t constructor lat t int aint repres modul lst exampl mlstyle signatur structur may express languag appear figur compar project two close relat issu crucial design modul system support type abstract modul compar equival anoth modul type compon project modul use type say modul compar iff compar equival anoth modul modul project type compon may project use type expr sion in literatur present emphas projectibil iti structur struct structur struct type string val val end compil figur ml structur exampl simpl analysi properti compar projectibil iti suggest close relat suppos pro jectibl modul signatur t typ type sinc type equal equival relat type may compar other particular typ anoth project modul signatur sinc typ typ fulli determin m are effect compar equiva lenc suggest project modul regard compar type check purpos convers compar modul extension equival typ m sensibl also project puriti impur design modul system rest semant notion puriti impur induc comput effect motiv design first recal firstclass modul system harper lillibridg impur modul express yield distinct type compon time evalu exampl modul express might consult state world yield differ modul outcom test type compon modul static welldetermin henc admit type express all much less compar equiv alenc hand even gener framework pure effectfre modul may safe regard compar project secondclass modul system exampl not fact express nevertheless find use classifi modul accord puriti classif semant sens defin judgment calculu rather syntact sens determin sole form express semant approach import correct account type abstract fullfeatur modul languag axiomat puriti impur system base set rule take account type express well syntact form type system conserv assum worst impur modul express rule moreov section introduc mean recreat exampl set make essenti use classif system incompar nonproject even type compon fact static welldetermin see shortli import enforc type abstract well ensur sound presenc firstclass modul addit sinc sound so deem pure modul express compar project is permiss possibl without violat sound abstract identifi compar project puriti final note modul judg pure base whether type compon welldetermin independ whether term compon comput effect literatur differ account higherord modul provid differ class pure modul exampl harper lil libridg firstclass modul system syntact valu consid pure leroy secondclass modul calculi puriti limit syntact categori path harper et al earli phasedistinct calculu modul deem pure mean abstract provid abstract via seal princip mean defin abstract type seal written ms seal prevent client depend ident type compon specifi opaquelywith signatur t point view modul equival mean seal modul consid incompara ble see thi suppos regard compar presum could deem equival sinc underli type compon differ howev sinc modul equival reflex compar must deem equival itself would mean type system would distinguish two opaqu modul base underli implement violat type abstract signific advantag judgment approach puriti afford natur mean ensur seal modul in compar name judg impur amount regard seal pro forma runtim effect even though actual effect occur execut time ensur abstract violat one illustr rule out also show section allow type system track runtim gener new type applic gener functor functor standard ml gener sens abstract type result functor gener afresh instanc functor regardless whether argument instanc equival functor object caml howev applic sens preserv equival appli equival argument yield equival result particular abstract type result functor two applic argument continu analog comput effect deem functor whose bodi pure total otherwis partial applic pure total functor pure argument pure henc compar total functor applic sens applic pure total functor two equival pure modul yield equival pure modul applic pure henc compar partial functor hand alway yield impur modul appli therefor respect equival argument becaus result im pure even compar ensur instanc yield distinct result distinguish signatur total applic partial gen er functor total functor p signatur wherea partial functor p par signatur subtyp relat defin everi total functor may regard degener partial functor weak strong seal system identifi applic functor total one gener functor partial one make work howev must refin notion effect seal regard induc runtim effect imposs employ abstract within bodi total func tor render bodi impur we may seal entir functor total functor signatur impos abstract ensur export type functor held abstract client functor permit substructur bodi functor held abstract client functor remaind functor bodi solut distinguish two form sealingstrong written ms befor weak written ms impos abstract sens limit type propag explicitli specifi ascrib signatur regard form seal induc impur howev support use class applic functor distinguish static dynam effect weak seal induc static effect wherea strong seal induc dynam effect signific distinct lie definit total partial functor functor whose bodi involv dynam effect ie dynam impur rule partial henc gener thu strong seal within functor bodi induc gener functor functor whose bodi either pure involv static effect ie dynam pure rule total henc applic ensur applic functor may use abstract within bodi without incur gener behavior methodolog import distinct discuss section dynam effect may thought one occur exe cution wherea static effect one occur type check ing dynam effect suspend insid labstract functor abstract dynam pure howev appli dynam effect insid functor releas applic dynam impur hand static effect occur type check henc suspend l abstract releas applic formal type judgment system written puriti classifi k drawn follow fourpoint lattic point p indic pure and henc compar pro jectibl indic dynam puriti indic static puriti w indic wellformed no puriti inform henc puriti judgment prove conveni type rule exploit order written meet join lattic p taken bottom w taken top also sometim find conveni use notat p ss s functor signatur either total partial depend whether figur key type rule key rule summar figur pure modul dynam pure static pure least wellform rule strongli seal modul neither static dynam pure weakli seal modul static pure dynam pure bodi applic functor must dynam pure bodi gener functor restrict applic functor may use gener one variabl pure lambda dynam pure applic applic functor pure functor applic gener functor best static pure final puriti modul preserv signatur subsumpt complet set type rule given appendix a rule functor applic rule requir functor argument pure functor argument substitut functor codomain produc result signa ture substitut impur modul variabl which alway pure turn wellform signatur illform one for exampl typ s becom illform impur modul substitut s an altern rule propos harper lillibridg resolv issu induc avoid problem discuss section therefor functor appli impur argument argument must first bound variabl pure similarli project second compon pair restrict pure pair rule restrict need made project first compon rule sinc substitut involv static equival forego discuss frequent made refer notion modul equival without specifi mean key design decis modul calculu defin two compar modul deem equival differ modul system aris differ notion equival pure modul signatur t possibl extract type compon it type check depend essenti matter type equal must consid typ equal typ simplest answer would regard exactli modul equal naiv cannot gener determin two modul equal suppos f latter equal undecid gener characterist featur second class modul system respect phase distinct compiletim runtim comput properti modul system state type equival must decid independ term equival intuit plausibl sinc secondclass modul system provid mean type compon modul depend term compon thi happenst result care design see section matter subtl appear base principl defin modul equival equiv alenc type check purpos static equival roughli speak two modul deem equival whenev agre correspond type compon write modul equival judgment g rule static equival atom modul expect one atom type compon must equal atom term compon need be sinc gener product new type gener functor notion dynam oper gener functor static compon compar thu pure gener functor alway static equival atom term modul are complet set equival rule given appendix a asid discuss modul equival refut misconcept firstclass modul gener secondclass modul fact express first secondclass modul incompar firstclass modul obviou advantag firstclass howev sinc type compon firstclass modul depend runtim comput imposs get static modul equival one phase distinct calculu harper et al includ nonstandard equal rule phasesplit modul structur m stat dyn consist static compon stat dynam compon dyn static equival m amount say stat m stat system howev identifi functor structur do must use dynam equival instead in word one cannot phasesplit modul harper et al consequ firstclass modul cannot propag much type inform secondclass modul can singleton signatur type share inform express languag use singleton signatur deriv transluc sum an illustr use singleton signatur express type share appear figur type system allow deduct equival membership singleton signatur vice versa also allow forget singleton inform use subsignatur relat deduct follow use primit rule type system sinc t ture follow definit given figur beyond express share singleton use selfifica tion instanc variabl bound signatur given fulli transpar signatur ss fact essenti exist princip signatur type check algorithm note sinc singleton signatur express static equival inform format singleton signatur restrict pure modul thu pure modul selfi fie as harper lillibridg leroy singleton signatur complic equival check sinc equival depend context exampl lst int lst s obvious inequival signatur t ever use subsignatur also given signatur signatur equival sinc return result given permiss argument int exampl illustr context sensit equival provid type equal would hold equival strictli context insensit therebi allow propag addit type inform exampl type typflst int typ flst s equal could case contextinsensit regim subtl technic point aris use higherord singleton defin figur suppos f intuit contain modul equival f take member fs domain return thing f doe formal speak howev canon member signatur f etaexpans lst fs fact obviou f belong t t ensur f belong singleton signatur type system follow stone harper includ extension type rule use rule f belong pst sf s function fs belong sf s similar extension type rule provid product possibl need ms figur singleton higher signatur rule could avoid make higherord singleton primit explor metatheoret implic chang sinc modul higherord singleton signatur fulli transpar obvious project compar henc could judg pure even would otherwis classifi impur instanc gener problem recogn benign effect need disturb puriti sinc puriti judgment framework could readili incorpor extens captur situat pursu matter here type check type system enjoy sound complet effect type check algorithm algorithm come three main part first algorithm synthes princip ie minim signatur modul second algorithm check subsignatur relationship third algorithm decid equival modul type modul typecheck proce usual manner synthes princip signatur modul check subsignatur intend signatur signatur synthesi algorithm given appendix b correct theorem state below main judgment signatur synthesi g k s state ms princip signatur ms puriti infer k subsignatur check syntaxdirect easi do given algorithm check modul equival modul equival aris two singleton signatur compar subsigna ture relat equival algorithm close base stone harper algorithm type constructor equival presenc singleton kind space consider preclud discuss algorithm here full detail algorithm proof appear companion technic report theorem sound g theorem complet g note sinc synthesi algorithm determinist follow theorem princip signatur exist final sinc synthesi algorithm conveni present term infer rule requir one result state realli algorithm theorem effect g m decid whether exist k g k s signatur symbol sig type symbol val string symbol string symbol val symbol string symbol string val functor symboltablefun symbol struct val tabl string array alloc intern hash tabl arrayarray initi size none fun string symbol lookup or insert x fun symbol string case arraysub tabl n none rais fail bad symbol structur figur strong seal exampl strong weak seal gener essenti provid necessari degre abstract presenc effect modul sideeffect alloc storag abstract may demand type gener correspond storag alloc order ensur element type relat local store store anoth instanc consid exampl symbol tabl exampl given figur symbol tabl contain abstract type symbol oper in terconvert symbol string equal test presum faster avail string implement creat intern hash tabl defin symbol indic intern tabl intent implement fail except never rais howev depend gener symbol type anoth instanc symbolt creat type symboltablesymbol symboltablesymbol consid equal symbolt could ask interpret indic symbolt tabl therebi caus failur thu essenti symboltablesymbol symboltablesymbol consid unequ symbol tabl exampl demonstr import strong seal encod gener abstract type state modul gener necessari howev pure function mod ule leroy give sever exampl modul motiv adopt applic functor instanc one may wish implement persist set use order list figur signatur sig type elem val compar elem elem order signatur persist set sig type elem type set val empti set val insert elem set set struct list structur struct val structur structur figur weak seal exampl exhibit pure function setfun functor parameter order element type whose implement abstract set type seal setfun instanti multipl timeseg differ client moduleswith element type use result abstract set type seen interchang system setfun made applic still opaqu weakli seal bodi specif intsetset intsetset equival setfunintordset type wellform setfun applic functor sig natur setfun intord variabl pure recal functor contain weak seal impur must bound variabl use applic astut reader may notic weak seal truli necessari setfun exampl fact one achiev effect code figur leav bodi functor unseal strongli seal functor applic functor signatur bind setfun techniqu employ shao encod applic functor system lack analogu weak seal fail approach work functor bodi fulli transparentin absenc weak seal opaqu substructur would strongli seal prevent functor given applic signatur best exampl need opaqu substructur applic functor provid interpret ml datatyp abstract type standard ml caml datatyp opaqu sens represent recurs sum type expos thu distinct instanc datatyp declar creat distinct type standard ml caml differ howev whether datatyp gener presenc applic functor which absent standard ml excel reason datatyp generativenam gener interpret would prevent datatyp appear bodi applic functor would sever diminish util applic functor particularli sinc ml recurs type provid datatyp mechan exampl implement setfun splay tree use datatyp declar defin tree type would requir use weak seal reason strong seal substitut weak seal neither weak seal substitut strong leroy ob serv functorfre code gener simul call weak seal thi seen framework observ dynam puriti provid extra privileg absenc functor functor howev strong seal necessari provid true gener nevertheless worth note strong seal defin term construct languag weak seal not particular defin strong seal use combin weak seal gener functor applic follow exist encod diminish import strong seal made primit languag regardless avoid problem rule type system particularli rule figur care ensur substitut modul alway pure expens requir functor secondproject argument pure necessari result substitut impur modul wellform signatur ill form thu appli functor impur argument one must letbind argument appli functor result pure variabl similar restrict impos shao harper lillibridg propos altern soften restrict harper lillibridg propos express term includ nondepend type rule without puriti restrict pure rule carri forc depend rule exploit singleton signatur contravari functor signatur impur rule express type rule applic still occur howev exploit rule type checker must find nondepend supersignatur suitabl applic avoid problem best way so exampl consid signatur obtain supersignatur avoid variabl s must forget first compon constant function therefor say second compon equal first compon result particular argument thu type t may promot supersignatur give us infinit array choic choic superior obviou t none compar other sinc f abstract thu minim supersignatur avoid s absenc minim signatur problem mean obviou way perform type check type system circumv avoid problem requir argument functor applic secondproject pure therebi elimin need find nondepend super signatur provid let construct oper still appli impur modul shown that result type theori enjoy princip signatur achiev thi howev let construct must label result signatur not mention variabl bound otherwis avoid problem rearis essenti requir everi functor applic project involv impur argument label result signatur well lead potenti unaccept syntact overhead practic fortun program systemat rewritten avoid problem describ next elabor existenti signatur consid unannot let express let pure let express given minim signatur m otherwis left variabl leav scope minim supersignatur mention s howev rewrit let express may give signatur sss s avoid problem aris similarli functor applic fm rewritten s mf given signatur sss s follow harper stone propos use elabor algorithm systemat rewrit elabor take code written extern languag support unannot let well impur functor applic secondproject produc code written type system sinc elabor rewrit modul manner chang signatur also must take respons convert modul back expect signatur wherev requir mean elabora tor must track pair real invent elabor circumv avoid problem elabor use type elabor invent pair circumv avoid problem give signatur use existenti rather s intern languag ss s mean thing sss s elabor treat two signatur differ elabor expect say functor encount sss s gener type error howev encount ss s extract compon the elab orat invari ensur alway so look expect functor space consider preclud detail elabor algorithm appear companion technic report sens elabor solv avoid problem introduc existenti signatur serv place nonexist minim supersignatur mention variabl light thi natur question whether need elabor could elimin make existenti signatur primit type system one natur way govern primit existenti introduct elimin rule rule avoid problem could solv least supersignatur mention ss would ss s s unfortun rule particularli first make type check undecid exampl queri lsst hold exist pure type tm ms equal thu decid subsignatur equival queri presenc existenti would hard higherord unif known undecid syntact princip signatur argu reason relat separ compil princip signatur express syntax avail programm provid strongest support separ compil programm break program point write interfac express inform compil could determin point strong support appear vital practic sinc system object caml standard ml new jersey higherord modul use success time without princip signatur all nevertheless desir properti type system ie intern languag provid syntact princip signatur sinc princip signatur exist syntax avail programm howev elabor extern languag provid syntax existenti signatur appear elabor signatur thought princip signatur extern modul thu say basic type system provid syntact princip signatur extern languag not extern languag programm permit write existenti signatur elabor code as requir elabor decid whether coerc belong ss s turn requir elabor produc determin whether exist requir elabor solv undecid higherord unif problem tm s m s equal thu allow programmerspecifi existenti signatur greatest possibl gener would make elabor undecid partial measur may possibl discuss here packag modul firstclass valu desir modul usabl firstclass valu use make possibl choos run time effici implement signatur particular data set for exampl spars dens represent array howev fulli gener firstclass modul present difficulti static type one practic approach modul firstclass valu suggest mitchel et al propos secondclass modul automat wrap existenti packag obtain firstclass valu similar approach modul firstclass valu describ russo implement moscow ml existentialpackag approach modul firstclass valu built languag write type packag modul s packag construct pack s elimin packag modul as existenti perform use closedscop unpack construct may defin follow pack s def unpack e ss compar definit s standard encod existenti type bt abtaa main limit existentiallypackag modul closedscop elimin construct observ repeatedli literatur construct restrict use one unpack e ss e t result type may mention s consequ function packag modul may depend is result type may mention argument defici mitig languag abil write function unpackag secondclass mod ule given depend type psst instead s t anoth problem closedscop elimin construct term packag type cannot unpack standalon secondclass modul unpack insid enclos term unpack packag modul creat abstract type separ scope packag must unpack earli stage ensur coher among client lead scope invers awkward manag practic desir therefor new modul construct form unpack e s coerc firstclass packag e type s back secondclass modul signatur s follow exampl illustr ad construct carelessli lead unsound modul modul modul note argument functor f atom term modul argument f static equival f given applic signatur x x deem equival even origin modul not thu f must type s term e pack s modul unpack e pack ss figur packag modul extens deem gener turn requir unpack construct induc dynam effect packag modul admit improv unpack construct defin core languag constitut simpl orthogon extens type system complic type check syntax type rule extens given figur note closedscop unpack construct defin intuit unpack gener modul unpack arbitrari term whose type compon may depend runtim condit core system present section gener induc strong seal mere pro forma effectth languag support secondclass mod ule provid way type compon modul actual gener run time type system howev treat dynam effect truli dynam thu scale easili handl real runtim type gener enabl extens figur relat work harper mitchel moggi pioneer theori phase sep arat fundament achiev maxim type propag higherord modul system nonstandard equat rule identifi higherord modul primit phase split one similar spirit to though differ detail from notion static modul equival one may view system subsystem seal mechan and consequ modul pure macqueen toft propos higherord modul extens origin definit standard ml implement standard ml new jersey compil semant involv twophas elabor process higherord functor reelabor applic take advantag addit inform argument advantag balanc disadvantag inhibit type propag presenc separ compil sinc functor compil separ applic cannot reelabor thorough comparison difficult macqueen toft employ stampbas semant difficult transfer set focus control abstract larg neglect higherord modul harper lillibridg leroy introduc close relat concept transluc sum manifest type mechan serv basi modul system revis definit standard ml harper stone formal elabor standard ml program transluc sum calculu deal avoid problem harper stone reli elabor mechan similar our harper stone languag view subsystem functor gener strong seal support leroy introduc notion applic functor enabl one give fulli transpar signatur mani higherord functor leroy formal may seen defin puriti syntact restrict functor applic appear type path must name form one hand restrict provid weak form structur share sens abstract type fxt result appli f modul name x hand restrict prevent system captur full equat theori higherord functor sinc equat express name form togeth manifest type applic functor form basi modul system object caml manifest type formal like transluc sum formal address avoid prob lem consequ lack princip signatur recent russo thesi formal two separ modul languag one close model sml modul system higherord modul system applic functor along line ocaml abandon name form restrict do russo two languag view subsystem our first support strong seal second support weak seal adopt use existenti signatur address avoid problem although russo also use existenti model gener not russo thesi also describ extens sml packag modul firstclass valu extens similar existenti packag approach discuss begin section therefor suffer limit closedscop unpack construct russo defin two languag separ implement higherord modul system experiment extens moscow ml compil combin two languag without distinguish static dynam effect unfortun consequ moscow ml higherord modul system place restrict bodi applic particular one defeat gener gener functor etaexpand applic one exploit uncov unsound languag that retrospect clear analysi one cannot convert partial total functor shao propos singl type system modul support applic gener functor roughli speak shao system may view subsystem base exclus strong seal dynam effect support p p par signatur observ section mean bodi applic functor may contain opaqu substructur such datatyp shao system like our circumv avoid problem section restrict functor applic project pure argument which must path system elimin implicit subsumpt amount requir let express annot system seem like elabor techniqu could well appli shao system lift restrict expens syntact princip signatur shao also observ fulli transpar functor may regard applic instanc gener problem recogn benign effect describ section conclus type system firstord modul system reason well understood contrast previou work typetheoret higherord modul left field fragment state variou compet design clear statement tradeoff if ani design state field made difficult choos one design anoth left erron impress tradeoff actual exist exampl previou design support sound gener applic functor opaqu subcompon languag seek unifi field provid practic type system higherord modul simultan support key function preced modul system process dispel misconcept tradeoff fulli express gener applic functor therebi elimin dilemma face languag design nevertheless sever import issu modular program go beyond scope type theori chief among are structur share origin version standard ml includ notion modul equival sensit dynam well static part modul although notion would violat phase distinct might possibl formul variat system take account dynam equival conserv fashion possibl simul structur share elab orat add abstract type structur serv compiletim name structur howev would mere elabor convent intrins account structur share within type theori recurs modul import direct futur research integr recurs modul present framework chief difficulti achiev practic type check presenc gener recurs depend signatur isol practic sublanguag avoid problem r type system modular program specif modula type system abstract type dot notat sound complet elimin singleton kind recurs modul moscow ml higherord modul un sound type system higherord modul expand version cool modul hot languag bound existenti minim type undecid secondord unif problem manifest type applic functor fulli transpar higherord modul syntact theori type gener share modular modul system transluc sum foundat higherord modul system abstract specif program develop use depend type express modular structur semant higherord functor definit standard ml david mac queen extens standard ml modul subtyp inherit abstract type existenti type type modul recurs structur standard ml transpar modul fulli syntact signa ture singleton kind singleton type decid type equival languag singleton kind program modula tr abstract specif program develop abstract type existenti type modulamyampersandndash type system higherord modul phase distinct extens standard ml modul subtyp inherit manifest type modul separ compil typetheoret approach higherord modul share applic functor fulli transpar higherord modul bound existenti minim type unit recurs modul transpar modul fulli syntat signatur decid type equival languag singleton kind typetheoret interpret standard ml recurs structur standard ml use depend type express modular structur definit standard ml semant higherord functor sound complet elimin singleton kind firstclass structur standard ml singleton kind singleton type ctr oleg kiselyov chungchieh shan lightweight static capabl electron note theoret comput scienc entc v n p june norman ramsey kathleen fisher paul govereau express languag signatur acm sigplan notic v n septemb karl crari sound complet elimin singleton kind acm transact comput logic tocl v n pe april manuel m t chakravarti gabriel keller simon peyton jone associ type synonym acm sigplan notic v n septemb dimitrio vytinioti geoffrey washburn stephani weirich open shut typecas proceed acm sigplan intern workshop type languag design implement p januari long beach california usa derek dreyer type system wellfound recurs acm sigplan notic v n p januari andrea rossberg gener dynam opac abstract type proceed th acm sigplan intern confer principl practic declarit program p august uppsala sweden derek dreyer robert harper manuel m t chakravarti gabriel keller modular type class acm sigplan notic v n januari daniel k lee karl crari robert harper toward mechan metatheori standard ml acm sigplan notic v n januari derek dreyer recurs type gener acm sigplan notic v n septemb eijiro sumii benjamin c pierc bisimul dynam seal theoret comput scienc v n p may eijiro sumii benjamin c pierc bisimul dynam seal acm sigplan notic v n p januari jame j leifer gill peskin peter sewel keith wansbrough global abstractionsaf marshal hash type acm sigplan notic v n p septemb manuel m t chakravarti gabriel keller simon peyton jone simon marlow associ type class acm sigplan notic v n p januari andrea rossberg miss link dynam compon ml acm sigplan notic v n septemb owen matthew flatt structur functor modul unit acm sigplan notic v n septemb john bill peter sewel mark shinwel rok strnia typesaf distribut program ocaml proceed workshop ml septemb portland oregon usa martin sulzmann manuel m t chakravarti simon peyton jone kevin donnelli system f type equal coercion proceed acm sigplan intern workshop type languag design implement januari nice nice franc