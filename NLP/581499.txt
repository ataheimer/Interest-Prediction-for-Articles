t tagless stage interpret type languag a multistag program languag provid conveni notat explicitli stage program stage definit interpret domain specif languag one way deriv implement readabl effici untyp set stage interpret remov complet layer interpret overhead like partial evalu type set howev hindleymiln type system allow us exploit type inform languag interpret practic mean slowdown cost factor three morprevi type special tag elimin appli problem paper propos altern approach name express definit interpret depend type program languag report experi issu aris write interpret design languag to demonstr sound combin stage depend type gener sens formal languag call metad prove type safeti formal metad extend shao saha trifonov papaspyr h languag multilevel set build h allow us demonstr type safeti set type languag contain calculu induct construct without repeat work need establish sound system b introduct recent year substanti effort invest develop theori tool rapid implement domain specif languag dsl dsl formal provid user notat appropri specif famili task promis approach implement domain specif languag write definit interpret dsl metalanguag stage interpret either manual ad explicit stage annot multistag program appli automat bindingtim analysi offlin partial evalu result either step stage interpret stage interpret essenti translat subjectlanguag the dsl targetlanguag alreadi compil targetlanguag approach yield simpl compil dsl addit perform benefit compil inter preter compil obtain process often retain close syntact connect origin interpret inspir greater confid correct paper concern subtl costli problem aris subject metalanguag static type particular metalanguag type gener need introduc univers datatyp repres valu uniformli see detail discuss univers datatyp mean perform tag untag oper run time subjectlanguag un type would write ml interpret scheme check realli necessari but subjectlanguag also static type would write ml interpret ml extra tag realli need necessari static type check interpret interpret stage inherit weak gener program contain superflu tag untag oper earli estim cost tag suggest produc time slowdown smlnj system extens studi metaocaml system show slowdown due tag high time remov tag overhead inher use univers type one recent propos possibl tag elimin transform design remov superflu tag postprocess phase scheme dsl implement divid three distinct stage rather tradit two extra stage tag elimin distinctli differ tradit partial evalu or special stage essenc tag elimin allow us type check subject pro stage multistag languag usual impli metalanguag targetlanguag languag gram transform check superflu tag simpli eras interpret not semant equival interfac ad around interpret tag elim inat howev static guarante tag eras must run tag elimin runtim in multistag languag paper studi altern approach provid guarante fact user never introduc tag first place type system metalanguag strong enough avoid need them follow describ detail superflu tag problem untyp interpret begin review one write simpl interpret untyp languag notat parsimoni use ml syntax disregard type interpret small lambda languag defin follow datatyp int v string l string exp exp exp fun eval e case e l se fn v eval e ext env v fe eval f env eval e env provid simpl implement subject program repres datatyp exp function eval evalu exp environ env bind free variabl term valu implement suffer sever perform limita tion particular abl inspect result interpret eval lxv x env would find equival term comput correct result contain unexpand recurs call eval problem aris callbi valu callbynam languag one main reason call layer interpret overhead degrad perform fortun problem elimin use stage annot untyp stage interpret stage annot partit program stage bracket surround express lift next stage build code escap _ drop surround express previou stage splice alreadi construct code build larger piec code appear within bracket stage annot chang evalu order program even evalu lambda abstract forc unfold eval function codegener time thu ad stage annot eval function chang behavior achiev desir oper semant case e discuss issu prove adequaci represent correct implement interpret beyond scope paper exampl done found elsewher l se fn v eval e ext env fe eval f env eval e env comput applic eval lxv x env directli yield term fn v v leftov recurs call eval multistag languag come run annot _ allow us execut code fragment stage interpret therefor view userdirect way reflect subject program meta program hand type safe way compil metalanguag hindleymiln stage interpret program languag haskel ml use hindleymiln type system eval function stage unstag welltyp branch case statement differ type type cannot reconcil within hindleymiln system circumv problem use univers type univers type type rich enough encod valu type appear result function like eval case abov includ function well integ valu typic definit univers type exampl might be int f v v interpret rewritten welltyp program fun unf fun eval e case e l se f fn v eval e ext env v fe unf eval f env eval e env now comput eval lxv x env get back valu untyp eval stage version eval comput eval lxv x env yield problem superflu tag unfortun result still contain tag f may seem like minor issu small program like one effect larger program profus tag untag oper tag would inde necessari subject languag untyp know subjectlanguag static type for exampl simplytyp lambda calcu lu tag untag oper realli need benchmark indic tag add time overhead sometim larg time number approach deal prob lem none approach howev guarante at time write stage interpret tag elimin runtim even tag elimin guarante elimin tag particular exampl requir separ metatheoret proof subject languag obtain guarante contribut paper propos altern solut superflu tag problem solut base use depend type multistag languag work inspir work write depend type interpret cayenn illustr viabil combin depend type stage design implement prototyp languag call metad use languag vehicl investig issu aris take approach built compil interpret begin end metad also report issu aris tri develop depend type program languag as oppos type theori featur basic stage oper depend type with help avoid redund type annot depend type induct famili depend datatyp separ valu type ensur decid type check treatment equal represent type use equalitytypelik mechan technic contribut paper formal multistag languag prove safeti sophist depend type system capit recent work shao saha trifonov papaspyr system turn build number recent work type intermedi languag organ paper section show take motiv exampl turn tagless stage interpret depend type set first present syntax semant simpl type languag show implement direct fashion metad first part write unstag interpret similar done cayenn simplifi presenc depend datatyp metad see relat work key observ interpret need defin type deriv rather express depend type datatyp need repres type deriv accur next show interpret easili stage step exactli untyp hindleymiln set section point address basic practic problem aris implement interpret depend type program languag first show construct type judgment consum tagless inter preter then review import clear separ comput languag type languag motiv need represent type effect code tagless stage interpret section present formal core subset metad formal proof type safeti origin work use system type comput languag includ basic effect nontermin paper develop multistag comput languag show essenti techniqu use verifi sound key technic modif need addit level type judgment address evalu type binder section discuss relat work section outlin direct futur work conclud extend version paper avail onlin technic report stage interpret section show exampl discuss introduct redevelop depend type set begin consid definit syntax semant of simpli type version subject languag subjectlanguag syntax semant figur defin syntax type system semant exampl subject languag shall call sl simplic develop use de bruijn indic variabl binder semant defin type sl map intend mean exampl mean type n set natur number mean arrow type function space furthermor map mean type assign g product set denot finit number type assign note semant program defin type judgment map element mean type standard way defin semant type languag implement next section direct codif definit interpret metad interpret sl simpli implement definit figur begin defin datatyp use interpret basic type and type environ sl defin datatyp metad use altern notat sml haskel datatyp definit exampl defin set natur number instead write datatyp write induct induct notat conveni defin depend datatyp wish defin new type new kind mean type type type express type assign repres follow induct induct induct definit mean defin new type implement type judgment sl need depend type datatyp index three paramet type assign env express exp type typ defin datatyp shown figur constructor datatyp correspond one rule type system object languag exampl consid rule lambda abstract lam figur basic idea use judgment type principl view type rule constant combin judgment combin take hypothesi judgment and return conclus judgment case rule requir environ g two type bodi e lambda abstract judgment gt return judgment rule codifi directli follow constructor je el s arrowt t definit j see differ tradit datatyp definit induct datatyp constructor depend type argument rang type j index differ indic variabl return practic reason discuss next section datatyp legal metad use section explain basic idea discuss need socal represent type figur semant sl induct figur type judgment j without represent type type constructor depend datatyp provid inform valu interpret type judgment defin judgment readi implement in terpret note howev type result interpret judgment depend interpret sl type depend captur interpret function typev figur present implement interpret type typev map type assign meta type envev interpret judgment eval function eval defin case analysi type judg ment comput function significantli differ one present section differ includ addit type annot case analysi type judg ment importantli write requir use tag result valu type system allow us specifi return type function typev t tag longer need help us discrimin type valu get back runtim type system tell us static stage interpret metad figur show stage version eval hindleymiln type stage complic depend type stage interpret eval return valu type code typev t note type valu assign also chang see envev figur rather carri runtim valu sl carri piec code repres valu variabl assign execut program produc tagless code fragment interest in even though eval function never perform tag un tag interpret overhead travers input still consider judgement must deconstruct eval run time may requir even work deconstruct tag valu stage overhead perform first stage overheadfre term gener execut later stage stage violat prevent standard way metad type system see technic report stage construct davi addit crossstag persist refer reader refer detail natur stage violat ad run construct along line previou work consid here turn address practic question uniqu depend type set includ abovement judgement construct practic concern build type judgment amount implement either typecheck type infer languag interpret anoth practic concern type depend valu lead either undecid unsound type check happen valu contain diverg sideeffect comput section discuss concern address context metad construct type judgment requir user dsl suppli type judgment program interpret like accept although depend situat user abl use implement suppli plain text subject pro gram therefor implement need includ least type check function function take represent type annot program produc appropri type judgment exist might even want implement type infer requir type annot input figur present function typecheck function use illustr number featur metad type result typecheck depend sum jest mean result typecheck consist sl type type judgment prove argument express particular type given type assign sinc judgment built subjudg case strong depend sum elimin construct need deconstruct pure that comput effect whatsoev set result typecheck option t typ j est sinc particular term given typecheck may welltyp function given paper omit option save space and reli incomplet case express instead case natt nat arrowt typev t typev t case e empty unit ext e envev e typev t case j jn e n n jv e rho jw e j eval e rho ev i j jl ee et et es ej fn ja e j j eval e rho arrowt t j eval e rho j figur depend type tagless interpret without represent type case e empty unit ext e envev e code typev t case j jn e n jv e rho jw e j eval e rho ev i j jl ee et et es ej fn vtypev et eval ext ee et rho es et ej ja e j j eval e rho arrowt t j eval e rho j case ev nn case nn z case e ext ee n case e ext e case x rx typj typecheck e ev n el targ case x rt typ j typecheck ext e targ s ea case x rt typj case x rt typj case rt arrowt tdom tcod cast assert rttdomjestdom j end typecheck e s typecheck e s case x case natt eval empty natt j arrowt z typecheck empty s figur stage tagless interpret function typecheck without represent type result recurs call typecheck case construct applic judgment illustr interest point build judgment express ea s involv first comput judgment subterm s judgment assign type arrowt tdom tcod rt respect expr sion howev definit induct famili j order build larger applic judgment tdom rt must sl type ie typ valu must equal introduc two languag construct metad express sort constraint valu first express form assert introduc equal judgment id e e valu equal type elimin construct use cast express e type tv tv e equal judgment type id v v type checker allow use leibniz style equal prove cast correct sinc e equal judgment state v v equal oper express assert ee evalu two subexpress compar equal inde equal comput proce if howev two valu equal program rais except termin cast construct make sure equal judgment introduc assert evalu runtim equal check succe simpli proce evalu argument express altern use assertcast includ equal judgment type part type judgment build equal proof part typecheck function approach possibl prove verbos omit paper assertcast howev serv conveni program shortcut reliev user effort formal equal type level manipul equal type represent type combin effect depend type requir care ex ampl typecheck function partial mani input term well type sl input typecheck would caus runtim pattern match failur equal assert except would like metad continu sideeffect nontermin except time depend type languag perform comput type check to determin equal type allow effect comput leak comput done type check risk nontermin even unsound typecheck time goal often describ preserv phase distinct compil time runtim basic approach deal problem allow type depend type valu disallow kind depend howev would allow us express type check function produc term whose type depend featur restrict ground type whose valu shown equal runtim due space limit omit approach here defin altern typecheck function accompani technic report valu argument standard solut introduc mechan allow limit kind depend valu type limit depend use socal singleton represent type basic idea allow biject ground term valu type world now rewrit interpret type depend runtim valu may introduc effect typecheck phase comput type check phase guarante complet effectfre runtim valu forc represent type reflect world valu valu induct kind metad special type constructor r use express kind depend exampl defin induct kind nat induct note definit exactli one type nat except classifi instead definit encount introduc constructor type also possibl use special type constructor r write rss z refer type uniqu inhabit also call rep ss z figur present implement represent type introduc restrict type system requir us turn definit exp env typ definit kind again chang one charact definit term kind cannot use gener recurs defin interpret therefor use special primit recurs construct provid type languag defin interpreta tion judgment howev remain type now type index type valu part definit judgment interpret function chang need chang judgment case natur number augment represent valu number constructor jn becom definit eval chang accordingli modifi eval use helper function convert represent natur type natur number definit typecheck function requir substanti chang figur particular function requir carri case analysi type purpos metad provid special case construct tycas x c_n x_n e_n pattern c_n x_n match valu x type k k induct kind provid represent valu type rx pattern match induct kind cannot perform without presenc correspond runtim valu appropri represent type insid bodi case e_n express rep x_n provid represent valu part induct constructor x_n bound to formal develop section report main technic result type safeti formal core subset metad result show multistag program construct safe use even integr sophist depend type system follow approach use develop tl build comput languag l h use type languag integr formal practic see fundament reason distinguish two identifi them howev requir addit special support syntact sugar particular represent type induct induct induct induct induct induct primrec typ nat fn c fn c d fun cast n rn z zero cast case j jn e n rn cast n rn jv e rho jw e j eval e rho ev i j jl ee et et es ej fn ja e j j eval e rho arrowt t j eval e rho j tycas rs ev n tycas n rep n z tycas e ext ee n tycas e ext e t case x rx typj j jw e rx n j typecheck e rep e ev n rep ev n el targ case x typecheck ext e targ rep ext e targ rep s ea case x t typj case x t typj tycas j arrowt tdom tcod cast assert ttdomjestdomj end typecheck e rep e rep s typecheck e rep e rep s figur tagless interpret represent type metad induct w figur definit type l h type express cast e figur syntax l h cast figur type system l h framework gave us signific practic advantag formal develop l h import metatheoret properti type languag use tl alreadi proven sinc chang anyth type languag itself result eg churchross properti type languag decid equal type term easili reus proof base comput languag lh tri make differ two languag small possibl result proof type safeti l h similar type safeti proof lh again abl reus certain lemmata techniqu develop lh proof detail proof type safeti l h present extend technic report figur defin l h comput type first step need integr l h framework syntax comput languag l h given figur languag l h contain recurs stage construct contain two predefin represent type natur boolean construct lh provid propag proof inform branch analog tycas construct metad full implement induct datatyp style metad left futur work sinc arbitrari depend type prohibit l h use univers existenti quantif express depend valu type kind exampl ident function natur express l h follow l h also formal assertcast construct requir extend languag comput type equal judgment type similarli add appropri construct syntax l h abl defin smallstep semant stage lan guag defin syntax l h term levelindex famili express valu type judgment fig ure well type assign l h also appropri extend level annot levelannot erasur function j n use convert l h type assign form requir type judgment tl interfac allow us reus origin type judgment due lack space show definit smallstep semant l h these togeth proof relev theorem includ companion technic report here list import theorem proof structur induct e n e n examin case type judgment proof case possibl reduct e e proof use subject reduct lemma progress lemma lemma follow wright felleisen syntact techniqu relat work barendregt good highlevel introduct theori depend type system number refer strictli termin function program depend type theori literatur cayenn depend type program languag essenc direct combin depend type theori potenti nontermin recurs fact use implement unstag interpret similar one discuss paper work present extend work done cayenn three respect first cayenn allow type depend valu thu ensur type check termi nate second cayenn support depend datatyp like jest so write interpret involv use separ proof object encod inform carri jest mostli thread program number paramet pass metad cayenn implement eval function same use depend datatyp metad allow direct analog standard definit semant type judgment rather raw term third cayenn provid explicit support stage essenti compon achiev perform result achiev use tagless stage interpret xi pfen studi number differ practic approach introduc depend type program languag work concentr limit express depend type thu limit constraint need solv presburg arithmet problem singleton type seem first use xi context dml idea later use number work develop idea represent type intension type analysi logic framework use depend type basi proof system relat work logic framework alon suffici purpos interest comput program languag effect nontermin recent work shao saha trifonov papaspyr gener framework safe integr comput base languag rich depend type system without lose decid or sound typecheck dybjer extens studi semant induct set famili simultan induct recurs definit use former in type level also use valu level jest coq proof assist provid fairli extens support kind definit futur interest explor integr second techniqu program languag one interest problem whether selfinterpret possibl given program languag possibl simplytyp languag clear howev done depend type languag explor problem interest futur work final stage type infer also use mean obtain program without tag techniqu discuss paper probabl closest spirit tag elimin fact multistag set tag elimin appli runtim noth nonstandard type analysi key differ stage type infer system code type use reflect type inform type inform determin dynam type check impor tantli success failur stage type infer depend whether valu code type undergon simplifica tion easi return valu tell us at runtim languag whether dynam infer succeed not tag elimin hand work code explicit static type addit use care craft fallback plan projectionembed pair runtim tag elimin guarante alway denot semant but certainli oper semant independ test code analyz simplif may done subject program conclus futur work paper shown depend type program languag use express stage interpret complet circumv need runtim tag untag oper associ univers datatyp highlight two key practic issu aris tri develop stage interpret depend type languag first need function build represent type judgment interpret function defin over second need represent type avoid pollut type languag impur term comput languag demonstr stage construct depend type safe combin formal languag multistag comput languag type shao saha trifonov papaspi rou system allow us prove type safeti fairli straightforward manner without duplic work done system practic concern use depend type write interpret system decid type infer view highlyvalu featur type languag find annot burden simpl trick implement enough avoid need redund annot carri work develop deeper appreci subtleti involv depend type program implement type checker depend type languag current implement prototyp system made avail onlin next step studi integr depend type languag practic implement multistag program metaocaml also found lot opportun context depend type languag would like explor futur exampl includ syntact lightersupport represent type formal simpl trick use implement help allevi need redund type annot also interest explor use depend type reflect resourc need gener program r exercis depend type welltyp inter preter lambda calculi type littl languag phase distinct type theori type theori program flexibl type analysi resourc bound certifica tion intension polymorph typeerasur semant modal analysi stage comput induct defin set martinlof set theori induct set famili martin lof type theori settheoret semant induct set famili martinlof type theori settheoret semant induct famili gener formul simultan inductiverecurs definit type theori finit axiomat induct inductiverecurs definit tutori recurs type coq semant program languag framework defin logic compil polymorph use intent type analysi practic implement tag elimin build domain specif embed languag modular domain specif languag tool prove correct reactiv system use size type partial evalu automat program gener jonesoptim special strongli type languag metaocaml compil inherit limit ideal metaml simpler program construct set the ori exampl program martinlof type theori oregon graduat institut technic report induct definit system coq rule properti induct definit system coq rule properti emir pasal logic program lf logic frame work leap languag eval polymorph basic categori theori comput scientist microlanguag oper system specializa tion definit interpret higherord program languag definit interpret higherord program languag nikolao pa paspyr benaissa emir pasal peyton jone transform librari data structur sound reduct semant untyp cbn multistag comput direct function program realtim applic tag elimin type specialis typeindex effect tag elimin jonesoptim semant program languag fulli reflex intension type analysi syntact approach type sound elimin array bound check depend type depend type practic program tr basic categori theori comput scientist logic program lf logic framework induct set famili martinlomyampersandumlf type theori settheoret semant semant program languag partial evalu automat program gener syntact approach type sound compil polymorph use intension type analysi typebas compil standard ml modal analysi stage comput prove correct reactiv system use size type build domainspecif embed languag multistag program explicit annot dynam type stage type infer elimin array bound check depend type intension polymorph typeerasur semant depend type practic program flexibl type analysi resourc bound certif sound reduct semant untyp cbn mutlistag comput or theori metaml nontriv extend abstract dsl implement use stage monad fulli reflex intension type analysi type system certifi binari principl program languag semant applic implement program gener tag elimin jonesoptim jonesoptim special strongli type languag induct definit system coq rule properti multistag program direct function program realtim applic ideal metaml inherit limit definit interpret higherord program languag program construct set theori modular domain specif languag tool multistag program ctr chiyan chen hongwei xi implement type program transform acm sigplan notic v n p octob jason eckhardt roumen kaiabachev emir pasal kedar swadi walid taha implicitli heterogen multistag program new gener comput v n p januari manuel fhndrich michael carbin jame r laru reflect program gener pattern proceed th intern confer gener program compon engin octob portland oregon usa adam chlipala certifi typepreserv compil lambda calculu assembl languag acm sigplan notic v n june seth fogarti emir pasal jeremi siek walid taha concoqt index type now proceed acm sigplan symposium partial evalu semanticsbas program manipul januari nice franc oleg kiselyov chungchieh shan lightweight static capabl electron note theoret comput scienc entc v n p june chiyan chen rui shi hongwei xi implement type program transform fundamenta informatica v n p januari oleg kiselyov kedar n swadi walid taha methodolog gener verifi combinatori circuit proceed th acm intern confer embed softwar septemb pisa itali sheard languag futur acm sigplan notic v n decemb edwin bradi kevin hammond verifi stage interpret verifi compil proceed th intern confer gener program compon engin octob portland oregon usa jim grundi tom melham john oleari reflect function languag hardwar design theorem prove journal function program v n p march walid taha michael florentin nielsen environ classifi acm sigplan notic v n p januari