t templat metaprogram haskel a propos new extens pure function program languag haskel support compiletim metaprogram purpos system support algorithm construct program compiletimeth abil gener code compil time allow programm implement featur polytyp program macrolik expans user direct optim such inlin gener support data structur function exist data structur functionsour design implement glasgow haskel compil ghc b introduct compiletim program optim similar po etri written actual publish commerci compil hard econom realiti mani interest optim narrow audienc justifi cost altern allow programm defin compiletim op timiz alreadi happen accident c albeit imperfectli it is obviou function programm committe realiz later c templat function languag evalu compil time haskel workshop oct pittsburgh robinson provoc paper identifi c templat ma jor albeit accident success c languag design despit extrem baroqu natur templat metaprogram templat use fascin way extend beyond wildest dream languag design perhap surprisingli view fact templat function program function programm slow capit cs success recent flurri work runtim meta program much less done compiletim meta program scheme commun notabl except discuss section paper therefor present design compiletim metaprogram extens haskel stronglytyp pure function languag purpos extens allow programm comput part program rather write them seamlessli conveni extens view templat system haskel a la c well typesaf macro system make follow new contribut describ quasiquot mechan languag binder precis describ translat monad comput allow use gensym like oper even pure function languag like haskel section stage typecheck algorithm coroutin type check compiletim comput stage use ful support code gener written ordinari program would need given depend type languag therefor express simpl no depend still secur runtim comput either handwritten comput alway typecheck execut section reific programmerwritten compon support comput part program analyz structur userwritten part particularli use build boilerpl code deriv data type declar section addit origin contribut synthes previou work coher system provid new capabl includ represent code ordinari algebra datatyp make possibl use haskel exist mechan case analysi observ structur code therebi allow programm write code manipul program well code gener program section augment quotat monad encapsul metaprogram featur fresh name gener program reific error report monad librari syntax oper built top algebra datatyp quotat monad provid easytous interfac metaprogram part system section section quasiquot mechan built top monad li brari templat haskel extend metalevel oper static scope static typecheck objectlevel code fragment built use quasiquot mechan sec tion static scope typecheck automat extend code fragment built use algebra datatyp represent would program user section reific facil quotat monad allow programm at compiletim queri compil intern data structur ask question what line number sourcefil current posit use error report what kind type construc tor section metaprogram produc group declar includ data type class instanc declar well express section basic idea begin exampl illustr mean meta program consid write clike printf function haskel would like write someth like printf error s line d msg line one cannot defin printf haskel printf type de pend complic way valu first argument but see ingeni altern templat haskel though defin printf typesaf ie report error compiletim msg line type string int respect effici the control string interpret compil time userdefin no fix number compil extens ever enough write call templat haskel printf error s line d msg line say evalu compil time call printf return haskel express splice place call compil origin express proceed often use term splice splice printf return follow code n show lambda abstract typecheck appli msg line exampl interact session illustr prompt printf error s line d bad var error bad var line note templat haskel follow open parenthesi alphabet charact special syntact form x y mean x appli splice y wherea x mean ordinari infix applic function ordinari haskel situat similar ab mean someth differ b function printf execut compil time program produc program result metaprogram templat haskel user defin printf thu printf string expr type printf say transform format string haskel express type expr auxiliari function pars break format string tractabl list format specifi data string pars string format exampl pars d s return d l s even though pars execut compil time perfectli ordinari haskel function leav definit exercis function gen much interest first give code gen assum exactli one format specifi gen format expr gen l result gen construct use quasiquot notat templat templat haskel quasiquot user interfac repres haskel program construct place quasiquot bracket _ around ordinari haskel concret syntax fragment function lift string expr lift string expr type produc expr which execut would evalu liftss ar gument say lift section matter becom interest want make gen recur sive deal arbitrari list format specifi so give auxiliari paramet name express repres string prefix result adjust call printf accordingli printf string expr gen format expr expr gen insid quotat splice annot still mean evalu quasiquot code construct is gen call recurs call gen therefor run compil time result splice enclos quasiquot express argument should befor type expr second argument recurs call gen it accumul paramet type expr henc anoth quasiquot ex pression notic argument recurs call gen refer objectvari n s bound outer quasiquot occurr within static scope bind occurr static scope extend across templat mechan templat write program highlevel languag make program shorter concis easier maintain easier think about mani low level detail such data layout memori alloc abstract compil programm longer concern detail time good sinc expert knowledg embed compil compil job manner superior user could manag sometim programm know particular detail compil doe compil deal detail econom reason limit number featur compil writer put one compil solut construct compil manner ordinari user teach new trick rational behind templat haskel make easi programm teach compil certain class trick compil do manipul program make easi user manipul program also easi interlac manipul compil manipul creat power new tool envis templat haskel use programm mani thing condit compil extrem use compil singl program differ platform differ debug option differ configur crude approach use preprocessor like cpp inde sever compil haskel support directli mechan part program languag would work much better program reific enabl program inspect structur exampl gener function serialis data structur base data type declar structur algorithm program construct allow programm construct program algorithm describ construct program simpler program itself gener function like map show prime exampl compiletim special program like printf code compil special compiletim constant abstract transcend abstract mechan access languag exampl includ introduc higherord oper firstord languag use compiletim macro implement integ index function like zip zip zipn strongli type languag optim may teach compil domainspecif optim algebra law inlin opportun templat haskel function execut compil time written languag function execut run time name haskel choic sharp contrast mani exist system exampl cpp languag if defin etc templat metaprogram c written entir type system big advantag approach exist librari program skill use directli arguabl disadvantag explicit annot necessari specifi bit code execut when anoth consequ programm may erron write nontermin function execut compil time case compil fail termin regard program error avoid diverg run time rest paper flesh detail design shall see follow section turn simpl quasiquot splice notat introduc far enough flexibl construct one start use templat haskel long one discov quasiquot splice cannot express anyth like full rang metaprogram opportun want haskel builtin function select compon name fst snd want select first compon tripl write hand case x abc templat haskel instead write sel least would like to write sel sel int int expr sel case x uh oh cant write ordinari haskel pattern case express depend n quasiquot notat broken down instead need way construct haskel syntax tree directli like thi sel int int expr sel alt match pat patt rh expr base string code use syntaxconstruct function construct express pattern list these type concret exampl refer syntax pattern pvar string patt x ptup patt patt xyz pcon string patt patt fork x y pwild patt _ syntax express var string expr x app expr expr expr f x lam patt expr expr x case x simplem patt expr match xx code sel verbos printf use explicit constructor express rather implicit one exchang code construct fundament flexibl sel show templat haskel provid full famili syntax construct function lam pvar abov document appendix a two style mix freeli exampl could also sel like thi sel int int expr sel illustr idea further suppos want nari zip func tion whose call might look like thi zipn as bs cs list zipn int expr gener code nari zip let start write zipn zipn int expr metafunct zipn gener local let bind like let zip bodi bind the dot gener auxiliari metafunct mkzip defin be low function defin let zip exampl paragraph recurs name function realli matter sinc use result let never escap scope let whole let express return name function must pass mkzip mkzip gener bodi let properli scope size zip function n also paramet mkzip use see mkzip gener particular n understand work appli object variabl var ff gener valu expr type prettyprint valu concret syntax get case yyy note paramet var ff end function one arm case user level function zipn as oppos auxiliari function mkzip appli obtain full let note name bound variabl zp pass paramet mkzip end recurs call case yyy zp function mkzip oper gener bunch pattern eg y y xxsxxsxx bunch express use variabl bound pattern gener sever pattern each patternvari associ express each expressionvari common abstract function string int pattexpr map pvar ns map var ns pvar xpvar xvar xvar x mkzip use function construct three list match pattern express assembl piec lambda abstract whose bodi case analysi lambda abstract variabl px py pcon x pcon px pxss b use quasiquot mechan pattern p _ function app anoth idiom worth abstract function applic function multipl argument app expr expr app app messag section thi work quasiquot notat simpl conveni secur it understand haskel static scope type rule howev quasiquot alon enough usual want gener code sequenc indetermin length templat haskel syntaxconstruct function app lam case etc allow programm drop less conveni express notat and necessari declar reific haskel one may add deriv claus data type declar data tip fork t a t a deriv eq deriv eq claus instruct compil gener boilerpl code allow valu type compar equal howev mechan work hand builtin type class eq ord ix on want instanc class write hand tiresom winstanley wrote drift preprocessor haskel allow programm specifi codegener algorithm onc use algorithm gener boilerpl code mani data type much work also done polytyp algorithm whose execut specifi all base structur type templat haskel work like fullyintegr version drift exampl data tip fork t a t a splice geneq reifydecl t code show two new featur seen befor reific declar splice reific involv make intern represent avail data structur compiletim comput reific cover detail section declar splice construct splice may appear declar group need wherea seen express expect splice instruct compil run enclos code compiletim splice result declar group place splice call splice gener one declar exampl geneq gener singl instanc declar which essenti asid syntax use splice rather latter seem rather ters declar context particular applic deriv gener could also gener one class data type valu declar gener declar rather express use purpos deriv code data type consid nari zip function discuss section everi time write zipn bs cs fresh copi way zip gener ate may precis programm want say may also want gener singl toplevel zip function like thi might want gener zip function whatev write splice genzip understand zip zip zip brought scope quasiquot scope quotat monad ordinari haskel static scope templat haskel exampl consid metafunct crossa below crossa expr expr expr execut crossa var x var y expect var x var y would inadvert captur local objectvari x insid quasiquot crossa definit inde case prompt crossa var x var y display toplevel term type expr quasiquot notat renam x y get expect result static scope work ordinari haskel quasiquot lift behavior objectlevel well unfortu nate syntax construct function lam var tup etc behav way consid lam ptup pvar x pvar y tup app f var xapp g var y appli crossb x result inadvert captur prompt crossb var x var y display toplevel term type expr sinc program gener cannot written use quasiquot notat alon appear syntax construct function inadequ express static scope appear troubl need way gener fresh name turn next secret reveal here then one correct render cross templat haskel without use quasiquot crossc expr expr expr x gensym x return lam ptup pvar xpvar tup app ft var x exampl reveal three secret type expr synonym monad type q exp in deed true declar code return crossc repres ordinari haskel algebra datatyp fact two algebra data type exampl exp express constructor lam tup app etc pat pattern constructor pvar ptup etc monad q quotat monad support usual monad oper bind return fail do notat well gensym oper gensym string q string gener expr return crossc use haskel monad donot first gener fresh name x use monad gensym build express return notic tiresom also perform f g monad give ft gt type exp f g type might intern gensym see avoid pain section summar templat haskel three layer represent objectprogram order increas conveni decreas power bottom layer two part first ordinari algebra data type repres haskel program fragment section second quotat monad q encapsul notion gener fresh name well failur inputoutput section librari syntaxconstruct function tup app lift correspond algebra data type constructor tup app quotationmonad level provid conveni way access bottom layer section quasiquot notat introduc section conveni but seen import metaprogram cannot express revisit quasiquot notat section show built top previou layer programm freeli mix three layer latter two simpli conveni interfac first discuss detail first two layer code represent leav detail discuss quasiquot section datatyp code sinc objectprogram data haskel repres data structur use algebra datatyp natur templat haskel repres haskel objectprogram use algebra datatyp particular data type use templat haskel given appendix b highlight includ algebra datatyp repres express exp declar dec pattern pat type typ addit data type use repres syntact element haskel guard definit bodi express comprehens statement arithmet sequenc dotdot use comment freeli appendix b illustr algebra datatyp concret syntax exampl tri make data type complet yet simpl model haskel concret surfac syntax haskel program abl use algebra constructor function repres them advantag algebra approach objectprogram represent ordinari data particular analys use haskel case express pattern match disadvantag approach verbos to construct represent program requir consider effort requir construct program itself littl support semant featur object languag scope type syntaxconstruct function syntaxconstruct function section stand reveal monad variant correspond data type constructor exampl type data type constructor app monad counterpart rememb app exp exp exp app expr expr expr argument app comput wherea argument app data valu howev app conveni function simpli perform argument comput build result app expr expr expr x b return app b conveni worth while exampl yet anoth version cross crossd expr expr expr x gensym x lam ptup pvar x pvar tup app f var x var y use monad version constructor build result therebi avoid bind ft gt by hand crossc instead lam app tup us gener use follow nomenclatur fourcharact type name eg expr monad version threecharact algebra data type eg exp lowercas function eg app monad version uppercas data constructor eg app expr decl monad comput version underli concret type correspond type pattern patt type type simpli synonym underli data type constructor whose lowercas name would clash haskel keyword like let case do data class instanc use convent suffix lowercas name initi letter type lete case doe datad classd instanc reason need gensym construct pattern type look crossd abov would point gensym x insid pattern variabl must scope bodi lambda well nevertheless provid type synonym patt type togeth lowercas constructor pvar ptup etc programm use consist set lowercas work comput set even though format exp dec comput uppercas work algebra datatyp set syntaxconstruct function ordinari haskel librari one readili extend program mer seen one exampl that definit app end section mani other possibl exampl consid common pattern wish gener code scope newlygener pattern care name variabl pattern are clash exist name one approach gensym new variabl construct pattern express hand crossd altern clone whole pattern one fell swoop rather gener new variabl one time vfp genpat ptup pvar xpvar y lam p tupapp f vf xapp g vf y function genpat patt q stringexpr patt alpharenam whole pattern return new pattern function map name variabl origin pattern expr name variabl alpharenam pattern easi write recurs pattern scheme even mix quasiquot notat vfp genpat p xy use quasiquot notat pattern p _ mention pass section also suppli quasiquot notat declar d _ type t _ cours renam happen automat quasiquot explain detail section type templat haskel templat haskel strongli type milner sens welltyp program cannot go wrong runtim tradit strongli type program first typecheck compil execut situat templat haskel littl complic exampl consid first exampl printf error s line d urk cannot readili typecheck form type splice express depend complic way valu string argument templat haskel type check take place stage first type check bodi splice case printf error s line d expr next compil it execut it splice result place call exampl program becom n show urk typecheck result program programm written program first place henc type check intim interleav compiletim execut templat haskel compiletim metasystem metalevel oper bracket splice reific appear code gener exampl f ill gal restrict well exampl definit illeg unless insid quotat whi say evalu compil time splice valu x known f call common stage error enforc restrict like these break staticcheck part compil process three state compil c state normal compil without metaoper compil would alway state compil enter state bracket compil code insid quasiquot compil enter state splice s encount express escap insid quasiquot bracket exampl consid definit f static check state c call foo type state b call zipn type state s addit state count level start state increment process quasiquot decrement process insid splice level use distinguish toplevel splice splice insid quasiquot exampl call h static check state level x check state b level three state legal transit reflect figur transit diagram indic error transit tempt think state merg togeth case transit state c impli compiletim comput thu requir complic static check includ comput itself transit state rule diagram enforc weav type checker formal type judgment type checker given figur embodi transit diagram suppli case legal state studi rule detail express begin rule express simpler inde simplif wellestablish rule metaml type judgment rule express take convent form g environ map variabl type bind state e express type state describ state type checker n level describ abov reifi reifi splice figur type state templat haskel rule bracket say one state c s express e type q exp regardless type e how ever notic e still typecheck new state b increment level reflect legal transit figur emphas use bracket type rule one list state type check term e detect intern type inconsist right away exampl would reject immedi repres interest design compromis metafunct includ code fragment gener static check guarante metafunct produc welltyp code complet splice recheck believ new approach type meta program approach catch mani error earli possibl avoid need use depend type yet still complet typesaf notic too rule quasiquot state b quasiquot cannot nest unlik multistag languag metaml rule escb explain type check splice e insid quasi quot state b type e must q exp tell us noth type express e evalu to henc use unspecifi t problem sound how ever express splice sit typecheck later inde precis happen rule esc deal splice state c express e type check evalu give new express e express type check scratch in state c programm written first place rule lam var deal stage environ g contain assumpt form record xs type also level bound rule lam think environ finit function then variabl x use level n check n later bind level rule var declar figur also give rule type declar whose judgment form state cb reifydecl fun figur type rule templat haskel here g environ declar check g minienviron give type variabl bound decl rule quit convent exampl rule fun explain type function definit rule splice interest one follow pattern splice expr sion first typecheck splice express e run it typecheck declar return abil gener group declar seem fundament use rais interest complic cannot even resolv lexic scope program let alon type splice done exampl program valid splice genzip well valid splice bring zip scope as expect do doesnt similar remark natur appli instanc declar produc geneq function section modul contain sever splice may obviou order expand them tackl complic assum programm intend splice expand toptobottom precis singl haskel declar bind mani variabl typecheck group declar d n follow follow procedur group declar follow splice e d a b splice e b splice e z d z n splice declar one indic explicitli group d etc ordinari haskel declar perform convent depend analysi follow type check first group free variabl scope environ thu establish typecheck expand first splice typecheck result expand first splice augment environ thu establish typecheck next ordinari group on algorithm implement judgment declar list use rule splice restrict declar splice notic rule splice assum state c level permit declar splice state exampl permit thi splice pq h int decl typecheck f cannot run comput h x x known yet run h x know let bind cannot sensibl typecheck bodi let name pq would possibl give typecheck bodi sinc all result everi call f typecheck logic conclus line thought would give typecheck bodi quasiquot express would sound would defer mani type error definit site metafunct call site choic pend experi err side earlier error detect want effect f abov still get drop lower level fact current restrict splice further must toplevel declar like haskel data class instanc declara tion reason restrict concern usabl rather technic complex sinc declar splice introduc unspecifi new bind may clear variabl occur origin program bound situat similar haskel exist import statement bring scope unspecifi collect bind restrict splice top level make worthwhil gain given occurr x see lexic enclos bind x inde xs bind top level splice cannot hide anoth toplevel bind or import x haskel permit two definit valu top level in contrast nest splice could hide enclos bind x inde one think toplevel splice kind programm import statement quotat monad revisit far use quotat monad gener fresh name use purpos too discuss section reific reific templat haskel way allow programm queri state compil intern symbol tabl exampl programm may write modul data tip fork t a t a rept decl lengthtyp type percentfix q int q string first construct reifydecl return comput type decl ie q dec repres type declar t perform comput rept perhap write rept would obtain dec data mt a constr mtip tvar a constr mfork tapp tcon name mt tvar a tapp tcon name mt tvar write mt mean unambigu the defin modul m say mt origin name origin name part syntax haskel necessari describ and inde implement metaprogram cor rectli say origin name section similar way reifydecl f give data structur repres valu declar f similarli class in deed reific provid gener way get compiletim in format construct reifytyp length return comput type type ie q typ repres compil knowledg type librari function length similarli reifyfix tell fixiti argument use figur print someth final reifylocn return comput type q string repres locat sourc file reifylocn occur reifi alway return comput combin comput compiletim reific languag construct say map reifytyp xs exampl import reific return result quotat monad exampl consid definit assert function assert expr bool b r els error assert fail notic comment give type express gener assert static type system metaml would nicer one might invok assert like thi find xs assert splice expand get find xs n error assert fail line fooh n xs n vital cours reifylocn captur locat splice site assert rather definit site precis achiev make reifylocn return com putat one take idea further make assert behaviour depend commandlin argument analog cpp command mechan defin symbol dfoo cassert expr bool mb reifyopt debug isnoth mb els assert assum anoth reific function reifyopt string mayb string return noth d command line option specifi string defin valu one one could go on yet clear much reific allow exampl might use restrict use reifydecl type constructor class variabl eg function declar top level current modul perhap type constructor declar data declar import modul may also use support addit kind reific make compil symbol tabl inform avail failur compiletim metaprogram may fail programm made error exampl would expect zipn fail make sens produc nari zip function argument error sort due inappropri use rather bogu implement metaprogram metaprogramm need way cleanli report error anoth place quotat monad use case zipn write zipn int expr arg zipn must fail standard monad fail oper class monad whose type in instanc fail string q compil catch error report via fail grace report occur inputoutput metaprogram may requir access inputoutput facil exampl may want write splice genxml fooxml gener haskel data type declar correspond xml schema store file fooxml togeth boilerpl haskel function work data type end easili provid way perform arbitrari inputoutput quotat monad qio io q natur power open abus mere compil malici program might delet entir file store mani compromis posit possibl includ rule io altogth allow limit set benign oper such file read onli polici choic technic one consid here print code far produc code order splice modul compil sometim want write program gener haskel program put file rather compil it happi parser gener exampl exist program follow paradigm inde pedagog reason extrem conveni display code gener rather compil it end librari provid make exp dec etc instanc class show instanc show exp instanc show dec etc display code construct comput framework suppli function runq q io a thu compil run program e runq sel output x case x abc a pro duce notic absenc splice sel defin section implement q far treat q monad abstractli easi im plement io monad augment environ newtyp q environ contain mutabl locat serv name suppli gensym sourc locat toplevel splice invok evalu reifylocn compil symbol tabl support implement reifydecl reifyfix reifytyp commandlin switch support reifyopt thing could cours readili ad quasiquot lexic scope introduc quasiquot notat inform time pay direct attent quasiquot notat conveni shorthand repres haskel program lexic scope precis everi occurr variabl bound valu lexic scope occurr site origin sourc program templat expans obvioussound properti lisp commun call hygien macro metaprogram set nearli easi implement one might think quasiquot notat implement top quotat monad section saw variabl bound insid quasiquot must renam avoid inadvert captur the crossa exampl all variabl bound outsid quasiquot crossstag persist possibl splice expand express contain name scope splice occur need take care happen consid rather contriv exampl modul t genswap consid call genswap anoth modul modul foo import t genswap splice genswap expand to cannot expand swap becaus modul foo plain swap would bind boolean valu defin foo rather swap defin modul t splice expand tswap use haskel qualifiednam notat tswap scope foo genswap import foo name space import t genswap instead expand splice tswap use origin name tswap origin name first discuss section context represent return reifi solv similar problem here part code represent must unambigu refer global toplevel variabl may hidden scope represent may use extens haskel templat haskel use implement static scope across metaprogram extens access ordinari part haskel exampl one cannot write mmap f abil includ gener code valu variabl exist compiletim special name crossstag persist requir care implement correctli seen happen toplevel variabl swap nest variabl requir differ treatment particular consid statu variabl x free quotat swap x unlik swap x toplevel bind modul t inde noth xs type known modul com pile way give origin name sinc valu vari everi call genswap crossstag persist kind variabl qualit dif ferent requir turn arbitrari valu code exampl compil execut call genswap pass valu genswap latter must return data structur type exp app var tswap tup lit int lit int somehow code genswap lift valu exp show happen genswap becom quasiquot translat away lift x return app var tswap t here take advantag haskel exist typeclass mecha nism lift overload function defin type class class lift lift expr instanc lift allow programm explain lift type choic expr exampl one provid part templat haskel instanc lift int instanc lift alift b lift ab take advantag type class way requir slight chang type judgment var figur stage b is insid quasiquot variabl x bound outsid quasi quot top level type checker must inject type constraint lift t x type t we omit mention type constraint figur real system there cours summar lexic scope mean free variabl such swap x toplevel quasiquot such right hand side definit genswap static bound clo sure need scope applic site insid modul foo case inde quit differ valu name may scope noth terribl surpris simpli lexic scope action precis behaviour would expect genswap ordinari function dynam scope occasion programm may instead want dynam scope strategi gener code templat haskel express dynam scope too like thi splice site genswapdyn expand swap swap bind whatev swap scope splice site regardless scope definit genswapdyn behaviour sometim use templat haskel clearli flag use stringquot variabl name var swap unquot variabl lexic scope open question whether power desir not easili remov make var take gensym return abstract type instead string implement quasiquot quasiquot notat explain term origin name syntax constructor function use gensym return lift oper one think translat process term within quasiquot anoth term figur make translat precis express translat ordinari haskel function skeleton handl enough constructor pat exp illustr process omit mani other interest breviti main function tre translat express insid quasi quot first argument environ type venv ignor coupl paragraph given term exp call cl t construct anoth term t exp t evalu t genswap exampl compil translat genswap bodi swap x execut translat function tre argument tre cl app var swap var x result call exp app app var app app var var str tswap app var lift var x print concret syntax is app var tswap lift x wed expect quasiquot swap x expand quasiquot translat out it environ cl tell tre treat swap x differ captur translat process haskel function write tre cl app b tran a tran b tre cl cond x z tran x tran tran z tre cl simpl pattern captur here tre cl app cl ab tre cl cond x cl xyz tre venv exp exp tre cl es map tre cl es rep string exp exp app f app f return environ cl venv section discov variabl need treat differ depend bound environ record inform use tre decid translat variabl occurr string varclass data modnam lift bound varclass variabl v follow tre cl var s case cl bound rep var var s lift rep lift var s orig mod rep var str mod tre cl elitint tre cl app f cl fx tre cl tup cl es tre cl lam ps ps cl e tre cl esc tre cl br nest bracket allow tre venv exp exp tre cl es map tre cl es copi venv exp exp copi cl var copi cl lit c lit c copi cl app f cl f copi cl x copi cl lam ps ps copi cl e copi cl br cl e trp pat statement pat exp decpat trp p pvar s rep pvar var s ps ps trp pat statement pat exp decpat figur quasiquot translat function trexp orig mean v bound top level modul m v origin name lift mean v bound outsid quasiquot top level translat function gener call lift type checker later ensur type v class lift bound mean v bound insid quasiquot alpharenam three case reflect directli case var tre figur need auxiliari function trp translat pattern trp pat statement pat exp decpat first part pair return trp list statement repres gensym bind gener translat second part pair pat repres alpharenam pattern exampl translat patternvari such x get one bind statement x gensym x result pvar x trp hand look lam case tre lambda express such f x f x wish gener local bind preserv scope quot lambda f gensym f lam pvar fpvar x app var f var x bind f gensym f x gensym x renam pattern pvar fpvar x bound metavari ss xs call trp ps assembl bodi app var f var x gener recurs call tre new express return last interest case esc case consid exampl translat tre translat follow tup f gensym f lam pvar f var f f gensym f lam pvar fptup pvar xpvar app app var f var y w a notic bodi splice w a transcrib liter translat code w a copi function doe look copi interest case reach nest quasiquot resort back tre exampl given code transform f quasiquot term nest quotat within escap x gensym x lam pvar x tup f var xlit int relat work c templat c elabor metaprogram facil known templat basic idea static compiletim comput take place entir type system c templat class consid function whose argument either type integ thu factori return type one extract integ result return struct select conventionallynam member thu factorialret type system rich enough one construct manipul arbitrari data structur list tree etc type system use comput control objectlevel code gen erat now wide recogn typesystem comput languag simpli extraordinarili baroqu function languag full ad hoc code trick convent fact c templat wide use strong evid need thing barrier use consider believ templat haskel take principl approach task particular static comput languag dynam languag new program idiom requir first think idea cours lisp commun year discuss next scheme macro lisp commun taken templat metaprogram serious twenti year modern scheme system support elabor tower languag extens base entir macro earli design suffer badli namecaptur prob lem problem solv evolut hygien macro dybvig hieb bruggeman paper excel lent selfcontain summari state art differ vocabulari worldview combin subtleti materi make quit difficult give clear pictur differ scheme approach our immediatelyobvi differ templat haskel static type expans afterward scheme macro expand sort static type system howev report stage error beyond that three pervas way scheme system power less tractabl our scheme admit new bind form consid macro call suitablydefin macro foo might requir first argument variabl name scope second ar gument exampl call foo might expand to much complex scheme macro aris abil defin new bind form way templat haskel too much clumsili hand least make clear occurr var k lexic scope sourc program declar splice splice e bind variabl declar splice occur top level outsid quasi quot situat tractabl scheme macro special bind form definesyntax call site syntact baggag instead macro call identifi observ token function posit bound definesyntax templat haskel special syntax definit site templat function ordinari haskel function splice requir call site interest tradeoff here templat haskel macro complet higherord first class like function pass argument return result partial appli construct anonym lamb da on scheme macro pretti much first order must call name bawden discuss firstclass macro scheme admit side effect complic everyth mutabl valu instanti move compiletim runtim share on haskel free complic metaml deriv goal metaml templat haskel differ sig nificantli mani lesson learn build metaml influenc templat haskel design import featur migrat metaml templat haskel includ use templat or quasiquot notat mean construct object program typesafeti program fragment ever execut context typecheck type check construct program fragment happen compiletim static scope objectvari includ alpha renam bound objectvari avoid inadvert captur crossstag persist free objectvari repres runtim function mention objectcod fragment correctli bound scope code creat use metaml also signific differ templat haskel metaml differ follow differ assumpt metaprogram system use follow assumpt use design templat haskel differ strongli metaml user comput portion program rather write pay runtim overhead henc assumpt exactli two stage compiletim runtim metaml code built execut even runtim templat haskel code meant compil metacomput happen compiletim code repres algebra datatyp henc amen inspect case analysi appear first odd staticscop quasiquot mechan shown accomplish rather interest way use monad everyth static typecheck check delay last possibl moment use strategi justintim type check allow power metaprogram written without resort depend type handwritten code reifiabl ie data repres obtain manipul runtim function data type definit reifi ie data structur represent obtain inspect compiletim function quasiquot metaml indic boundari stage execut bracket run metaml akin quot eval scheme templat haskel bracket indic boundari compiletim execut runtim execut one main breakthrough type system metaml introduct quasiquot respect scope type metaml code gener program typecorrect program gener properti crucial gener step happen runtim late start report type error howev secur come price metaml cannot express mani use program exampl printf exampl section cannot type metaml type call printf depend valu string argument one way address problem use depend type system approach distinct disadvantag here start programm would burden write function transform format string type type system becom much complic explain templat haskel second stage may give rise type error still occur compil time situat much less seriou runtim code gener contribut current work develop semant quasiquot monad comput allow quasi quot exist pure languag without side effect process gener fresh name encapsul monad henc quasiquot referenti transpar metaocaml metaocaml stage ml implement built top ocaml system like metaml runtim code gener sy tem unlik metaml compil rather interpret gener compil bytecod runtim demonstr impress perform gain stage program non stage counterpart translat quasiquot manner preserv scopingstructur quot express first implement metaocaml macroml macroml propos add compiletim macro ml languag macroml demonstr even macro implement new bind construct given precis semant stage program macro strongli type macroml allow introduct new hygen local binder macroml support gener macro macro limit construct new code combin code fragment cannot analyz code fragment dynam type approach justintim typecheck root earlier studi dynam type stage typeinfer work well templat haskel type code fragment split stage templat haskel code final typecheck toplevel splice point splice state c work code type check splice point addit code construct splice point typecheck runtim activi tie signific effort place reduc runtim overhead typecheck implement small prototyp read templat haskel perform compiletim execut throe scale prototyp full implement embodi templat haskel extens glasgow haskel compil ghc ghc implement fulli support separ compil in deed compil modul m function defin modul compili earlier execut compil time rea son execut function defin itself compil would need compil function function call way execut code even typecheck part m compiletim function invok compil find previouslycompil execut dynam link and modul packag import run com piler modul consist complet metafunct need link execut built final link step although ghc make yet clever enough figur out work design repres work progress hope that provid work implement work driven directli experi real user meanwhil mani avenu alreadi know want work on veri import except reifi data type defini tion said littl userdefin code manipul optim one advertis goal well get that yet know confus error messag templat haskel be given may aris code programm see least possibl display code alreadi found one often want get earlier type secur addit document say thi expr whose type int like metaml type expect add parameteris code type expr int use expr or such indic type static known c templat scheme macro lighterweight syntax call macro do inde programm may need awar macro involv all interest tradeoff discuss briefli section lot said reduc syntact baggag call site specul idea infer splice annot acknowledg would like particularli thank matthew flatt sever long convers explor relationship templat haskel scheme macro error comparison two remain our also thank magnu carlsson fergu henderson toni hoar dick kieburtz simon marlow emir pasal haskel workshop refere help comment draft work would also like thank student class cse fundament stage comput winter particip mani live discuss use stage especi bill how whose final project motiv tim sheard begin work work describ support nsf grant ccr mj murdock charit trust depart defens r modern c bytecod compil macro work function unpars technic overview gener haskel syntact abstract scheme macro multistag comput typesaf deriv type class hygien macro expans special form lisp impact econom compil optimiza tion accomplish research challeng meta program introduct multistag program use metaml tr macro work syntact abstract scheme multistag program explicit annot dynam type stage type infer hygien macro expans firstclass macro type impact econom compil optim macro multistag comput accomplish research challeng metaprogram special form lisp ctr andi gill introduc haskel equat reason assist proceed acm sigplan workshop haskel septemb portland oregon usa bjrn bringert ander hckersten conni andersson martin andersson mari bergman victor blomqvist torbjrn martin student paper haskelldb improv proceed acm sigplan workshop haskel p septemb snowbird utah usa walid taha patricia johann stage notat definit proceed second intern confer gener program compon engin p septemb erfurt germani sava krsti john matthew semant reflect languag proceed th acm sigplan intern confer principl practic declar program p august verona itali gregori neverov paul roe toward fullyreflect metaprogram languag proceed twentyeighth australasian confer comput scienc p januari newcastl australia sheard languag futur companion th annual acm sigplan confer objectori program system languag applic octob vancouv bc canada martin sulzmann meng wang aspectori program type class proceed th workshop foundat aspectori languag p march vancouv british columbia canada ralf lmmel simon peyton jone scrap boilerpl class extens gener function acm sigplan notic v n septemb louisjulien guillemett stefan monnier typesaf code transform haskel electron note theoret comput scienc entc v n p june bjrn bringert aarn ranta pattern almost composit function acm sigplan notic v n septemb marco viera alberto pardo multistag languag intension analysi proceed th intern confer gener program compon engin octob portland oregon usa ralf lmmel scrap boilerpl xpathlik combin acm sigplan notic v n januari lloyd allison program paradigm machin learn case studi bayesian network proceed th australasian comput scienc confer p januari hobart australia tim sheard emir pasal twolevel type parameter modul journal function program v n p septemb arthur i baar s doaits swierstra typesaf self inspect code proceed acm sigplan workshop haskel septemb snowbird utah usa syme leverag net metaprogram compon f integr queri interoper heterogen execut proceed workshop ml septemb portland oregon usa amr sabri model quantum comput haskel proceed acm sigplan workshop haskel p august uppsala sweden martin erwig zhe fu softwar reus scientif comput program gener acm transact softwar engin methodolog tosem v n p april jerzi karczmarczuk structur interpret quantum mechan function framework proceed acm sigplan workshop haskel p august uppsala sweden jame cheney scrap namepl function pearl acm sigplan notic v n septemb ralf lmmel simon peyton jone scrap boilerpl practic design pattern gener program acm sigplan notic v n march stephani weirich replib librari deriv type class proceed acm sigplan workshop haskel septemb portland oregon usa edwin bradi kevin hammond verifi stage interpret verifi compil proceed th intern confer gener program compon engin octob portland oregon usa murdoch j gabbay new calculu context proceed th acm sigplan intern confer principl practic declar program p juli lisbon portug maribel fernndez fabien fleutot histor function objectori calculu proceed th acm sigplan symposium principl practic declar program juli venic itali chiyan chen hongwei xi metaprogram type code represent journal function program v n p novemb sheard languag futur acm sigplan notic v n decemb ralf hinz gener mass journal function program v n p juli martin erwig dele ren updat calculu express typesaf program updat scienc comput program v n p juli jim grundi tom melham john oleari reflect function languag hardwar design theorem prove journal function program v n p march judith bayard cush nalini nadkarni michael finch ann fiala emerson murphyhil loi delcambr david maier componentbas endus databas design ecologist journal intellig inform system v n p august rita loogen yolanda ortegamalln ricardo peamar parallel function program eden journal function program v n p may paul hudak john hugh simon peyton jone philip wadler histori haskel lazi class proceed third acm sigplan confer histori program languag p june san diego california