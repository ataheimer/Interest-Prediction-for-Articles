t regular languag testabl constant number queri a continu studi combinatori properti test initi goldreich goldwass ron j acm pp subject paper test regular languag main result follow regular languag lin integ n exist random algorithm alway accept word w length n win l reject high probabl w modifi least epsilon n posit creat word l algorithm queri tildeoepsilon bit w queri complex shown optim factor polylogarithm epsilon also discuss testabl complex languag show particular queri complex requir test contextfre languag cannot bound function epsilon problem test regular languag view part gener approach seek probe testabl properti defin logic mean b introduct properti test deal question decid whether given input x satis prescrib properti p far input satisfi it let p properti ie nonempti famili binari word word w length n call far satisfi p word w length dier w n place satis p test p random algorithm given quantiti n abil make queri valu desir bit input word w length n distinguish probabl least case w p preliminari version paper appear proceed th symposium foundat comput scienc depart mathemat raymond beverli sackler faculti exact scienc tel aviv univers tel aviv israel att labsresearch florham park nj usa email nogamathtauacil research support usa isra bsf grant grant israel scienc foundat hermann minkowski minerva center geometri tel aviv univers z depart mathemat raymond beverli sackler faculti exact scienc tel aviv univers tel aviv israel email krivelevmathtauacil part research perform author dimac center rutger univers piscataway nj usa att labsresearch florham park nj usa research support part dimac postdoctor fellowship x depart comput scienc univers haifa haifa israel email ilancshaifaacil part research perform author visit at lab research florham park nj usa school mathemat institut advanc studi olden lane princeton nj usa email szegedymathiasedu part research perform author att labsresearch florham park nj usa case w far satisfi p final say properti p c testabl everi exist test p whose total number queri bound c properti test dene goldreich et al inspir emerg natur context pac learn program check probabilist checkabl proof approxim algorithm author mainli consid graph properti bipartit show among thing quit surpris fact test bipartit done randomli test polynomi number edg graph answer question constant probabl failur also rais question obtain gener result is everi test properti use queri ie c function independ n constant probabl failur call properti type testabl far answer quit spars interest exampl given sever addit one obtain appli regular lemma show subsequ paper paper address testabl formal languag see gener refer languag properti usual view sequenc boolean function f main result state regular languag testabl queri complex o also show complex optim factor polylogarithm posit result cannot extend contextfre languag exampl simpl contextfre languag testabl sinc regular languag character use second order monad logic thu obtain larg set logic dene object testabl provid testabl graph properti describ logic mean well result indic strong interrel testabl logic although result regular languag view separ result logic bear all opinion logic provid right context testabl problem may lead discoveri class testabl properti rest paper organ follow section present proof main result show everi regular languag testabl section show upper bound o queri complex test regular languag obtain theorem tight polylogarithm factor section devot discuss testabl contextfre languag show particular exist nontest contextfre languag also discuss testabl dyck languag nal section contain conclud remark outlin new research direct test regular languag section prove main result paper name regular languag o testabl result asymptot assum n big enough respect and respect constant depend xed languag work with logarithm binari unless state explicitli otherwis start recal standard denit regular languag base nite automata denit conveni algorithm purpos denit determinist nite automaton dfa f g state given function set f q one state q call initi state state belong set f call accept state call transit function extend transit function f g recurs follow let denot empti word thu start state q process string u end state q u say accept word u q reject u mean q final languag accept denot lm set u f g accept use follow denit regular languag denit languag regular exist nite automaton accept it therefor assum section regular languag l given automaton word w length n dene sequenc state q follow natur way q j n sequenc describ automaton move read w later paper occasion refer sequenc travers path w nite automaton dene direct graph gm v g period gg direct graph g greatest common divisor cycl length g g acycl set use follow lemma direct graph lemma let e nonempti strongli connect direct graph nite period gg exist partit v exceed jv j everi everi length everi direct path u v g j i mod everi everi everi integ r m mod g exist direct path u v g length r proof prove part x arbitrari vertex z v g let v set vertic reachabl v direct not necessarili simpl path length g note sinc close direct walk g disjoint union cycl length walk divis g impli set v pairwis disjoint inde assum fals suppos w lie v v j j g strongli connect path p w z denit path p length mod g z w well path p length mod g z w number edg either divis g imposs therefor set v form inde partit v union direct path z u direct path u v form path z v path must length j mod g assert part follow next prove part consid set posit integ fa g whose greatest common divisor g well known smallest number everi integ divis g linear combin nonneg integ coecient number moreov known see smaller squar maxim number fix close direct walk g visit vertic whose length jv j thi easili obtain number vertic g arbitrarili concaten direct path v v i k indic taken modulo k associ set cycl length walk set posit integ fa g abov then follow close walk travers direct cycl mani time desir conclud everi integ divis g exce jv j length close walk pass vertic graph given now vertex integ r jv j i mod g x shortest path p u v note length l satis l j i mod g l jv j jv j ad p close walk length r l v obtain requir path complet proof call constant lemma reachabl constant g denot mg sequel assum divis g lm f g test algorithm reject input without read all therefor assum nontrivi case lm f g n introduc key denit sequel denit given word w f g n subword run w w start posit call feasibl languag lm exist state q q q reachabl q g exactli step path length n jw g state q w least one accept state otherwis w call cours nding infeas run w prove w l aim show given word w length n far word length n l mani short run w infeas thu choic small number random run w almost sure contain infeas run first treat follow basic case denit call automaton essenti strongli connect uniqu accept state q acc set state automaton q partit two part c subgraph gm induc c strongli connect edg gm go c but edg go c d note may empti lemma assum languag contain word length n essenti strongli connect c partit state denit let reachabl constant gc assum also n logm word w length exist integ logm number infeas run w length i least n proof intent construct sequenc r j j disjoint infeas run minim sens prex feasibl subword given word w show concaten subword form word languag far w not far essenti depend number run construct turn show distw l n lower bound number infeas run reason becom obviou later also want run interv m natur way construct sequenc repeat follow procedur start shortest infeas run start wm end run stop assum construct end wc j next construct r j take minim infeas run start wc end wn m run stop assum construct way run r r h note run subword w run pairwis disjoint concaten order form continu subword w also note denit run r j minim infeas prex r obtain discard last bit r j feasibl thi turn impli r j obtain r j ip last bit feasibl addit denit mean r state q j reachabl q c next induct construct word w l distw w hm m assum distw l n impli lower bound h gener idea glue togeth r h feasibl yet close subword w except last bit each concern glue piec togeth whole word feasibl requir extra chang bit per run plu addit bit end word maintain induct construct feasibl start posit end posit c j base case let c word length feasibl start posit assum alreadi dene word w posit end posit c j let q p j q j reachabl q path length c j accord lemma chang last bit w j get word u j q dene w j concaten u j r let w h nal word dene way end place c h reason stop r h either infeas run start c h case chang last bit w h concaten remain sux w that start posit c h exactli case ad r yield requir w possibl reason stop grow r h minim infeas run start c h end posit n m let r run let r run obtain ip last bit r case r feasibl posit c h henc feasibl word u r prex u length q h construct w w h u exactli construct w form w h sux w previou case denit w w l follow induct construct w follow get w h w concaten r either subword w in rst case previous discuss subword w one bit chang in second case follow chang bit end w h possibl addit bit end u therefor distw w hm claim recal distw l n conclud h n last inequ assumpt n logm alreadi show distw l n n mani disjoint infeas run w howev need stronger depend state lemma achiev follow way let logm a denot number run fr j g h whose length fall interv p h nm nm therefor exist index nam consid infeas run r j jr run contain infeas subrun infeas itself now infeas run length contain least run length i except mayb rst two last two run these two smallest js two largest js r j disjoint infeas run length contain three r j length least thu get total least run length i assumpt paramet number is logm claim aim reduc gener case describ case given dfa graph cg graph compon g whose vertic correspond maximalbi inclus strongli connect compon g whose direct edg connect compon g connect edg g note vertic cg may repres singl vertic g self loop belong strongli connect subgraph g least two vertic compon non empti path insid call truli connect reserv k number vertic cg set may assum vertic g reachabl initi state q cg acycl graph exist direct path compon c contain q everi compon run truli connect compon g correspond vertic cg assum sequel follow relat satis paramet condit k log mk log clearli xed k m l small enough n larg enough condit hold next step describ word w lm length n move along automaton word w belong l travers g start q end one accept state accordingli w travers cg start c end compon contain accept state reason call path cg admiss start c end compon accept state given admiss path cg sequenc pair vertic g state m call admiss sequenc portal satis follow restrict everi j t accept state everi j one p idea behind denit admiss portal simpl given admiss path a admiss sequenc p portal dene word w l move one strongli connect compon next one start initi state q end accept state rst last state travers c j now given admiss path correspond admiss sequenc p portal say increas sequenc integ form admiss partit respect a p follow hold everi j t exist path p j p length n j mean partit j follow w l w travers accord t valu n j indic w arriv compon c rst time n j bit conveni also set n thu j t word w stay c j interv n possibl principl given admiss path correspond admiss sequenc portal p correspond admiss partit thi could happen path set portal p correspond word length n triplet a admiss path p correspond admiss sequenc portal correspond admiss partit call admiss triplet clear denit admiss triplet word w l travers g accord scenario suggest one admiss triplet therefor order get convinc w l enough check w admiss triplet fix admiss triplet a t dene languag l j contain word travers p j p done formal dene automaton j follow set state j obtain ad new state f j initi state j uniqu accept state p respect f g q set j name j transit within c remain same transit go compon go f j loop itself thu j essenti strongli connect denit g l j languag accept j given xed admiss triplet a word w length subword set t note jw name w path accord partit substr w j correspond portion travers path w lie within compon c lemma let a admiss triplet let w word length n satisfi distw l n dene languag l word w describ abov exist index j j t distw k proof assum case let j partit recal k everi word length n j n j the empti word also j choos j f g p j construct word w belong l distw w contradictionnow present key idea proof ideal would like test whether input word w length n ts admiss triplet posit case ie w lm travers path w dene natur admiss triplet w obvious t neg case ie distw l n lemma impli everi admiss triplet a p least one subword w j far correspond languag l j lemma w j contain mani short infeas run thu sampl small number random run catch one high probabl howev problem total number admiss triplet clearli depend n make task appli directli union bound probabl catch infeas run imposs circumv diculti follow way place evenli bound number depend paramet m transit interv bound length postul transit compon cg happen insid transit interv show w l modi slightli meet restrict wherea distw l n choic admiss triplet w far tting it number admiss triplet consider bound function onli appli union bound estim probabl failur recal run truli connect compon g correspond vertic cg let log place transit interv s evenli n length transit interv jt m algorithm input word w length logkm choos r random run w length i admiss triplet a j j one follow form automata j j t describ abov discard chosen run end begin place p jp n j j nkm log name run one end closer nkm log remain run r r fall n j n j check whether feasibl automaton j start b n rst coordin r w name place r start rel n j place w enter j admiss triplet check run turn feasibl output ye otherwis ie case admiss triplet least one infeas run found output no lemma distw l n algorithm output no probabl least w l algorithm alway output ye proof proof contain two independ part rst consid case input w distw l n algorithm answer no with high probabl part treat case w l algorithm answer ye let us rst assum distw l n number admiss triplet a partit point fall union transit interv estim rst choos admiss path cg number admiss path k subset vertic cg dene one path span it choos portal total number chosen portal k therefor jv j k possibl choic portal xed sjt j choic n j j k satisfi condit abov express k thu need check k admiss triplet let admiss triplet satisfi restrict formul step algorithm write triplet dene automata languag l describ befor lemma j one nk lemma exist i logkm contain least nkm logkm run length i may touch last bit interv n may touch rst bit interv henc least nkm log touch neither rst last nkm log bit interv obvious random sampl contain one infeas run provid certic fact w admiss triplet random sampl r run length i miss infeas run probabl k thu union bound conclud case random sampl contain wit feasibl triplet probabl complet proof case distw l n address case w l need show case algorithm answer ye enough show w l exist admiss triplet pass success test algorithm travers w natur dene triplet a follow compon cg order accord order travers w rst resp last state c visit w set rst time w enter travers howev partit necessarili meet requir state step algorithm true travers w transit c j c j might occur outsid transit interv show desir triplet obtain actual triplet modifi third compon it modi triplet would correspond dierent word w which quit close w make transit insid postul transit interv addit take care queri made bit w dier w henc algorithm actual consist both fact reason discard run close n j step algorithm intuit done follow assum n j transit interv either make travers longer end p transit interv shorten travers c enter transit interv depend closest transit interv is formal done follow dene new partit choos transit interv closest n j c truli connect compon choos n j leftmost coordin satisfi follow restrict a n singleton without loop set n n exist final set note obtain triplet a truli connect exist path p j p length n j n j also exist path length n j impli admiss henc admiss a let r run w insid n j nkm log let b rst coordin sinc place transit interv ft g evenli n jn m therefor r fall also complet insid n remark point purpos discard margin run step algorithm achiev one remain run fall complet within n j also within see immedi guarante r feasibl correspond automaton j without delet posit probabl one sampl run r may start place w c end place w c j thu make imposs attribut r one particular automaton j therefor posit probabl algorithm would fail posit case discard margin run allow us get onesid error algorithm w l exist state q c q r c also q reachabl p the initi state c step b rst coordin r accord choic n j period c lemma q reachabl p m step show r feasibl j start b n thu w l algorithm alway output ye final number bit w queri algorithm logkm x logkm x thu proven follow theorem theorem everi regular languag l everi integ n everi small enough exist onesid error test algorithm l f g n whose queri complex c log constant c depend l nal note depend complex paramet place here proof consid xed algorithm tailor xed given languag howev calcul kept depend queri complex paramet explicit one take mind though estim hold condit hold particular requir third item anoth note run time algorithm rather queri complex domin term step rst two subset step algorithm queri complex last substep run check j check involv check whether word u word v of suitabl length urv l check whether u v done directli lemma case length u v longer m check word one shorter m lower bound regular languag mani testabl question quit natur expect lower bound order queri complex test usual proven take posit exampl size n perturb randomli chosen n place creat neg instanc hard distinguish posit one regular languag except respect shown next proposit fairli simpl proof proposit let l regular languag alphabet f g dene g n test l f g n queri complex least proof proof base follow reformul renown principl yao say exist probabl distribut union posit neg exampl determinist test algorithm queri complex correct probabl less input randomli chosen accord distribut lower bound queri complex random test algorithm dene distribut set posit neg instanc length n follow word get probabl next partit index set n size n give probabl t vector creat n ip bit note disti neg instanc appli mention principl yao let determinist test algorithm queri complex d incorrect word n alreadi incorrect probabl least otherwis accept input test bit equal therefor accept well least input show give incorrect answer probabl least t dt impli t main idea proof proposit use get lower bound queri complex test nontrivi regular languag natur denit nontrivi proven next proposit somewhat paradox featur proof main posit result theorem proof use get neg result languag l let l denit languag l nontrivi exist constant innit mani valu n set l n nonempti exist word w f g n distw l n n proposit let l nontrivi regular languag sucient small test algorithm l requir queri proof proof essenti gener proof proposit thu present somewhat abridg form let n larg enough assum l n w f g n distw l n n may clearli assum constant small need purpos main result theorem proof impli probabl least random choic set run built describ step test algorithm theorem total length algorithm reject w notic test algorithm one side error ie alway accept word l thu choos random set run abov caus reject w probabl coincid word u l n for otherwis would reject u too random set run random set interv ng of length dene step test algorithm total length bound two random set intersect probabl n therefor choos n subset random expect o n pair intersect member reject w impli exist famili disjoint set run member s word l n coincid w set fix let small enough compar partit famili cardin n constant c depend thu independ let u word l n t word w obtain u chang bit u correspond w follow inde transform w word l n least one bit chang everi member now proof proposit dene probabl distribut union posit neg exampl word u get probabl one word w probabl t simpl argument essenti ident proof proposit show determinist algorithm need queri least bit input word success probabl least dene probabl distribut appli yao principl get desir result testabl contextfre languag essenti complet analysi testabl regular languag quit natur tri make one step address testabl much complex class contextfre languag see eg background inform turn gener situat chang drastic compar case regular languag show exist quit simpl contextfre languag testabl turn attent one particular famili contextfre languag socal dyck languag prove rst languag famili testabl time polynomi languag famili alreadi nontest relev denit proof follow contextfre languag nontest alreadi mention contextfre languag testabl proven follow proposit theorem test algorithm contextfre languag revers word w requir n queri order error proof let n divis dene distribut union posit neg input follow way neg instanc chosen uniformli random among neg instanc ie word w f g n distanc least n l refer distribut n posit instanc gener accord distribut p dene follow pick uniformli random integ k interv n select posit exampl uniformli among word vv r uu r k final distribut input dene follow probabl choos posit input accord p probabl choos neg input accord n note posit instanc actual pair k w the word w may gener use dierent ks use mention yao principl again let determinist test algorithm l show a maximum number queri n expect error respect least algorithm view binari decis tree node repres queri certain place two outgo edg label repres possibl answer leaf repres end possibl comput label posit neg accord decis algorithm trace path root node a associ node pair q ng set queri input word f vector answer receiv algorithm may obvious assum full binari tree height thu leav jq leaf a use follow notat subset q ng function f f qg f qg set neg resp posit instanc length n consist pair q f also probabl distribut set binari string length n subset dene pr pr w set leav label posit let set leav label neg total error algorithm distribut pr theorem follow follow two claim everi subset q ng cardin pr e q f everi subset q ng cardin n everi function f pr base claim estim error algorithm pr theorem follow present proof claim proof claim notic rst l n n word length n rst choos word length n cut two part v u thu get word number word length n distanc less n l jl f g n j logn get follow denit pr e q f proof claim follow denit distribut word w lf g n pr recal f set word l consist f set queri q henc pr observ pair place q two choic k pair symmetr respect k n k impli n choic k set q contain pair symmetr respect k nk k therefor pr conclud remark subsect would like note next subsect theorem give anoth proof fact contextfre languag testabl show nontest dyck languag howev prefer give theorem well due follow reason first languag discuss theorem simpler natur dyck languag secondli lower bound theorem better theorem proof two theorem mani common point reader may view theorem warmup theorem testabl dyck languag would extrem nice determin exactli contextfre languag testabl present seem far fulll task howev abl solv question complet one famili contextfre languag call dyck languag integ n dyck languag order n denot n languag alphabet n symbol group n order pair a languag n dene follow product denot empti word though word n binari accord denit easili encod grammar describ use s s thu may still assum framework languag binari alphabet interpret n languag n distinct pair bracket word w belong n form balanc bracket express basic well known languag famili one pair bracket dyck languag play import role theori contextfre languag see eg relev discuss therefor task explor testabl interest rst goal subsect show languag testabl let us introduc suitabl notat first sake simplic denot bracket assum n larg enough even number obvious odd n f g noth test case let w binari word length n n denot xw i number s rst posit w also yw i stand number rst posit w follow claim word w belong follow two condit hold a xw i proof follow easili denit exampl induct length w omit detail proof proof observ rst claim word w partit letter pairwis disjoint pair left letter pair zero right letter one consid bipartit graph whose two class vertic set indic set indic respect connect assumpt a defect form hall theorem graph contain match size least yw n assumpt b yw n n therefor least n disjoint pair letter w pair zero left one right let us pair remain element w arbitrarili pair one consist either two s two s chang now need left entri pair right entri obtain word total number chang perform s complet proof a n one yw i xw i s distw s b proof follow immedi claim conclud three claim word w far coordin deviat signicantli necessari sucient condit provid claim observ use analysi algorithm test propos below c sucient larg constant whose valu chosen later assum even integ follow omit oor ceil sign simplifi present algorithm input word w length choos sampl bit follow way bit w independ probabl choos s then contain ye without queri bit els dist f g lemma algorithm output correct answer probabl least proof alreadi mention set proof contain two independ part rst prove algorithm correct with probabl second part prove algorithm bound error word w distw n consid rst posit case w set assum simplic well nt integ j t let x j number s s sampl interv njt let also j denot number s s sampl interv x j j binomi random variabl paramet xw njt p yw njt p respect w get claim xw njt yw njt impli ex j ey j appli standard bound tail binomi distribut obtain note ez j npt use similar argument abov get w claim xw henc final follow estim distribut sampl size jsj choos c larg enough recal denit t deriv probabl least follow event hold simultan x np jsj np assum four condit satis claim dist inde rst two condit guarante jsj ys i xs i npt last two condit provid xs jsj ys therefor claim algorithm accept w probabl least requir end rst part proof let us consid neg case assum distw f g n n claim least one follow two condit hold a exist index n yw i xw i n b xw n yw n n former case let x number s s respect s sampl interv i let also k number element i chosen s binomi distribut paramet xw i p yw i p respect follow denit ey ex np choos constant c sucient larg recal denit p see probabl ys follow claim xw n yw n n obtain use similar argument probabl made choic c xs jsj ys jsj follow claim dist thu case obtain algorithm accept w probabl addit algorithm may accept w in case rst item algorithm howev equat may bound choos c rst part henc algorithm reject w probabl least complet proof lemma lemma follow result testabl dyck languag theorem everi integ n everi small enough exist test algorithm queri complex c log absolut constant c reader possibl notic one signic dierenc algorithm section test regular languag algorithm test algorithm test regular languag onesid error algorithm section twosid error coincid show onesid error algorithm test membership whose number queri bound function onli inde assum onesid error algorithm test consid execut input word easi see distu n therefor must reject u probabl least fix sequenc coin toss make reject u denot q correspond set queri bit u claim jq nnj n n exist word w length n q prove claim may clearli assum jq n follow take rst n indic n set last n indic n sucient condit membership given claim inde point j n n number s rst j bit w least larg number s also j n therefor w assum onesid error algorithm alway accept everi must jq n queri linear n number bit proven follow statement proposit onesid error test membership queri n bit word length n next goal prove dyck languag name k k nontest present detail proof statement clearli impli result k sake clariti exposit replac symbol denit respect dene follow contextfre empti word mind mention bracket interpret dyck languag sometim refer left bracket right bracket note use encod languag f g rather alphabet size clearli nontest dene impli nontest binari encod obtain xed binari encod f g theorem languag testabl proof let n larg enough integ divis denot l use yao principl assign probabl distribut input length n show determinist algorithm probe bit output incorrect answer probabl o posit neg word compos three part rst sequenc match bracket rst kind follow sequenc left bracket sequenc right bracket posit instanc gener accord distribut p follow choos k uniformli random rang given k word length n length n k gener by choos vi random set vn k neg instanc chosen follow process similar posit case except restrict vn k name choos k random rang given k word length n length n k gener by choos vi random choos vn k i random let us denot n distribut stage note word gener may distanc less n l n in fact word l n gener too henc condit n event word distanc least n l n probabl distribut input length n dene choos probabl posit instanc gener abov probabl neg instanc chosen accord describ process probabl instanc gener accord n nclose word l n exponenti small n proof fix k let word length n gener n xed k three part w rst part match length k second part random sequenc length n kand third part random sequenc length n k let us denot three disjoint set indic w bound number word w length n form kwhich distanc n l n first choos valu w n give n kpossibl choos at most n bit w chang get word l n n choic set bit n possibl point part w still set valu n allow use right bracket word obtain belong l n easi see one way complet current word word l n use right bracket onli henc number word altogeth n k total number word w form word get probabl distribut n therefor probabl word chosen accord n nclose l n estim n nn n small enough promis d xed set place let k chosen uniformli random rang n n contain pair j symmetr respect n k probabl n proof distinct pair uniqu k symmetr respect point henc probabl bound return proof theorem let algorithm test l n queri queri may assum nonadapt name queri xed set place size as everi adapt made non adapt queri ahead possibl queri dene two possibl branch adapt queri look queri s possibl set answer f input event w consist f s let nosym event contain symmetr pair respect n k also let f denot f s algorithm answer no let f f s answer ye final denot w posit w neg event random w posit instanc neg instanc respect total error algorithm howev given contain symmetr pair xed f probf w w neg essenti equal probf w w posit these probabl would exactli equal neg w would gener accord n claim assert n exponenti close real distribut neg instanc henc probabl probf w jnosym o plug sum abov use claim get error probabl bound probnosym f oprobf w jnosym conclud remark main technic achiev paper proof testabl regular languag possibl continu research describ class testabl languag formul sucient condit contextfre languag testabl recal theorem shown contextfre languag testabl one natur way describ larg class testabl combinatori properti put restrict logic formula dene them particular restrict ariti particip relat number quantier altern order logic express rst order second order etc result present paper exampl approach sinc regular languag exactli express second order monad logic unari predic embed linear order anoth exampl found sequel paper address testabl graph properti dene sentenc rst order logic binari predic complement class graph properti shown testabl goldreich et al analog result predic higher ariti would desir obtain technic diculti aris ariti greater two long term goal propos systemat studi testabl logic dene class sinc mani dierent type logic framework known nd one suit studi challeng virtual singl problem look far perspect captur gener logic dene class member testabl properti dierent avenu tri develop gener combinatori techniqu prove lower bound queri complex test arbitrari properti possibl nding analog block sensit fourier analysi approach decis tree complex present candid combinatori condit would necessari sucient testabl acknowledg would like thank ode goldreich help comment also grate anonym refere care read r proof veri proof conjectur erd properti test connect learn approxim introduct automata theori bound solut linear diophantin problem new direct test degre boolean function real polynomi robust character polynomi applic program test probabilist comput tr ctr michal parna dana ron ronitt rubinfeld test membership parenthesi languag random structur algorithm v n p januari beat bollig larg lower bound queri complex simpl boolean function inform process letter v n p august beat bollig ingo wegen function readonc branch program quadrat size necessarili testabl inform process letter v n p juli eldar fischer strength comparison properti test inform comput v n p februari eldar fischer eric lehman ilan newman sofya raskhodnikova ronitt rubinfeld alex samorodnitski monoton test gener poset domain proceed thiryfourth annual acm symposium theori comput may montreal quebec canada eli bensasson prahladh harsha sofya raskhodnikova cnf properti hard test proceed thirtyfifth annual acm symposium theori comput june san diego ca usa alon test subgraph larg graph random structur algorithm v n p octob eldar fischer ilan newman ji sgall function readtwic constant width branch program necessarili testabl random structur algorithm v n p march alon asaf shapira everi monoton graph properti testabl proceed thirtyseventh annual acm symposium theori comput may baltimor md usa asaf shapira combinatori character testabl graph properti regular proceed thirtyeighth annual acm symposium theori comput may seattl wa usa alon asaf shapira test subgraph direct graph proceed thirtyfifth annual acm symposium theori comput june san diego ca usa alon asaf shapira character easili testabl induc subgraph proceed fifteenth annual acmsiam symposium discret algorithm januari new orlean louisiana