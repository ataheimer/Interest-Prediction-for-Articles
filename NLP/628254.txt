t hash method tempor data a extern dynam hash use tradit databas system fast method answer membership queri given dynam set object membership queri ask whether object ident k the current state of s paper address gener problem tempor hash set chang dynam set timestamp membership queri tempor predic in find whether object ident k set time t present effici solut problem take ephemer hash scheme make partial persist solut also term partial persist hash use linear space total number chang evolut set small olog_bnb queri overhead experiment comparison partial persist hash variou straightforward approach like extern linear hash multivers btree rtree show provid faster membership queri respons time partial persist hash seen extens tradit extern dynam hash tempor environ independ ephemer dynam hash scheme use paper concentr linear hash methodolog appli dynam hash scheme well b introduct hash use fast method address membership queri given set object distinguish ident attribut oid membership queri ask whether object oid k set s hash appli either main memori scheme all data fit mainmemori dkm fnss databas system where data store disk l latter form call extern hash en r hash function map oid bucket everi object s hash function comput bucket number object store bucket initi size page discuss assum page hold b object ideal distinct oid map separ bucket howev unrealist univers oid usual much larger number bucket alloc hash scheme b oid map bucket bucket overflow occur overflow dealt variou way includ rehash tri find anoth bucket use anoth hash scheme andor chain creat chain page overflown bucket overflow present find whether given oid hash set trivial simpli comput hash function queri oid visit appropri bucket object set bucket henc hash scheme perfect membership queri answer o step just one io access page bucket overflow howev complic situat data known advanc worst case queri perform hash larg linear size set sinc oid could map bucket g kollio dept comput inform scienc polytechn univers brooklyn ny gkolliosparospolyedu v j tsotra dept comput scienc univers california riversid research partial support nsf grant iri new york state scienc technolog foundat part center advanc technolog program bad hash scheme use nevertheless practic shown absenc patholog data good hash scheme overflow constant averag case queri perform usual bucket size one two page exist one major differ hash index scheme balanc tree b tree c use instead answer membership queri take logarithm on size s time worst case mani applic for exampl join comput sd hash scheme provid expect constant queri perform one two io prefer worst case logarithm queri perform four io larg balanc search tree static hash refer scheme use predefin set bucket ineffici set allow chang by ad delet object set set small number prealloc bucket larg scheme use space need set becom larg small number bucket use overflow becom often deterior scheme perform need dynam hash scheme properti alloc space proport size hash set s variou extern dynam hash scheme propos among linear hash l or variat appear commonli use note even set evolv tradit dynam hash ephemer ie answer membership queri current state set s paper address gener problem assum chang set timestamp time instant occur interest answer membership queri state set possess let st denot state collect object set time t membership queri tempor predic in given oid k time find whether k st term problem tempor hash new queri tempor membership queri motiv tempor hash problem stem applic current well past data interest exampl includ account bill market taxrel social medic financialstockmarket applic applic cannot effici maintain convent databas work term singl usual current logic state instead tempor databas propos sa time vari data two time dimens use model realiti name validtim transactiontim j valid time denot time fact valid realiti transact time time fact store databas transact time consist serial order transact ie monoton increas implement use commit time transact s rest term time tempor refer transactiontim assum everi time st chang by addingdelet object could good ephemer dynam hash scheme say linear hash ht map effici with overflow oid st collect bucket bt one straightforward solut tempor hash problem would separ store collect bucket bt t answer tempor membership queri oid k time need appli ht k access appropri bucket bt would provid excel queri perform take advantag good linear hash scheme ht use t space requir prohibit larg n denot number chang ss evolut flash bt disk could easili creat on space instead propos effici solut similar queri perform use space linear n term solut partial persist hash reduc origin problem collect partial persist subproblem appli two approach solv subproblem first approach see subproblem evolv subset set base snapshot index tk second approach see subproblem evolv sublist whose histori effici kept case partial persist hash scheme observ store evolut ephemer hash effici way enabl fast access ht bt we note partial persist fit nice transactiontim databas environ alway increas characterist compar partial persist hash three approach first one use tradit dynam hash function map oid ever creat evolut st solut distinguish among mani copi oid k may creat time proce given oid k ad delet mani time creat copi k associ differ time interv copi hash bucket bucket reorgan solv problem thi also observ as overflow eventu deterior perform especi number copi increas second approach see oidinterv combin multidimension object use rtree store it third approach assum b tree use index st make b tree partial persist bgo vv ls experi show structur call persist store access past state dsst call partial persist structur evolv appli chang most current state partial persist hash outperform three competitor membership queri perform minim space overhead partial persist b tree bgo vv ls technic interest among competitor approach correspond extend ephemer b tree tempor environ like ephemer b tree support worst case logarithm queri time tempor queri open problem whether effici tempor extens exist hash scheme work present answer question posit nontempor environ partial persist hash provid faster index expect queri perform tempor membership queri result reassert conjectur ktf tempor problem support transactiontim solv take effici solut correspond nontempor problem make partial persist rest paper organ follow section present background previou work relat tempor index method interest here section describ basic snapshot index linear hash descript partial persist hash appear section perform comparison present section conclus open problem research appear section background previou work research tempor databas shown immens growth recent year os work tempor access method concentr index worst case comparison tempor index appear st best knowledg approach address hash problem tempor environ among exist tempor index four special interest paper name snapshot index tk timesplit btree tsb ls multivers btree mvbt bgo multivers access structur mva vv simpl model tempor evolut follow assum time discret describ success nonneg integ consid simplic initi empti set s time proce object ad delet set object ad if ever delet s call aliv repres associ object semiclos interv lifespan form start_tim end_tim object aliv cannot read s ie contain duplic delet appli aliv object object ad t start_tim end_tim yet unknown thu lifespan interv initi t now variabl repres alway increas current time object later delet s end_tim updat object delet time sinc object ad delet mani time object oid may exist nonintersect lifespan interv ie object aliv differ time state set given time t name st collect aliv object time t assum evolut store transactiontim databas way chang happen time t transact timestamp updat databas variou queri may ask tempor databas common queri puresnapshot problem also denot s propos notat tj given time find st anoth common queri rangesnapshot problem rs given time rang oid r find aliv object st oid rang r categor tempor index accord queri answer effici compar perform use three cost space queri time updat time ie time need updat index chang happen set s clearli index solv rangesnapshot queri also solv puresnapshot queri if rang provid howev indic tgh method design address primarili puresnapshot queri need order incom chang accord oid note evolut model chang arriv increas time order unord oid henc method could enjoy faster updat time method design rangesnapshot queri latter order incom chang oid provid fast respons rangesnapshot queri inde snapshot index solv puresnapshot queri io use onb space o updat time per chang in expect amort sens clr hash scheme employ iooptim solut pure snapshot queri here correspond number aliv object queri state st rangesnapshot queri three effici method exist name tsb tree mvbt tree mva structur assum exist b tree index st time proce set evolv correspond b tree evolv too differ algorithm provid effici store access b tree evolut answer rangesnapshot queri time impli access b tree time search node find oid rang interest conceptu approach take b tree make partial persist dsst result structur form graph includ whole histori evolv b tree abl effici access past state b tree log b mvbt mva solv rangesnapshot queri io use onb space updat per chang in amort sens clr optim solut rangesnapshot queri denot number aliv object updat take place denot answer size rangesnapshot queri ie mani object queri st oid queri rang r mva structur improv mergesplit polici mvbt thu result smaller constant space bound tsb tree anoth effici solut rangesnapshot queri practic space effici mvbt and mva guarante worst case queri perform set evolut describ addit new object updat exist object sinc purpos paper assum object delet frequent use mvbt instead tsb basic snapshot index linear hash purpos partial persist hash need fundament snapshot index ephemer linear hash describ next detail descript refer tk l s en r respect snapshot index method tk solv puresnapshot problem use three basic structur balanc tree timetre index data page time pointer structur accessforest among data page hash scheme timetre accessforest enabl fast queri respons hash scheme use updat purpos first discuss updat object store sequenti data page order ad set s particular new object oid k ad set time t new record form k t now creat append data page data page becom full new data page use on given instant one data page store accept record acceptor data page time acceptor page creat along page address store time tree acceptor page creat sequenti timetre easili maintain amort o io index new acceptor page object addit sequenc data page resembl regular log two main differ way delet updat manag use addit link pointer among data page creat accessforest log b log io object delet ad sequenti rather inplac updat object k delet time record first locat updat k t now k t object record found use oid hash scheme object ad oid address page store object record insert hash scheme object delet hash scheme consult object record locat interv updat object oid remov hash function store one record object suggest time instant record object st may dispers variou data page access page aliv object t would requir much io if st object may access oa page henc record aliv object must cluster togeth ideal ab page achiev good cluster introduc copi control manner ie way total space remain explain copi procedur need introduc concept page use consid page get full record ie stop acceptor page number aliv record contain record interv end now time instant page contain ub aliv record call use time page contain good part answer st puresnapshot queri time abl locat use page time page contribut least ub object answer use paramet u constant tune behavior snapshot index acceptor page special page acceptor page may contain fewer ub aliv record definit also call page use long acceptor page page may give enough answer justifi access still access it nevertheless time instant exist exactli one acceptor page let ustart_tim uend_tim denot page use period ustart_tim time page start acceptor page page get full either continu use and long page least ub aliv record becom nonus if time becam full page less ub aliv record next step cluster aliv record among use page t page becom nonus artifici copi occur copi aliv record page current acceptor page as timesplit e ls nonus page behav object mark delet copi aliv record still found acceptor page copi record contain subsequ nonoverlap interv object lifespan copi procedur reduc origin problem find aliv object find use page t solut reduc problem facilit accessforest accessforest pointer structur creat logic forest tree among data page new acceptor page append end doublylink list remain list long use data page becom nonus a remov list b becom next child page page c preced list ie c left sibl list becam nonus time proce process creat tree nonus data page root use data page list accessforest number properti enabl fast search use page time tk show start acceptor page use page found twice mani io in practic much less io need find acceptor page balanc timetre search which correspond logarithm part queri time practic search fast height balanc tree small it store one entri per acceptor page clearli onb main part queri time find use page perform snapshot index fine tune chang paramet u larg u impli acceptor page becom nonus faster thu copi creat increas space also cluster answer smaller number page ie less queri io linear hash linear hash lh dynam hash scheme adjust grace data insert delet scheme use collect bucket grow shrink one bucket time overflow handl creat chain page overflown bucket hash function chang dynam given instant two hash function use scheme specif let u univers oid h m initi hash function use load set bucket for exampl h insert delet oid perform use h first overflow happen first overflow occur it occur bucket first bucket lh file bucket split rehash two bucket origin bucket new bucket m attach end lh file oid origin map bucket use function h distribut bucket use new hash function h oid next overflow attach new bucket m content bucket distribut use h bucket m crucial properti h oid origin map h bucket j remap either bucket j bucket jm necessari properti linear hash work exampl hash function is h overflow caus addit bucket split linear bucketnumb order variabl p indic bucket split next conceptu valu p denot two hash function may enabl given time appli bucket initi p mean one hash function use appli bucket lh file first overflow exampl p h introduc suppos object oid k insert second overflow ie p first older hash function appli k bucket h k split yet k store bucket otherwis bucket provid h alreadi split newer hash function store bucket h k search oid similar is hash function may involv enough overflow origin bucket split mark end split round round p went subsequ bucket bucket m end round lh file total bucket hash function h longer need bucket address hash function h note reset new round name splittinground start next overflow in bucket introduc hash function h oid oid mod m round last bucket m split gener round start hash function h oid oid round end bucket split purpos use h call split function h split function h j properti ii oid either h j given time linear hash scheme complet identifi round number variabl p given round variabl p search oid k perform use h otherwis h i use round valu p increas one overflow next round i start p reset split perform whenev overflow occur uncontrol split let l denot lh file load factor ie current number oid lh file size set s b page size in number oid r current number bucket file load factor achiev uncontrol split usual depend page size l br oid distribut l practic achiev higher storag util split instead perform overflow occur load factor upper threshold g control split typic achiev util delet set caus lh file shrink bucket split recombin load factor fall lower threshold f two bucket merg togeth oper revers split occur revers linear order practic valu f g respect partial persist hash first describ evolvingset approach base snapshot index evolv list approach follow evolvingset approach use partial persist tempor hash problem reduc number subproblem effici solut known assum ephemer linear hash scheme as one describ section use map object st st evolv time hash scheme function time too let lht denot linear hash file time t two basic timedepend paramet identifi lht t name it pt paramet it round number time t valu paramet pt identifi next bucket split interest properti linear hash bucket reus round i start doubl number bucket round first half bucket sequenc sinc new bucket append end file let b total denot longest sequenc bucket ever use evolut st assum b total consist bucket let bt sequenc bucket use time t observ impli t bt prefix b total addit consid bucket b j sequenc b total observ collect object store bucket time proce state bucket b j time t name b j t set oid store bucket t let denot number oid b j t state somehow reconstruct bucket b j answer tempor membership queri oid k time answer two step find bucket b j oid k would map hash scheme t and search content b j t k found first step requir identifi hash scheme use time t evolut hash scheme lht easili maintain record form t it pt append array h instant valu it andor pt chang given t hash function use identifi simpli locat insid timeord h logarithm search second step impli access b j t obviou way would store b j t time b j t chang explain earlier would easili creat quadrat space requir updat per chang would also suffer sinc io store current state b j would proport bucket current size name observ evolut bucket b j note state chang evolv set ad delet oid chang timestamp time instant occur time ephemer linear hash scheme may appli rehash procedur remap current content bucket b j bucket b j new bucket b r assum rehash occur time result move v oid b j b r evolut b j b r rehash view delet respect addit v oid time ie delet addit timestamp time correspond object evolut figur show exampl ephemer hash scheme two differ time instant simplic figur show correspond evolut set evolut variou bucket time addit oid bucket caus first overflow rehash content bucket bucket bucket result oid move bucket bucket evolut chang consid delet addit oid instant b j t avail search content oid k perform linear search process lower bound io sinc mani page least need store b j t thi similar tradit hash queri oid translat search page bucket search also linear continu oid found bucket page search therefor need method given reconstruct b j t effort proport io sinc everi bucket b j behav like set evolv time snapshot index tk use store evolut b j reconstruct b j t requir effici thu conclud given evolv set s partial persist hash answer tempor membership queri oid k time t almost queri time effici plu small overhead separ ephemer hash scheme exist st good ephemer hash scheme st would requir expect o io answer membership queri mean averag bucket b j t use st would limit size equival correspond page in practic one two page perspect partial persist hash reconstruct b j t io expect o small overhead incur persist hash due fact store whole histori ss evolut singl state st array h store entri everi time page overflow occur even chang new oid addit number overflow upper bound onb henc array h index page search take io identifi hash function appropri bucket b j pinpoint time must search timetre associ bucket overhead impli search bound n j correspond number chang record bucket bucket bucket a b figur two instant evolut ephemer hash scheme a time split occur map bucket caus overflow bucket rehash use h log histori practic expect n chang ss evolut concentr first b total bucket sequenc simpli prefix sequenc alway use assum ss histori record first bucket for i n j behav therefor search b j s timetre rather fast logarithm overhead proport number chang n common characterist queri time tempor index use partial persist mvbt or mva tree answer tempor membership queri oid k time t io note mvbt logarithm bound contain two search first appropri btree index st found fast search similar identifi hash function bucket search persist hash second logarithm search mvbt find k tree index st logarithm size st instead persist hash find oid k expect o io figur detail evolut set time additiondelet respect chang assign histori three bucket shown hash scheme figur assum addit oid caus first overflow move oid bucket bucket seen delet addit respect record store bucket histori also shown exampl t oid delet set s updat lifespan oid correspond record bucket s histori now evolut set time now now oid lifespan record bucket s histori now oid lifespan evolut bucket oid lifespan now now oid lifespan record bucket s histori now now oid lifespan evolut bucket now oid lifespan oid lifespan record bucket s histori now oid lifespan evolut bucket now oid lifespan now now updat space analysi proceed analysi updat space characterist partial persist hash suffic show scheme use onb space o amort expect updat process per chang deriv clearli array h satisfi space bound next show space use bucket histori also bound onb recal n correspond total number real object additionsdelet set ss evolut howev rehash process move object among bucket bucket histori move seen new chang delet oid previou bucket subsequ addit oid new bucket must thu shown number move due rehash still bound number real chang n purpos use two lemma lemma n overflow occur least nb real object addit need proof proof base induct number overflow creation first n overflow least b oid addit need happen oid map bucket hold b oid each bucket start one empti page assum n first overflow nb real object addit need must prove first overflow need least nb oid addit assum true ie oid addit enough show contradict result assumpt accord first n n overflow need nb real object addit henc b remain oid addit creat extra overflow consid page last overflow occur bucket page exactli one record if less would overflow more nth overflow could achiev one less oid page overflow need least b oid addit ie remain b enough nth overflow result contradict lemma prove note page nth overflow occur need consid page space addit oid cannot one oid alreadi sinc overflow occur bucket could achiev less oid q previou lemma lower bound number real oid addit n overflow next lemma upper bound total number copi due oid rehash happen overflow lemma n overflow creat nb oid copi proof use induct number overflow first overflow creat b oid copi happen first overflow occur oid bucket remap new bucket delet record remap b oid still store histori origin bucket assum n first overflow nb oid copi must shown first n overflow creat nb oid copi use contradict henc let assum true ie first n overflow creat copi let nbx number consid last n overflow sequenc overflow impli overflow alreadi creat nb oid copi henc least bx addit copi creat first overflow howev contradict sinc first overflow creat copi q readi prove basic theorem space updat theorem partial persist hash use space proport total number real chang updat amort expect o per chang proof assum simplic set evolv ad oid oid addit creat new record overflow henc copi delet creat overflow overflow occur linear hash proce round first round variabl p start bucket end round reach bucket m point bucket use copi remap oid first round creat sinc overflow occur lemma impli must least mb real oid addit copi construct copi place last bucket next round variabl p start bucket extend bucket m p reach bucket m new overflow new overflow impli must least mb new real oid addit mb copi creat addit also mb copi oid first round purpos second round seen regular oid copi oid copi second round the origin oid copi creat first round cannot copi second round repres delet record correspond bucket henc maximum number copi second round is mb total number copi c total creat ith round i upper bound by repres copi per round equival ith round total number real oid addit total lower bound by equival ii i ii deriv exist posit constant const sinc total bound total number chang n on prove partial persist hash o expect amort updat per chang note real chang occur direct appropri bucket structur snapshot index updat o expect time rehash care examin rehash bucket caus singl real oid addit the one creat overflow result bunch copi made new bucket at wors whole current content rehash bucket sent new bucket howev use space bound prove sequenc n real chang creat on copi extra work equival o amort effort per real chang q optim issu optim perform partial persist hash involv load factor l ephemer linear hash use paramet u snapshot rt denot size evolv set number bucket use clearli good ephemer linear hash scheme tri equal distribut oid among bucket t henc averag size in oid bucket b j t satisfi total mb mb total mb k c total total const l one advantag snapshot index abil tune perform use paramet u index distribut oid b j t among number use page sinc use page except acceptor page contain least ub aliv oid oid occupi page actual lu ideal would like answer snapshot queri contain singl page plu probabl one acceptor page good optim choic keep conceptu load l give measur size bucket aliv oid time aliv oid store data page snapshot index recal artifici copi happen number aliv oid data page fall ub point remain ub aliv oid page copi new page keep l u expect aliv oid split page copi singl page minim number io need find them hand use paramet u affect space use snapshot index return overal space persist hash scheme mention section higher valu u impli frequent time split ie page copi thu space henc would advantag keep u low impli even lower l return lower l would mean bucket ephemer hash fulli util low l caus set st distribut bucket may fulli occupi first requir seem contradictori howev purpos partial persist hash low l still accept recal low l appli ephemer hash scheme whose histori partial persist hash observ accumul even though singl time instant b j ts may fulli util whole time evolut mani object oid map bucket count partial persist scheme total number chang accumul per bucket due bucket reus bucket gather mani chang creat larg histori bucket thu justifi use partial persist scheme find regard optim verifi experiment result appear next section evolvinglist approach element bucket b j t also view evolv list lb j t aliv oid observ consist way bucket search ephemer hash ie linearli bucket content belong list practic bucket expect one two page long access bucket state b j t reduc reconstruct lb j t equival evolv list oid made partial persist l u bucket b j first creat empti page assign list lb j list page two area first area use store oid record size b r b r b second area of size accommod extra structur array nt explain shortli first oid k ad bucket b j time t record k t now append first list page addit oid insert creat record insert list page append need oid k delet bucket record list found by serial search among list page end_tim updat a logic delet snapshot index need notion page use page call use long contain least v aliv object last page list otherwis nonus page follow discuss assum except last page list use page becom nonus oid delet which bring number aliv oid page threshold last page turn use nonus get full record an event caus oid insert time page total number aliv oid less l page becom nonus otherwis continu regular use page last page get full new last page ad list find state b j t equival find use page lb j t use two extra structur first structur array ft j t time provid access first use page lb j t entri array ft j form time pid pid page address first use page list chang t new entri pid new first use page append ft j array implement multilevel pagin index sinc entri ad increas time order find remain use page lb j t everi use page must know next use page list achiev second structur implement insid everi list page particular structur form array store page area size b r let nta array insid page a array maintain long page use entri nta also form time pid pid correspond address next use page use page a use period page a next use page chang mani time nta becom full assum scenario happen time let c use page page a page artifici turn nonus even still v aliv record replac copi it page call process artifici sinc caus oid insertiondelet page rather due chang page ahead new page aliv record empti nt new entri ad ntc s pid first entri nt pid use page if ani page t use list page page nt array full time t process artifici turn use page nonus propag way top list reach first use page list copi creat array ft j updat howev happen often figur show exampl array nt ft j maintain need artifici creation copi page faster queri process ntc array enabl find next use page c variou time instant assum moment new copi page creat instead nta allow grow avail area page a addit page last entri ntc would still point page a locat next page c time would lead page serial search among page array nta need clearli approach ineffici use page front page chang often use artifici copi guard similar situat next use list page time interest found one io techniqu gener backward updat techniqu use tgh special care need page turn use nonus due oid delet a a a a figur a exampl evolut use page list lb j t b correspond ft j nt array page nt array shown exampl bb entri sinc page front page chang often nta array fill time artifici copi page creat array nta array ntc also updat artifici creat new page f f f f a b artifici entri insert page achiev good answer cluster aliv oid page merg aliv oid sibl use page if sibl exist creat one or two depend number aliv oid new use page new use page may full record oid ie futur oid insert accommod there result new oid insert list use page serial search new oid ad first use page found space in b r area accommod it detail describ appendix answer tempor membership queri oid k time appropri bucket b j oid would map hash scheme must found part evolvingset approach reconstruct state bucket b j t perform two step first use first use page lb j t found search array ft j which correspond search timetre bucket evolvingset approach search bound remain use page lb j t and thu oid b j t found locat nt array subsequ use page instead evolvingset approach use access forest snapshot index sinc use page except last list lb j t least v aliv oid answer oid b j t found addit io space use evolvinglist structur on j b two differ evolvinglist evolvingset approach first updat use snapshot index remain constant evolv list whole current list may search ad delet oid second natur reconstruct b j t differ evolvinglist reconstruct start top list page evolvingset reconstruct start last page bucket may affect search given oid depend whether place near top near end bucket perform analysi compar partial persist hash pph linear hash in particular atempor linear hash discuss later mvbt rtree implement experiment setup describ data workload find method implement experiment setup set size page hold oid record b oid record follow form oid start_tim end_tim ptr first field oid second start time third end time oid lifespan last field pointer actual object which may addit attribut log first discuss atempor linear hash alh clarifi alh ephemer linear hash whose evolut partial persist hash observ store rather linear hash scheme treat time anoth attribut scheme simpli map object bucket use object oid consequ see differ lifespan oid copi oid implement alh use scheme origin propos litwin lin split function use hash divis function h get good space util control split employ lower upper threshold name f g valu respect anoth approach atempor hash would scheme use combin oid start_tim end_tim attribut howev approach would still problem alh tempor membership queri exampl hash start_tim help queri time instant start_tim multivers btree mvbt implement base bgo fast updat mvbt use buffer store page path last updat lru buffer replac polici use buffer updat advantag sinc updat direct current btree small part whole mvbt structur experi set buffer size page origin mvbt use buffer queri too howev fair comparison method measur queri perform mvbt invalid buffer content previou queri thu measur queri perform independ order queri execut final origin mvbt process answer queri start root array everi time t array identifi root btree time ie search queri start from even though root increas time small enough fit main memori thu count io access search root snapshot index page mvbt aliv long least q aliv record number aliv record fall q page merg sibl thi call weak version underflow extrem page alreadi b record aliv not new record ad page split a page overflow condit need special handl first timesplit happen which like copi procedur snapshot incorpor structur mvbt requir number aliv record new page qe be e predetermin constant constant e work buffer guarante new page split merg least e new chang valu q e b possibl must satisfi constraint detail refer bgo implement set directori page mvbt format data page partial persist hash implement setevolut pph listevolut pphl approach approach observ ephemer linear hash lht whose load lt lie f g array h identifi hash scheme use time kept mainmemori io access count use structur similar keep root array mvbt main memori experi size array h never greater kb unless otherwis note pph implement variou valu use paramet u also examin sinc entri timetre associ bucket half oid record size timetre page hold entri pphl implement space oid record b r hold record valu v set equal sinc thi mean that page list use long number aliv oid page greater equal remain space list page of size oid record use page nt array similarli timearray nt array entri half size ie page hold nt entri reason page ft j array hold entri rtree method use two implement one interv ri twodimension space anoth point threedimension space rp ri implement assign oid lifespan interv one dimens use oid one lifespan interv new oid k ad set time t record k t now ptr ad rtree data page oid k delet record updat k t ptr directori page includ one attribut per record repres oid rang rp implement similar format data page assign separ dimens start_tim end_tim object lifespan interv henc directori page record seven attribut two oid start_tim end_tim one pointer updat rtree implement use buffer page keep page path lead last updat mvbt buffer use queri phase workload variou workload use comparison workload contain evolut dataset tempor membership queri evolut specif workload defin triplet wueq u univers oid the set uniqu oid appear evolut set s e evolut set collect queri set queri correspond oid k evolut start time finish time maxtim chang given evolut first gener per object oid merg first object oid k number k differ lifespan object evolut chosen choic n k made use specif random distribut function name uniform exponenti step normal whose detail describ next section start_tim lifespan oid k gener randomli pick n k differ start point set maxtim end_tim lifespan chosen uniformli start_tim lifespan start_tim next lifespan oid k sinc lifespan oid k disjoint final whole evolut e set creat merg evolut everi object anoth mix lifespan also creat evolut pick start_tim length lifespan use poisson distribut call poisson evolut tempor membership queri queri set q specifi tupl oidt number queri q k everi object oid k chosen randomli thu averag form kt queri tupl correspond time instant select use uniform distribut set maxtim maxtim set workload workload describ distribut use gener object lifespan number differ oid total number chang evolut n object addit delet total number object addit nb total number queri experi first behavior implement test use basic uniform workload number lifespan per object follow uniform distribut total number distinct oid number real chang object addit henc averag number lifespan per oid nb we refer workload uniform number queri figur a present averag number page access per queri method pph method best perform two page per queri alh approach use queri io about time exampl larger bucket creat mvbt use twice mani io pph approach sinc tree travers per queri ri use io per queri mvbt mainli due node overlap larger tree height which ri structur relat total number oid lifespan mvbt correspond number aliv oid time specifi queri problem node overlap even greater queri perform rp tree figur a truncat fit graph rp use averag io per queri experi rp aliv oid end_tim now caus cluster togeth even though differ oid that is overlap extend oid dimens well observ elsewher ktf transactiontim lifespan maintain effici plain rtree figur b show averag number io per updat best updat perform given pph method mvbt second best updat perform larger pph sinc mvbt travers tree updat instead quickli find locat updat element hash updat ri follow larger mvbt sinc size tree travers relat oid lifespan while size mvbt tree travers relat number aliv oid time updat alh pphl use even larger updat process alh lifespan oid thrown bucket thu creat larg bucket search serial updat pph l nt array implement insid page limit actual page area assign store oid thu increas number page use per bucket rp tree use even larger updat process due bad cluster common end_tim space consum method appear figur c alh approach use smallest space sinc store singl record per oid lifespan use control split high util f g valu pph method also good space util pph close alh pphl use space pph nt array implement reduc page util rtree method follow rp use slightli less space ri pagin interv put bound rectangl demand point note similarli alh r method use singl record per oid lifespan addit space mainli averag rtree page util mvbt largest space requir twice space alh figur a queri b updat and c space perform implement uniform workload a b c alh pph pphl mvbt ri rp avg number io per updatealh pph pphl mvbt ri rp number pagesalh pph pphl mvbt ri rp avg number io per queri pph method summari pph best overal perform similarli comparison ephemer hash btree mvbt tree behav wors tempor hash pph tempor membership queri alh slightli better pph space requir even though significantli rtree base method much wors pph three perform criteria consid effect lifespan distribut approach compar use four addit workload name exponenti step normal poisson workload number distinct oid number queri similar n m paramet exponenti workload gener n k lifespan per oid use exponenti distribut probabl densiti function mean total number chang total number object addit step workload number lifespan per oid follow step function first oid lifespan next lifespan on ie everi oid number lifespan advanc workload normal workload use normal distribut paramet were poisson workload first lifespan everi oid gener randomli time instant length lifespan gener use poisson distribut mean next start time given oid also gener poisson distribut mean valu workload main characterist poisson workload number aliv oid time vari small number larg proport u ie time instant number aliv oid hundr time instant almost distinct oid aliv figur present queri updat space perform new workload simplic ri method present among rtree approach as uniform load rp use consist queri updat ri similar space result resembl previou uniform workload befor pph approach best overal perform use slightli space minim space alh pphl queri perform compar space pph use much updat note figur a queri perform ri truncat fit graph on averag ri use per queri exponenti step normal poisson workload respect similarli figur c space mvbt truncat mvbt use k k k k page respect workload effect number lifespan per oid test use eight uniform workload vari averag number lifespan use differ oid number queri k paramet shown follow tabl result appear figur queri perform atempor hash deterior nb increas sinc bucket becom larger figur a pph pphl mvbt method queri perform independ nb thi three method nb lifespan given oid appear differ time instant thu interfer other queri perform ri much higher truncat fig a interestingli ri queri perform decreas gradual nb increas from io io ri cluster improv nb increas there record key pph outperform method updat perform figur b queri updat pph pphl mvbt basic independ nb better cluster increas nb updat ri gradual decreas contrast increas nb impli larger bucket size updat alh increas space method increas nb chang n per evolut tabl alh lower space follow pph mvbt steeper space increas for nb valu mvbt use k k page effect number distinct oid use evolut examin consid three variat uniform workload number distinct oid u wa tabl workload n nb nb figur a queri b updat and c space perform alh pph pphl mvbt ri method use exponenti step normal poisson workload k oid n m nb a b c exponenti normal poisson avg number io per queri alh pph pphl mvbt step exponenti step normal poisson avg number io per updat alh pph pphl mvbt ri number page exponenti normal poisson step figur a queri b updat and c space perform alh pph pphl mvbt ri method use variou uniform workload vari nb a b c avg number io per queri avg number io per updat avg number lifespan per oid nb number page alh pph pphl mvbt alh pph pphl mvbt respect workload similar averag number lifespan per distinct oid nb paramet appear tabl result appear figur queri perform pph pphl independ u contrast increas mvbt ri the ri use io per queri reason increas oid store tree structur thu increas structur height thi evid ri oid appear tree theori alh also independ univers size u slight increas alh figur a due control split polici constrain alh given space util similar observ hold updat perform final space method increas n increas tabl experi pph method appear competit perform among solut mention section pph perform optim set use paramet u figur show result basic differ valu u expect best queri perform occur u greater maximum load observ ephemer hash experi maximum load assert figur a queri time minim updat similarli minim figur b us sinc point aliv oid compactli kept page updat easier for smaller us aliv oid distribut page increas updat process figur c show space pph us maximum load aliv oid distribut among data page henc page becom nonus contain less aliv oid thu less copi made result smaller space consumpt use optim space pph made similar alh expens increas queryupd perform conclus open problem paper address problem tempor hash equival support tempor membership queri timeevolv set s effici solut term partial persist workload n nb of queri figur a queri b updat and c space perform alh pph pphl mvbt ri method use variou uniform workload vari u a b c avg number io per queri alh pph pphl mvbt alh pph pphl mvbt alh pph pphl mvbt avg number io per updat number page number distinct oid u in thousand hash pph present queri updat scheme behav separ ephemer dynam hash scheme avail everi state assum set time howev method still use linear space hash oid variou bucket time pph reduc tempor hash problem reconstruct previou bucket state two flavor partial persist hash present one base evolvingset abstract pph one evolvinglist pphl similar queri compar space perform pph use much less updat method compar straightforward approach name tradit atempor linear hash scheme two rtree implement multivers btree experi show pph robust perform among approach partial persist hash seen extens tradit extern dynam hash tempor environ methodolog independ ephemer dynam hash scheme use paper consid linear hash appli dynam hash scheme well variou open interest problem figur a queri b updat and c space perform pph uniform workload vari valu use paramet u a b c avg number io per queri pph avg number io per updat pph unumb page pph tradit hash use speed join comput current investig use tempor hash speed tempor join ssj anoth problem extend tempor membership queri time interv find whether oid k state set interv t discuss paper assum tempor membership queri linear transactiontim evolut interest investig hash branch transact environ lst acknowledg would like thank b seeger kindli provid us r mvbtree code part work perform vj tsotra sabbat visit ucla would thu like thank carlo zaniolo comment hospit r perform evalu tempor databas manag system an asymptot optim multivers btree the rtree effici robust access method point rectangl the ubiquit btree introduct algorithm dynam perfect hash upper lower bound make data structur persist fundament databas system nonoblivi hash rtree dynam index structur spatial search a consensu glossari tempor databas concept design access method bitempor databas linear hash new tool file tabl address lha scalabl distribut data structur access method multivers data on histor queri along multipl line time evolut tempor realtim databas survey databas manag system prentic hall timestamp commit a taxonomi time databas tradeoff process complex join queri via hash multiprocessor databas machin branch tempor index structur effici evalu validtim natur join a comparison access method timeevolv data effici manag timeevolv databas an extens notat spatiotempor index queri the snapshot index iooptim access method timeslic queri an effici multivers access structur tr ctr huanzhuo ye hongxia luo kezhen song huali xiang jing chen index move object base n index tree proceed th confer th wsea int conf artifici intellig knowledg engin data base p februari corfu island greec sy chien v j tsotra c zaniolo effici scheme manag multiversionxml document vldb journal intern journal larg data base v n p decemb