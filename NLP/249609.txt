t crash resili commun dynam network a abstractan endtoend data deliveri protocol dynam commun network present protocol use bound sequenc number toler link failur intermedi processor crash previou bound endtoend protocol could toler crashesw present selfstabil version algorithm recov crash sender receiv well intermedi processor start network arbitrari state selfstabil version guarante proper transmiss messag follow finit converg period b introduct basic commun task network endtoend commun is deliveri finit time data item gener design sender processor design receiv processor without duplic omiss reorder data item endtoend commun easi achiev reliabl net work link never fail processor crash howev exist commun network link failur processor crash possibl network subject failur call dynam network one approach construct endtoend protocol dynam network use unbound sequenc number uniqu identifi data item sent sender approach use protocol ae use unbound sequenc number impli messag size amount memori need grow number data item transmit therefor much effort spent design endtoend protocol use bound sequenc number import aspect endtoend commun protocol type fault toler clearli endtoend task unsolv perman senderreceiv link cut network work support nsf presidenti young investig award ccr fund texa am univers colleg engin contact author jennif l welch email welchcstamuedu phone fax link forev thu assumpt behavior faulti link necessari three common assumpt literatur are infinit frequent stabil infinit often network topolog stabil period time senderreceiv link cut stabil topolog eg aag as infinit frequent path stabil infinit often period time link form least one path sender receiv oper eg agh h eventu connect assumpt perman senderreceiv link cut eg ag am ag agr almost exist endtoend protocol depend physic link are made be wellbehav sequenc messag deliv alway prefix sequenc sent ie messag lost middl processor crash behavior ensur run altern bit protocol bsw processor crash good behavior cannot achiev without keep inform includ messag current transmit stabl storag even weaker behavior physic link requir name crash end point sequenc deliv prefix sequenc sent either stabl storag requir flm bound capac link must known adw unfortun exist dynam network processor may repeatedli crash recov corrupt memori even problem one endtoend protocol caus crash messag current transmit lost probabl data item deliv could exponenti small length path data item travel assum probabl processor crash deliveri data item bound constant would like protocol resili crash intermedi processor ie processor network design sender receiv reli stabl storag exclud possibl sender receiv fail sinc do stabl storag would requir argument allud physic link obvious actual system sender receiv could crash recoveri techniqu use case applic depend beyond scope paper presenc processor crash previou definit eventu connect suffici exist protocol sinc perman cut combin crash processor crash link could elimin connect sender receiv thu make weakest assumpt possibl name exist least one viabl path sender receiv path contain perman faulti link known endtoend protocol withstand processor crash without stabl storag random protocol present h howev protocol bound probabl failur use header strictli bound processor perman crash for path ie least one path along commun possibl eleg approach design commun protocol view network run black box provid messag transfer servic messag lost reorder duplic corrupt howev approach limit wz show bound sequenc number protocol toler reorder duplic aa show although bound sequenc number protocol toler reorder loss protocol must properti number messag need transmit data item increas without bound imposs result hing assumpt black box network reorder messag arbitrarili assumpt model situat user network know network layer protocol which implement black box rout messag even network topolog is altern approach avoid arbitrari reorder use knowledg network topolog explicitli control retransmiss rout packet inde lost travel physic link howev duplic caus protocol retransmit packet certain circumst packet retransmit protocol duplic exist reorder also protocol properti protocol use singl path sender receiv singl path receiv sender fifo properti direct preserv network thu protocol design work top bare network consist node connect fifo nondupl link lose messag although protocol retransmit use multipl path thu messag duplic reorder lost activ care coordin paper present endtoend protocol dynam network toler crash node failur link commun network without requir stabl storag knowledg link capac best knowledg protocol first crash resili endtoend protocol use bound sequenc number space complex protocol ie maximum amount space use processor program op log p p number simpl path network messag size op log p bit time complex ol l length viabl path messag complex onplt n number processor system retransmiss paramet roughli speak time messag complex measur run time messag travel viabl link compar complex measur agr which assum reliabl data link layer number possibl path p two processor system theoret exponenti jej number link system could drawback protocol howev practic commun scheme practic nonzero probabl messag corrupt howev due error detect scheme assum messag identifi discard base send messag along singl rout sourc destin see h nice discuss practic protocol thu protocol theoret interest could use improv exist protocol use constant number path sourc destin long least one viabl data item deliv moreov deliveri time time interv due fastest reliabl path period anoth applic protocol case parallel physic link two processor applic would provid implement reliabl nonparallel link situat number path would obvious extrem small bare network model commun network graph gv e jv node processor edg undirect commun link undirect link consist two direct link deliv messag opposit direct commun link connect two processor two processor connect link call neighbor commun link obey fifo disciplin bound transmiss delay known processor system view state machin execut pro gram execut program consist sequenc step step consist one receiv oper zero one messag re ceiv intern comput zero send oper intern comput sender includ input data item intern comput receiv includ output data item assum sender receiv subject crash processor call intermedi processor intermedi processor subject crash follow crash processor reenter initi state may continu execut crash intermedi processor could occur middl step model partial step subset messag sent actual sent model link processor p q two fifo queue one hold messag transit p q hold messag transit q p link subject failur link failur caus one messag elimin compon queue configur system set state processor content messag link run sequenc configur initi configur each processor initi state link empti i go c c i one follow hold processor p take next step possibl partial step accord program messag receiv ani head relev queue c dequeu c i p chang state accordingli enter initi state partial step messag sent enqueu c i noth els chang link fail chang one messag queue particular link c longer c i go concern run satisfi certain basic con dition given now run admiss sender take infinit number step receiv take infinit number step exist least one viabl path sender receiv remain defin viabl path assum infinit run satisfi first two admiss condit intermedi processor p viabl provid whenev p receiv messag infinit often succe send infinit often link viabl provid whenev infinit number messag sent link infinit number messag receiv receiv processor assum true direct link note definit viabl link impli receiv processor must take infinit number step partial step path viabl everi intermedi processor everi link path viabl definit viabil weaker agr sinc latter consid processor crash viabl path network sender receiv everi path either nonviabl processor nonviabl link thu senderreceiv cut note restrict concern rel order processor step number step send messag receipt thu asynchron system assum whatev entiti suppli data item sender provid one sender request one problem statement algorithm solv endtoend commun problem everi admiss run follow properti satisfi safeti prefix run sequenc data item output receiv prefix sequenc data item input sender definit restrict behavior intermedi processor way compat system suppos strip part header send one link gener definit viabl processor would be upon receiv messag infinit often p execut infinit often complet step start receiv m howev protocol weaker condit infinit execut partial step succe forward suffici live receiv infinit number output interest complex measur space maximum amount space requir node program messag size maximum number bit messag messag number maximum number messag sent transfer data item ideal run two success input time maximum length time two success input ideal run time messag complex discuss ideal run defin processor send messag either respons receiv messag base timeout paramet in order guard messag loss say messag retransmit sent base timeout expir otherwis new time retransmiss due speed processor natur frequenc retransmiss influenc total time number messag need deliv data item processor procedur respons send messag send procedur keep track number step k processor taken order estim real time elaps systemdepend valu that depend on say probabl loss distribut messag delay link want estim base k good one rational condit definit ideal goal retransmit everi unit time ensur messag deliv within one time unit assum link viabl rational condit definit ideal admiss run ideal whenev processor taken k step least real time elaps processor p receiv messag time address travel viabl path path neighbor q path receiv time protocol main problem protocol keep track set sequenc number label messag transit network key observ fifo properti link use ensur fifo deliveri everi path sender receiv and vice versa messag sent descript path take messag sent path obey fifo order note two differ path might share link thu set messag transit link could relat one path order two messag within one link necessarili impli anyth rel order send receipt unless two messag path defin below sender receiv use set p sequenc number shortli explain number suffici sender receiv rememb sequenc number recent messag sent receiv path sender use array sent sr recvr entri possibl path whenev sender send messag sequenc number seqnum path path sender assign sent sr pathseqnum similarli whenev sender receiv messag sequenc number seqnum sender assign recvr pathseqnum receiv use array sent rs recv sr bookkeep sender use clean path send new data item new sequenc number path path sender receiv consid clean sent sr pathrecv sr path say sequenc number current repeatedli sent path arriv destin use clean path ensur set sequenc number messag particular senderreceiv path path contain sent sr path path moreov case two sequenc number path path messag order path one sequenc sent sr path closer sender messag sequenc number recv sr path unfortun array recv sr updat receiv thu valu recv sr path known sender consequ receiv send array recv sr sender howev sender abl distinguish old valu recv sr current valu done implement independ altern bit protocol bsw one entir path r not individu physic link given path protocol keep track number altern bit token ie number time sender receiv acknowledg bit current tri send arriv sender path sinc sender input last data item sender use inform concern recv sr arriv path come second token arriv path sinc last data item input rule ensur inform receiv reflect current state path whenev inform concern recv sr arriv sender updat view recv sr array call vrecv sr sender use inform sent sr vrecv sr determin whether senderreceiv path clean not similarli receiv use sent rs vrecvr determin whether receiversend path clean not view run protocol sequenc altern sting begin sender use sequenc number sting receiv first data item sender repeatedli send messag sequenc number possibl path eventu messag arriv receiv use sequenc number sting sender acknowledg time receiv send next sequenc number call stingtag use sender sting receiv second data item receiv choos sequenc number minim sequenc number appear either recv sr vsent sr thu sequenc number set size p big enough case recv sr vsent sr includ sequenc number thu receiv choos next sequenc number use sender sting receiv sender eventu stung acknowledg receiv first messag sequenc number arriv sender sender calcul next stingtag use sting with acknowledg similar argument abov sequenc number sender readi send ith data item after get acknowledg st data item sequenc number entri sent sr could distinct roughli speak entri contain last sequenc number sent yet clean path ie arriv side howev sinc least one viabl path path path eventu clean by sequenc number sent sr path sender eventu get two token path updat vrecv sr vrecv sr pathsent sr path sender use path send ith data item ith data item sent seqnum sr chosen receiv st acknowledg ith acknowledg arriv sender continu updat cleandirti statu senderreceiv path use inform concern recv sr arriv messag receiv senderreceiv path chang statu clean ith acknowledg arriv sender use path also send ith data item seqnum sr receiv use similar scheme deliv ith acknowledg unlik endtoend protocol base flood in stead messag sent entir path specifi s formal descript protocol appear figur variabl use sender initi valu appear figur variabl receiv similar except order subscript r revers confus possibl use name array eg sent sr repres set sequenc number yield entri correct proof throughout section assum admiss run step caus transit c igamma c step i denot vari valu variabl var configur c correct proof induct number sting r sender stung whenev sender execut line execut line occur either first atom step end line atom step start messag receiv line end messag send line receiv stung whenev sender execut line line execut line occur first atom step end line execut line occur atom step start line end line variabl name type initi valu set path empti arbitrari fig variabl sender forev repeat path path cleanpathssr recvrsmsgpath msgseqnum vrecvsrpath msgrecvsrpath vsentr msgsentr od fig program sender forev msg nil pendingmsgpathmsg od fig program intermedi processor recvsrmsgpath msgseqnum forev repeat els sendpathnilsentr pathbitr pathnil sentr recvsr msg nil seqnumr msgstingtag od fig program receiv copi altern bit protocol implement distinct undirect path consid singl copi altern bit protocol undirect path path token altern bit protocol arriv sender sender receiv messag bit sender current send token arriv receiv receiv receiv messag opposit bit last bit receiv sent given configur denot path path sequenc messag sender receiv i messag sequenc messag receiv sender j messag togeth current valu bit sr p ath bit rs p ath follow rs well known eg bsw messag lost duplic configur altern bit protocol bitseq contain singl valu either exist singl border bitseq valu furthermor border sender eventu chang valu bit sr border produc border look sequenc bitseq success configur run border travel toward end bitseq import properti altern bit use protocol two success token arriv sender one token arriv receiv ensur properti follow lemma lemma suppos j messag msg arriv sender path p step j token p first token p sender receiv sinc step i exist k k analog properti true receiv well next lemma state consecut sting sender resp receiv set valu fseqnum srg sent sr resp fseqnumrsg sent rs either remain decreas seen true inspect code sinc sender chang entri sent sr send messag sequenc number equal seqnum sr lemma step sting sender fseqnum sr ig analog properti true receiv well prove correct protocol theorem protocol crash resili endtoend protocol proof safeti live properti prove induct number sting r prove follow sting even a ith sting occur receiv caus ith data item output data output equal data previou input b everi configur i gamma st ith sting messag msg transit sender receiv sting sr msgsent sr sent sr odd a ith sting occur sender caus st data item input b everi configur i gamma st ith sting messag msg transit receiv sender sting rs msgsentr sent rs configur ith sting everi senderreceiv path p sequenc sequenc number messag transit along p order start closest sender form x j k configur ith sting everi receiversend path p sequenc sequenc number messag transit along p order start closest receiv form x j k prove statement basi obviou code initi els vacuous true induct assum j show well show odd the case even similar left reader even index step ith sting r occur if exist show consid step sender step assum statement true preced configur well show true configur t pick path p messag sent p step sequenc number sent sr p t gamma clearli true suppos messag sent p differ sequenc number p cleanpath sr t sent sr p let equal valu sent sr p sinc p cleanpath sr sent sr p code first time sender chang sent sr p sinc step look step step vrecv sr p updat caus p put cleanpath sr second token p receiv sinc lemma inform reflect valu recv sr p receiv configur t induct hypothesi hold messag path p sequenc number name s long sequenc number p recv sr p continu s thu configur p sequenc number s assert hold configur t show similar show a must show sender never stung step long receiv stung ie must show everi messag receiv sender step sequenc number equal sting rs t note sting rs chang sender stung chosen vsentr t recvr t note ith sting arriv sender set vsentr accord inform sting messag induct hypothesi b sinc transit sting msentr superset sent rs sent rs induct hypothesi messag transit configur sequenc number either sent rs though recvr chang s path sting messag path follow sequenc number alreadi includ sent rs sequenc number thu includ recvr t messag transit configur sting sender must show messag sent receiv step sting sender follow lemma assert prove i st sting occur occur receiv induct hypothesi a would i output straightforward check data correct show b immedi ith sting messag transit sender receiv sting receiv chose next stingtag back sting gamma messag seqnum transit sender receiv messag sent sting seqnum current valu sent sr attach lemma current set element sent sr shrink rel sent messag show vacuou sinc show must show eventu receiv stung ie receiv receiv messag sequenc number equal sting sr suppos true first note sting sr chang receiv stung sender get least two token viabl path p put p cleanpath sr send current messag p by lemma current messag sting sr eventu copi messag get receiv contradict messag length op log p sinc messag consist constant number compon largest sent recv array consist p entri size log p assum data item bigger thi space complex due intermedi processor store messag path op log p recal time messag complex defin ideal run first explain detail messag retransmit send proce dure send procedur keep track pend recent messag sent path whenev send procedur execut follow first consid messag input procedur messag fresh last messag sent path store pend array differ one compon sent recv array messag store pend actual alreadi done intermedi node need done sender receiv messag fresh immedi sent onward path otherwis sent least k step elaps sinc last sent thi determin count step modulo k consid viabl path p length lp happen input two success data item worst case path need clean cost olp new messag olp time sender receiv two altern bit token cost olp new messag olp time final new stingtag must sting receiv cost olp new messag olp time similar analysi hold acknowledg come back sender thu time complex ol l length shortest viabl path discuss messag complex number retransmit messag sent two success data item input onplt recal retransmiss paramet reason ol time input n processor retransmit p path olt time consid new messag path p length lp discuss show olp new messag use sinc lp n p path number new messag onp thu messag complex onp note cost due retransmiss implicitli explicitli protocol assum reliabl data link layer conclud remark present crash resili endtoend protocol protocol ensur reliabl data transfer even present processor crash long least one viabl path sender receiv although bypass datalink layer protocol still work link run datalink protocol even presenc crash crash affect correct function datalink protocol one two way either messag lost link could even without datalink protocol messag duplic howev duplic toler protocol could happen point intermedi node protocol well duplic immedi follow duplic of insert later malici way protocol easili modifi work case viabil one direct impli viabil direct let p sr number path sender receiv pr number path receiv sender one possibl virtual implement p sr theta pr altern bit protocol one possibl combin senderreceiv path receiversend path sinc least one combin viabl direct current inform recv sr array reach sender current inform recvr array reach receiv sever optim possibl one updat vrecv sting arriv addit one token arriv chang caus path place cleanpath earlier anoth possibl optim concern reduc messag size send array element chang sinc last time third optim would everi node period send one larg messag neighbor contain individu messag path go neighbor instead send messag separ immedi chang would decreas total number messag but would increas messag length time howev simplic present incorpor optim protocol could also made selfstabil detail selfstabil version appear dw acknowledg thank reuven cohen amir herzberg help discuss amir also gave us use comment written draft r reliabl commun unreli channel appli static network protocol dynam network memori requir connect manag reliabl broadcast protocol unreli net work bootstrap network resynchron effici techniqu endtoend commun quantit approach dynam network slide mechan applic dynam network polynomi end end com munic dynam network fast static network note reliabl fullduplex transmiss halfduplex link crash resili commun dynam network resynch procedur failsaf network protocol imposs implement reliabl commun face crash tight bound sequenc transmiss problem tr ctr micah adler faith fich complex endtoend commun memoryless network proceed eighteenth annual acm symposium principl distribut comput p may atlanta georgia unit state pierr fraigniaud cyril gavoil headers lower bound endtoend commun memoryless network comput network intern journal comput telecommun network v n p juli faith fich eric ruppert hundr imposs result distribut comput distribut comput v n p septemb