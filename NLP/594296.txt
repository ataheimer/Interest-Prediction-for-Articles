t new worstcas upper bound sat a monien speckenmey prove satisfi proposit formula consist ik claus of arbitrari length check time order ik recent kullmann luckhardt prove worstcas upper bound il il length input formula algorithm lead bound base isplit method goe back davisputnam procedur itransform rule pure liter elimin unit propag etc constitut substanti part method paper present new transform rule two algorithm use rule prove algorithm worstcas upper bound ik il respect b introduct sat the problem satis proposit formula conjunct normal easili solv time order n n number variabl input formula earli trivial bound reduc formula cnf monien speckenmey see also independ dantsin see also that mani upper bound sat subproblem obtain author consid bound wrt three main paramet length l input formula number k claus number n variabl occur it confer proceed version paper best known worstcas upper bound sat were pl l pl k see also p polynomi also upper bound pl l satis problem gener boolean formula ie necessarili cnf known recent paturi pudlak sak zane prove sat checkabl random time o n still work describ paper present th acmsiam symposium discret algorithm soda steklov institut mathemat stpetersburg fontanka stpetersburg russia email hirschpdmirasru url httplogicpdmirasruhirschindexhtml support part grant inta rfbr unknown whether trivial upper bound n gener sat problem improv kullmann luckhardt simpli algorithm monien speckenmey present also improv algorithm complex pl k work better ratio number claus number variabl greater confer proceed version paper present two algorithm improv bound pl pl k pl l respect journal version improv second algorithm prove worstcas upper bound pl l new algorithm use pl k time algorithm subroutin proof correspond upper bound much simpler proof confer proceed version popular method solv sat local search method split method mani experiment averagecas result show signic power local search method for refer see survey howev best known worstcas upper bound sat npcomplet subproblem obtain use split method for worstcas upper bound local search method see split method also use prove worstcas upper bound exact approxim maxsat solv split method goe back davisputnam procedur let l liter occur formula f let f l formula obtain f assign valu rue liter l ie remov claus contain l delet occurr l claus short main idea davisputnam procedur f satis least one formula f l f l satis wider sens split algorithm construct tree reduc satis formula f satis sever formula f i f i obtain f assign spectiv then split algorithm simpli formula f i f i accord transform rule chang satis transform take polynomi time role reduc paramet l k n formula f i f i simplifi formula elimin pure liter a liter pure negat occur formula claus claus claus consist one liter easi piec recurr equat often use complex analysi algorithm kullmann luckhardt describ similar simpler techniqu use estim run time split algorithm one consid execut split algorithm branch tree ie tree formula label children simpler formula label parent leav label simplest formula node tree associ branch vector nonneg number polynomi construct vector one estim number leav tree use largest posit root polynomi precis denit formul given sect transform rule play import role split algorithm two simplest rule propos origin paper davi putnam elimin pure liter claus transform rule use describ sect paper introduc new transform rule goe follow simpl observ claus formula contain least one neg liter formula trivial satis assign variabl valu f als let p l f properti liter formula exampl f contain exactli two occurr l least three occurr l addit suppos variabl v formula f one liter v v satis p given f liter satisfi properti p refer p liter black white liter principl let f formula cnf least one follow two altern hold claus f contain p liter contain negat p liter satis f equival satis formula obtain f remov claus contain negat p liter formal proof black white liter principl given lemma figur illustr principl white circl denot p liter black circl denot negat circl dot denot liter ie liter neither p liter negat p liter note negat liter neither p liter negat p liter column correspond claus formula gure contain two formula rst one satis condit second one satis condit z figur two altern black white liter principl principl key point algorithm correspond upper bound pl k algorithm use presenc claus contain p liter contain negat p liter certain properti p black white liter principl kind insur guarante cannot nd requir claus replac f simpler formula f contain p liter all principl one reformul follow simpl properti partial assign ie set liter contain simultan x x variabl x formula f cnf either claus f contain liter a set valu liter f als chang satis f anoth known reformul properti gener sign principl autark principl see also comprehens studi autark principl found use black white liter principl lead two new bound sat present paper also sever upper bound satis problem formula cnf a formula cnf liter occur posit onc satis problem formula npcomplet sect give basic denit section contain techniqu allow us estim size branch tree sect explain transform rule use algorithm sect sect describ algorithm upper bound pl k pl l respect correspond proof basic denit let v set boolean variabl negat variabl v denot v given set u denot ug liter member set posit liter member set v neg liter negat w denot neg liter v w denot variabl v claus nite set liter contain simultan variabl togeth negat empti claus interpret f als formula cnf cnfformula nite set claus empti formula interpret rue length claus cardin length formula sum length claus length claus c denot jcj kclaus claus length k k claus claus length least k k claus claus length k say liter v occur claus formula mean claus formula contain liter v howev say variabl v occur claus formula mean claus formula contain liter v contain liter v assign nite subset w contain variabl togeth negat inform speak assign contain liter w mean w valu rue i obtain f i f assign remov f claus contain liter w delet occurr liter w claus short write f w assign satisfi formula f f i empti formula formula satis exist satisfi assign it say two formula f g equisatis satis unsatis let w liter occur formula f liter iliter f contain exactli occurr w ijliter f contain exactli occurr w exactli j occurr w ij liter f contain exactli occurr w least j occurr w ij liter f contain exactli occurr w occurr w similarli dene i denot number occurr liter w formula f w sum length claus contain w w mean f clear context omit f liter w iliter similarli dene estim size branch tree kullmann luckhardt introduc notion branch tree intend estim time complex split algorithm sinc tree formula algorithm split branch tree one consid execut split algorithm tree whose node label cnfformula node label cnfformula f son label simpli formula f i f i assign suppos tree whose node label formula cnf formula f attach nonneg integ tree branch tree if node complex formula label node strictli greater complex formula label son paper use number variabl f number claus f length f prove two upper bound wrt k wrt l howev section x concret measur complex let us consid node tree label formula f suppos son label formula f f fm branch vector node mtupl posit number exceed characterist polynomi branch vector dene characterist polynomi h x monoton function x interv h exactli one posit root denot root call branch number suppos leav omit one pair parenthes write exampl exampl golden ratio branch number tree largest branch number node denot maxt follow lemma prove kullmann luckhardt allow us estim number leav branch tree use branch number lemma kullmann luckhardt let branch tree let root label formula f number leav exceed maxt lemma alreadi allow us estim run time split algorithm know branch number split tree algorithm process leaf polynomi time howev algorithm correspond upper bound call algorithm correspond upper bound pl k subroutin thu process leav exponenti time estim overal run time use follow simpl gener lemma lemma let branch tree let root label formula f let g l denot object label leaf l tree let l leaf proof induct construct tree base tree consist uniqu node case step consid tree present fig let branch tupl root l leaf l leaf j fg l a by denit tupl t figur split tree by denit h max maxt by monoton h ut know branch number tree correspond split algorithm estim run time explicitli requir algorithm perform split branch number greater wish and need prove alway exist split satisfi condit purpos algorithm compar branch number correspond dierent vector cours done examin constant number case use monoton howev gener statement hold lemma kullmann luckhardt let m k natur constant x posit ration number problem whether y y solvabl time polynomi maxx x follow estim run time algorithm use frequent inequ like without proof one check inequ approxim calcul branch number howev sever simpl observ may help prove inequ easier lemma kullmann luckhardt permut compon branch vector aect correspond branch number branch number strictli decreas one compon branch vector increas transform rule section f denot formula cnf lemma allow us take consider dierenc complex input formula complex formula obtain split higher dierenc are smaller number leav is thu obtain good algorithm reduc much possibl complex formula obtain split explain transform rule allow us it precis explain certain case nd simpler formula equisatis f follow use rule never increas paramet consider the number claus formula length formula elimin claus f contain claus fag formula f f a equisatis sinc assign contain unsatisfi subsumpt f contain two claus c c d f f nfdg equisatis sinc assign satis claus c satis also claus d resolut subsumpt suppos given liter claus c liter satisfi condit c d case claus c d n fa ag call resolv liter claus c d denot rc d let f contain claus c d clear ad rc d formula chang satis howev increas size avoid eect use rule rc d d case reduc satis problem formula f satis problem dg elimin variabl resolut given liter a construct formula dp ad f resolv a remov f claus contain a lemma davi putnam formula f dp equisatis transform increas size formula orand number claus it use rule increas paramet consider the number claus formula length formula note particular transform increas paramet f pure liter thu elimin pure liter elimin block claus claus c block liter wrt f c contain liter a liter occur claus f contain negat least one liter occur c n fag note f may may contain c word resolv claus c claus formula f cnfformula f liter occur it dene assign ag j claus fa xg block wrt fg mean f clear context omit f write ia notion block claus introduc investig kullmann use follow two fact block claus lemma kullmann claus c block liter wrt f f f n fcg f fcg equisatis given liter a formula f satis least one formula f a f ia satis applic black white liter principl let p binari relat liter formula cnf variabl v formula f one p v f p v f hold lemma suppos claus f contain liter w satisfi p w f contain also least one liter b satisfi p b f f f fl j p l f g equi proof particular case autark principl denot suppos g satis consid satisfi assign formula g clear assign hand assign satisfi f satis also g ut bound wrt number claus section present algorithm check satis formula f time polynomi algorithm two subroutin function reducek function splitk function reducek simpli input formula use transform rule see sect function splitk intend reduc satis problem input formula satis problem sever simpler formula execut algorithm view follow function reducek simpli input formula splitk split sever formula reducek sim pli these on follow denot reducek formula function reducek output input f similarli dene splitk function reducek input formula f cnf output simpli formula cnf method kr elimin claus f contain claus repeat step f contain claus kr applic black white liter principl claus c f contain contain also f f fa j elimin variabl resolut choos liter occur f maxim sever liter choos liter minim f dp repeat step f satis condit f chang step krkr go step kr otherwis return f ut function splitk input formula f cnf output f satis rue otherwis f als method ks empti formula contain empti claus f return f als split two subproblem liter occur f construct two exist liter kf choos formula f f correspond liter splitk return rue least one these return rue otherwis return f als split four subproblem choos liter occur f two liter b c occur f a f a respect construct four formula f reducek f reducek f reducek exist liter b c choos formula f f f f correspond liter return rue least one these return rue otherwis return f als ut algorithm input formula f cnf output f satis rue otherwis f als method return splitk reducek ut sect explain none step reducek chang satis formula step krkr cannot repeat kf sinc none increas number claus number variabl iter krkrkr least one quantiti decreas step take polynomi time thu reducek chang satis formula return answer polynomi time construct tree ect behaviour algorithm togeth function reducek splitk intern node label formula algorithm split step ks ks leav label formula satisfi condit step ks ks intern node label f two son label f f four son label f f f f sinc condit step ks ks guarante correspond branch number exceed lemma number leav tree input formula thu algorithm return answer time plf kf p polynomi remain prove algorithm perform correctli ie formula cnf reduc reducek satis least one condit step ksk prove statement need two simpl lemma concern output reducek lemma let f valu f step kr function reducek point time mayb elimin sever claus f correspond output formula function reducek e liter occur f e claus f contain e simultan proof reducek modi formula step kr kr least one claus delet it otherwis least one claus elimin step kr sinc kf kdp wlog suppos f contain one claus claus if ani contain liter elimin claus formula f contain claus all f contain exactli one claus elimin step kr one claus elimin sinc least one liter e remain let f contain claus reducek modi formula step kr least one claus ie least two occurr elimin f valu f step kr wlog suppos step kr step kr liter chosen rst applic dp least one liter e remain liter negat liter remain formula henc least one claus elimin ut lemma let f formula cnf formula reducek contain claus liter liter proof function reducek elimin claus step kr liter liter kdp elimin liter step kr ut theorem algorithm perform correctli stop time pl k pl k l length input formula k number claus it p polynomi proof shown suce prove formula f cnf reduc reducek satis least one condit step ksk suppos f satisfi condit step ksk consid possibl case prove case imposs symbol mean correspond step function splitk key observ formula f contain frequent variabl transform f f a f a liter appli lemma prove formal case formula f contain claus formula f contain liter disappear f a claus contain liter disappear f a sinc thu term step ks ie condit step ks case formula f contain claus contain liter b three claus formula f contain disappear f a three claus contain disappear f a addit b becom liter f a thu term step ks lemma henc ie condit step ks satis case formula f contain claus consist liter claus formula f contain disappear f a claus contain disappear f a lemma similarli case term step ks addit c becom claus f a elimin step kr ie ie condit step ks satis case formula f contain consist liter sg claus formula f contain disappear f a claus contain disappear f a lemma addit becom f a c claus contain simultan lemma kf a kreducek otherwis becom f a ie kf a kreducek depend two altern take place choos term step ks ie condit step ks satis case condit case satis sinc step kr chang f contain liter sinc f satisfi condit step ks liter a let liter occur f prove exist liter b c condit step ks satis consid three subcas the rst two similar case case exist claus f a liter liter suppos term step ks similarli case case exist claus f a liter liter suppos term step ks similarli case note liter j cannot occur togeth two claus case condit case satis sinc step krkr reduc number claus formula f a condit case satis formula consist claus contain liter claus contain liter sinc exactli three claus formula f disappear f a occurr liter cannot disappear f a henc contain least one liter b let b liter formula f contain claus similarli cannot contain two claus contain liter b simultan thu f a contain liter choos liter b b claus formula f a contain b disappear f a b addit claus contain liter becom liter thu lemma hand two claus f a contain b disappear f a b two claus disappear lemma sinc b b becom liter note formula f contain one claus contain b b simultan thu case exist liter b f a liter c chosen similarli henc condit step ks satis ut bound wrt length formula section present algorithm check satis formula f time plf lf where p polynomi previou section dene two subroutin function reduc l function split l use similarli reducek splitk function reduc l simpli input formula split l split sever formula reduc l simpli these on function reduc l input formula f cnf output simpli formula cnf method lr elimin claus f contain claus repeat step f contain claus subsumpt f contain two claus c c d f fdg repeat step f contain claus elimin block claus f contain block claus c f fcg repeat step f contain block claus resolut subsumpt f contain two claus c rc dd f frcdg repeat step f contain claus elimin variabl resolut choos liter occur f repeat step f satis condit f chang step lrlr go step lr otherwis return f ut function split l input formula f cnf output f satis rue otherwis f als method ls empti formula contain empti claus f return f als contain claus f contain claus appli algorithm f return answer split two subproblem liter occur f construct two exist liter lf choos formula f f correspond liter split l return rue least one these return rue otherwis return f als ut algorithm input formula f cnf output f satis rue otherwis f als method return split l reduc l ut similarli reducek function reduc l chang satis formula return answer polynomi time construct tree ect behaviour algorithm togeth function reduc l split l leav label formula satisfi condit step lsl algorithm process polynomi time formula satisfi condit step ls ls pass formula satisfi condit step ls algorithm process formula f time polynomi note f contain claus sinc claus elimin step lr intern node tree label formula algorithm split step ls intern node label f two son label f f sinc condit step ls guarante correspond branch number exceed run time algorithm upper bound qlg lg input formula g q polynomi remain prove algorithm perform correctli ie formula cnf reduc reduc l satis least one condit step lsl need three simpl lemma concern output reduc l prove statement lemma let f formula cnf liter occur it liter occur claus ldp liter occur claus ldp liter ldp proof straightforward calcul ut lemma let f valu f one step lrlr function reduc l f correspond output formula function reduc l liter occur liter occur claus liter occur claus proof note chang formula step lrlr remov claus andor chang claus subset thu result decreas length formula least one occurr formula chang step lr least one occurr remov lemma suppos f get valu f function reduc l modi formula step lr modifi cannot result increas length claus increas number occurr liter moreov formula chang step least one occurr remov one occurr remov least one liter d remain formula occurr d lemma least one occurr remov step lr hold otherwis becom pure liter remov step lr thu hold again suppos reduc l modifi formula step lr then follow lemma ut use follow simpl properti formula reduc function reduc l proof without explicit mention lemma let g f satisfi condit step lrlr claus f pure liter liter f claus f contain liter liter occur f liter occur f liter occur f proof trivial sinc f satisfi condit step lrand see also lemma ut theorem algorithm perform correctli stop time pl l pl l l length input formula p polynomi proof shown sucient prove formula f cnf reduc reduc l satis least one condit step lsl suppos f satisfi condit step lsl consid two possibl case f contain least one liter a contain liter prove case f satis condit step ls inform done follow rst case show assign ia contain mani liter second case handl care examin subcas choos claus fc dg f examin follow subcas mani occurr claus contain liter c or d f contain mani occurr liter c or d two subcas show mani occurr elimin transform f f c f c or f d f d subsequ elimin claus obtain claus contain liter c c or d d third subcas is none previou subcas hold subcas one c liter occur claus allow us use lemma one occurr liter elimin split anoth liter follow denot f liter mean step ls algorithm case formula f contain liter a claus contain a let lemma max number claus among claus contain a transform formula f f occurr liter claus contain elimin thu transform formula f f claus occurr liter elimin claus contain elimin at step lr sinc block wrt f exist claus f fa g claus elimin sinc claus fa g block wrt f ie fa claus contain a claus claus distinct thu r r ie condit step ls satis case formula f contain liter sinc f satisfi condit step ls contain claus dg let us note formula f contain claus contain liter liter c liter liter c liter liter c simultan proposit true sinc f satisfi condit step lr lr also case ic fcg id fdg denit i let us denot one liter c we shall choos later one denot remain liter b let number claus among claus contain note let number claus among claus contain a count occurr disappear transform formula f f ia f a f a subsequ elimin claus result claus contain liter a transform formula f f occurr liter claus contain elimin claus contain elimin at step lr claus kullmann luckhardt prove similar algorithm case thu condit step ls replac howev would improv upper bound would make proof longer thu present simpler proof formula f a contain claus fbg obtain claus d elimin step lr f contain claus contain a claus obtain elimin step lr too number claus transform formula f f occurr liter claus contain b elimin claus contain b liter a occur thu even count occurr disappear claus contain rst applic step lr consid sever subcas case c thu ie condit step ls satis case c let fc dg liter hold let b remain liter fc dg thu thu ie condit step ls satis case let fc dg liter remain liter fc dg b b case b liter occur one claus denot claus c b liter b becom liter f ia f a complet proof show sever liter occurr elimin addit occurr count three subcas case least two occurr elimin rst applic step lr addit occurr count case case exactli one occurr elimin rst applic step lr addit occurr count remind count occurr claus contain one liter aa occurr liter b claus c b occurr liter b cannot elimin transform formula f formula f a count occurr term elimin claus fbg obtain claus fa bg sinc imposs two distinct ident claus fa bg formula two occurr anoth occurr liter b occurr liter b c b elimin moment count fact contradict assumpt case thu case b remain liter rst applic step lr lemma least one occurr elimin thu hold case occurr elimin rst applic step lr addit occurr count similarli case b remain liter rst applic step lr transform formula f a function reduc l thu jc b two occurr elimin lemma hold if howev jc appli lemma case thu henc three subcas ie condit step ls satis ut conclus work paper improv exist upper bound sat respect k the number claus l the length formula key point algorithm proof black white liter principl new transform rule view reformul two previous known principl autark gener sign principl proof as well proof previou upper bound neither short eleg would kind breakthrough nd compact way present proof upper bound split algorithm believ way could lead even better bound sinc current possibl creat new heurist prove correspond upper bound limit length comprehens proof hand challeng problem prove more tight lower bound some class split algorithm current exponenti lower bound resolut proof see eg far enough known upper bound split algorithm most split algorithm view resolut proof vice versa anoth direct work nd random algorithm give better upper bound sat or nd way appli modern random algorithm alreadi invent sat recent breakthrough paper also remain challeng problem nd lessthan n upper bound n number variabl r tautolog proof system base split method less n sati approxim algorithm max sat better perform ratio cost longer run time exponenti upper bound sati machin program theoremprov comput procedur quanti algorithm sati separ sign sati two new upper bound sat local search algorithm sat worstcas analysi hard formula sat local search algorithm sat local search algorithm worstcas studi new method sat decis worstcas analysi investig autark assign algorithm complex ober komplexit parametr guarante valu maxsat maxcut new upper bound maxsat upper bound cover problem solv sati improv exponentialtim algorithm ksat solv sati abil less n step pure liter look ahead o n complex proposit proof sati tr ctr rainer schuler algorithm satisfi problem formula conjunct normal form journal algorithm v n p januari bolett ammitzbl madsen algorithm exact satisfi analys number claus paramet inform process letter v n p januari evgeni dantsin andrea goerdt edward a hirsch ravi kannan jon kleinberg christo papadimitri prabhakar raghavan uwe schning determinist k n algorithm ksat base local search theoret comput scienc v n p octob ramamohan paturi pavel pudlk michael e sak franci zane improv exponentialtim algorithm ksat journal acm jacm v n p may tobia rieg jrg roth holger spakowski masaki yamamoto improv exact algorithm domat number problem inform process letter v n p februari ryan william algorithm quantifi boolean formula proceed thirteenth annual acmsiam symposium discret algorithm p januari san francisco california haiou shen hantao zhang improv exact algorithm maxsat annal mathemat artifici intellig v n p august jen gramm edward a hirsch rolf niedermei peter rossmanith worstcas upper bound maxsat applic maxcut discret appli mathemat v n p august edward a hirsch worstcas studi local search maxksat discret appli mathemat v n p august laurent simon daniel le berr edward a hirsch sat competit annal mathemat artifici intellig v n p januari oliv kullmann lean clauseset gener minim unsatisfi clauseset discret appli mathemat v n p august rolf niedermei peter rossmanith effici fixedparamet algorithm hit set journal discret algorithm v n p februari