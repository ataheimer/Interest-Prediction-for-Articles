t priorit multiprocessor spin lock a abstractin paper present pr lock priorit spin lock mutual exclus algorithm pr lock contentionfre spin lock block process spin local store cach variabl contrast previou work priorit spin lock algorithm maintain pointer lock holder result spin lock support oper lock holder eg abort ceil protocol unlik previou algorithm work maintain prioriti queue done process acquir lock block anyway releas lock constant time oper present simul result demonstr priorit acquisit lock compar perform pr lock best altern priorit spin lock b introduct mutual exclus fundament synchron primit exclus access critic section share resourc multiprocessor spinlock one mechan use provid mutual exclus share memori multiprocessor spinlock usual implement use atom read modifywrit instruct testset compareswap avail sharedmemori multiprocessor busi wait effect critic section small processor resourc need process interim howev spinlock usual fair naiv implement sever limit perform due network memori content care design avoid content requir process spin local store cach variabl real time system process time constraint associ prioriti indic urgenc process prioriti use oper system order render servic among compet process normal higher prioriti process faster request servic get honor synchron primit disregard prioriti lower prioriti process may block execut process higher prioriti stricter time constraint prioriti may caus higher prioriti process miss deadlin lead failur real time system work done synchron base prioriti thu suitabl real time system furthermor gener purpos parallel process system often process more import other kernel process process hold mani lock etc perform system benefit priorit access critic section paper present priorit spinlock algorithm prlock prlock algorithm suitabl use system either use staticprior schedul use dynamicprior schedul rel prioriti exist task chang block such earliest deadlin first minimum laxiti prlock contentionfre lock use creat excess network memori content prlock maintain queue record one record process request yet releas lock queue maintain sort order except head record acquir lock oper releas lock oper perform constant time result queue order maintain process block anyway high prioriti task perform work low prioriti task releas lock lock keep pointer record lock holder aid implement prioriti inherit protocol task lock request releas perform welldefin point time make lock predict present correct proof simul result demonstr priorit lock access local refer improv previous propos priorit spin lock organ paper follow section describ previou work area section present algorithm section argu correct algorithm section discuss extens algorithm present section section show simul result compar perform prlock similar algorithm section conclud paper suggest applic futur extens prlock algorithm previou work prlock algorithm base mcslock algorithm spinlock mutual exclus algorithm sharedmemori multiprocessor mcslock grant lock request fifo order block process spin local access flag variabl onli avoid content usual associ busywait multiprocessor process record repres place lock queue mcslock algorithm maintain pointer tail lock queue process add queue swap current content tail pointer address record previou tail nil process acquir lock otherwis process insert pointer record record previou tail spin flag record head queue record lock holder lock holder releas lock reset flag successor record successor exist lock holder set tail pointer nil use compareswap instruct moleski shen zlokapa describ priorit spin lock use testandset instruct algorithm base burn fair testandset mutual exclus algorithm howev lock contentionfre markato leblanc present priorit spinlock algorithm base mcslock algorithm acquir lock algorithm almost mc acquir lock algorithm except markato algorithm maintain doubli link list lock holder releas lock search highest prioriti process queue process record move head queue flag reset howev point task request releas lock well defin lock holder might releas lock low prioriti task even though higher prioriti task enter queue addit work maintain prioriti queue perform lock releas choic make time releas lock unpredict significantli increas time acquir releas lock as shown section craig propos modif mc lock markato lock substitut atom swap compareswap instruct permit nest lock use one lock record per process goscinski develop two algorithm mutual exclus real time distribut system algorithm base token pass process request critic section broadcast intent process system one algorithm grant token base prioriti process wherea algorithm grant token process base remain time run process holder token enter critic section util priorit lock demonstr rate monoton schedul theori suppos n period process uniprocessor let e c repres execut time cycl time period process assum c c cn assumpt block show j process meet deadlin suppos b j worst case block time process j incur show task meet deadlin thu block high prioriti process lower prioriti process signific impact abil task meet deadlin much work done bound block due lower prioriti process exampl prioriti ceil protocol guarante high prioriti process block lower prioriti process durat one critic section prioriti ceil protocol extend handl dynamicprior schedul multiprocessor contribut previou work develop priorit contentionfre spin lock directli implement desir prioriti queue algorithm maintain pointer head lock queue record lock holder result prlock use implement prioriti inherit work maintain prioriti order perform acquir lock oper task block anyway time requir releas lock small predict reduc length varianc time spent critic section prlock welldefin point time task join lock queue releas lock result guarante highest prioriti wait task alway receiv lock final provid proof correct prlock algorithm similar mcslock algorithm maintain queue block process use compareswap instruct howev mcslock markato lock maintain global pointer tail queue prlock algorithm maintain global pointer head queue mcslock markato lock process queu fifo order wherea prlock queue maintain prioriti order process assumpt make follow assumpt comput environ underli multiprocessor architectur support atom compareswap instruct note mani parallel architectur support instruct relat instruct multiprocessor share memori coher cach locallystor global access share memori processor record place queue lock numa architectur record alloc local global access memori record use purpos lifetim queue section allow record use among mani lock queue higher actual number assign prioriti higher prioriti process we also assum opposit rel prioriti block process chang accept prioriti assign algorithm includ earliest deadlin first minimum laxiti note process p particip synchron associ uniqu processor p expect queu process preempt though requir correct implement prlock algorithm consist two oper acquir lock oper acquir design lock releas lock oper releas lock process use acquir lock releas lock oper synchron access resourc acquir lockl r critic section releas lockl follow subsect present requir version compareswap need data structur acquir lock releas lock procedur compareswap prlock algorithm make use compareswap instruct code shown figur compareswap often use pointer object record record refer physic memori space object refer data within record current pointer record old previous sampl valu current new pointer record would like substitut old the record point old comput record new base object old or decid perform swap base object old want set current equal new current still point record old howev even current point old might point differ object one origin read occur old remov data structur reinsert current new object sequenc event cannot detect compareswap known aba problem follow work prakash et al turek et al make use doubleword com pareswap instruct avoid problem counter append current treat part current thu current consist two part valu part current counter part current counter increment everi time modif made current variabl procedur casstructur pointer current old new assum ca oper doubl word atomicf current old els f figur ca use prlock algorithm current old new twice origin size approach reduc probabl occurr aba problem accept level practic applic doubleword compareswap avail address counter pack bit restrict possibl address rang lock record use version compareswap oper current valu target locat return old compareswap fail semant compareswap use given figur version compareswap instruct return true fals use perform addit read data structur basic data structur use prlock algorithm prioriti queue lock l contain pointer first record queue first record queue belong process current use lock process l contain nil process locallystor globallyaccess record insert lock queue process insert record q queue say q ps record p qs process record contain process prioriti nextrecord pointer boolean flag lock process own element busywait lock free addit field data use store applicationdepend inform lock holder nextrecord pointer doubl size variabl one half actual pointer half counter avoid aba problem counter portion pointer two part one bit counter call dq bit use indic whether queu element queue rest bit use actual counter techniqu similar one use prakash et al turek et al counter refer record referenc pointer algorithm counter refer record contain pointer record point to dq bit record q fals record queue lock l dq bit true record probabl queue for short period time record might queue dq bit set true dq bit let prlock avoid garbag access process keep address record local variabl self addit process requir two local pointer variabl hold previou next queue element navig queue enqueu oper prev node next node data structur use shown figur dq bit pointer field initi true ctr field initi record first use typic queue form prlock algorithm shown figur below l point record q current process hold lock record q pointer record q next process highest prioriti among process wait acquir lock l record q point record q next higher prioriti wait process on record q n belong process least prioriti among wait process acquir lock oper acquir lock oper call process use critic section resourc guard lock l paramet acquir lock oper lock pointer l record q process pass local variabl self acquir lock oper search correct posit insert q queue use prev node next node keep track current posit figur prev node next node abbrevi p n record point p n q q i belong process p p i process posit p rp r function map process prioriti posit found q prepar insert make q point q i then insert commit make q point q use compareswap instruct variou stage final result shown figur acquir lock algorithm given figur acquir lock procedur call data prioriti field process record initi appropri addit dq bit next pointer implicitli true acquir lock oper begin assum lock current free the lock pointer l structur pointer f structur object ptr boolean dq structur record f structur structur data data boolean lock integ prioriti structur pointer next share variabl structur pointer l privat variabl structur pointer self prev node next node boolean success failur constant true fals null max prioriti data prioriti nextctr nextptr lock nextdq record structur figur data structur use prlock algorithm figur queue data structur use prlock algorithm start posit prepar commit figur stage acquir lock oper null attempt chang l point record compareswap instruct compareswap success lock inde free process acquir lock without busywait context composit pointer structur algorithm use null pointer zero swap unsuccess acquir process travers queue posit higher equal prioriti process record lower prioriti process record junction found point record higher prioriti process next node point record lower prioriti process process first set link next node then attempt chang previou record link record atom compareswap success process set dq flag record fals indic presenc queue process busywait lock bit set fals indic admit critic section three case unsuccess attempt enter queue problem detect examin return valu fail compareswap mark f algorithm note return valu next node addit process might detect misnavig search queue read next node content record point prev node fix record counter read next node concurr acquir lock oper may overtak acquir lock oper insert procedur acquir lockl self f f els f lock use f next nodeprev nodeptrnext ifnext nodedqtru dequ tri ii prev nodeptrpriorityselfptrprior f iii els f ifnext nodeptrnul next nodeptrnul next nodeptrpriorityselfptrpriorityf use lock els f ifnext nodedqtru dequ tri ii prev nodeptrprior els next nodeprev node gwhilesuccess failur figur acquir lock oper procedur record immedi prev node shown figur case compareswap fail posit mark f figur correct oper posit affect oper continu current posit line mark figur concurr releas lock oper may overtak acquir lock oper remov record point prev node shown figur case dq bit link pointer record true algorithm check condit scan queue tri commit modif algorithm detect situat two place mark ii figur everi time new record access by prev node link pointer read next node dq bit check addit compareswap fail link pointer save next node dq bit test dq bit true algorithm start begin concurr releas lock oper may overtak acquir lock oper remov record point prev node record put back queue shown figur record return prioriti higher equal self prioriti posit still correct oper continu otherwis oper cannot find correct insert point start begin condit test line mark iii figur spinlock busi wait process broken eventu releas lock process immedi ahead wait process releas lock oper releas lock oper straight forward algorithm given figur process p releas lock set dq bit record link pointer true indic record longer queue set dq bit prevent acquir lock oper modifi link releas process copi address successor record ani l process releas lock set lock boolean variabl record next process wait fals avoid test special case acquir lock oper prioriti head record set highest possibl prioriti correct prlock algorithm section present inform argument correct properti prlock algorithm prove prlock algorithm correct show maintain prioriti queue head procedur releas lockl selff lselfptrnext releas lock ifselfptrnextnullf figur releas lock oper procedur prioriti queue process hold lock prlock decisiveinstruct serializ oper prlock algorithm singl decis instruct decis instruct acquir lock oper success compareswap decis instruct releas lock oper set dq bit correspond concurr execut c queue oper equival with respect return valu final state serial execut oper execut decis instruct oper c thu equival prioriti queue prlock singl state instant simplifi correct proof a concurr data structur lineariz decisiveinstruct serializ might sever state simultan use follow notat discuss prlock l lock pointer l point first record lock queue and record process hold lock let n process p particip lock synchron prioriti lock l use prlock algorithm mention earlier process p alloc record q enqueu dequeu thu process p particip lock access associ queue record q let p rp function map process prioriti number n also defin anoth function p rq map record belong process p prioriti prioriti queue abstract data type consist of ffl finit set q element simplic assum everi n uniqu assumpt requir correct fact process prioriti obtain lock fcf order ffl two oper enqueu dequeu instant state queue defin call q head record prioriti queue q head record process current lock holder note nonhead record total order enqueu oper defin enqueu dequeu oper nonempti queue defin return valu q dequeu oper empti queue undefin everi prlock l abstract prioriti queue q initi l q empti process p record q perform decis instruct acquir lock oper q chang state enqueu q q similarli process execut decis instruct releas lock oper q chang state dequeueq show observ l find structur equival q observ l take consist snapshot current state system memori next start lock pointer l observ record follow link list head record dq bit set process exit acquir lock oper discard observ observ record sequenc l q say l q equival write l q theorem repres prioriti queue q equival observ queue prlock l proof prove theorem induct decis instruct use follow two lemma releas lock decis instruct q l releas lock decis instruct proof let releas lock decis instruct releas lock oper equival dequeu oper abstract queue definit q qn figur observ queue l releas lock figur observ queue l acquir lock state l shown figur l point record q releas lock decis instruct releas lock decis instruct set dq bit q true remov q observ queue thu q l releas lock oper note l point q next releas lock decis instruct acquir lock decis instruct q l acquir lock decis instruct proof two differ case consid case acquir lock decis instruct equival oper abstract queue q enqueu oper thu lock l empti qs process execut success decis compareswap instruct make l point q acquir lock figur clearli q acquir lock decis instruct case acquir lock decis instruct state queue q acquir lock given correspond l acquir lock shown figur pointer p n prev node next node pointer qs acquir lock oper posit record process observ p rq next pointer q set address q i figur observ queue l acquir lock compareswap instruct mark f figur attempt make next pointer q point q compareswap instruct succe decis instruct qs process result queue l illustr figur equival q enqueu oper compareswap succe q queue q i successor record p rq concurr oper queue observ p n posit correctli compareswap succe concurr oper interfer execut acquir lock oper a three possibl case a anoth acquir lock a enqueu record q q q i q yet dequeu p rq qs process attempt insert q q q i process modifi q s next pointer qs compareswap fail sinc q dequeu process continu search q happen qs process skip q continu search q i happen scenario illustr figur case b releas lock oper r overtak remov q queue ie r set q s dq bit q yet return queue it dq bit still fals sinc q lock queue lost must start search again base observ q q i may decid continu search queue commit oper either case see dq bit set fail start begin queue scenario illustr figur case c releas lock oper r overtak remov q queue q put back queue anoth acquir lock a tri commit oper pointer q chang compareswap fail note even q point q i version number prevent decis instruct succeed continu search two possibl base new valu p rq lost cannot find correct place insert q condit detect prioriti q examin the line mark iii figur oper restart head queue p still find correct place insert past q q a a continu figur concurr acquir lock a succe f r r restart figur concurr releas lock r succe continu search scenario illustr figur interfer occur alway take right action therefor q l acquir lock decis instruct prove theorem use induct initi point nil so q l trivial true suppos theorem true th decis instruct th decis instruct acquir lock oper lemma th decis instruct th decis instruct releas lock oper lemma th decis instruct therefor induct step hold henc q l extens section discuss coupl simpl extens increas util prlock algorithm multipl lock describ record prlock use one lock queue otherwis process might obtain lock one desir realtim system sever critic section lock which like process must lock record lock queue wast space fortun simpl extens prlock algorithm allow lock record use mani differ lock queue replac dq bit dq string l bit dq string evalu interpret ri ri rm rm restart prq prqi continu prq prqi r a r figur releas lock r acquir lock a succeed binari number record queue lock i dq string evalu record probabl queue acquir lock releas lock algorithm carri modifi test queue appropri note process set nest lock new lock record must use level nest craig present method reus record nest lock back process obain lock certain deadlin might wish stop wait continu process process must first remov record lock queue so process follow step find preced record lock queue use method algorithm acquir lock oper process determin record head lock queue return lock obtain valu set dq bit dq string process record dequeu perform compar swap predecessor record next pointer process next pointer compareswap fail go compareswap succe return lock releas valu valu processs successor process remov queue without obtain lock compareswap decis instruct compareswap fail predecessor might releas lock third process enqueu predecessor process cant distinguish possibl must research lock queue simul result simul execut prlock algorithm proteu configur multiprocessor simul also implement mcslock markato lock demonstr differ acquisit releas time characterist simul use multiprocessor model eight processor global share memori processor local cach memori byte size proteu unit execut time cycl process execut uniformli randomli distribut time rang cycl issu acquirelock request acquir lock process stay critic section fix number cycl plu anoth uniformli randomli distribut number cycl releas lock procedur repeat fifti time averag number cycl taken acquir lock process comput proteu simul parallel repeatedli execut processor program time quanta q simul prioriti process set equal processprocessor number lower number higher prioriti process figur show averag time taken process acquir lock use mcslock algorithm prlock algorithm respect process use mcslock algorithm wait fifo queue process everi round howev process use prlock algorithm wait time proport number higher prioriti process exampl highest second highest prioriti process averag wait one critic section period note two highest prioriti process acquir lock execut time altern acquir lock process complet execut third fourth highest prioriti process obtain lock figur clearli demonstr averag acquisit time lock use prlock proport process prioriti wherea averag acquisit time proport number process case mcslock algorithm featur make prlock algorithm attract use real time system figur show averag time taken process acquir lock use markato algorithm priorit lockacquisit behavior shown averag time acquir lock greater prlock use first result puzzl markato lock perform major work lock releas prlock perform work lock acquir howev time releas lock part time spent critic section time acquir lock depend primarili time spent critic section preced lock holder thu prlock allow much faster access critic section see prlock also allow predict access critic section figur show cach hit ratio instanc time processor time cachehit ratio higher processor found averag cach hit rage thu prlock gener littl network memori content spite process use busywait final compar time requir releas lock use prlock markato lock result shown figur markato lock figur time releas lock use prlock small consist process releas lock use markato lock requir significantli time furthermor experi high prioriti process requir spend significantli averag timecycl x processorprior figur lock acquisit time mcslock algorithm time releas lock requir low prioriti process behavior result way simul run high prioriti process execut low prioriti process block queue result mani record must search high prioriti process releas lock thu high prioriti process work behalf low prioriti process time requir high prioriti process releas lock depend number block process queue result long unpredict amount time requir releas lock sinc lock must releas next process acquir lock time requir acquir lock also made long unpredict conclus paper present prioriti spinlock synchron algorithm prlock suitabl realtim sharedmemori multiprocessor prlock algorithm character priorit lock ac quisit low releas overhead littl buscontent welldefin semant simul result show prlock algorithm perform well practic prioriti lock algorithm use present mutual exclus access critic section use provid higher level synchron construct priorit semaphor monitor prlock maintain pointer record lock holder prlock use implement prioriti inherit protocol final prlock algorithm adapt use singledequeu multipleenqueu parallel prioriti queue averag timecycl x processorprior figur lock acquisit time prlock algorithm averag timecycl x processorprior figur lock acquisit time markato algorithm time x processor figur cach hit ratio prlock algorithm averag timecycl processorprior figur lock releas time prlock algorithm averag processorprior figur lock releas time markato algorithm sever priorit spin lock propos prlock follow advantag ffl algorithm content free ffl higher prioriti process work lower prioriti process releas lock result time requir acquir releas lock fast predict ffl prlock welldefin acquirelock point ffl prlock maintain pointer process use lock facilit implement prioriti inherit protocol futur work interest priorit access oper system structur make appropri use realtim parallel oper system r perform spin lock altern share memori multiprocessor concurr program principl practic mutual exclus linear wait use binari share variabl distribut snapshot determin global state distribut system dynam prioriti ceil concurr control protocol realtim system prioriti ceil protocol multipleinst resourc schedul algorithm multiprogram hard realtim environ ment queu spin lock altern support time predict character memori hotspot share memori mimd machin two algorithm mutual exclus realtim distribut comput system methodolog implement highli concurr data object correct condit concurr object perform analysi minimum laxiti earliest deadlin realtim system effici synchron multiprocessor share memori multiprocessor synchron primit prioriti algorithm scalabl synchron sharedmemori multiprocessor predict synchron mechan realtim system prioriti inherit protocol approach realtim synchron concurr search structur algorithm tutori hard realtim system lock without block make lock base concurr data structur algorithm nonblock tr ctr prasad jayanti farray implement applic proceed twentyfirst annual symposium principl distribut comput juli monterey california jame h anderson yongjik kim ted herman sharedmemori mutual exclus major research trend sinc distribut comput v n p septemb