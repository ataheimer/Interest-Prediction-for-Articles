t approxim minimum equival digraph a meg minimum equival graph problem follow given direct graph find smallest subset edg maintain reachabl relat node problem nphard paper give approxim algorithm achiev perform guarante polynomi time algorithm achiev perform guarante time requir transit closur heart meg problem minimum scss strongli connect span subgraph problem meg problem restrict strongli connect digraph minimum scss problem paper give practic nearli lineartim implement achiev perform guarante algorithm analysi base simpl idea contract long cycl analysi appli directli exchang gener local improv algorithm show perform guarante b introduct connect fundament studi graph graph algorithm recent mani approxim algorithm find minimumsubgraph meet given connect requir develop result provid practic approxim algorithm nphard networkdesign problem via increas understand connect properti now techniqu develop applic undirect graph consid basic networkdesign problem direct graph follow given digraph find smallest subset edg form minimum equival graph meg maintain reachabl relat origin graph meg problem restrict stronglyconnect graph call minimum scss strongli connect span subgraph problem meg problem restrict acycl graph call acycl meg problem problem reduc linear time singl acycl problem given socal strong compon graph togeth one minimumscss problem strong compon given subgraph induc compon furthermor approxim meg problem lineartim equival approxim restrict version moyl thompson observ decomposit give exponentialtim algorithm restrict problem hsu give polynomialtim algorithm acycl meg problem relat problem find transit reduct digraph smallest set edg yield reachabl relat studi aho garey ullman transit reduct differ meg problem edg comput scienc depart institut advanc comput studi univers maryland colleg park md research support nsf research initi award ccr comput scienc depart univers texa dalla richardson z school oper research industri engin cornel univers ithaca ny part work done umiac support part nsf grant ccr ccr email neyoriecornelledu transit reduct requir origin graph howev transit reduct problem decompos like meg problem acycl strongli connect instanc strongli connect instanc transit reduct given hamilton cycl vertic acycl instanc transit reduct uniqu and aho et al observ equival meg problem consist edg u v altern path u v fact aho garey ullman show transit reduct problem equival transit closur problem thu acycl meg problem reduc transit closur acycl meg problem solv polynomi time wherea minimum scss problem nphard consequ paper focus approxim algorithm minimumscss problem observ preced paragraph perform guarante obtain minimum scss problem carri gener meg problem overhead solv singl instanc transit closur result given strongli connect graph basic algorithm find long cycl can contract cycl recurs contract graph remain strongli connect graph final collaps singl vertex algorithm return set edg contract cours algorithm desir scss algorithm achiev perform guarante constant greater polynomi time give nearli lineartim version achiev perform guarante give exampl show lower bound perform guarante algorithm gener algorithm lower bound slightli nearli lineartim version lower bound match upper bound perform guarante analysi extend directli simpl local improv ment algorithm call exchang exchang start given digraph perform follow local improv step long applic find two edg current graph replac one edg origin graph maintain strong connect similar localimprov algorithm natur candid mani optim problem often elud analysi prove perform guarante exchang natur improv cyclecontract algorithm modifi algorithm solv problem optim contract graph cycl longer given length c instanc modif improv perform guarante gamma use scss c denot minimum scss problem restrict digraph cycl longer c minimumscss problem trivial minimum scss problem solv polynomi time shown khuller raghavachari young howev improv direct limit show minimum scss problem nphard fact show minimum scss problem max snphard preclud possibl polynomialtim approxim scheme assum pnp relat work union incom branch outgo branch root yield scss n gamma edg where n number vertic graph special case algorithm given frederickson jaja use minimumweight branch achiev perform guarante weight graph sinc scss least n edg yield perform guarante scss problem minim scss one edg delet n gamma edg also yield perform guarante problem effici find minim scss studi simon gibbon karp ramachandran sorok tarjan give parallel algorithm relat problem undirect graph find smallest subset edg form biconnect respect bridgeconnect ie edgeconnect span subgraph given graph problem nphard khuller vishkin give dfsbase algorithm achiev factor biconnect bridgeconnect garg santosh singla subsequ improv approxim factor use similar approach respect none method appear extend minimum scss problem undirect graph bound cycl length bound tree width arn borg lagergren sees shown mani nphard problem includ minimum biconnectedspanningsubgraph problem polynomialtim algorithm restrict graph preliminari contract pair vertic u v digraph replac and occurr u v edg singl new vertex delet subsequ selfloop multiedg edg result graph identifi correspond edg origin graph or case multi edg singl remain edg identifi one correspond edg origin graph contract edg u v contract pair vertic u v contract set pair vertic graph g contract pair arbitrari order contract graph denot gs contract edg also analog extend contract set edg let opt g minimum size subset edg strongli connect g gener term cycl refer simpl cycl lower bound opt g begin show graph long cycl size scss larg lemma cycl lemma direct graph g n vertic longest cycl g length c proof start minimums subset strongli connect graph repeatedli contract cycl subset cycl left observ maximum cycl length increas contract consequ cycl contract ratio number edg contract decreas number vertic least c sinc total decreas number vertic least c contract note lemma give lower bound existenti tight valu c exist graph bound given lemma equal opt g also note c trivial upper bound n and use thi get lower bound n opt g known trivial lower bound lemma contract lemma direct graph g set edg proof scss g contract around treat edg pair scss gs cyclecontract algorithm algorithm follow fix k posit integ contractcycl k g graph contain cycl least edg contract edg cycl return contract edg section show algorithm implement run omffm n time case polynomi time fix valu k clear edg set return algorithm strongli connect graph follow theorem establish upper bound number edg return algorithm theorem contractcycl k g return c k delta opt g edg proof initi let graph n vertic let n vertic remain contract graph contract cycl edg mani edg return contract cycl least k edg contribut solut contract cycl contribut number edg return thu vertic remain cycl edg lemma opt g thu number edg return divid opt g n use ident from p get desir standard techniqu yield accur estim c k eg graph initi cycl longer k as point anonym refere analysi gener show perform guarante k instanc graph cycl longer analysi bound perform guarante when tabl give lower upper bound perform guarante algorithm small valu k limit k lower bound shown next subsect upper bound lower bound tabl bound perform guarante lower bound perform ratio section present lower bound perform ratio contractcycl k g graph fig n kgamma group vertic group consist k gamma cycl thread kcycl first iter contractcycl k g contract kcycl within group leav graph cycl algorithm subsequ must contract remain edg thu k gamma return scss graph contain hamilton cycl optim solut thu n henc arbitrarili larg lower bound perform guarante contractcycl k g k approach lower bound tend fig bad exampl contractcycl k g exchang algorithm section use cyclecontract analysi show exchang perform guarante exchang special case kexchang defin follow follow improv step possibl pick set e k k edg e set e kgamma set edg form scss note fix k step perform polynomialtim reduc size e kexchang run polynomi time follow theorem show approxim factor achiev exchang theorem perform guarante exchang proof show edg output exchangeg could output contractcycl g thu perform guarante contractcycl carri exchang first show perform guarante let e set edg return contractcycl graph h set edg contract first iter cycl least three edg contract result graph g h strongli connect cycl graph treelik structur particular edg u v present iff revers edg v u present import observ gh equival g h clearli g h subgraph gh prove convers suppos edg u v gh g h consid ad edg u v g h structur g h u v adjac g h edg path v u revers edg also g h u v ad g h at least two revers edg delet g h without destroy strong connect g h consequ origin edg g correspond u v ad g origin edg g correspond revers edg delet g without destroy strong connect g contradict fact e output exchangeg sinc e elig improv step next consid execut contractcycl g sinc gh equival g h sequenc cycl chosen first iter contractcycl could also chosen first iter contractcycl g similarli second iter contractcycl could mimick contractcycl g case contractcycl g would return edg set contractcycl g sinc e minim otherwis improv step appli edg set return exactli e thu upper bound perform guarante contractcycl theorem inherit exchang lower bound perform guarante given graph fig exchang choos number edg arbitrarili close time minimum n group vertic group first observ graph direct hamilton cycl edg mark fig form solut exchang could termin with solut clearli n edg give lower bound perform algorithm implement fix k contractcycl k implement polynomi time use exhaust search find long cycl instanc cycl size least k exist one found polynomi time follow simpl path p check whether path head p tail exist p s intern vertic remov graph k even k path k odd number nm kgamma take edg return exchang edg use exchang fig worstcas exampl exchang om time decid path head p tail p first iter loop may on iter loop sinc first iter time consum algorithm implement practic implement yield next give practic near lineartim implement contractcycl perform guarante achiev c consist two phase repeatedli find contract cycl three edg call long cycl cycl exist contract remain cycl highlevel descript algorithm perform phase algorithm depthfirst search df graph arbitrari root search algorithm identifi edg contract ad set s point search g denot subgraph edg vertic travers far rule ad edg follow new edg travers new edg creat long cycl g s algorithm add edg cycl s algorithm thu maintain g s long cycl df finish g s cycl edg cycl togeth s desir scss g s long cycl fact origin graph strongli connect g s maintain simpl structur lemma addit edg g possibl contract cycl ad s i graph g s consist outward branch revers edg ii revers edg might present activ path supervertex contain root supervertex contain current vertex df proof clearli invari initi true show given step algorithm maintain invari case u w denot vertic graph let u w denot vertic g s contain u w respect df travers edg u w visit new vertex w vertex w edg u w ad g vertex w becom current vertex g s outward branch extend new vertex w addit edg u w edg ad cycl creat thu part i invari maintain supervertex contain current vertex w new activ path contain old activ path thu part ii invari also maintain activ activ root inact activ u inact inact inact fig contract graph g s df travers edg u w w alreadi visit u w edg u w alreadi exist g s cycl creat g s unchang invari clearli maintain otherwis edg u w ad g cycl simpl structur illustr fig creat g s cycl consist edg u w follow possibl empti path revers edg w lowestcommonancestor lca u w follow possibl empti path branch edg lcau w u addit u w g s contract cycl in case long cycl maintain part i invari activ path chang part contract part ii invari maintain df finish visit vertex w edg ad cycl contract part i clearli maintain let u new current vertex ie ws parent df tree u w part ii clearli maintain otherwis consid set descend w df tree sinc origin graph strongli connect edg x y origin graph goe set complement vertic visit x y g part i invari vertex g s contain x must w vertex contain must u otherwis edg correspond x y g s would creat long cycl algorithm maintain contract graph g s use unionfind data structur repres vertic standard way use three data structur maintain branch revers edg discov far activ path cycl aris g s must form describ proof lemma illustr fig use data structur algorithm discov and long contract number unionfind oper proport length cycl yield omffm ntime algorithm vertic g s repres unionfind set follow add set fvg correspond new vertex g s findv return set g s contain vertex v join singl set two set correspond vertic vertic u v data structur repres branch revers edg activ path respect are branch edg u w g s u w u theta w torootu revers edg u w g s torootu toactiveu vertex u activ path g s toactiveu child u recurs df call current execut unless recurs df execut case toactiveu current vertic toactiveu pseudocod algorithm given figur contractcycl choos r v add cycl remain g s s return current vertex w adjac u travers edg u w w yet visit new vertex current els edg creat cycl g s cycl length least length two cycl parent u record edg parent els forward edg child therefor length cycl fig practic implement contractcycl preced discuss algorithm implement contractcycl straightforward show run omffm n time henc follow theorem theorem omffm ntime approxim algorithm minimum scss problem achiev perform guarante medg nvertex graph ffm n inverseackermann function associ unionfind data structur exampl illustr algorithm exampl fig algorithm begin df vertex visit vertic travers revers edg sinc edg creat cycl g s contract cycl next toactivefindw current toward l c a along revers edg toactivefindp go l c a along activ path p c toactivefindw toactivefindc contract parent p child c fig subroutin contractcycl travers revers edg contract sinc form cycl contract graph continu df visit vertic travers edg discov contract cycl next visit vertic travers revers edg travers edg discov contract cycl exampl cycl remain return contract edg potenti improv contractcycl k natur modif contractcycl k would stop contract graph cycl length c somehow solv remain problem optim instanc follow proof theorem one show would improv perform guarante contractcycl k c k gamma for k match lower bound tabl the lower bound given hold modifi algorithm lead us consid minimum scss c problem minimum scss problem restrict graph cycl length bound c follow theorem shown theorem polynomialtim algorithm scss problem make conjectur concern scc problem howev next show scc problem nphard scss problem max snphard nphard scss prove follow theorem theorem minimum scss problem nphard proof proof reduct sat fix arbitrari cnf formula f build root digraph scss contain edg root d them f satisfi iff exist scss e remain nonroot vertic outdegre equal one thu formula satisfi scss edg graph fix root vertex r vertex claus f these vertic shown fig claus vertex return edg root variabl f graph instanc gadget illustr fig edg gadget come root edg present scss edg gadget altern label gamma everi claus graph g travers edg travers edg edg c travers edg travers edg fig exampl illustr execut algorithm posit instanc variabl one edg goe claus vertex everi claus neg instanc variabl one gamma edg goe claus vertex unassign edg go root the gadget easili enlarg allow number occurr key properti gadget everi nonroot vertex outdegre one scss either counterclockwis edg scss correspond variabl true clockwis edg scss correspond variabl fals thu given scss edg outdegre root n number vertic digraph construct easi construct satisfi assign f convers given satisfi assign f easi construct scss size dn gamma max snphard scss next consid max snphard problem proof use reduct vertexcov problem boundeddegre graph scss problem sinc proof follow close reduct vertex cover hamiltonian circuit see suggest reader studi reduct read subsect known problem find minimum vertex cover max snphard graph whose maximum degre bound seven let g connect undirect graph whose maximum degre bound seven let g edg n vertic construct digraph variabl gadget incom edg root outgo edg claus vertic root root edg scss variabletru fig variabl gadget nphard proof vertic cycl longer vertex cover g size yield scss size ms vice versa show that sinc g on edg yield lreduct ie approximationpreserv reduct construct d appli vize theorem color edg g polynomi time eight color two edg incid vertex share color let color edg one f g construct begin special root vertex r outgo arc n vertic correspond vertic g arc r vertic form begin path correspond vertex g x fig covertest compon construct proce vertex g current vertex d initi start vertex edg u v order nondecreas color add covertest gadget d illustr fig specif add two new vertic x y add two edg x first label u current vertex u second label y similarli add two edg y first label current vertex v second label v gamma x make new current vertex u make x new current vertex v final edg g consid vertex v g add edg label v final current vertex root gadget implicitli layer gadget assign layer correspond color associ edg g lemma graph construct cycl edg proof first assign number vertic d root r assign number construct proce order increas color edg g consid edg u v color c add two new vertic x ad vs path ad us path assign vertic x number c consid cycl x length greater two d clear cycl must pass r sinc layer henc cycl form r consid edg order increas color number assign vertic x increas least everi two step path not includ r word number assign vertic x form nondecreas sequenc three consecut vertic get number sinc edg g color color number assign vertic rang onli r get number combin these length cycl x analysi show everi vertex cover g correspond scss d proof similar correspond proof in reduct vertex cover hamiltonian circuit everi vertex cover correspond hamiltonian circuit consid arbitrari vertex cover g idea choos scss path correspond d path vertic yet connect sinc form vertex cover vertic path connect use covertest compon lemma given vertex cover size g scss size construct proof construct subgraph h follow vertex u g let degre u g u vertex cover add h otherwis add edg label u gamma h easi verifi h follow properti h edg h cycl length everi vertex h least one outgo least one incom edg mention earlier layer everi cycl length greater contain r therefor properti impli everi cycl h pass r condit h contain path r everi vertex v anoth path v r therefor strongli connect obtain path v r start v keep travers outgo edg which exist properti current vertex path must eventu reach r r contain everi cycl h henc h satisfi lemma show everi scss correspond vertex cover g proof work show scss convert canon scss whose size larger correspond vertex cover g lemma given scss size s vertex cover g size construct proof first long nonroot vertex incom edg scss modifi scss follow let x y edg label v gamma v remov edg x y add edg x alreadi present altern nonroot vertex x outgo edg scss remov edg x y add edg y repeat either modif long applic layer d modif maintain strong connect scss clearli none modif increas size step reduc number edg label u gamma u scss step neither modif appli result scss everi nonroot vertex exactli one incom edg one outgo edg scss easi induct layer show vertex v g either edg label v scss none are case edg label scss let c set vertic g former kind easi show size scss jcj s everi edg u v g form gadget ensur least one two endpoint c henc c desir cover theorem minimum scss problem max snphard proof let g arbitrari undirect graph g whose maximum degre bound seven let g edg n vertic construct digraph shown earlier lemma cycl greater lemma vertex cover g size use obtain scss size s convers lemma scss size use obtain vertex cover g size s sinc degre g bound easili verifi yield lreduct degreebound vertex cover minimum scss problem open problem obviou problem character variou complex minimum scss k problem interest open problem obtain perform guarante less weight strong connect problem as mention earlier perform factor due frederickson jaja algorithm may implic weight connect problem undirect graph well perform guarante kexchang probabl improv k increas prove would interest similar local improv algorithm applic wide varieti problem r approxim algorithm gener steiner problem network transit reduct direct graph easi problem treedecompos graph proof verif hard approxim problem introduct algorithm effici algorithm find minimum span tree undirect direct graph comput intract guid theori npcomplet improv approxim algorithm biconnect subgraph via better lower bound techniqu transit compact parallel via branch gener approxim techniqu constrain forest problem introduct theori direct graph algorithm find minim equival graph digraph strongli connect digraph bound cycl length biconnect approxim graph carv gener approxim techniqu constrain twoconnect problem fundament algorithm algorithm find minimum equival graph digraph complex class siam journal comput find minim transit reduct strongli connect digraph within linear time data structur network algorithm estim chromat class pgraph russian primaldu approxim algorithm gener steiner network problem tr ctr adrian vetta approxim minimum strongli connect subgraph via match lower bound proceed twelfth annual acmsiam symposium discret algorithm p januari washington dc unit state liang zhao hiroshi nagamochi toshihid ibaraki linear time approxim minimum stronglyconnect span subgraph problem inform process letter v n p cristina g fernand better approxim ratio minimum stphane bessi stphan thomass everi strong digraph span strong subgraph n arc journal combinatori theori seri b v n p march harold n gabow special edg approxim smallest direct kedg connect span subgraph proceed fifteenth annual acmsiam symposium discret algorithm januari new orlean louisiana