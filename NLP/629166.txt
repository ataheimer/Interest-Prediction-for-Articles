t effici parallel backtrack a analyt model experiment result concern averag case behavior ofparallel backtrack present two type backtrack search algorithm areconsid simpl backtrack use heurist order prunesearch heurist backtrack doe analyt model use compareth averag number node visit sequenti parallel search case forsimpl backtrack shown averag speedup obtain linear thedistribut solut uniform superlinear distribut solut isnonuniform heurist backtrack averag speedup obtain least linearand speedup obtain subset instanc superlinear experiment result formani synthet practic problem run variou parallel machin valid thetheoret analysi present b introduct consid problem find solut statespac tree contain one solut backtrack also call depthfirst search wide use techniqu solv problem storag effici throughout paper use two name interchang use acronym df denot backtrack depthfirst search statespac tree mani variant df algorithm tune certain type problem paper deal two import simpl backtrack which use heurist inform ii heurist backtrack which use order andor prune heurist reduc search complex number parallel formul df develop variou research one formul n processor concurr perform backtrack disjoint part statespac tree part statespac search differ processor roughli equal size actual part search space search differ processor sequenc node subspac visit determin dynam differ differ execut result execut sequenc parallel version may find solut visit fewer node sequenti version thu give superlinear speedup the speedup defin ratio time taken sequenti parallel df execut sequenc may find solut visit node thu give sublinear speedup type behavior common varieti parallel search algorithm refer speedup anomali superlinear speedup isol execut parallel df report mani research may appear averag speedup would either linear sublinear otherwis even parallel df execut sequenti processor via timesl would perform better sequenti df paper consid averag case speedup anomali parallel df algorithm base techniqu develop though simpl backtrack heurist backtrack algorithm analyz use df strategi behavior differ analyz separ develop abstract model search space travers two type df algorithm analyz compar averag number node visit sequenti search parallel search case simpl backtrack show averag speedup obtain i linear distribut solut uniform ii superlinear distribut solut nonuniform heurist backtrack averag speedup obtain least linear ie either linear superlinear speedup obtain subset instanc that difficult instanc superlinear theoret analysi valid experiment analysi exampl problem problem gener testpattern digit circuit n gammaqueen puzzl hacker problem result parallel backtrack search give least linear speedup averag import sinc df current best known practic use algorithm solv number import problem occurr consist superlinear speedup certain problem impli sequenti df algorithm suboptim problem parallel df timesl one processor domin sequenti df highli signific known search techniqu domin sequenti df problem restrict attent paper statespac search tree df algorithm effect search tree overal speedup obtain parallel df depend upon two factor search overhead defin ratio node expand parallel sequenti search commun overhead amount time wast differ processor commun synchro nizat etc orthogon sens caus complet differ search overhead caus sequenti parallel df search node differ order commun overhead depend upon target architectur load balanc techniqu commun overhead parallel df analyz previous publish paper experiment valid varieti problem architectur paper analyz search overhead howev experi run real multiprocessor overhead incur henc overal speedup observ experi may less linear ie less n n processor even model predict parallel search expand fewer node sequenti search parallel df effect commun overhead less signific larger instanc ie instanc take longer time execut henc larger instanc problem obey analys accur smaller instanc reader keep mind interpret experiment result present paper section briefli describ two differ kind df algorithm analyz paper section review parallel df simpl backtrack search algorithm analyz section order backtrack search algorithm analyz section contain relat research section contain conclud remark experi parallel df modifi find optim solut number node search sequenti df parallel df becom equal make search overhead type df algorithm consid problem formul term find solut path implicit direct statespac tree initi node goal node tree gener fli aid successorgener function given node tree function gener successor backtrack ie df use solv problem follow search begin expand initi node ie gener successor later step one recent gener node expand in problem heurist inform use order successor expand node determin order successor visit df method heurist inform also use prune unpromis part search tree prune node discard search recent gener node successor determin node lead solut backtrack done recent gener node remain as yet unexpand node select expans major advantag df storag requir linear depth search space search follow two search method use backtrack search strategi simpl backtrack depthfirst search method use find one solut use heurist order successor expand node heurist may use prune node search space search avoid node order backtrack depthfirst search method use find one solut may use heurist order successor expand node may also use heurist prune node search space search avoid node method also refer order df parallel df mani differ parallel formul df suitabl execut asynchron mimd multiprocessor formul discuss use quit commonli formul processor search disjoint part search space whenev processor complet search assign part request busi processor work busi processor split remain search space two piec give one piec request processor solut found processor notifi processor search space finit solut eventu processor would run work search sequenti parallel termin without find solut backtrack search algorithm search termin whole search space exhaust ie either search prune parallel df algorithm analyz theoret differ slightli descript follow simplic analys model assum initi static partit search space suffici good load balanc parallel df use experiment result work partit dynam reader see close agreement experi analys analysi speedup simpl backtrack inform assumpt definit statespac tree leaf node solut occur among leaf node amount comput need visit leaf node same execut time search proport number leaf node visit unreason assumpt search tree branch factor greater one number node visit df roughli proport number leav visit also section model effect prune heurist explicitli assum number leaf node statespac tree alreadi prune use prune function sequenti parallel df stop find one solut parallel df statespac tree equal partit among n processor thu processor get subtre node least one solut entir tree otherwis parallel search sequenti search would visit entir tree without find solut result linear speedup inform order search statespac tree henc densiti solut across search frontier independ order search solut densiti ae leaf node probabl leaf node solut assum bernoulli distribut solut ie event leaf node solut independ leaf node solut also assum ae wn denot averag total number node visit n processor one processor find solut w averag number leaf node visit sequenti df solut found clearli w wn less equal sinc execut time search in sequenti well parallel case proport number node expand wn theta n effici e speedup divid n e denot effect util comput resourc wn effici analysi consid search frontier leaf node static divid n region leav let densiti solut among leav th region ae parallel case processor search region i independ one processor find solut sequenti case region arrang random sequenc search order theorem ae densiti region number leav k region larg mean number leav visit singl processor search region ae proof sinc bernoulli distribut mean number larg enough k second term becom less henc mean number trial aesequenti df select one n region probabl n search find solut henc averag number leaf node expand sequenti df ae n given express assum solut alway found select region thu one region search probabl solut anoth region would need search take account would make express w precis increas averag valu w somewhat reader verifi overal result analysi chang step parallel df one node n region explor simultan ousli henc probabl success step parallel algorithm approxim ae neglect second order term sinc ae s assum small henc inspect equat see w hm hm harmon mean ae s arithmet mean sinc know arithmet mean am harmon mean hm satisfi relat hm w wn particular ffl ae s equal solut uniformli distribut averag speedup parallel df linear ffl differ hm therefor w wn solut densiti differ region nonuniform averag speedup parallel df superlinear assumpt the event node solut independ event node solut unlik true practic problem still analysi suggest parallel df obtain higher effici sequenti df provid solut distribut uniformli search space inform densiti differ region avail characterist happen true varieti problem space search simpl backtrack experiment result present experiment result perform parallel df three problem i hacker problem ii puzzl problem iii n gammaqueen problem experi discuss section sequenti parallel df visit newli gener successor node random order differ convent df successor visit static defin left right order order df successor visit heurist order visit successor random order rather lefttoright heurist order tri valid model assum heurist inform avail order node henc random order good other get averag run time asid reader note order inform alway improv effect df exampl experi ida algorithm puzzl problem indic experi repeat mani time note that besid random order successor anoth sourc variabl execut time parallel df part statespac tree search differ processor determin dynam highli depend run time event beyond programm control henc parallel df experi repeat even frequent sequenti df hacker problem involv search complet binari tree leaf node solut node path solut node repres correct password among variou binari sequenc fix length may one solut due wild card notat implement program sequent balanc multiprocessor experi differ case processor experi done two differ kind tree one case one solut distribut uniformli whole search space correspond case branch point due wild card tree more solut wild card exactli one solut case predict analysi sequenti search parallel search approxim amount work henc speed parallel df linear case correspond curv label figur effici start decreas beyond processor commun overhead higher larger number processor second case four solut distribut uniformli small subspac total space subspac randomli locat whole space correspond case branch point due charact denot wild card low tree case expect effici parallel df greater region search differ processor tend differ solut densiti result shown figur fraction indic next curv denot size subspac solut locat exampl mean curv case solut locat randomli space figur reader would notic peak effici r processor case solut distribut r fraction search space see curv label happen possibl one r processor receiv region contain solut thu give substanti higher densiti region compar processor cours sinc search space experi distribut dynam best case happen time probabl occurr becom smaller number processor increas height peak success curv decreas valu r also decreas use manhattan distanc heurist order which best known admiss heurist puzzl make df better hand problem n gammaqueen order inform improv perform df substanti experi puzzl perform bbn butterfli parallel processor processor experi involv instanc puzzl uniform distribut nonuniform distribut solut depth bound df use limit search space instanc sequenti df parallel df execut depthbound equal depth shallowest solut node averag time sequenti parallel search obtain run experi time for everi puzzl instanc figur show averag speedup obtain instanc uniform distribut solut show near linear speedup maximum deviat speedup indic band region width band region expect reduc lot repetit say everi instanc tri instanc nonuniform distribut solut give superlinear speedup figur show effici versu number processor n gammaqueen problem problem natur known exhibit non uniform solut densiti data point shown obtain averag trial see parallel df exhibit better effici sequenti df number processor increas fix problem size effici goe overhead parallel execut mask gain due parallel execut expect larger instanc problem parallel df exhibit superlinear speedup even larger number processor experi confirm predict model superlinear speedup occur parallel df densiti solut region search differ processor differ linear speedup occur solut uniformli distribut whole search space mean solut densiti region search differ processor parallel same number processor n effici figur effici curv hacker problem effici greater indic superlinear speedup number processor n uniform dist non uniform dist singl soln figur speedup curv puzzl problem queen queen queen linear speedup number processor n figur effici curv nqueen problem speedup parallel order depthfirst search assumpt definit given balanc binari tree depth d tree contain node leaf node solut node find one solut travers tree use sequenti parallel df bound heurist avail make unnecessari search nonleaf node either follow two case identifi solut reach node even identifi node solut identifi solut exist subtre root node thu make unnecessari search node bound heurist succe prune nonleaf node need search node if node nonleaf node bound heurist succeed search proce usual node character bound heurist success rate gamma ie probabl procedur succe prune node purpos discuss shall assum ensur effect branch factor greater search complex becom insignific consid balanc binari tree depth k prune use bound heurist let f k number leaf node tree clearli f k would k given tree solut df visit f d leaf node tree one solut df find solut visit fewer leaf node f d actual number leaf node visit depend upon locat left solut tree turn depend upon order successor node visit extrem case correct successor node visit first df solut found visit exactli one leaf node as left node search tree solut practic order heurist avail aid us visit promis node first postpon visit inferior one if necessari later character order heurist paramet fl heurist make correct choic order probabl fl ie flfraction time subtre contain solut visit remain gamma flfraction time subtre contain solut visit obvious make sens consid mean heurist provid wors inform random coin toss order perfect solut found visit leaf node shall refer tree obtre orderedbound tree order bound inform avail reduc search summar obtre model search problem bound andor order heurist avail guid search error probabl constant reader caution problem may necessarili true effici analysi analyz averag number leaf node visit sequenti parallel df algorithm obtre let sd averag number leaf node prune node termin node visit sequenti search p d sum averag number leaf node visit processor parallel df theorem f proof see proof theorem a appendix atheorem sd see proof theorem a appendix athu use order bound heurist sequenti df cut effect size origin search tree larg factor bound heurist reduc effect branch factor approxim order heurist reduc overal search effort factor gamma fl even though obtre complet binari tree backtrack algorithm use prune heurist reduc branch factor less let consid number node visit parallel df clearli bound heurist use parallel df effect as use sequenti df howev might appear parallel df cannot make good use order heurist one processor work promis part space wherea processor work less promis part follow theorem say intuit wrong theorem obtre parallel df expand node averag sequenti df proof first consid two processor parallel df later gener result twoprocessor parallel df tree static partit root processor search two tree depth independ least one succe individu perform sequenti df help bound prune heurist note though second processor violat advic order heurist root node follow advic everywher els consid case root node prune bound heurist two possibl case case solut exist left subtre case happen flfraction time case sequenti df visit sd gamma leaf node averag wherea parallel df visit sd gamma leaf node left subtre also solut parallel df visit exactli sd gamma leaf node averag otherwis if subtre solut averag work done parallel df smaller case solut exist left subtre ie exist right subtre case happen gammaflfract time case sequenti df visit f dgammasdgamma leaf node averag wherea parallel df visit exactli sd gamma leaf node thu flfraction time parallel df visit sd gamma extra node gamma fl fraction time visit f d node sequenti df henc averag ignor case solut found root theorem a result extend case processor perform parallel search follow theorem theorem p number node expand parallel search processor p p agamma proof theorem compar search effici agamma processor use processor use first case entir search tree split agamma equal part near root part search one processor root prune ignor differ p d sd tree one node second case split two equal part two processor share work one processor use do let us compar number node expand one processor first case correspond pair processor second case know subtre deal obtre fore theorem show pair processor much work singl processor first case sum agamma part whole tree theorem follow induct theorem show p d sd hold case k processor perform parallel search superlinear speedup hard solv instanc theorem follow import consequ partit randomli select set problem instanc two subset one subset averag speedup sublinear averag speedup one superlinear one partit accord correct order near root let us call instanc order heurist make correct decis near root easytosolv instanc other hardtosolv instanc sequenti df easytosolv instanc take smaller time solv hardtosolv instanc processor case easytosolv instanc flfraction total instanc order heurist make correct decis root these parallel version obtain averag speedup ie speedup remain instanc averag speedup roughli gammafl arbitrarili high depend upon close fl processor easiest solv instanc fl fraction total instanc sequenti search make correct decis first branch start root maximum superlinear avail hardest solv instanc fraction total instanc experiment result problem chose experi test gener problem aris comput aideddesign cad vlsi problem automat test pattern gener atpg obtain set logic assign input integr circuit distinguish faulti faultfre circuit presenc set fault input pattern said test given fault if presenc fault produc output differ faulti faultfre circuit studi sequenti parallel implement algorithm call podem pathori decis make use combin circuit and sequenti circuit base levelsensit scan design approach one success algorithm problem wide use number fault possibl circuit proport number signal line it known sequenti algorithm abl gener test fault reason time spend enorm amount time much execut time tri gener test remain fault result execut algorithm termin fail gener test predefin number node expans backtrack fault cannot solv reason time serial algorithm call hardtodetect htd fault practic import gener test mani fault possibl higher fault coverag result reliabl chip atpg problem fit model analyz well follow reason i search tree gener binari ii nonredund fault problem typic one small number solut iii good imperfect order heurist avail iv bound heurist avail prune search node either prune node solut longer lead solut experi atpg problem support analysi hardtosolv in stanc parallel algorithm show superlinear speedup implement sequenti parallel version podem processor symult multiprocessor perform experi use isca benchmark file test data detail implement experiment result found experi conduct follow htd fault first filter pick fault seven file whose test pattern could found within backtrack use sequenti algorithm serial parallel podem algorithm use find test pattern htd fault sinc htd fault may solvabl by sequenti andor parallel podem algorithm reason time upper limit impos total number backtrack sequenti parallel algorithm could make sequenti parallel algorithm exceed limit the sum backtrack made processor count parallel case algorithm abort fault classifi undetect for backtrack limit time taken pure sequenti podem parallel podem use comput speedup result shown figur circuit isca benchmark experi use upperlimit backtrack test variat superlinear hard fault select two set fault first set consist fault serial algorithm abl solv execut total number backtrack node expans rang similarli number processor speedup figur speedup curv atpg problem second set fault solv serial algorithm backtrack rang fault second set thu harder solv serial algorithm two seven file name c c yield fault either two set execut parallel algorithm processor averag speedup obtain given number processor separ two set fault runtim fault averag obtain run result shown figur result clear superlinear increas increas hard instanc degre superlinear decreas increas number processor effici parallel df decreas problem size fix number processor increas note experiment result valid discuss section valid theorem would necessari find number node expand parallel df even easi detect fault fault experiment run time roughli proport number node search parallel df small tree commun overhead becom signific superlinear hardtodetect fault experiment observ atpg heurist patil banerje relat research occurr speedup anomali simpl backtrack studi monien et al studi parallel formul df solv satisfi problem formul processor tri prove satisfi differ subformula input formula due natur satisfi problem subformula lead search space differ averag densiti solut differ solut densiti respons averag superlinear speedup context model monien et al show possibl obtain averag superlinear speedup sat problem analysi simpl backtrack in section done similar model result gener stronger also analyz averag case behavior parallel simpl backtrack theoret result present much stronger show region search processor solut uniformli distribut region search rest processor solut all averag speedup parallel backtrack would superlinear analysi section show nonuniform solut densiti among region search differ processor lead superlinear speedup averag two type heurist df algorithm discuss outsid scope number processor figur speedup curv hardtosolv instanc atpg problem search space search random fashion ie newli gener successor node order randomli number node expand solut found random variabl let call t one simpl parallel formul df present let search space search mani processor independ random order one processor find solut total number node expand processor formul random variabl let call tn clearli g v random variabl averag valu tn less time t also expect superlinear speedup certain distribut t happen case exampl probabl find solut level statespac tree same properti note parallel formul df domin one term effici parallel formul duplic work henc parallel formul exhibit superlinear speedup search space formul exhibit superlinear speedup convers true certain problem probabilist algorithm perform substanti better simpl backtrack exampl happen problem statespac tree balanc binari tree like hacker problem discuss section overal densiti solut among leaf node rel high solut distribut nonuniformli probabilist search perform better simpl backtrack problem make densiti solut leaf node look virtual uniform reader infer analysi section kind search space parallel df also obtain similar homogen solut densiti even though processor still perform enumer a part of search space domain applic two techniqu probabilist algorithm vs sequenti parallel df howev differ depth leaf node tree vari probabilist search algorithm visit shallow node much frequent deep node statespac tree mani problem such n gammaqueen problem shallow node correspond failur node solut node locat deep tree problem probabilist algorithm perform well simpl backtrack visit failur node frequent note simpl backtrack visit failur node exactli onc densiti solut among leaf node low expect run time probabilist algorithm also high in extrem case solut probabilist search never termin wherea simpl backtrack parallel df will case also enum search algorithm simpl backtrack probabilist algorithm state space search obtain gener random walk root node leaf node solut found superior probabilist algorithm parallel variant retain advantag homogen order df random parallel df algorithm given perform poorli abl benefit order heurist probabilist algorithm weak decis problem analysi section show util order heurist cut search larg factor sequenti df parallel df case optim problem ie interest find leastcost solut random parallel df algorithm well probabilist algorithm use one cannot guarante optim solut unless exhaust search perform saletor kale present parallel formul df quit differ one formul explicitli ensur number node search sequenti parallel formul nearli equal result paper appli parallel df gener model explain occurr superlinear speedup varieti search problem present shown parallel algorithm perform less work correspond sequenti algorithm superlinear speedup possibl paper identifi analyz problem inde case conclus present analyt model theoret result character averag case behavior parallel backtrack search df algorithm show averag parallel df show deceler anomali two type problem also present experiment result valid claim multiprocessor further identifi certain problem characterist lead superlinear speedup parallel df problem characterist parallel df algorithm better sequenti df algorithm even timesl one processor isol occurr speedup anomali parallel df report earlier variou research experiment analyt result show possibl superlinear speedup averag with except result avail parallel df number question need address research problem sequenti df domin parallel df search techniqu best possibl sequenti search algorithm one deriv run parallel df one processor time slice mode ye optimum number processor emul mode case order backtrack search show parallel search effici hardtosolv instanc sequenti search effici easytosolv instanc practic one therefor use combin sequenti parallel search optim combin paper analyz effici parallel df certain model would interest perform similar analysi model also parallel formul backtrack search given acknowledg would like thank sunil arvindam hang ng help us experi would also like thank dr jame c brown dr vineet singh mani help discuss appendic detail analysi order df algorithm theorem a f proof clear f consid case k root node prune thu f remain probabl root node prune successor case f henc bound heurist succe root df visit one leaf otherwis visit left subtre root fl fraction time visit left subtre unsuccess visit right subtre fraction time henc have a moder suffic henc use theorem a simplifi previou assumpt d term ignor term becom neglig larger say thu theorem a error ignor smallin twoprocessor parallel depthfirst search tree static partit root processor search two tree depth d independ least one succe individu perform sequenti df consult three wise oracl note though second processor violat advic order heurist root node follow advic everywher els henc time root prune prune liber convent two node expand parallel search otherwis two obtre depth d search two node expand step one processor succeed inequ aris averag minimum two trial minimum two averag formula sd use theorem a error ignor less theorem a inequ becom equal restrict one solut entir search tree theorem a averag parallel search visit number node sequenti search larg randomli select set problem instanc singl solut proof see argument r automat test pattern gener multiprocessor implicit enumer algorithm gener test combinatori logic circuit experiment evalu load balanc techniqu hypercub model speedup n greater n fundament comput algorithm parallel search scheme multiprocessor system applic combinatori problem random parallel algorithm prolog program backtrack applic perfect heurist n nonattack queen problem search artifici intellig person commun use parallel implement heurist search scalabl load balanc techniqu parallel comput parallel branchandbound formul andor tree search scalabl parallel formul depthfirst search parallel depthfirst search anomali parallel branch bound algorithm wah comput effici parallel approxim branchandbound algorithm share virtual memori system parallel comput superlinear speedup random algorithm superlinear speedup parallel back track parallel depthfirst search superlinear speedup statespac search parallel implement iterativedeepeninga principl artifici intellig parallel branchandbound algorithm test gener probabilist algorithm consist linear speedup first solut parallel statespac search averag complex depthfirst search backtrack cutoff effici search techniqu empir studi nqueen problem perform pragmat orparallel logic program system tr heurist intellig search strategi comput problem solv averag complex depthfirst search backtrack cutoff dibmyampersandmdasha distribut implement backtrack principl artifici intellig perform orparallel logic program system parallel depth first search part i implement parallel depth first search part ii analysi search artifici intellig almost perfect heurist italicnital nonattack queen problem scalabl parallel formul depthfirst search anomali parallel branchandbound algorithm fundament comput alori automat test pattern gener multiprocessor superlinear speedup parallel statespac search ctr jung m s krishnamoorthi georg nagi andrew shapira ntupl featur ocr revisit ieee transact pattern analysi machin intellig v n p juli finkelstein shaul markovitch ehud rivlin optim schedul parallel anytim algorithm case independ process eighteenth nation confer artifici intellig p juli august edmonton alberta canada fumiaki okushi parallel cooper proposit theorem prove annal mathemat artifici intellig v n p jame cheetham frank dehn andrew rauchaplin ulrik stege peter j taillon solv larg fpt problem coarsegrain parallel machin journal comput system scienc v n p decemb ariel felner sarit krau richard e korf kbf kbestfirst search annal mathemat artifici intellig v n p septemb daniel j challou maria gini vipin kumar georg karypi predict perform random parallel applic robot motion plan journal intellig robot system v n p septemb g karypi v kumar unstructur tree search simd parallel comput summari result proceed acmiee confer supercomput p novemb minneapoli minnesota unit state weim lin wei xie bo yang perform analysi parallel solut gener search problem proceed acm symposium appli comput p april san jose california unit state andrea di bla arun jagota richard hughey optim neural network simd parallel comput parallel comput v n p januari g karypi v kumar unstructur tree search simd parallel comput ieee transact parallel distribut system v n p octob ananth grama vipin kumar state art parallel search techniqu discret optim problem ieee transact knowledg data engin v n p januari peter a krauss andrea ganz kurt j antreich distribut test pattern gener stuckat fault sequenti circuit journal electron test theori applic v n p dec luca bordeaux youssef hamadi lintao zhang proposit satisfi constraint program compar survey acm comput survey csur v n pe