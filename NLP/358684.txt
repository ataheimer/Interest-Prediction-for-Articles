t effici address gener affin subscript dataparallel program a address gener compil program written hpf execut spmd code import necessari phase parallel compil paper present effici compil techniqu gener local memori access sequenc blockcycl distribut array refer affin subscript dataparallel program memori access array refer affin subscript within twonest loop exist repetit pattern outer inner loop use tabl record memori access repetit pattern accord tabl new startcomput algorithm propos comput start element processor outer loop iter complex tabl construct ok k distribut block size access stride inner loop tabl construct gener start element outer loop iter run o time moreov also show repetit iter outer loop pkgcdpk p number processor access stride outer loop therefor total complex gener local memori access sequenc blockcycl distribut array affin subscript twonest loop opkgcdpksk b introduct gener speak dataparallel languag support three regular data distribut block cyclic blockcycl data distribut block distribut distribut contigu array element evenli onto processor cyclic distribut distribut array element onto processor one time roundrobin fashion distribut block size k distribut onto processor roundrobin fashion blockcycl distribut denot cyclick blockcycl distribut known gener data distribut block cyclic distribut repres blockcycl distribut cyclicd na e cyclic respect na number array element p number processor address gener problem compil array refer block cyclic distribut studi thoroughli gener problem compil array refer blockcycl distribut also studi extens finit state machin fsm approach propos travers local memori access sequenc processor method tablebas approach tabl construct need solv k linear diophantin equat incur sort oper work improv fsm approach propos effici fsm tabl gener propos improv work enumer local memori access sequenc view access element integ lattic sort step avoid improv work author use virtual processor gener commun set processor differ viewpoint blockcycl distribut virtual processor approach actual contain two approach one term virtual block approach term virtual cyclic approach virtual block approach view blockcycl distribut block distribut set virtual processor cyclic map processor con trari virtual cyclic approach view blockcycl distribut cyclic distribut set virtual processor blockwis map processor approach similar either fsm approach virtual processor approach except modif howev consid simpl array subscript is array subscript contain one induct variabl recent sever effort compil array refer affin array subscript propos affin array subscript mean array subscript linear combin multipl induct variabl miv author use linear algebra framework gener commun set affin array subscript complex loop bound local array subscript gener code incur signific overhead tablebas approach propos author classifi block class use class tabl record memori access first repetit pattern use class tabl deriv commun set processor address compil array refer affin subscript within multinest loop how ever propos method effici enough deal special case compil array refer affin sub script research pay attent array refer enclos within twonest loop find better result base fsm approach kennedi et al propos anoth approach solv compil array refer affin subscript within twonest loop memori access array refer affin subscript within twonest loop exist repetit pattern outer inner loop moreov fix iter outer loop affin subscript reduc simpl subscript therefor iter outer repetit pattern use fsm approach gener local memori access sequenc inner loop use fsm approach inner loop start comput decid initi state fsm iter outer loop necessari propos opk algorithm startcomput p number processor k distribut block size outer loop found repetit iter pk iter henc total complex gener local memori access sequenc array refer affin subscript within twonest loop op ramanujam et al propos improv work find local start element processor first find factor basi vector jump global start processor space travers lattic hit start element enddo enddo fig hpflike program model consid paper sinc travers step incur complex startcomput algorithm ok thu total complex ramanujam algorithm turn opk paper also propos anoth new start comput algorithm preprocess step requir comput start element complex preprocess step ok access stride inner loop preprocess done time complex gener start element processor o addit also discov outer loop repetit iter pk gcdpk instead pk access stride outer loop therefor total complex propos approach opk gcdpk asymptot opk propos approach correct also effici paper organ follow section formul problem describ tradit techniqu gener local memori access sequenc compil array refer affin subscript within twonest loop effici approach find start element global start propos section perform analys comparison relat work demonstr section section conclud paper address gener affin subscript problem formul specif fig illustr program model consid paper array distribut onto processor cyclick distribut array refer contain two induct variabl access stride array refer respect respect access offset array refer o fig exampl program model shown fig fig a layout array element processor color element array element access array refer twonest loop fig b show global address array element access everi processor howev data distribut transfer global address space processor local space therefor care gener local address processor access ele ment thu miv address gener problem gener local address array element access processor like fig c show tabl base address gener affin subscript case array refer contain singl induct variabl siv wellknown memori access processor repetit pattern finit state machin fsm built orderli iter local memori access sequenc pro cessor similarli array refer contain multipl induct variabl miv extend techniqu use siv orderli enumer local memori access sequenc processor consid program model shown fig outer iter miv address gener problem reduc siv problem thu util fsm approach gener local memori access sequenc siv problem gener local memori access sequenc miv problem can therefor easili solv enumer sequenc outer loop iter reach outer loop bound exampl consid exampl illustr fig suppos outer loop iter twonest loop reduc singl nest loop array refer turn ai thu finit state machin fsm built enumer local memori access sequenc siv problem fig illustr fsm gener local memori access sequenc array refer contain singl induct variabl access stride fig a show fsm tabl next record next transit state deltam record local memori gap success array element current state transmit next state fig b transit diagram fsm initi state fsm depend posit start array element block processor instanc start element processor p posit a b c fig miv address gener exampl layout array element processor b global address array element access everi proce sor c local address array element access everi processor state next deltam a b fig finit state machin fsm gener local memori access sequenc siv problem access stride block thu initi state fsm case state addit initi state fsm also need know local address start element sinc fsm record local memori gap success array element alloc processor fsm enough inform show start term local address word although fsm initi state still know start local address case exam ple besid initi state fsm state know figur local address start element obvious local address start element processor p therefor local memori access sequenc processor p on likewis twonest loop reduc singl nest loop array refer simplifi finit state machin built case still reus sinc memori access stride still exampl start element processor posit block thu initi state fsm case state howev start term local address key point now start element processor p local address processor p therefor local memori access sequenc processor p on similarli done likewis outer loop iter accordingli obtain local memori access sequenc processor fig c show actual need iter outer loop iter n found iter outer loop iter pk gcdpk time enough repetit pattern outer loop discoveri save lot time due avoid recomput repetit pattern follow theorem demonstr repetit period outer loop pk gcdpk iter sinc space lim ite proof theorem omit paper one refer detail theorem program model shown fig memori access array refer repetit pattern repetit period respect outer loop iter pk gcdpk tion accord descript evid determin local address start element outer loop iter primari step solv miv address gener problem problem find local address start element outer loop iter describ next section new approach gener local address start element present next section well gener start element find start element outer loop iter import solv miv address gener problem obviou given outer loop iter memori access depend inner loop access stride therefor section use indic inner loop access stride except otherwis notifi method find start element case k found o com plexiti howev method find start element case k opk ok re spectiv propos new approach find start element case k time complex algorithm o problem solut describ follow problem descript given overal descript miv address gener problem section find start element processor given outer loop iter play import role deal miv address gener problem follow formal describ induc problem let access element fix outer loop iter a b fig start element everi processor exampl shown fig a global address start element everi processor b local address start element everi processor global start g local address global start specif given global start g processor p g alloc processor q would like find start element problem figur q local address start element processor q exampl consid exampl shown fig a gray color element element access array refer deepcolor shade element global start correspond everi outer loop iter lightcolor shade element processor start element correspond everi global start suppos given global start local address processor start element processor p p respect term global address problem figur local address start element is respect start element everi outer loop iter shown fig global local address start element everi processor list fig a b respect goal induc problem obtain tabl contain local address start element requir processor everi global start fig b show requir processor preprocess given global start g propos new approach find local address start element q processor q case k propos approach tablebas approach approach necessari precomput tabl order evalu start element given global start section describ charact fig onelevel map exampl illustr idea tabl use paper assum array element distribut processor cyclic distribut access stride istic tabl work propos approach complex time space analyz section sake space limi tation construct tabl omit paper detail pleas refer cp pc offset tabl wellknown access element block repetit pattern block classifi class accord posit access element block note block class format block number term class accord rule b mod b block number block repetit pattern contain block class class term class cycl addit sinc k one access element block therefor use tabl record posit access element everi class differ assum access element block class first posit is posit block access element record tabl easili effici get posit access element block class number block given therefor easili deduc q g sinc block classifi class denot tabl record posit access element everi class cp tabl exampl let us suppos array element distribut processor cyclic distribut access stride layout array element processor illustr fig figur access element element white text black background obvious block classifi class class color gradat gray color class number block label bottom block block bound dash line indic repetit pattern access element class posit respec tive therefor valu cp respect moreov access element class so cp thu obtain cp tabl fig a illustr cp tabl exampl shown fig get posit access element block accord class number block use cp tabl contrast cp tabl pc tabl record class number accord posit access element block thu obtain class number block accord posit access element block gener speak obtain class number block accord posit access element block use cp tabl howev requir search oper and case recogn class number block accord cp tabl instanc number class smaller block size possibl that posit class access element posit would caus confus recogn class number posi tion therefor pc tabl necessari pc tabl construct cp tabl exampl consid cp tabl shown fig a one scan tabl obtain pc tabl pc tabl illustr fig b note that case number class smaller block size posit class number correspond to assum class number posit class number previou po sition exampl suppos distribut block size access stride block classifi class access element class posit respect result posit correspond class re spectiv pc obvious posit suitabl class number correspond to assumpt class number correspond posit previou posit similarli class number correspond posit thu pc basic cp pc tabl sens like hash tabl reason make assumpt pc tabl construct solv offset prob lem offset problem solv assumpt conjunct anoth tabl offset gener speak global start g posit block howev construct cp tabl assum access element block class posit further more construct pc tabl posit class number correspond to assign class number previou valu current valu nevertheless accord cp tabl class number real posit correspond to consequ differ real posit assum posit make assumpt order make use cp tabl everi case use anoth tabl record differ order make shortcom cp tabl tabl denot asoffset tabl paper discuss number class larger block size posit suitabl class number correspond to case offset tabl use fig exampl condit offset tabl shown fig c hand number class smaller block size follow exampl use explan pc tabl assum distribut block size access stride cp pc tabl respect sinc posit suitabl class number correspond to assign class number correspond posit posit although posit correspond class real posit access element block class posit accord cp ta ble thu differ assum valu real valu result offset similarli offset problem posit sinc suitabl class number correspond to consequ offset tabl nextact jump tabl previous describ block contain one access element access stride larger block size cours block may contain access element case thu name block element access activ block otherwis term empti block tabl nextact jump would like introduc use jump empti a b fig a one group order sequenc b multipl group order sequenc block activ block one import observ that processor viewpoint block processor repetit pattern term class explain concret let us take look exampl shown fig block processor class repeat class similar situat also happen processor sequenc class number p p p interest sequenc class number processor except initi class number processor is sequenc class number processor view sequenc initi class number p p respect use notat denot order sequenc clearli class number appear order sequenc thu say one group order sequenc fig a illustr one group order sequenc exampl address possibl sequenc class number processor may differ may one group order sequenc howev group mutual disjoint processor belong one one group give exampl illustr phenomenon suppos array element distribut processor cyclic distribut access stride class exampl sequenc class number p order sequenc repres obvious order sequenc contain two group one anoth mutual disjoint processor p belong group belong group fig b illustr multipl group order sequenc a c offset d nextact fig tabl use start element find exampl import discoveri sinc obtain class number next block processor current block class number current block known base discoveri use one tabl record class number next activ block current block processor anoth record mani empti block need skip over name nextact jump respect construct two tabl base order sequenc cp tabl current block empti block need jump block thu valu nextact tabl block record class number jump tabl record otherwis travers order sequenc find activ block valu nextact tabl block record class number activ block jump tabl record number block travers find activ block valu nex tact jump tabl record exampl array element distribut processor cyclic distribut access stride nextact jump tabl respect although processor belong one one group nextact tabl suitabl processor sinc construct tabl base class number group nextact jump tabl exampl shown fig illustr fig d e respect algorithm tabl evalu start element given global start o time complex iti fig illustr algorithm evalu start element given global start term algorithm start comput algorithm basic concept start comput algorithm algorithm start comput algorithm case k input g global start p processor global start alloc q processor would like find start element q p k distribut block size p number processor s access stride c number class cp pc offset nextact jump tabl output q start element processor q step po dist po po return start element q els po jumpclambdak endif endif q p endif return q fig start comput algorithm case that viewpoint global start tri figur distanc start element global start distanc can therefor get local address start element ad distanc local address global start detail algorithm describ follow given g local address global start g alloc step calcul posit block global start obtain valu store po g step measur distanc processor p q store dist step pcpo g obtain class number block global start on thu step get class number block processor q may contain start element class number obtain step repres c accord cp tabl cpc get posit access element block class c ever therefor step obtain posit block start element processor q obtain posit repres po po equal mean access element block cours access element start element go direct step evalu distanc start element global start q p still need add size block distanc sinc start element must one cours global start step done result local address start element obtain step show hand po mean access element block use nextact tabl obtain class number next activ block nextactc impli exist activ block processor certainli start element pro cessor otherwis mean find activ block processor get number block requir jump current block next activ block posit access element activ block jump nextact tabl respect sinc po step repres posit start element block cours global start henc distanc caus number block requir jump activ block ad po case thu step step explain previou paragraph let us take fig exampl assum given global start whose local address processor first find start element processor input start comput algorithm tabl use exampl shown fig follow step algorithm obtain po sinc po equal go direct step obtain offset due invalid condit step go direct step correspond array element term global address input except take find start element processor p fig layout array element processor case k anoth miv exampl anoth exampl execut step po po sinc po equal mean block contain access element go step accord nextact jump tabl activ block one block empti block processor p step po step offset need add size block turn correspond array element term global address evid time complex start comput algorithm o complex analys tabl use algorithm perform comparison exist method discuss section perform analys comparison perform analys tabl use start comput algorithm shown tabl perform comparison method exist method shown tabl sake space limit pleas refer detail conclus paper present effici approach evalu start element processor given global start key step solv miv address gener problem tabl perform analys tabl complex time space offset nextact oc c tabl perform comparison s s start comp o o o preprocess o o os start comp opk ok o outer loop repetit pk pk pk iter total dataparallel program assum array block cyclic distribut subscript affin approach tablebas approach construct tabl requir os plexiti access stride inner loop tabl start comput algorithm run o time addit discov exist repetit pattern everi iter therefor miv address gener problem solv access stride outer loop futur would like appli address gener approach evalu commun set furthermor address gener commun set evalu gener affin subscript also investig r linear algebra framework static hpf code distribut program vienna fortran gener local address commun set data parallel program automat parallel distributedmemori multiprocess system concret mathemat compil array express effici execut distributedmemori machin high perform fortran forum effici address gener blockcycl distri bution lineartim algorithm comput memori access sequenc dataparallel program compil global namespac parallel loop distribut execu tion local iter set comput blockcycl distribut comput local iter set blockcycl distribut refer affin subscript optim represent local iter set access sequenc blockcycl distribut code gener complex subscript dataparallel program gener commun array state ment design effici comput address sequenc data parallel program use close form basi vector optim fortran compil mimd distributedmemori machin compil array refer affin function dataparallel program tr concret mathemat foundat comput scienc compiletim gener regular commun pattern vienna fortranmyampersandmdasha fortran languag extens distribut memori multiprocessor high perform fortran handbook gener commun array statement compil techniqu blockcycl distribut optim fortran compil mimd distributedmemori machin gener local address commun set dataparallel program lineartim algorithm comput memori access sequenc dataparallel program effici address gener blockcycl distribut compil array express effici execut distributedmemori machin effici comput address sequenc data parallel program use close form basi vector empir studi fortran program parallel compil compil global namespac parallel loop distribut execut code gener complex subscript dataparallel program