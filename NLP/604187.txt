t type compil recurs datatyp a standard ml employ opaqu or gener semant datatyp everi datatyp declar produc new type differ type includ ident defin datatyp natur way account consid datatyp abstract interpret appli typepreserv compil howev unfortun consequ datatyp constructor cannot inlin substanti increas runtim cost constructor invoc compar tradit compil paper examin two approach elimin function call overhead datatyp constructor first consid transpar interpret datatyp away gener alter semant sml second propos interpret datatyp constructor coercion runtim effect cost faith implement sml semant b introduct program languag standard ml sml provid distinct mechan defin recurs type known datatyp declar exampl follow declar defin type list integ datatyp intlist nil con int intlist datatyp declar introduc type intlist two constructor nil repres empti list con combin integ list produc new list instanc express con con con nil type intlist correspond list valu datatyp deconstruct case analysi examin list determin whether construct nil con latter case extract origin integ list import aspect sml datatyp gener is everi datatyp declar defin type distinct type includ produc other possibl ident datatyp declar formal definit sml make precis state datatyp declar produc new type name associ name defini tion sens datatyp similar abstract type harper stone hereaft hs give typetheoret interpret sml exhibit translat sml simpler type intern languag translat faith definit sml sens that wellknown except translat sml program welltyp il program sml program wellform accord definit consequ consid hs suitabl foundat typedirect compil sml furthermor seem like suitabl typetheoret interpret ie one faith definit encount issu explor analysi harper stone captur datatyp gener translat datatyp declar modul contain abstract type function construct deconstruct valu type thu set hs interpret datatyp abstract type gener datatyp pose challeng typedirect compil sml particular although hs interpret easi understand faith definit sml ineffici implement nave problem construct deconstruct datatyp valu requir call function export modul defin datatyp unaccept given ubiqu datatyp sml code convent compil disregard type inform initi typecheck phase may dispens cost inlin function is may replac function call actual code correspond function elimin call overhead typedirect compil howev option sinc optim includ inlin must type preserv move implement datatyp constructor across modul boundari violat type abstract thu result illtyp intermedi code made precis section paper discuss two potenti way handl perform problem present altern context tiltml compil develop cmu relev howev tilt understand definit languag typepreserv compil gener first approach away datatyp gener alto gether replac abstract type hs interpret concret one call approach transpar interpret datatyp clearli compil implement standard ml show that although modifi languag admit inlin datatyp constructor unexpect properti particular case everi wellform sml program allow transpar interpret contrast second approach adopt recent version tilt compil offer effici way implement datatyp type set consist particular sinc valu recurs type typic repres run time way unrol observ mediat function produc hs interpret behav like ident function run time replac function special valu distinguish ordinari function introduct coercion type call coercion interpret datatyp argu allow compil strategi gener code runtim effici compar would attain datatyp constructor inlin paper structur follow section give detail hs interpret datatyp which also refer opaqu interpret datatyp illustr problem inlin ing section discuss transpar interpret section give coercion interpret discuss properti section give perform comparison three interpret section discuss relat work section conclud opaqu interpret datatyp section review part harper stone interpret sml relev discuss datatyp par ticular defin notat use intern languag give exampl hs elabor datatyp refer exampl throughout paper also review way harper stone defin match structur signatur discuss implic datatyp import section show differ signatur match sml signatur match transpar interpret datatyp type st recurs type term e x roll e unrol e type context g e figur syntax isorecurs type x metavari figur shorthand definit notat harper stone give interpret sml translat call elabor sml type intern languag il give complet formal descript intern languag use paper instead use mllike syntax exampl employ standard notat function sum product type complet discuss elabor includ thorough treatment intern languag refer reader harper stone sinc focus attent datatyp recurs type particular import therefor give precis descript semant form recurs type use syntax recurs type given figur recurs type separ syntact subcategori rang d mostli matter notat conveni mani time wish make clear particular type recurs one recurs type form j type variabl may appear free n intuit type ith system n mutual recurs type such isomorph j replac jth compon recurs bun dle formal isomorph follow somewhat unwieldi type where usual denot ts n a n simultan captureavoid substitut n n t sinc write type often use notat convent make thing clearer shown figur use shorthand type may written judgment form static semant intern languag given figur rule relev recurs type given figur note rule use judg two recurs type equal requir two type question ith project bundl length whose respect compon equal particular un wellform context wellform type equival type wellform term figur relev type judgment figur type rule isorecurs type roll rule state expandd type theori equal hold said equirecurs type significantli complex recurs type theori iso recurs type isomorph equal expan sion isomorph embodi roll unrol oper term level former turn valu type expandd one type d latter invers elabor datatyp declar hs interpret sml includ full account datatyp includ gener main idea encod datatyp recurs sum type hide implement behind opaqu signatur datatyp declar therefor elabor structur export number abstract type function construct deconstruct valu type exampl consid follow pair mutual recurs datatyp repres express declar abstract syntax toy languag datatyp letexp dec exp dec valdec var exp seqdec dec dec hs elabor declar given figur use mllike syntax readabl construct valu one datatyp program must use correspond function function take element sum type un roll datatyp produc valu datatyp concret implement constructor exp dec follow notic type exp dec held abstract opaqu signatur ascript captur gener datatyp sinc abstract prevent expdecexp expdecdec judg equal type howev mention section abstract also prevent inlin structur expdec sig type exp type dec val exp var val exp exp var val dec var exp dec dec dec val dec dec var exp dec dec struct fun exp fun exp fun dec fun dec figur harperston elabor expdec exampl function exampl attempt inlin exp definit varexp abov get illtyp outsid expdec modul fact exp recurs type visibl thu perform inlin welltyp code lead illtyp code say inlin across abstract boundari typepreserv therefor accept strategi type compil problem sinc cannot inlin function compil must pay runtim cost function call everi time valu datatyp construct caseanalyz sinc oper occur frequent sml code perform penalti signific one strategi allevi somewhat hold implement datatyp abstract elabor expos underli implement elabor code defin compil unit call constructor locallydefin datatyp safe inlin set wholeprogram compil approach potenti elimin constructor call overhead datatyp except appear argument functor howev context separ compil client datatyp gener access implement rather specif constructor shall see section specif datatyp constructor provid suffici inform correctli predict datatyp actual implement compil strategi limit success true separ compil set datatyp signatur match standard ml make import distinct datatyp dec larat appear top level structur datatyp specif appear signatur seen hs interpret elabor datatyp declar opaqu seal structur datatyp specif translat specif structur exampl signatur datatyp intlist nil con int intlist contain datatyp specif elabor follow struct intlist sig type intlist val intlist intlist intlist val intlist intlist intlist structur match contain structur intlist appropri signatur particular clear structur definit produc hs interpret datatyp intlist defin section signatur datatyp declar match specif abov necessari gener datatyp declar match specif interpret sinc datatyp declar translat opaqu seal structur datatyp specif translat structur specif match datatyp declar spec boil match one signatur one opaqu seal declar structureagainst anoth signatur suppos wish know whether signatur match signatur t is whether structur signatur may also given signatur t intuit must make sure everi specif specif compat it instanc contain valu specif form t must also contain specif val t abstract type specif form type occur t must check specif also appear furthermor specif transpar one say imp check remaind specif may assum signatur imp transpar type specif similar ad requir specif type spec specif type imp must equival return specif question datatyp match specif form datatyp where may sum type elabor specif structur follow signatur sig val val n n n val datatyp match datatyp spec ific actual hs elabor must use name datatyp cannot guess programm structur expdec sig specif function structur figur transpar elabor exp dec order match signatur structur correspond datatyp declar must defin type name n must contain function appropri type each note structur produc elabor datatyp declar interpret s abstract type thu exampl n datatyp declar datatyp match specif sinc necessari suffici type function match type mention specif transpar interpret datatyp natur approach enabl inlin datatyp typepreserv compil away gener semant datatyp context hs interpret correspond replac abstract type specif signatur datatyp modul transpar type definit call modifi interpret transpar interpret datatyp tid make datatyp transpar idea transpar interpret expos implement datatyp recurs sum type elabor rather hide it expdec exampl correspond chang declar shown figur shown figur we continu use mllike syntax readabl importantli chang must extend datatyp specif well datatyp declar thu structur export datatyp must export implement transpar use signatur similar one figureotherwis datatyp insid structur would appear gener outsid structur would littl point new interpret mention befor alter interpret datatyp expos implement recurs type realli creat new languag neither subset superset standard ml exampl obviou differ seen figur figur two datatyp defin seemingli ident declar sml datatyp gener two type listt listt distinct sinc variabl l type listt pass listcon expect listt function switch illtyp transpar interpret howev implement datatyp export transpar aunit int a thu interpret listt listt equal switch welltyp function clear mani program like one fail typecheck sml succeed transpar interpret less structur struct datatyp con int structur struct datatyp con int fun switch switch listcon obviou program opposit true discuss two main reason thi problemat datatyp match recal accord hs interpret datatyp match datatyp specif type datatyp function match type function speci ficat note type function match type function match hereaft refer function transpar interpret how ever also necessari recurs type implement datatyp match one given specif trivial requir give two exampl match succeed sml fail transpar interpret simpl exampl simpl exampl problemat match follow opaqu interpret match structur struct datatyp u u b int signatur sig datatyp v b int amount check type function u defin structur match expect signatur u u substitut v signatur no definit substitut u sinc abstract structur sub stitut type requir signatur function exactli type function given structur match succe transpar interpret howev structur defin u u imp int signatur specifi u int order match succeed two type must equival substitut u imp u imp v spec ific is requir observ type right none aexpandu imp notic also bound variabl appear free bodi type hereaft write type wildcard place type variabl indic use bodi equival hold isorecurs type match fail complex exampl anoth exampl datatyp match legal sml fail transpar interpret found reconsid run exampl exp dec opaqu interpret structur contain pair datatyp match follow signatur hide fact exp datatyp sig type exp datatyp seqdec dec dec datatyp specif elabor transpar interpret howev result il signatur look like sig type exp dec spec a elabor declar exp dec hand produc structur figur signatur sig defin exp imp dec imp match structur contain datatyp signatur succeed dec spec dec imp under assumpt exp exp imp equival hold two type differ number compon problemat signatur constraint modul system sml provid two way express share type inform structur first type modifi signatur patch in definit type signatur origin held abstract second share type assert two type name possibl differ structur refer type form constraint restrict multipl inconsist definit given singl type name case share type exampl requir name flexibl is must either abstract defin equal anoth type abstract opaqu interpret datatyp abstract therefor flexibl mean share transpar inter pretat datatyp concret defin henc never share exampl follow signatur legal sml type datatyp type datatyp share type write equival signatur replac share type line type also valid sml neither signatur elabor success transpar interpret datatyp sinc interpret datatyp transpar therefor inelig either share type anoth exampl follow signatur signatur type val datatyp share type again construct analog exampl type sinc name bt flexibl opaqu interpret transpar code legal sml must reject transpar interpret relax recurs type equival describ way weaken type equival ie make equat type problemat datatyp match describ section succeed transpar interpret thi help problemat share constraint section idea section base upon equival algorithm adopt shao flintml compil begin consid simpl uv exampl section recal exampl match datatyp declar spec requir prove equival type righthand side expandu imp simpl variat exampl easi show gener transpar interpret permiss opaqu follow recurs type equival must hold refer boxedunrol rule say recurs type equal unrol box altern formul equival first one transit make two recurs type equal unrol equal ie intuit rule need datatyp match succe opaqu interpret whenev unrol form datatyp implement equal unrol form datatyp spec becaus suppos describ domain function although boxedunrol equival necessari transpar interpret datatyp admit match admit opaqu one suffici see thi consid problemat expdec match section problemat constraint exampl is dec spec dec imp dec substitut exp imp exp dec imp effect sinc variabl appear free expand definit type get constraint avar exp imp boxedunrol rule insuffici prove equival order appli boxedunrol prove two type equival must abl prove unrol equival word var exp imp var exp imp dec imp dec imp cannot prove without first prove dec spec dec imp exactli set prove first place boxedunrol rule therefor unhelp case troubl prove premis boxedunrol rule the equival expandd expandd may requir prove conclus the equival similar problem address context gener equirecurs type set decid type equival involv assum conclus equival rule prove premis appli idea provid natur solut problem discuss previou section maintain trail type equival assumpt decid equival two recurs type add equival trail compar unrol formal equival judgement becom ga t set assumpt form equival rule static semant must modifi account trail rule except recurs type trail simpli pass unchang conclus premis two new rule handl recurs type first rule allow assumpt trail use second rule enhanc form boxedunrol rule add conclus assumpt premis clear trail necessari order resolv expdec anomali describ abov compar unrol dec spec dec imp add assumpt dec spec dec imp trail use assumpt avoid cyclic depend encount befor fact trail version boxedunrol rule suffici ensur transpar interpret accept datatyp match accept sml see whi consid datatyp spec ific datatyp where may sum type may occur suppos implement match spec opaqu interpret implement type must recurs type furthermor type function given spec type implement match succe opaqu interpret know type equal substitut thu know expandd i specif elabor transpar interpr tation howev result signatur declar implement appropri project recurs bundl determin spec itself is transpar specifi t t order implement match transpar specif thu suffici prove follow theorem theorem i n g n g proof see appendix a given formal argument trail version boxedunrol rule flexibl enough allow datatyp match sml typecheck transpar interpreta tion precis maintain trail relat rest type equival fact work regard trail awar semin work amadio cardelli subtyp equirecurs type later coinduct axiomat brandt henglein conduct context simplytyp lcalculu trail boxedunrol rule view restrict correspond rule amadio cardelli trail algorithm applic type compar recurs type clear though trail affect complex type system contain type constructor higher kind gi rard f w addit higher kind mil middl intermedi languag tilt employ singleton kind model share proof mil typecheck decid rather delic involv implement trail algorithm tilt experiment purpos see section interact trail singleton wellunderstood remain conflict transpar interpret type share one might argu solut broaden sml semant share constraint permit share rigid compon problem kind share would necessari make exampl section typecheck transpar interpret would requir form type unif difficult determin draw line sml share semant full higherord unif undecid moreov unif would constitut signific chang sml semant disproportion origin problem effici implement datatyp coercion interpret datatyp section discuss treatment datatyp base coercion solut close resembl harperston interpret thu requir boxedunrol rule trail algorithm incur runtim cost function call constructor applic site either represent datatyp valu calculu discuss paper given usual structur oper semant express form roll v valu v valu from assum metavari v rang valu fact shown without difficulti close valu datatyp must form roll v v close valu type expandd thu roll oper play similar role inj oper sum type far highlevel languag semant concern although specifi behavior program languag formal oper semant intent program compil machin code execut forc us take slightli differ view data rather work directli highlevel languag valu compil program manipul represent valu compil free choos represent scheme use provid basic oper languag faith perform represent exam ple compil construct valu inj v attach tag valu v store new object somewher tag necessari order implement case construct particular represent valu type must carri enough inform determin whether creat inj inj recov represent inject valu requir represent valu recurs turn somewhat weaker sum elimin form recurs type unrol unlik case need extract inform argument origin roll valu fact requir represent v extract represent roll v thu one reason represent strategi repres roll v exactli v companion technic report give precis argument rea sonabl make use two key insight first invari tilt compil represent valu fit singl machin regist anyth larger bit alway store heap mean possibl complic size recurs valu avoid second defin represent valu type is defin set machin word repres valu v structur induct v rather defin set word repres valu type induct might expect tilt compil adopt strategi identifi represent roll v v pleasant consequ roll unrol oper noop instanc untyp machin code gener compil express roll e need differ code e alon sinc latter evalu v former evalu roll v type term e l afold l aunfold v te figur syntax coercion represent two valu same revers happen unrol thi turn import consequ datatyp sinc function produc hs elabor datatyp noth roll unrol argument code gener function ident function henc runtim cost incur use function construct datatyp valu overhead function call itself remaind section explain elimin cost allow type function reflect fact implement trivial coercion interpret mark function runtim noop use coer cion similar function except known noop therefor code need gener coercion applic incorpor coercion term level languag introduc special coercion type belong figur give chang syntax calculu note far confin discuss monomorph datatyp gener case polymorph datatyp requir polymorph coercion syntax give essenti use tilt compil address nonuniform datatyp extend type level languag type possibl polymorph coercion valu type coercion take length a type argument chang valu type one type where cours variabl appear either type empti similarli extend term level possibl polymorph coercion valu l afold l aunfold take place roll unrol express coercion appli type valu argument express form v te v coercion type argument e valu coerc note coercion syntact restrict valu make calculu amen simpl code gener strategi discuss section type rule coercion essenti ordinari polymorph function shown figur modif languag place elabor datatyp exp dec use coercion instead function implement oper result elabor pair datatyp shown figur note interfac exactli hs interfac shown section except function arrow replac coercion arrow interfac implement defin exp dec way hs interpret implement coercion appropri fold unfold valu elabor constructor applic superfici similar opaqu interpret coercion applic gener instead function call instanc letexpd elabor exp ininj de coercion erasur readi formal justifi claim coercion may implement erasur is sound compil consid coercion retyp oper ignor gener code first describ oper semant coercion construct ad intern languag next give translat calculu untyp one coercion applic disappear final state theorem guarante translat safe oper semant coercion construct shown figur extend class valu fold unfold coercion well applic fold coercion valu canon form coercion type recurs type respect two infer rule shown figur defin manner coercion applic evalu evalu coercion applic similar evalu normal function applic applicand alreadi valu rule left specifi argument reduc valu applicand fold applic valu applicand unfold argument must recurs type therefor by canon form consist fold appli valu v rule right defin unfold left invers fold henc evalu v alreadi discuss data represent strategi tilt code need gener comput foldv v comput result cancel fold unfold thu seem intuit gener code coercion applic v te compil simpli gener code e result datatyp constructor destructor coercion interpret runtim cost harper stone function would inlin make precis defin erasur map translat term type intern languag untyp languag coercion applic untyp natur target languag and machin languag import treat v foldv would destroy subject reduct properti type languag figur give syntax untyp target languag coercioneras translat target languag intend essenti type intern languag except type coercion applic remov contain untyp coercion valu fold unfold coercion applic form erasur translat turn express type annot express without labstract coercion valu shown figur remov coercion applic erasur v te erasur e particular valu v v foldv identifi translat consist intuit compil oper semant target languag analog sourc languag coercion import typesafeti properti term welltyp evalu get stuck import theorem coercioneras translat preserv safeti welltyp program theorem erasur preserv safeti g e t e safe is e f f stuck proof see companion technic report g type g type figur type rule coercion structur expdec sig type exp type dec val exp var val exp exp var val dec var exp val dec dec var exp struct val exp foldexp val exp unfoldexp val dec fold dec val dec unfold dec figur elabor exp dec coercion interpret valu v l afold l aunfold l afold sv figur oper semant coercion fold unfold l afold l aunfold unfold figur target languag syntax type coercion erasur test life leroy boyer simpl tyan msort pia lexgen figur perform comparison note valu restrict coercion crucial sound coercion erasur interpret sinc diverg express given arbitrari type includ coercion type semant coercion express evalu appli fail typesaf thu arbitrari express coercion type could appear applic posit compil would gener code them sinc valu cannot diverg effect free ignor coercion applic gener code perform evalu rel perform differ interpret datatyp discuss perform experi use three differ version tilt compil one implement nave harperston interpret construct nonlocallydefin datatyp requir function call one implement coercion interpret datatyp one implement transpar interpret compil ten differ benchmark use version compil run time result execut averag three trial shown figur test run ultrasparc enterpris server time report cpu time second measur clearli indic overhead due datatyp constructor function call nave hs interpret signific optim afford coercion transpar interpret provid compar speedup opaqu interpret order compar total run time given that two optim approach coercion interpret entir faith semant sml sinc theori coercion type simpler orthogon extens hs type theori trail algorithm section believ coercion interpret robust choic relat work trail algorithm weaken recurs type equival base one implement shao flint intermedi languag standard ml new jersey compil type rule section base formal semant flint given leagu shao although first give formal argument trail algorithm actual work import note smlnj implement transpar particular implement strategi describ end section ent interpret intern opaqu interpret employ elabor datatyp specif made transpar afterward exampl section illustr program typecheck accord sml transpar interpret even trail equival unclear smlnj after elabor case happen final exampl section valid sml reject smlnj compil curien ghelli crari defin languag use coercion replac subsumpt rule languag subtyp ing crari calculu coercion includ roll unrol recurs type sinc focu paper subtyp explor potenti use coercion detail nev ertheless notion coercion erasur proof safeti preserv theorem base crari implement type assembl languag x architectur talx allow operand annot coercion chang type represent coercion includ roll unrol well introduct sum elimin univers quantifi intermedi languag differ includ coercion term level languag rather treat special syntax simplifi present coercion interpret datatyp simplifi implement requir smaller increment chang earlier version tilt compil howev includ coercion term level bit unnatur plan extens tilt typepreserv backend like involv full coercion calculu conclus gener natur sml datatyp pose signific challeng effici typepreserv compil gener correctli understood interpret datatyp structur hold type compon abstract export function construct deconstruct datatyp valu interpret inlin datatyp construct deconstruct oper typepreserv henc cannot perform type compil tilt paper discuss two approach elimin function call overhead typepreserv way first away gener make type compon datatyp structur transpar result new languag differ neither less permiss than standard ml lost express regain relax rule type equival intermedi languag expens complic type theori fact transpar interpret forbid datatyp appear share type type signatur constraint unfortun possibl revis semant construct could remov restrict second approach replac construct deconstruct function datatyp coercion may eras code gener elimin function call overhead without chang static semant extern languag howev erasur coercion make sens set recursivetyp valu unrol repres run time coercion interpret datatyp implement tilt compil although present analysi sml datatyp context harperston tilt compil idea co ercion type one think gener use term serv retyp oper pervas type intermedi languag usual describ coercion elimin run code howev applic inform coercion cannot gener eras way distinguish coercion ordinari function type problem especi presenc true separ compil contribut provid simpl mechan permit coerciv term recogn applic safe elimin without requir signific syntact metatheoret overhead r subtyp recurs type coinduct axiomat recurs type equal subtyp type compil inclus subtyp coher sub sumption recurs subtyp reveal formal semant flint intermedi languag david mac queen realist type assembl languag implement tilt intern languag overview flintml compil decid type equival languag singleton kind type compil recurs datatyp tr subtyp recurs type coinduct axiomat recurs type equal subtyp decid type equival languag singleton kind type compil inclus subtyp recurs subtyp reveal ctr derek dreyer recurs type gener acm sigplan notic v n septemb vijay s menon neal glew brian r murphi andrew mccreight tatiana shpeisman alireza adltabatabai leaf petersen verifi ssa program represent aggress compil optim acm sigplan notic v n p januari dimitrio vytinioti geoffrey washburn stephani weirich open shut typecas proceed acm sigplan intern workshop type languag design implement p januari long beach california usa