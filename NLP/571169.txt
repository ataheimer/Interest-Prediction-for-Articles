t constraintbas mode analysi mercuri a recent logic program languag mercuri hal requir type mode determin declar predic inform allow gener effici target code detect mani error compiletim unfortun mode check languag difficult one main reason that predic mode declar compil requir decid part procedur bind variabl conjunct predic definit reorder enforc behaviour current mode check system limit possibl mode may use keep track alias inform limit abil infer mode sinc infer perform reorder paper develop mode infer system mercuri base map predic system boolean constraint describ variabl produc allow us handl program support exist system b introduct logic program languag tradit untyp unmod recent year languag mer permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ppdp octob pittsburgh pennsylvania usa curi shown strong type mode system provid mani advantag type mode determin declar mercuri program provid use document develop also enabl compil gener ecient code improv program robust facilit integr foreign languag inform gain declar also use mani program analys optimis mercuri mode system describ languag refer manual express allow programm describ complex pattern dataflow how ever implement mode analysi system current releas melbourn mercuri compil limit remov much express see particular current mode analys allow construct partial instanti data struc ture case allow fill in anoth limit mode infer prevent reorder order limit number possibl examin eect limit hard write mercuri program use anyth basic mode possibl write program certain type data flow well limit way describ abov current mode analysi algorithm also complic combin sever conceptu distinct stage mode analysi singl pass make modif algorithm eg includ miss function quit dif ficult algorithm also quit ineci analys code involv complex mode paper present new approach mode analysi mercuri program attempt solv problem current system separ mode check sever distinct stage use constraint base approach natur express constraint aris mode analysi believ approach make easier implement extens mode analysi system mercuri overcom limit current system associ program variabl set posi tion correspond node type graph key idea new mode system identifi posit type variabl posit produc ie goal bind part variabl function symbol associ node type graph goal program variabl occur boolean variabl indic whether node graph program variabl bound within goal given boolean variabl describ constraint aris correct mode term boolean constraint repres manipul descript use standard data structur reduc order binari decis diagram robdd allow constraint individu posit dierent data structur obtain much precis analysi current mercuri mode system start consider research mode infer check howev work base assumpt dier at least one two signific respect type reorder almost work mode analysi logic program focus untyp languag mainli prolog consequ paper use simpl analysi domain ground free unknown one use pattern code deriv detail programspecif domain eg analys must sacrific much precis achiev accept analysi time propos fix problem requir type inform use type variabl domain mode analysi sever paper sinc eg base similar idea like paper mode infer enc also assum program analyz is without reorder therefor use mode describ program execut wherea interest use mode prescrib program execut order insist compil must exact inform instanti state mode analysi system likewis work much simpler domain for exampl ground prolog recogn two instanti state relat work mode check concurr logic program languag logic program languag coroutin emphasi detect commun pattern possibl deadlock constraintbas mode analysi awar mode flat ghc mode flat ghc reli posit claus in head guard versu bodi determin unif allow bind variabl significantli simplifi problem constraint gener equa tional reli delay complex case three occurr variabl goal work constraintbas analysi mercuri particular work constraintbas bindingtim analysi notabl similar basic approach use constraint po sition type tree variabl express data flow depend howev bindingtim analysi dierent object mode analysi and fact analysi requir result mode analysi avail section give background inform rest paper depend on section briefli outlin current approach weak section give simplifi exampl constraintbas system present full system section section show result analysi use select execut order goal conjunct section give preliminari experiment result background mercuri pure declar logic program languag design construct larg reliabl ecient softwar system team programm mercuri syntax similar syntax prolog mercuri also strong modul type mode determin system catch larg fraction programm error enabl compil gener fast code rest section explain main featur mercuri relev paper program definit predic mercuri goal contain atom conjunct disjunct negat if thenels simplifi algorithm compil convert definit predic call superho mogen form form predic defin one claus variabl appear given atom in clude claus head distinct atom one follow three form paper assum unif neither side variabl appear outsid unif itself unif meet requir cannot influenc execut program thu delet simplic also assum negat replac ifthenels one replac g g fail true abstract syntax languag deal therefor written atom goal rule order describ variabl becom bound algorithm need abl uniqu identifi subgoal predic bodi code subgoal cannot serv identifi sinc piec code may appear predic definit therefor use goal path purpos goal path consist sequenc path compon use repres path zero compon denot entir procedur bodi goal path p conjunct goal path pcn denot nth conjunct goal path p disjunct goal path pdn denot nth disjunct goal path p ifthenels goal path pc denot condit pt denot then part pe denot elsepart definit parent goal path pcn pdn pc pt pe goal path p function parentp map goal path parent definit let g set variabl occur within goal g let g g set variabl nonloc goal g ie occur insid outsid g conveni also defin set goal s sinc goal path uniqu identifi goal sometim appli oper goal goal path determinist regular tree grammar order abl express dierent use mode program variabl must abl talk individu part term program variabl abl take valu finit manner use regular tree express tree grammar signatur set pair fn f function symbol n integ ariti f function symbol ariti call constant given signatur set tree the herbrand univers denot defin least set satisfi ft tn t tn simplic assum contain least one constant let v set symbol call variabl set term v denot v similarli defin least set satisfi ft tn t tn v tree grammar r signatur nontermin set nt finit sequenc product rule form x x nt form fx xn fn x xn nt tree grammar determinist regular x nt fn one rule form x fx xn breviti shall often write tree grammar compress form use x sequenc product rule x x type type mercuri polymorph hindleymiln type type express or type term languag type vtype type type constructor variabl vtype type paramet type constructor fn type must definit definit type definit fn form v vn distinct type paramet fm fkmk tree distinct tree con structorar pair type express involv paramet v vn clearli view type definit f simpli sequenc product rule signatur tree nontermin set type vtype order avoid type express depend infinit number type restrict type definit regular essenti regular ensur type t grammart defin below finit exampl type definit list simpl type abc includ constant a b c associ nonparamet type express product rule defin topmost symbol type let type express form ft tn let fn type definit form definit defin rulest product rule fv vn fv vn vtype defin rulest empti sequenc extend notat associ tree grammar type express let grammart sequenc product rule recurs defin oper concaten sequenc product rule remov second later occurr duplic product rule call nontermin set product rule po sition sinc use describ posit term posit root one term subterm also sometim call posit node sinc correspond node type tree exampl consid type listabc correspond grammar listabc abc two nontermin thu two posit grammar listabc abc mode infer check take place type check ing assum know type everi variabl appear program instanti mode instanti describ bind pattern variabl particular point execut program mode map one instanti anoth describ instanti variabl chang execut goal instanti also defin use tree grammar dierenc instanti associ predic involv instanti paramet no polymorph modesalthough possibl extens two base instanti free ground repres complet uniniti variabl complet bound term instanti express term inst vinst definit instanti definit g inst form inst gw wn boundg i w wn distinct instanti paramet gm gkmk tree distinct tree constructor instanti express inst free ground vinst associ set product rule rulesi instanti express type expr sion base instanti defin exampl exampl instanti definit inst list skeli bound i list skeli defin instanti list skeli variabl instanti must bound either empti list con cell whose first argument instanti given instanti variabl whose tail also instanti list skeli exampl list skelfre describ list element free instanti usual intend use specif type eg list skeli listt normal list function symbol variabl type bound to instanti so inst non empti skeli boundi list skeli repres kind subtyp variabl whose instanti non empti skelfre cannot bound definit mode f map initi instanti final instanti f common mode shorthand express eg ground ground goal chang instanti state posit free ground said produc bind posit goal requir initi instanti state posit ground said consum posit current mode analysi system mode analysi algorithm current use mercuri compil base abstract interpret abstract domain map program variabl instantia tion mode analysi compil creat separ procedur mode usag predic analys procedur separ start initi instanti state argument given mode declar analysi travers procedur bodi goal determin instanti state variabl point goal travers conjunct conjunct abl schedul need input variabl sucient bound delay tri later goal analys unschedul subgoal comput final instanti state argument match final instanti state mode declara tion procedur determin mode correct see detail although paper talk languag approach mercuri similar system also abl mode infer predic export defin modul use top travers modul howev prevent combinatori explos mode analysi algorithm reorder conjunct perform arriv call assum call predic suppos abl run given variabl bound left mode analysi system sever task onc must determin produc consum variabl reorder conjunct ensur consum variabl execut produc ensur subtyp constraint met lead complic implement one aim constraintbas approach simplifi analysi split task distinct phase done separ limit two main problem approach first keep track alias informa tion two consequ first without mayalia inform bound node cannot handl uniqu data structur nontrivi manner particular cannot implement compiletim garbag collect second without mustalia inform free node cannot accur mode analysi code manipul partial instanti data structur partial instanti data structur data structur contain free variabl use one want dierent part data structur fill dierent part program exampl consid follow small program pred lengthlistint int mode lengthfre list_skelfre in det lengthl n pred iotalistint int mode iotalist_skelfre ground in det goal lengthl iotal length construct skeleton list specifi length iota fill element list current system unabl verifi mode correct second disjunct iota one problem disjunct set alia variabl h first element l which initi free variabl instanti h unifi second argument without inform alias h first element l mode checker unabl determin also instanti first element l second problem absenc reorder mode infer prevent mani correct mode detect exampl consid mode infer predic pred appendlistt listt listt listt infer find mode appinininout find mode appoutoutoutin reorder restrict cannot simpli lift without it current mode infer algorithm explor arbitrarili larg number mode fact useless sinc look ahead see mode infer call predic use construct desir mode current predic simplifi exampl motiv constraint base mode analysi system avoid problem current system order do break mode analysi problem phase first phase determin subgoal produc variabl second use inform determin execut order procedur now focu first task return second section eas explan first show simplifi form approach simplifi form requir variabl instanti onc ie two instanti state recogn free ground requir variabl eventu reach ground state avoid complex aris dierent part variabl bound dierent time part left unbound address complex give full algorithm section constraint gener algorithm associ sever constraint variabl program variabl everi program variabl v associ famili constraint variabl form vp vp true i v produc goal path p predic bodi explain algorithm use append code shown transform compil superho mogen form describ section also ensur variabl appear one argument one functor ad extra unif necessari pred appendlisttlisttlistt appendat b ct examin bodi gener constraint it bodi disjunct constraint get simpli specifi variabl nonloc disjunct disjunct produc variabl disjunct must produc variabl disjunct produc variabl disjunct may produc variabl append express constraint a a process disjunct one anoth disjunct conjunct process conjunct algorithm consid variabl occur conjunct one potenti produc variabl nonloc conjunct may produc either insid outsid conjunct variabl share two conjunct may produc one conjunct algorithm gener constraint make sure variabl exactli one produc variabl local constraint say exactli one conjunct must produc variabl variabl non local constraint say one conjunct may produc variabl first disjunct variabl share among conjunct constraint get one say nonloc produc conjunct i produc conjunct appear first conjunct first disjunct yield nontrivi constraint intuit lack constraint goal reflect fact use produc test valu second conjunct first disjunct yield one con straint say goal use produc one b c second disjunct gener constraint analog first conjunct nonloc variabl disjunct unlik first contain share local variabl ah ch ct appear two conjunct constraint variabl state variabl must produc exactli one conjunct appear first conjunct second disjunct show handl unif form key understand behavior algorithm case know tri decid two altern either unif take input produc x take x input produc s contrari peopl experi real program unif form also use way make bind produc subset howev use unif way requir x input possibl produc outsid unif transform program su perhomogen form make sure unif form fresh variabl right hand side could produc would replac right hand side unif new variabl addit new unif is convert unif take x input unif take x input produc variabl right hand side variabl right hand side appear variabl must unbound use unif produc x would creat nonground term sinc simplifi approach consid nonground term case gener extra constraint requir x input goal case ah at ah appear elsewher get constraint first say either goal produc variabl right hand side produc none them conjunct first second constraint say goal cannot produc variabl left hand side variabl right hand side constraint get analog equat act equat first disjunct gener last conjunct call case recurs call assum call predic scc caller mode mean call produc ith argument i predic bodi produc ith argument lead one constraint argument posit conclud set constraint gener algorithm append infer check constraint gener predic use infer mode project onto head variabl constraint set built five dierent solut append five mode a b c appendin in in a b c appendin out in a b c appendout in in a b c appendout out in a b c appendin in out five mode two appendin in out appendout out in call princip mode three impli mode exist impli exist princip mode chang mode argument make job predic strictli easier rest pa per assum everi predic set mode downward close mean contain mode pm also contain mode impli pm prac tice compil gener code mode declar princip mode synthes mode caller renam variabl insert extra unif synthesi superhomogen form equival replac append append x solut also implicitli assign mode primit goal bodi specifi variabl produc exampl solut assign true constraint variabl c c c fals other correspond mode appendininout also show deconstruct ie use field defin ah at construct ie bind c new heap cell case valu constraint variabl head variabl uniqu determin valu constraint variabl sometim one set valu assign constraint variabl bodi consist given valu assign constraint variabl head case compil choos assign prefer full mode infer expand grammar consid problem handl program dierent part variabl may instanti assumpt somewhat restrict set allow wellmod program howev found unreason restrict practic come across case typic mercuri program one would want make recurs call dierent mode dierent goal need ensur two distinct posit variabl may dierent instanti be haviour way refer separ henc need expand type grammar associ variabl begin empti grammar origin code predic express superhomogen normal form modifi grammar predic bodi first stage mode analysi unif appear definit predic x grammar rule functor fn add rule alreadi occur grammar rule head claus replac occurr program add equat x grammar rule x fb bn replac equat process may add equat form one x occur nowher els equat safe remov process unif add copi rule rulest grammar variabl v type all exampl superhomogen form usual sourc code append some variant of aah at cah ct appendatbct second claus algorithm replac aah at cch ct yield form shown section expand comput append nontermin grammar constitut set posit creat constraint variabl gener constraint predic bodi use nontermin posit as well node interchang note nontermin denot toplevel functor everi variabl variabl eg nontermin denot nontoplevel functor well note also nontermin fulfil function one variabl strictli part anoth exampl nontermin ah stand variabl ah first element list bound variabl a variabl b c unifi comput path nontermin predic need three boolean variabl posit true posit produc outsid predic b v true posit produc insid predic c v true posit produc somewher either insid outsid predic note v v v definit let pn tupl h hn head variabl ie formal paramet predic pn definit expand grammar posit x defin immedi descend x set posit reachabl x gener constraint two variabl which alway type need abl refer posit within two variabl correspond other eg ah ch denot correspond posit insid c notion correspond use allow two variabl expand dierent extent expand grammar exampl descend nontermin append b even though type unif b nontermin b would correspond well a definit expand grammar posit x defin set pair correspond node x x wx wn conveni also defin pair ntupl i x definit given expand grammar rule say x parent node node yn mode infer constraint ensur variabl occur one pred icat renam necessari construct expand grammar p program modul com pile next group predic modul stronglyconnect compon scc process scc bottom up creat function cscc scc repres boolean constraint gener predic scc remaind section defin cscc constraint function cscc i s scc conjunct constraint function c pred i pn gener predic pn scc ie cscc i s constraint function infer predic pn constraint function scc ie c inf i pn s c inf i pn may stricter c pred i pn pn alon scc predic defin modul deriv c inf mode declar use mechan describ section c pred conjunct two function c struct structur constraint relat variabl goal constraint predic bodi goal c pred i ph hn defin c struct c goal below structur constraint v proposit v bound call v proposit v bound return v proposit v bound predic constraint relat relationship variabl relationship bounded dierent time node reachabl one predic argument variabl cannot bound call node bound return bound call produc within predic bodi node may bound call produc predic bodi node bound call parent node must also bound call similarli node bound return parent node must also bound return c struct i d v d v d v exampl append structur constraint are a a a ah ah ah ah ah at at at ae ae ae ae ae be be be ch ch ch ch ch ct ct ct ct ct ce ce ce ce ce ah ah ae ae b b ch c ch c ct c ct c ce ct ce ct goal constraint boolean variabl vp path p contain program variabl x v i x variabl repres proposit posit v produc goal refer path p constraint gener goal fall two categori gener constraint appli goal type gen constraint specif goal type c goal complet set constraint goal ccomp conjunct two set gener constraint two compon first node reachabl variabl local goal bound return i produc goal second c ext say node reachabl variabl v extern goal g ie occur g cannot produc g conjunct definit c ext could variabl predic occur g howev variabl v occur gs parent goal parent c goal constraint mention v point creat constraint variabl v g compound goal constraint gener kind compound goal conjunct disjunct ifthenels shown figur case goaltypespecif constraint conjoin complet set constraint subgoal conjunct goal posit produc one conjunct disjunct goal node either must produc disjunct produc disjunct ifthenels goal node produc ifthen els produc either condit branch els branch node may produc condit branch node reachabl variabl nonloc ifthenels must produc condit node reachabl nonloc variabl produc branch must also produc els branch vice versa atom goal due space consider leav discuss higherord term may handl simpl extens modecheck algorithm consid three kind atom goal unif form unif form call form qy yn unif form may produc one pair correspond node mercuri allow alias exist unbound node node reachabl variabl involv unif must produc somewher unif goal path p constraint c goal i exampl unif append goal path c constraint gener are goal schedul phase requir node must produc alias anoth node two restrict togeth disallow use partial instanti data structur futur mercuri implement handl consequ would like lift restrict unif form yn path p produc argument yn x must produc somewher either p somewher els constraint c goal i exampl unif append goal path c constraint gener are call qy yn constrain node reachabl argument call predic current scc allow recurs call mode caller constraint c goal i p qy yn vw qni y n vwp v w first part ensur call produc posit posit produc predic scc second part ensur call variabl w produc somewher requir bound call call v true v true cant mistakenli use call site produc w exampl recurs call appendatbct goal path c append constraint gener first argument are call predic lower scc constraint similar must existenti quantifi head variabl possibl call predic dierent mode dierent place within current scc c goal i p qy vw qni y n v wp v w mode declar constraint predic mode declar mode analysi system check declar infer mode inform involv gener set constraint mode declar ensur consist constraint gener predic bodi declar constraint c decl i d predic set mode declar disjunct constraint c decl i d mode declar d dd c decl i d constraint c decl i d mode declar pm mn predic ph hn conjunct constraint c arg i mh argument mode correspond head variabl h c struct i h hn structur constraint use determin h variabl h h constraint c arg i mh argument mode head variabl h conjunct constraint c goal i p g gn figur constraint conjunct disjunct ifthenels c init i i h initi instanti state i constraint c fin i f h final instanti state f constraint c init i i h initi instanti state head variabl h given below w h w constraint c fin i i h final instanti state head variabl h given below c fin i c fin i ground w h w c fin i mode check simpli determin declar mode least strong infer mode declar mode predic pn check whether implic hold not doesnt declar mode incorrect given declar mode predic pn use shortcircuit calcul scc sinc use c decl i d mode infer predic qm call pn exampl given mode definit mode lsg listskelfre ground mode declar give c decl i ignor v variabl ah ae b be c ch ct ce a ah at ae b be c ch ct ce show c decl i d c inf i append select procedur execut order gener constraint scc solv constraint constraint solu tion posit consum produc report mode error constraint solu tion solut give mode predic scc set solut thu defin set mode predic need find feasibl execut order mode predic scc algorithm find feasibl execut order take solut input given mode predic correspond sever solut sucient one feasibl order main problem find feasibl schedul mode analys code gener distinct view mean produc posit a variabl grammar gener append exampl nontermin ah repres valu variabl ah valu first element variabl a forward mode append ah true mode analys consid ah produc caller even execut enter append howev far code gener concern produc ah unif ahat cater diverg view separ notion variabl produc notion variabl visibl definit given expand grammar i assign boolean valu constraint variabl predic pn make constraint c inf i pn true model c inf i pn write c inf i pn definit given model c inf i pn defin set node produc goal path p produc i definit given model c inf i pn defin set node consum goal g goal path p formula shown figur unif form say node one side equat consum i correspond node side produc due symmetr natur relationship v v correspond w v consum i v consum v produc produc also possibl pair correspond node neither produc consum unif mean one two thing subterm x node alreadi bound unif test equal subterm still free creat alia them note unif produc either top level node x call assign unif unif form node x consum i produc node ever consum reason latter half rule grammar use nontermin eg first subterm x sinc unif mere creat alias correspond subterm x nontermin produc i p v w i x produc i p produc i p i y ynqn c inf i qn v w mvd produc i p produc i p produc i p figur calcul node consum posit cannot produc unif produc all produc elsewher note unif produc x call construct unif consum x call deconstruct unif call predic q know node actual paramet call model predic analyz say produc call need find model constraint q caus correspond node actual paramet q output sinc first stage analysi succeed know model exist consum node call node actual paramet correspond node formal paramet q requir input compound goal consum node union consum node subgoal minu node produc within compound goal exampl in in out mode append produc consum set conjunct are path produc consum c ct ce at aebb neither disjunct produc posit also con sume therefor order algorithm requir node produc consum would find order accept hand code gener fussi exampl emit code recurs call need know variabl ah store even bound yet need concept visibl definit variabl visibl goal path p variabl head variabl appear predic bodi somewher left p function make visibl need visibl defin figur respect determin whether goal make variabl visibl requir visibl exampl given in in out mode append make visibl need visibl set conjunct are path make visibl need visibl algorithm need find conjunct bodi order conjunct produc node come consum variabl made visibl point need visibl travers predic bodi top down conjunct construct direct graph whose node conjunct initi graph edg c c j i c produc node c j consum graph cyclic mode order fail isnt tri add edg keep graph acycl sort variabl need visibl anywher conjunct also made visibl conjunct two class clear conjunct make visibl isnt variabl fall first class i made visibl one conjunct conjunct make visibl also produc top level node in forward mode append variabl fall first class variabl made visibl one conjunct ch need visibl conjunct conjunct variabl add edg conjunct make variabl visibl conjunct c j need visibl graph still acycl start search space map map variabl second class conjunct make variabl visi ble look map result acycl graph add link select make visibl conjunct variabl correspond need visibl conjunct also happen conjunct need variabl visibl none goal conjunct make visibl variabl made visibl goal left whole conjunct anoth conjunct enclos one everyth fine isnt order enclos conjunct would alreadi fail conjunct make variabl visibl conjunct whole need visibl map yield acycl graph procedur mode error map do algorithm gener two choic make pick acycl graph pick order conjunct consist graph make visiblem i p g make visibl i pc gc make visibl i pt g make visibl i pe ge need visiblem need visiblem need visiblem pccte need visibl i ppc gpc make visibl i p g figur calcul make visibl need visibl node forward mode append consum input predic order constraint produc consum first disjunct visibl constraint either given or der second disjunct visibl requir dictat must occur appendat b ct make ah visibl re quir leav compil appendat b ct graph complet fix order con junct parallel implement may choos execut sever conjunct parallel although case would worth while like implement may choos schedul recurs call last ensur tail re cursion with old mode analys need program transform separ mode analysi introduc tail recurs predic like thi experiment evalu analysi implement within melbourn mercuri compil repres boolean constraint reduc order binari decis diagram robdd use highlyoptimis implement schacht shown robdd provid ecient represent logic program analys base boolean domain robdd direct acycl graph common subexpress merg provid ecient canon represent boolean function worst case size robdd exponenti number variabl practic howev bit care worstcas behaviour usual avoid use number techniqu keep robdd small ecient possibl present preliminari result show feasibl analysi time taken test run gateway select pc mhz amd athlon cpu kb l cach mb memori run linux kernel tabl compar time mode check simpl benchmark column label simpl time simpl constraintbas system ground variabl present section column label full full tabl mode check ground simpl full old simpleold fullold cqueen crypt deriv poli prime qsort queen queri tak constraintbas system present section column label old time mode check current mercuri mode checker final two column show ratio new old system time millisecond averag run constraintbas analys significantli slower current system partli obtain much inform program thu lot work exampl current system select fix sequenti order conjunct mode analysi order disallow partial instanti data structur wherea constraintbas approach allow possibl order consid build constraint appropri schedul select base execut model con sider exampl argument pass convent eg possibl introduc tail call whether execut sequenti parallel profil show much execut time spent build manipul robdd may worth investig dierent constraint solver propagationbas solver anoth possibl method improv overal analysi time would run old mode analysi first use new analysi predic old analysi fail interest observ dierenc simpl constraint system full system none benchmark requir partial instanti data structur abl analys simpl system case simpl system dierent full system othersparticularli bigger tabl mode check partial instanti check infer infercheck iota append copytre benchmarksit significantli faster specul bigger benchmark benefit reduc number constraint variabl simpl analysi tabl show time program make use partial instanti mode current mercuri system and simpl constraintbas system unabl analys time millisecond averag run iota benchmark program exampl append benchmark classic append howev check version valid combin in lsg mode declar copytre benchmark small program make structur copi binari tree skeleton element copi new free variabl time check column check program mode declar wherea infer column show time mode infer mode declar remov interest note save analysi time achiev ad mode declar particularli notabl copytre benchmark mode infer abl infer mani mode one declar we similarli declar in in out mode append reduc analysi time ms conclus defin constraint base approach mode analysi mercuri ecient current system mode check abl check infer complex mode current system decoupl reorder conjunct determin produc although describ implement handl mercuri construct higherord constraintbas mode analysi yet handl subtyp uniqu mode plan extend handl featur well explor advanc mode sy tem complic uniqu mode uniqu object store recov data structur polymorph mode boolean variabl repres pattern mode usag circular mode need clientserv program client server process model recurs loop cooper instanti dierent part data structur coroutin manner would like thank australian research council support r direct type annot method experiment evalu gener abstract interpret algorithm prolog diagnos nonwellmod concurr logic program abstract interpret concurr logic languag static infer mode data depend logic program layer mode type synthesi ground prolog deriv descript possibl valu program variabl mean abstract interpret automat deriv mode declar prolog program practic abstract equat system polymorph type system prolog type static analysi applic ground analysi prolog lambdaprolog make mercuri program tail recurs mode analysi domain type logic program system precis mode logic program execut algorithm mercuri tr polymorph type system prolog graphbas algorithm boolean function manipul static infer mode data depend logic program abstract interpret concurr logic languag deriv descript possibl valu program variabl mean abstract interpret experiment evalu gener abstract interpret algorithm prolog type static analysi mode analysi domain type logic program make mercuri program tail recurs model check hal ctr lee naish approxim success set logic program use constrain regular type proceed twentysixth australasian confer comput scienc research practic inform technolog p februari adelaid australia