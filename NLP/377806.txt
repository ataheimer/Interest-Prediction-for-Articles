t data local enhanc memori reduct a paper propos memori reduct new approach data local enhanc approach use compil reduc size data repeatedli referenc collect nest loop reus data like remain higherspe memori devic cach specif present optim algorithm combin loop shift loop fusion array contract reduc temporari array storag requir execut collect loop appli benchmark program techniqu reduc memori requir count data code averag transform program gain speedup averag due reduc footprint and consequ improv data local b introduct compil techniqu tile improv tempor data local interchang nest order time iter loop arraysweep loop unfortun data depend mani program often prevent loop interchang therefor import seek local enhanc techniqu beyond tile paper propos memori reduct new approach data local enhanc approach use compil reduc size data repeatedli referenc collect nest loop end end end ei end a b ei ei end end ei end c d figur exampl reus data like remain higherspe memori devic cach even without loop inter chang specic present optim algorithm combin loop shift loop fusion array contract contract number dimens array exam ple twodimension array may contract singl dimens whole array may contract scalar opportun memori reduct exist often natur way specifi comput task may memoryeci program written array languag f hpf often memori ineci consid extrem simpl exampl exampl figur a array assum dead loop l rightshift loop l one iter figur b l l fuse figur c array contract two scalar a figur d show as posit sideeect tempor local array e also improv aggress fusion propos also improv tempor data local dierent loop nest fraboulet et al present network ow algorithm memori reduct base retim theori given perfect nest retim techniqu shift number iter either left right statement loop bodi dierent statement may dierent shift factor three issu remain unresolv work algorithm assum perfectlynest loop appli one loop level onli loop realiti how ever mostli multipl level arbitrarili nest perfectlynest loop although one may appli algorithm one level time approach provabl minim memori requir program transform loop coalesc coalesc multipl loop level singl level unfortun howev algorithm applic result loop requir loop model longer satis sinc work target data local relationship memori minim local ityperform enhanc studi gener minim memori requir guarante better local better perform care must taken control scope loop fusion lest increas loop bodi may increas regist spill cach replac even though footprint whole loop nest may reduc experiment data show memori requir actual reduc use algorithm moreov sinc algorithm address memori minim onli experiment data verifi conjectur reduc memori requir result better local better perform especi scope loop fusion care control paper make follow main contribut present network ow algorithm provabl minim memori requir multidimension case handl imperfectli nest loop contain collect perfect nest combin loop shift loop fusion array contract complet reformul network ow exactli model problem multidimension gener case work could also appli program model loop fusion appli rst possibl enabl loop shift howev new algorithm prefer multidimension case algorithm optim polynomialtim solvabl complex heurist algorithm model imperfectlynest loop directli gener case propos heurist control fusion estim number regist spill cach miss greater one origin loop nest even though benchmark case test far small util heurist import bigger case mani realist program may immedi program model even though alreadi gener use number compil algorithm transform program order model implement memori reduct techniqu research compil appli techniqu benchmark program experi result show memori requir reduc substanti also reduct inde lead better cach local faster execut test case averag memori requir benchmark reduc count code data use arithmet mean transform program averag speedup use geometr mean origin program rest paper present preliminari section formul network ow problem prove complex section present control fusion discuss enabl techniqu section section provid experiment result relat work discuss section conclus given section preliminari section introduc basic concept present basic idea algorithm present program model section introduc concept loop depend graph section make three assumpt algorithm section section illustr basic idea algorithm section introduc concept refer window base algorithm develop lastli section show origin loop depend graph simpli preserv correct algorithm program model consid collect loop nest l l lexic order shown figur a label l denot perfect nest loop indic l i start outmost loop in exampl ie figur a loop l ij lower bound l ij upper bound respect l ij u ij loop invari simplic present loop nest l m assum nest level n not appli techniqu dierent loop level increment case strictli satisfi requir transform model use techniqu code sink array region referenc given collect loop divid three class input array region upwardli expos begin l output array region live lm local array region intersect input output array region util exist depend analysi region analysi live analysi techniqu comput input output local array region ecient note input output region overlap other exampl figur a e n input array c d a b e figur origin transform loop nest region output array region a n local array region figur a show complex exampl exampl resembl one wellknown livermor loop exampl declar array dimens jn zz zakn zbjnkn input array region zp zr zq zz output array region zajnkn zbjnkn local array region figur b show code form loop shift loop fusion p j l repres shift factor loop l ij rest paper assum loop coalesc singlelevel loop loop shift loop fusion figur c show code form loop coalesc loop fusion l lower upper loop bound coalesc loop nest l figur d show code form loop fusion loop coalesc eas code gener gener case howev common case loop coalesc unnecessari figur e show code form loop fusion without loop coalesc appli array contract appli code shown either figur d figur e loop depend graph extend denit tradit depend distanc vector depend graph collect loop follow denit given collect loop nest l lm figur a data depend exist iter n loop l iter j loop l say distanc vector j denit given collect loop nest l l lm loop depend graph ldg direct graph e node v repres loop nest direct edg e repres data depend ow anti output depend l end end l end end l end end l end end a b c figur exampl origin simpli loop depend graph edg e annot distanc vector dve depend edg e distanc vector constant replac set edg follow let set depend distanc e repres let lexicograph minimum distanc s let f d dg vector u lexicograph greater n a subset s lexic neither smaller equal vector s replac origin edg e js annot figur b show loop depend graph exampl figur a without show array region exampl ow depend l l due array region figur b multipl depend type ow anti output exist one node anoth use one arc repres gure associ distanc vector mark singl arc assumpt make follow three assumpt order simplifi formul section assumpt loop trip count perfect nest l l j equal correspond loop level h n also state u ih l ih assumpt satis appli techniqu loop peel loop partit dierenc iter count small loop peel quit eectiv otherwis one partit iter space certain loop equal piec throughout paper use h denot loop trip count loop l level h constant symbol icli constant wrt program segment consid erat denot equal number accumul leveln loop iter execut one levelh loop iter let paper also denot number static write refer due local array region loop l arbitrarili assign static write refer l number k order distinguish them take loop figur b exampl assumpt sum absolut valu depend distanc loop level h loop depend graph e less onefourth trip count loop level h assumpt also state jej dvek j ek e annot depend distanc vector assumpt reason becaus program constant depend distanc gener small nonconst depend distanc exist techniqu discuss section loop interchang circular loop skew may util reduc depend distanc rest paper term a static write ref erenc mean a static write refer due local array region a b figur illustr memori minim assumpt static write refer r instanc r write distinct memori locat ifstat within loop guard statement contain refer r dierent static refer write dierent memori locat static write refer write distinct memori locat loop iter appli scalar array expans refer later on techniqu minim total size local array region case statement assum branch taken discuss case region written two dierent static write refer overlap other basic idea loop shift appli loop fusion order honor depend associ integ vector pl loop nest l loop depend graph denot shift factor l j loop level k figur b depend edg distanc vector dv new distanc vector pl dv pl memori minim problem therefor reduc problem determin shift factor p j l loop l ij total temporari array storag requir minim loop coalesc legal fuse dv pl distanc vector dv loop shift paper v denot inner product v v loop coalesc distanc vector v becom v call coalesc depend distanc order make loop fusion legal must hold legal transform stand key memori minim count number simultan live local array element transform loop shift loop coalesc loop fusion exampl figur a show part iter space three loop nest loop coalesc loop fusion rectangl bound iter space loop nest point gure repres one iter two arrow repres two ow depend due static write refer say r is r sourc loop fusion iter space dierent loop nest map common iter space figur b show three separ iter space map common one base assumpt v also repres number simultan live variabl due v common iter space figur b number simultan live variabl howev could overlap simultan live local array element due dierent depend figur b simultan live array element depend overlap other case number simultan live local array element due static write refer r greater two due depend ie case given collect loop fusion total number simultan live local array element equal sum number simultan live local array element due static write refer refer window gannon et al use refer window quantifi minimum cach footprint requir depend loopinvari distanc shall use concept quantifi minimum temporari storag satisfi ow depend denit from refer window w x depend variabl x time t dene set element x referenc also referenc accord depend t figur a refer window due ow depend from l l due array a begin loop l iter f ai ai g refer window size rang n figur c refer window due ow depend caus array a begin loop iter f ai g refer window size next extend denit set ow depend follow denit given ow depend edg e e es suppos refer window time w w respect dene refer window f es g time sinc refer window character minimum memori requir carri comput problem minim memori requir given collect loop nest equival problem choos loop shift factor loop legal coalesc fuse that fusion refer window size ow depend due local array region minim given collect loop nest legal fuse need predict refer window loop coalesc fusion denit loop node l in ldg write local array region r suppos iter j becom iter j loop coalesc fusion dene predict refer window l iter j refer window ow depend due r begin iter j coalesc fuse loop suppos predict refer window iter jn largest size due r dene predict refer window size entir loop l due r dene predict refer window due static write refer r l predict refer window l due array region written r conveni l write nonloc region onli dene predict refer window empti base denit follow lemma lemma predict refer window size kth static write refer r l must smaller predict refer window size ow depend due r proof predict refer window size ow depend smaller minimum requir memori size carri comput depend predict refer window size kth static write refer r l smaller memori size carri comput ow depend due r theorem minim memori requir equival minim predict refer window size ow depend due local array region proof denit lemma given depend distanc vector dv depend distanc loop coalesc loop fusion also call coalesc depend distanc due assumpt dv also repres predict refer window size coalesc iter space origin iter space lemma loop fusion legal coalesc depend distanc nonneg proof preserv origin depend take loop node l figur c exampl predict refer window size l due static write refer zbj k predict refer window size l sinc zbj k write refer l ldg simplif loop depend graph simpli keep depend edg necessari memori reduct simplic process base follow three claim claim depend l automat preserv loop shift loop coalesc loop fusion reorder comput within loop l among depend edg l l j suppos edg e lexicograph minimum depend distanc vector loop shift coalesc depend distanc associ e nonneg legal fuse loop l l j loop shift coalesc depend distanc depend edg remain equal greater edg e thu remain nonnega tive word fusionprev depend ex ist prove claim section lemma amount memori need carri comput determin lexicograph maximum owdepend distanc vector due local array region accord lemma simplic also classifi edg two class ledg medg ledg use determin legal loop fusion medg determin minimum memori requir medg ow depend edg ledg could ow anti output depend edg possibl edg classi ledg medg simplic process follow combin node l static refer r l among depend edg l due r keep one whose ow depend distanc vector lexicograph maximum edg medg node l remov depend edg l itself node l among depend edg l l j j i keep one depend edg legal depend distanc vector lexicograph minimum edg ledg static write refer r l among depend edg l l j j i due r keep one ow depend edg whose distanc vector lexicograph maximum edg medg node l among depend edg l l j j i keep depend edg whose depend distanc vector lexicograph minimum edg ledg process simpli program formul make graph travers faster figur c show loop depend graph simplic figur b figur c mark class depend edg exampl depend edg l l mark ledg one mark medg latter edg associ static write refer zaj k object function section rst formul graphbas system minim number simultan live local array el ement reduc problem network ow problem solvabl polynomi time formul problem given loop depend graph g object function minim number simultan live local array element loop nest formul follow edg g subject call system dene problem ik repres number simultan live array element due kth static write refer l constraint say coalesc depend distanc must nonneg ledg loop coalesc loop fusion constraint say number simultan live local array element due kth static write refer l must smaller number simultan live local array element everi medg origin l due kth static write refer l combin constraint assumpt follow lemma say coalesc depend distanc also nonneg medg lemma constraint hold pl hold medg e g proof dve hold otherwis assum rst nonzero compon dve hth compon base assumpt medg e must exist ledg e constraint guarante hold pl dve denit ledg medg similar proof case abov prove hold proof lemma also see depend elimin simplic process section coalesc depend distanc also nonneg given constraint hold henc coalesc depend distanc origin depend befor simplic section nonnega tive loop shift coalesc loop fusion loop fusion legal accord lemma section know ow depend edg e l l j due static write refer r elimin simplic process must exist medg e l l j due r proof hold henc constraint comput predict refer window size ow depend origin l due kth static write refer unsimpli loop depend graph see section accord lemma constraint correctli comput predict refer window size ik transform problem dene new problem problem ad follow two constraint problem e edg g lemma given optim solut problem construct optim solut problem valu object function proof search space problem subset problem given ldg g optim object function valu problem must equal greater problem given optim solut problem nd shift factor p ik valu problem follow initi let p ik valu problem solut problem follow step adjust valu constraint problem satis valu object function chang p valu satisfi constraint go step otherwis go step step nd p valu satisfi constraint follow topolog order node g nd rst node l exist ledg constraint satis here ignor self cycl sinc must repres medg g suppos sth rst nonzero compon let two nonzero compon sth s pl new p valu includ pl j satisfi constraint valu object function also chang pl lexicograph nega tive repeat process process termin within n time sinc otherwis constraint would hold optim solut problem note node l select base topolog order shift factor pl j increas compar origin valu ledg destin node l j constraint hold updat pl j still hold updat properti guarante process termin go step step nd ik valu satisfi constraint given nd valu satis constraint constraint becom equal least one edg achiev satis constraint done otherwis increas nth compon ik valu constraint hold becom equal least one edg find valu valu object function chang p ik valu valu object function problem problem henc get optim solut problem valu object function theorem optim solut problem also optim solut problem proof given optim solut problem take p ik valu solut problem p ik valu satisfi constraint valu object function problem problem solut must optim problem otherwis construct problem anoth solut problem lower valu object function accord lemma contradict optim origin solut problem expand vector problem integ program problem result gener solut ip problem howev take ldg graphic characterist account instead solv ip problem figur transform graph g figur c transform network ow problem discuss next subsect transform problem given loop depend graph g gener anoth graph node l creat correspond node g node l outgo medg let weight l w static refer rk k l creat anoth node g call sink due rk let weight w node l g outgo medg let weight medg g due static write refer rk suppos distanc vector dv add edg g distanc vector dv ledg suppos distanc vector dv add edg g distanc vector dv origin graph figur c figur show transform graph assign vector q node g follow node node new system call problem dene follow edg g annot dk subject dk e theorem problem equival problem proof henc object function equival edg e g inequ equival e ledg g l l j inequ equival henc inequ equival edg e g inequ equival e medg g l l j due kth static write refer l inequ equival henc inequ equival similarli easi show constraint equival constraint note one edg g could ledg m edg correspond two edg g assumpt follow inequ hold transform graph dvek j ek e annot depend distanc vector problem problem solv linear vector represent origin problem becom integ program problem gener form npcomplet next subsect howev show achiev optim solut polynomi time problem util network ow properti optim condit develop optim condit solv problem util network ow properti network ow consist set vector vector fe correspond edg e e and node v v sum ow valu inedg equal wv plu sum ow valu outedg is ek v repres inedg v repres outedg v lemma given exist least one legal network ow proof find span tree g assign ow valu edg henc nd legal network ow ow assign also legal g assign ow valu edg revers topolog order sinc total weight node equal legal network ow exist base equat given legal network ow node v v network ow algorithm abstract factor wv wv repres c onli abstract give ow valu ck integ constant suppos fek edg ek e equival ck constraint henc therefor equat fek collect optim condit state follow theorem hold inequ becom equal optim achiev problem theorem follow three condit hold constraint satis legal network ow fek exist ck jv j dk hold ie inequ becom equal problem achiev optim solut dk proof obviou discuss solv problem here let us consid vector wv dk singl comput unit base dualiti theori problem exclud constraint equival subject constraint mandatori equival problem dual problem follow develop optim condit section constraint dual system precis dene ow properti edg e associ ow vector fe dene problem system similar wv vector fek repres ck although appar search space problem enclos problem problem correct solut within search space dene problem base properti dualiti problem achiev optim solut constraint hold object function valu equal dk hold prove constraint hold optim solut problem solut must also optim problem accord theorem exist plenti algorithm solv problem although algorithm target scalar system the vector length equal directli adapt system vector summat subtract comparison oper network simplex algorithm directli util solv sy tem algorithm complex howev exponenti worst case term number node edg g sever graphbas algorithm hand polynomialtim complex exampl includ success shortest path algorithm complex scale algorithm complex ojv jje jlogjv j on current fastest polynomialtim algorithm solv network ow problem enhanc capac scale algorithm complex logjv j algorithm follow lemma lemma optim solut q problem exist span tree g edg proof true due foundat simplex method let span tree lemma x q determin uniqu uniquelydetermin ds e dk inequ ds j inequ base inequ annot lemma annot dk subject constraint proof hold otherwis assum rst nonzero compon hth dk then q q h constraint henc inequ guarante constraint hold optim problem achiev optim solut problem also optim solut problem success shortest path algorithm brie present one network ow algorithm success shortest path algorithm use solv problem algorithm depict figur let fek scalar rst iter algorithm alway output procedur initi set select node vk e v l d determin shortest path distanc j node vk node g respect residu cost c edg annot ij g let p denot shortest path vk v l updat ow valu residu network ow graph augment unit ow along path p residu graph figur success shortest path algorithm maintain feasibl shift factor nonneg ow valu satisfi constraint adjust ow valu constraint hold edg g algorithm end complet descript algorithm includ concept reduc cost residu network ow graph semant set e d etc pleas refer exampl in figur appli success shortest path algorithm pl pl figur show transform code exampl memori reduct refin control fusion although array contract loop fusion decreas overal memori requir loop fusion mani loop level potenti increas work set size loop bodi henc potenti increas regist spill cach miss particularli true larg number loop consider control number fuse loop comput shift factor minim memori requir use simpl greedi heurist pick reject see figur increment select loop nest actual fuse new addit caus estim cach miss regist spill wors fusion loop nest consider fuse heurist continu select fusion candid remain loop nest loop nest examin order loop whose fusion save memori consid rst estim regist spill use approach estim cach miss use approach may also import avoid perform loop fusion mani loop level correspond loop shift becaus loop shift loop fusion mani loop level potenti increas number oper either due ifstat ad loop bodi due eect loop peel coalesc appli may also introduc subscript comput overhead although cost tend less signic cost cach miss regist spill still care end end end end end end figur transform code figur a memori reduct control fusion innermost loop rate increas oper fusion exce certain threshold fuse outer loop enabl loop transform use sever wellknown loop transform enabl eectiv fusion long backward datadepend distanc make loop fusion ineect memori reduct long distanc sometim due incompat loop correct loop interchang long backward distanc may also due circular data depend correct circular loop skew fur thermor techniqu appli loop distribut node depend distanc vector origin l dierent other case distribut loop may allow dierent shift factor distribut loop potenti yield favor result experiment result implement memori reduct techniqu research compil panorama implement net work ow algorithm success shortest path algorithm loop depend graph experi rel simpl success shortest path algorithm take less second benchmark measur eectiv test memori reduct techniqu benchmark sun ultra ii uniprocessor workstat mip rk processor within sgi procedur pick reject input collect loop nest estim number regist spill np estim number cach miss nm origin loop nest output set loop nest fuse fs procedur initi fs empti let os initi contain loop nest os empti return fs otherwis select loop nest l os local array region r written l reduc most ie dierenc size r number simultan live array element due static write refer l lexic neither smaller equal loop nest os let tr set loop nest os contain refer r estim a number regist spill b number cach miss fuse loop fs tr perform array contract fuse loop a npb nm fs fstr os os tr otherwis os os fl g go step figur procedur pick reject origin multiprocessor present experiment result rk result ultra ii similar rk processor kb way setassoci data cach byte cach line mb way setassoci uni l cach byte cach line cach miss penalti machin cycl l data cach machin cycl l cach benchmark memori reduct tabl list benchmark use experi descript input paramet benchmark chosen either readili program model transform enabl algorithm t addit enabl algorithm develop futur hope collect test program tabl mn repres number loop loop sequenc m maximum loop nest level n note array size iter count chosen arbitrarili ll jacobi dierenti benchmark swim spec spec denot spec version swim spec version swim program swim almost ident swim except larger data size combust chang array size n n execut time last sever second program climat laplacejb laplaceg purdu set problem hpf benchmark suit rice univers except luca benchmark written f manual appli techniqu luca written f among benchmark program algorithm nd purdueset program luca combust need perform loop shift benchmark tabl loop fuse togeth swim swim hydrod outer loop fuse benchmark n loop level fuse benchmark examin three version code ie origin one one loop fusion array contract one array contrac tabl test program benchmark name descript input paramet mn livermor loop no jacobi jacobi kernel wo converg test tomcatv mesh gener program specfp refer input swim weather predict program specfp refer input swim weather predict program specfp refer input hydrod astrophys program specfp refer input luca promal test specfp refer input mg multigrid solver npbserial benchmark class w combust thermochem program umd chao group purdu purdu set problem refer input purdu purdu set problem refer input purdu purdu set problem refer input purdu purdu set problem refer input purdu purdu set problem refer input purdu purdu set problem refer input purdu purdu set problem refer input climat twolay shallow water climat model rice refer input laplacejb jacobi method laplac rice laplaceg gaussseidel method laplac rice combust purdu purdu purdu purdu purdu purdu purdu climat laplacejb laplaceg benchmark for benchmark left right origin transform code normal occupi memori size code data data size origin program unit kb swim hydrod luca mg combust purdu purdu climat laplacejb laplaceg figur memori size transfor mation tion among program combust purdu purdu program model case algorithm deriv result our so need list result version benchmark use nativ fortran compil produc machin code simpli use optim ag o follow adjust ment switch prefetch laplacejb softwar pipelin laplaceg loop unrol purdu swim swim nativ compil fail insert prefetch instruct innermost loop bodi memori reduct manual insert prefetch instruct three key innermost loop bodi follow exactli prefetch pattern use nativ compil origin code figur compar code size data size origin transform code comput data size base global data common block local data dene main program data size shown origin program normal actual data size vari greatli dierent benchmark list tabl associ gure mg climat memori requir dier littl program transform due small size contract local array benchmark techniqu reduc memori requir consider arithmet mean reduct rate count data code benchmark sever small purdu benchmark reduct rate almost perform figur compar normal execut time mid repres execut time code loop fusion array contract final repres execut time code array contract geometr mean speedup memori reduct benchmark best speedup achiev program purdu combust purdu purdu purdu purdu purdu purdu purdu climat laplacejb laplaceg normal execut time origin mid final figur perform transfor combust normal cach refmiss count dlhit dlmiss lmiss origin mid final left right figur cach statist tran format program contain two local array a p carri valu three adjac loop nest techniqu abl reduc array scalar fuse three loop one memori refer statist understand eect memori reduct perform examin cach behavior dier ent version test benchmark measur refer count dynam loadstor instruct miss count l data cach miss count l uni cach use perfex packag get cach statist figur compar statist total refer count origin code normal array contract scalar regist reus often increas figur show number total refer get decreas case total number refer count benchmark reduc howev case total refer count get increas instead examin assembl code found number reasonspurdu purdu purdu purdu purdu purdu purdu climat laplacejb laplaceg normal cach refmiss count dlhit dlmiss lmiss origin mid final left right figur cach statist transform cont fuse loop bodi contain scalar refer singl iter fusion increas regist pressur sometim caus regist spill nativ compil perform scalar replac refer noncontract array fuse loop bodi may prevent scalar replac two reason regist pressur high certain loop nativ compil may choos perform scalar replac loop fusion array data ow may becom complex may defeat nativ compil attempt perform scalar replac loop peel may deceas eectiv scalar replac sinc fewer loop iter benet it despit possibl increas memori refer count case due reason figur show cach miss gener reduc memori re duction total number cach miss bench mark reduc memori reduct total number l data cach miss reduc memori reduct improv cach perform seem often bigger impact execut time total refer count experi report memori reduct techniqu aect prefetch softwar pipelin regist alloc unrollandjam conclud techniqu seem creat diculti optim relat work work fraboulet et al closest memori reduct techniqu given perfectlynest loop use retim adjust iter space individu statement total buer size minim compar algorithm introduct section callahan et al present unrollandjam scalar replac techniqu replac array refer scalar variabl improv regist alloc howev consid innermost loop perfect loop nest consid loop fusion neither consid array partial contract gao sarkar present collect loop fusion perform loop fusion replac array scalar consid partial array contract perform loop shift therefor cannot fuse loop fusionprev depend sarkar gao perform loop permut loop revers enabl collect loop fusion enabl techniqu also use framework lam et al reduc memori usag highlyspeci multidimension integr problem array subscript loop index variabl program model allow fusionprev depend lewi et al propos appli loop fusion array contract directli array statement array languag f result achiev array statement transform variou loop loop fusion array contract appli consid loop shift formul strout et al consid minimum work set permit tile loop regular stencil depend method appli perfectlynest loop onli ding indic potenti combin loop fusion array contract exampl how ever appli loop shift provid formal algorithm evalu loop fusion studi extens name public kennedi mckinley prove maxim data local loop fusion nphard provid two polynomialtim heurist singhai mckinley present parameter loop fusion improv parallel cach local perform memori reduct loop shift recent dart analyz complex loop fusion claim problem maximum fusion parallel loop constant depend distanc npcomplet combin loop shift goal nd minimum number partit loop within partit fuse possibl enabl loop shift fuse loop remain parallel mainli dierent object function problem yield complet dierent complex manjikian abdelrahman present shiftandpeel shift loop order enabl fusion none work list address issu minim memori requir collect loop techniqu dierent our conclus paper propos enhanc data local via memori reduct techniqu combin loop shift loop fusion array contract reduc memori reduct problem network ow problem solv optim ojv j time experiment result far show techniqu reduc memori requir signicantli time speed program execut factor averag furthermor memori reduct seem creat diculti number backend compil optim also believ memori reduct vital import comput sever memoryconstrain applic extrem memorydemand acknowledg work sponsor part nation scienc foundat grant ccr aciitr mip indiana st centuri fund purdu research foundat donat sun microsi tem inc r network flow theori linear program network flow improv regist alloc subscript variabl interprocedur array region analys complix loop fusion improv estim enhanc cach e loop align memori access optim strategi cach local memori manag global program transform collect loop fusion array contract structur data ow analysi array use optim compil experi ecient array data ow analysi array privat maxim loop parallel improv data local via loop fusion distribut structur comput comput optim memori usag commun requir class loop implement multidimension integr retim synchron circuitri implement evalu fusion contract array languag fusion loop parallel local array data ow analysi use array privat applic benchmark set fortrand high perform fortran problem test parallel vector languag optim unrol nest loop optim array access collect loop transform theori linear integ program parameter loop fusion algorithm improv parallel cach local new tile techniqu improv cach tempor local perform enhanc memori reduct improv local parallel nest loop high perform compil parallel comput tr theori linear integ program strategi cach local memori manag global program transform linear program network flow nd ed structur dataflow analysi array use optim complier improv regist alloc subscript variabl optim array access collect loop transform network flow arraydata flow analysi use array privat improv local parallel nest loop interprocedur array region analys fusion loop parallel local experi effici array data flow analysi array privat implement evalu fusion contract array languag scheduleindepend storag map loop new tile techniqu improv cach tempor local optim unrol nest loop high perform compil parallel comput structur comput comput optim memori usag requir class loop implement multidimension integr estim enhanc cach effect collect loop fusion array contract maxim loop parallel improv data local via loop fusion distribut complex loop fusion loop align memori access optim improv effect bandwidth compil enhanc global dynam cach reus ctr g chen m kandemir m j irwin g memik compilerdirect select data protect soft error proceed confer asia south pacif design autom januari shanghai china yonghong song cheng wang zhiyuan li polynomialtim algorithm memori space reduct intern journal parallel program v n p februari david wonnacott achiev scalabl local time skew intern journal parallel program v n p june g chen m kandemir m karakoy constraint network base approach memori layout optim proceed confer design autom test europ p march apan qasem ken kennedi profit loop fusion tile use modeldriven empir search proceed th annual intern confer supercomput june juli cairn queensland australia alain dart guillaum huard new complex result array contract relat problem journal vlsi signal process system v n p may benni thrnberg qubo hu martin palkov mattia onil per gunnar kjeldsberg polyhedr space gener memori estim interfac memori model realtim video system journal system softwar v n p februari daniel cociorva gerald baumgartn chichung lam p sadayappan j ramanujam marcel nooijen david e bernholdt robert harrison spacetim tradeoff optim class electron structur calcul acm sigplan notic v n may geoff pike paul n hilfing better tile array contract compil scientif program proceed acmiee confer supercomput p novemb baltimor maryland yonghong song rong xu cheng wang zhiyuan li improv data local array contract ieee transact comput v n p septemb zhiyuan li yonghong song automat tile iter stencil loop acm transact program languag system topla v n p novemb chen ding ken kennedi improv effect bandwidth compil enhanc global cach reus journal parallel distribut comput v n p januari mahmut taylan kandemir improv wholeprogram local use intraprocedur interprocedur transform journal parallel distribut comput v n p may