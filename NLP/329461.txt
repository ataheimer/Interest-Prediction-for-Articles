t codemot prune techniqu global schedul a highlevel synthesi asic code gener asip presenc condit behavior descript repres obstacl exploit parallel exist method use greedi choic way search space limit appli heurist exampl might miss opportun optim across basic block boundari treat condit execut propos construct method allow gener code motion schedul code motion encod form unifi resourceconstrain optim problem approach mani altern solut construct explor search algorithm optim solut kept search space method cope issu like specul execut code duplic moreov tackl constraint impos advanc choic control pipelinedcontrol delay limit branch capabl underli time model support chain multicycl task code motion account may lead larger search space codemot prune techniqu present prune proven keep optim solut search space cost function term schedul length b introduct highlevel synthesi applicationspecif integr circuit asic code gener applicationspecif instruct set processor asip four main difficulti face schedul condit loop present behavior descript a npcomplet resourceconstrain schedul problem itself leav ineufsc brazil partial support cnpq brazil fellowship award n bthe limit parallel oper within basic block avail resourc poorli util c possibl state explos number control path may explod presenc condit dthe limit resourc share mutual exclus oper due late avail test result method appli differ heurist subproblem basicblock schedul code motion code size reduct independ heurist use decid order oper schedul like mani flavor prioriti list anoth decid whether particular code motion worth yet anoth reduct number state result approach might miss optim solut propos formul encod potenti solut interdepend subproblem formul abstract lineartim model allow us concentr order oper avail resourc differ prioriti encod use induc altern solut mani solut gener explor basic idea highqual solut search space code motion specul execut taken account sinc number explor solut control paramet search method approach allow tradeoff accuraci search time approach code motion principl unrestrict although constrain avail resourc code motion typic lead larger search space envisag techniqu reduc search time main contribut paper codemot prune techniqu techniqu first captur constraint impos downward code motion then constraint use criterion select effici code motion show experiment evid induc solut space higher densiti goodqual solut codemot prune appli consequ given local search method number explor solut applic techniqu typic lead superior local optimum convers smaller number solut explor reach given schedul length correl reduct search time paper organ follow section formul problem show represent survey exist method tackl problem describ section approach summar section support global schedul describ section section show constraint impos code motion captur explain codemot prune techniqu section list main featur approach experiment result summar section conclud paper section remark suggest research proof codemot prune present appendix i motiv condit present behavior descript introduc basic block bb structur instanc descript figur four bb depict shadow box figur repres input repres output x z local variabl oper label small letter bracket bb label capit letter i i els descript a b c k l figur basic block structur assum adder subtract compar avail could think schedul independ nevertheless straightforward approach would effici amount parallel insid bb limit exampl bb adder would remain idl two cycl even though oper q bb l could schedul step either k l exampl suggest exploit parallel across bb boundari allow oper move one bb anoth call code motion oper q allow move bb l bb i cycl save bb l note oper q alway execut regardless result condit c hand oper n condit execut depend result condit c say oper n control depend condit c howev oper data depend oper l could schedul time step code motion violat control depend execut evalu condit soon outcom c known result either commit discard techniqu call specul execut result condit turn true cycl save gener case may necessari insert extra code order clean outcom move oper socal compens code exampl howev compens code need variabl z overwritten oper n consid move oper q bb k execut parallel oper n howev oper q must alway execut oper bb k execut result c fals copi q place end bb j result say code duplic take place exampl duplic save cycl result c fals impact differ applic domain controldomin applic normal requir path optim much possibl role code motion obviou hand dsp applic unnecessari optim beyond given global time constraint although highli optim code might imper code motion overlook even dsp applic reduc schedul length longest path consequ tighter constraint are import code motion becom earli phase design flow optim object dictat realtim requir embed system design longest possibl execut time piec code must still meet realtim constraint fact motiv formul problem term schedul length see section moreov earli phase tend iter sever time runtim effici imper often need fast accur estim term schedul length reason motiv develop techniqu prevent prune ineffici code motion see section approach advantag take code motion account bestow expens much larger search space due codemot prune formul order defin optim problem repres specif data control depen denci solut problem form graph defin below definit control data flow graph e direct graph node repres oper edg repres depend them assum cdfg special node repres condit construct exampl shown figur b descript figur a circl repres oper triangl repres input output pentagon node associ controlflow decis branch node b distribut singl valu differ oper merg node m select singl valu among differ one branch merg node control condit whose result carri control edg dash edg figur b detail explan symbol semant found definit state machin graph direct graph node repres state edg repres state transit smg seen skeleton state transit diagram underli finit state machin whose formal definit found keep track code motion use auxiliari graph condens cdfg deriv use depthfirst search defin below definit basic block control flow graph direct graph node repres basic block edg repres flow control oper cdfg enclos pair branch merg node control condit condens form basic block bbcg branch merg node cdfg control condit condens singl branch merg node bbcg domain input output node condens singl input output node instanc bbcg depict figur c explicitli show bb structur descript figur a circl repres basic block bb associ set oper cdfg bbcg domain branch node b repres control select merg node m repres data select cdfg contain condit oper may execut differ condit execut condit oper or group oper repres boolean function call predic whose variabl call guard guard g k boolean variabl associ output condit c k descript figur a condit c associ guard g cons quenc oper n execut predic g g respect oper enclos bb execut condit path bbcg from input output defin sequenc bb valu guard data depend taken path determin execut time onli set oper enclos bb given path call execut instanc exi path bbcg correspond exactli one exi cdfg let us formul resourceconstrain problem address paper optim problem op given number k function unit acycl cdfg find smg depend cdfg obey resourc constraint satisfi function unit type function cost f l l l n minim l schedul length th path bbcg f monoton increas function solut op said complet valid schedul exist everi possibl execut instanc sinc condit resourc share affect time avail guard valu solut said causal guard valu use time avail feasibl solut satisfi constraint must causal complet previou highlevel synthesi approach pathbas schedul pb socal asfastasposs afap schedul found path independ provid fix order oper chosen advanc due fix order fact schedul cast cliqu cover problem interv graph code motion result specul execut allow origin method recent extend releas fix order reorder oper perform insid bb onli reorder allow across condit oper would destruct notion interv foundat whole pb techniqu consequ although reorder improv handl complex dataflow method cannot support specul execut limit exploit parallel complex control flow limit releas treebas schedul tb specul execut allow afap approach conserv keep path tree howev sinc notion interv lost list schedul use fill state oper condit vector list schedul cvl allow code duplic support form specul execut although shown underli mutual exclus represent limit approach would possibl remain valid extens origin condit vector altern represent suggest hierarch reduct approach hra present cdfg condit transform equival cdfgwithout condit schedul convent schedul algorithm code duplic allow specul execut support approach present codemot exploit first bb schedul use list schedul and sub sequent code motion allow one prioriti function use bb schedul anoth code motion code motion allow insid window contain bb keep runtim low iter improv need avoid restrict much kind code motion allow among method pb exact solv partial problem specul execut allow tb cvl address bb schedul code motion simultan use classic list schedul heurist differ heurist appli subproblem method may exclud optim solut search space exact symbol techniqu present never theless use exact method earli more iter phase design flow unlik especi prune present cope larger search space due code motion previou approach compil arena traceschedul ts main path trace chosen schedul first independ path anoth trace chosen schedul on first resourc unconstrain schedul produc heurist map avail resourc ts allow certain type code motion across main trace downsid ts maintracefirst heurist workwel applic whose profil show highli predict control flow eg numer applic percol schedul ps defin set semanticspreserv transform convert program parallel one primit transform induc local code motion ps iter neighborhood schedul algorithm atom transform code motion combin permit explor wider neighborhood heurist use decid code motion worth prioriti assign transform applic direct first import part code import aspect ps primit transform potenti abl expos avail instructionlevel parallel anoth system transform present base notion region controlequival bb oper move one region anoth applic seri primit transforma tion origin ps essenti resourc constrain parallel techniqu extend heurist map ideal schedul avail resourc drawback heurist map resourc perform ts ps greedi code motion undon sinc accommod within avail resourc effici global resourceconstrain parallel techniqu report whose key issu twophas schedul scheme first set oper avail schedul comput global heurist use select best one among them global resourceconstrain percol schedul grcp techniqu describ best oper select actual schedul take place sequenc ps primit transform allow oper migrat iter origin final posit global resourceconstrain select schedul gss techniqu present oppos grcp global code motion select oper perform onc instead appli sequenc local code motion result present give experiment evid that although ps gss achiev essenti result gss lead smaller parallel time contribut relat previou work one hand keep approach major achiev resourceconstrain schedul recent year follow a like global schedul method approach also adopt global comput avail oper howev implement differ sinc base cdfg unlik mention approach bwe perform global code motion onc way similar differ sequenc primit transform appli hand distinguish approach relat work follow a formul differ mention method respect order oper process allow proper explor altern solut use heuristicbas select instead select base prioriti encod determin extern and therefor tunabl search engin see section bunlik resourceconstrain approach provid support exploit downward code motion see section c main contribut new codemot prune techniqu take constraint impos code motion account prevent ineffici code motion see section envisag approach restrict impos beforehand neither kind code motion order oper select schedul section introduc construct approach free restrict outlin approach shown figur solut encod permut oper cdfg solut explor creat permut solut constructor build solut permut evalu cost explor base local search algorithm select solut lowest cost build solu tion constructor need check mani time condit resourc share test model boolean queri direct socal boolean oracl the term coin allow us abstract way queri implement detail view explor scope paper way permut gener accord criteria given local search algorithm found on focu solut constructor constructor cost explor boolean oracl figur outlin approach keep highqual solut search space design constructor follow properti hold first neither greedi choic made restrict impos code motion see section second prune use discard lowqual solut prevent gener solut certainli lead lower cost see section third everi permut gener complet causal solut see section although method ensur optim solut alway reach consequ localsearch formul least one optim solut kept search space proof claim found appendix gener method allow trade cpu time solut qualiti practic implement method succe find optim solut short cpu time test benchmark see section support code motion specul execut use predic model condit execut oper base time avail guard valu distinguish two kind predic predic g said static repres execut condit oper valu guard avail dynam predic repres execut condit oper one guard valu may avail given time step note static predic abstract rel posit time complet condit execut controldepend oper predic use keep track code motion use check condit resourc share g use check whether result specul execut oper commit not assum oper move bb bb j let g g j static predic bb j respect product g j give static predic oper figur instanc oper q duplic bb j k copi q bb j execut copi q bb k execut code motion may lead specul execut gmay repres actual execut condit becaus guard valu may time avail new predic must comput drop consider guard whose valu avail observ necessari prevent specul execut might lead noncaus solut figur instanc static predic oper move bb j bb i oper specul execut bb i actual execut condit given dynam predic insid new bb alway execut note dynam predic condit result produc static predic g condit result commit algorithm show obtain dynam predic predic g given time step endc k stand complet time condit c k assum time slot function support smooth repres concept boolean algebra definit found dynamicpredicateg step slot foreach algorithm evalu dynam predic condit resourc share construct solut need check two oper share resourc differ execut condit let j denot two oper oper share resourc given time step ident j hold boolean oracl use answer queri well comput predic schedul engin solut constructor take permut explor gener solut construc tor borrow techniqu construct topologicalpermut schedul schedul construct permut follow schedul select oper schedul one one instant first readi oper unschedul oper whose predecessor schedul permut select select oper schedul earliest time free resourc avail proven optimum schedul alway among creat principl topologicalpermut construct a c d e b f g t c c f f f e f schedul time step schedul evolut c f els e descript a c d figur use topolog permut schedul figur shown lineartim sequenc construct topolog permut schedul given behavior descript cdfg shown figur b util resourc model place oper entri resourc util vector ruv shown figur a entri ruv differ function unit first appli schedul without pay attent mutual exclus show principl see figur c second experi appli mutual exclus case oper b schedul second step share adder oper c see figur d assum outcom avail insid first step allow b condit share resourc result schedul length reduc step exi note howev could schedul two step thu inform mutual exclus clearli enough limit lineartim model allow effici solut mechan split lineartim sequenc expos flow control mechan base addit inform extract cdfg explain next section method prune ineffici code motion captur encod freedom code motion method want captur freedom code motion without restrict purpos introduc notion link link connect oper u cdfg bb v bbcg given follow interpret oper u execut predic defin execut oper bb v oper link sever mutual exclus bb may belong mani execut instanc figur illustr link concept els e descript a b figur link concept initi link encod freedom code motion use set initi link given oper initi link point latest bb given path oper still execut initi link obtain follow first look socal termin oper termin either direct predecessor output node direct predecessor branch merg node whose result must avail control select data select figur condit termin result condit must alway avail control select take place even though oper b direct predecessor branch node termin affect control select oper c termin result must avail prior data select oper e obvious termin then termin attach branch merg output node cdfg link bb preced correspond branch merg output node bbcg figur initi link shown termin c due data select due control select e due output afterward link non termin oper predecessor termin link bb latter link oper initi link not shown figur bb b bb c oper b singl initi link point bb c initi link interpret follow condit must execut latest bb a result must avail control select branch oper c must execut latest bb b oper latest bb c result must avail prior select merg note initi link encod freedom code motion downward mean oper free execut insid preced bb path soon data preced resourc constraint allow the control depend satisfi need execut oper latest insid bb point initi linkth underli idea travers bbcg topolog order tri schedul oper visit bb even oper origin belong it observ that oper u given initi link bb v v reach travers u must schedul insid bb v say assign oper u bb v compulsori equival oper u compulsori bb v notion compulsori assign oper allow us identifi control depend violat also notion one key prune techniqu shown next subsect final assign link call final oper assign from call simpli assign schedul respect oper insid point bb obey preced constraint impli need avail function unit assign might increas regist andor interconnect usag includ search space assign oper u bb v given follow attribut a begin start time oper u insid complet time oper u insid bb v c g static predic d dynam predi cate note assign repres relativetim encod absolut time controldepend given instant bb v start execut plu valu attribut begin handl redund oper may redund path behavior descript shown method redund elimin gener initi link oper b figur instanc link bb c even though origin describ bb a belong path tb use tree optim remov redund propag oper latest bb use cvl elimin use extend condit vector even though remov redund method care encod freedom code motion properli code motion determin heuristicbas prioriti function anyway exampl order cast controlflow graph tree structur tb duplic oper bb succeed merg node consequ priori duplic tb loos inform freedom code motion due data select inform could use construct solut avoid ineffici code duplic b c e f els e descript bbcg a b figur link uncondit oper freedom code motion initi link elimin redund also encod freedom code motion figur f may link bb a bb c bb b bb d initi link control depend satisfi f must execut output avail oper f execut bb preced bb soon resourc data depend constraint satisfi unrestrict code motion exploit codemot prune travers topolog order solut constructor follow flow token cdfgwhile bbcg travers topolog order oper assign travers bb soon data preced resourc constraint allow first readi oper permut attempt schedul insid visit bb notic that travers oper may readi given exi anoth figur d instanc oper g readi third time step fifth step exi e d f g reason say oper readi predic g given bb oper readi belong path contain bb given initi link u v assign oper bb visit compulsori long bb v reach bb v reach travers u schedul insid bb v initi link becom final assign howev oper u succe schedul insid ancestor w bb v induc code motion initi link revok replac final assign oper attempt schedul insid travers bb accord criteria below criterion codemot prune let oper initi link point bb j readi predic g visit bb ij schedul would requir alloc exactli delayo extra time step accommod execut oper schedul insid bb i prevent code motion bb j bb i criterion construct schedul visit bb predic g first oper readi predic g reject criterion schedul earliest time insid bb claim applic criteria discard better solut optim problem defin section see proof appendix i split lineartim sequenc note oper allow alloc extra time step accommod execut insid visit bb assign bb compulsori i j make space schedul noncompulsori oper idl resourc readi oper satisfi criterion constructor stop schedul bb anoth bb visit observ result global schedul lineartim sequenc instead sequenc split time travers cross branch flow control kept expos criterion respons split lineartim sequenc decid stop schedul bb prior control data select note decis base constraint resourc constraint control data depend counterexampl heurist criterion use tb lineartim sequenc split time condit turn oper higher prioriti readi queue exampl figur exampl use figur schedul illustr method first show figur b exi would schedul independ appli topolog permut schedul note exi e d f g schedul five step exi g schedul step yet possibl overlap sequenc b cannot share adder b outcom condit avail insid first step tent solut would noncaus and consequ infeas even though path afap schedul given conflict one sequenc chosen impos extra step show constructor gener feasibl solut figur c initi link depict figur k evolut construct process shown oper circl bold mark current bb travers notic figur that even though readi oper a e b preced schedul one oper reject criterion it compulsori current bb schedul figur e step idl adder exist point readi oper schedul bb would requir alloc extra step criterion then anoth bb taken figur f on figur k show final result obtain schedul exi independ figur b exi need extra step note b exchang solut figur b would obtain exi would need extra step conflict happen path method solv certain way induc exist anoth permut induc anoth solut conflict solv opposit way no limit search space observ assign oper b first step repres specul execut allow specul execut exi need extra step result schedul length a c d e b f g t b f b f c e f c e c e c f e c e c f b c d e f g c c c c c c c a f figur split lineartim sequenc notion order domin notion time step oppos approach method use time primari issu decid posit oper instead notion order avail resourc use assign incorpor relativetim encod time use manag resourc util insid bb c j unscheduledscheduledpr asap annot algorithm solut constructor solut constructor summar algorithm permut c set bb u oper v bb assign start time oper u insid bb v function return bb arbitrari topolog order candid assign creat pair uv condit unschedul scheduledpr evalu condit hold earliest step bb v free resourc found function issuit decid whether candid assign commit revok check criterion compulsori oper schedul room schedul other new bb taken function solvecodemot insert compens code duplic succe runtim complex let n number oper b number bb p number path c number condit readi oper kept heap data structur search first readi oper take olog n search may repeat oper bb worst case complex algorithm ob n log n runtim effici approach depend p which grow exponenti c oppos pathbas method wewil illustr applic codemot prune discard better solut goal provid outlin proof appendix i origin solut induc permut tri construct better solut n figur oper addit subtract multipl assum one resourc type grey entri util vector ruv mean either resourc occupi oper occupi due data depend these grey field use abstract oper concentr certain scope figur show differ solut gener constructor mean construct follow criterion exampl oper schedul insid bb must prevent schedul p note empti field mean oper could schedul idl resourc due data depend solut wewil construct new solut n shown figur b b allow boost bb pwhere alloc exactli step make room oper bb move up wewil consid two differ scenario code motion show allow boost bb p better result would reach term schedul length a b r r a a a a figur first scenario figur assum oper move bb r alloc step notic that even though preced permut could schedul time step either figur b possibl origin solut mean schedul engin must detect data depend them moreov could move step alloc bb p result number step freed number alloc step path shorten note figur even though optimist assum boost oper complet freed step move better solut could reach figur illustr case path p q r shorten possibl oper move first step bb p fill entri occupi oper figur b notic schedul time step a howev possibl indic empti field first step bb q figur a mean schedul detect data depend them data depend violat code motion solut n infeas a b r r a a a a figur exampl suggest given permut possibl obtain feasibl solut shorter path solut gener solut constructor feasibl solut could obtain best good construct one underli idea illustr that instead allow arbitrari code motion gener topologicalpermut schedul engin solut criterion obey construct lead notion codemot prune sinc applic criterion prune better solut appendix i topolog calpermut construct guarante least one permut return optim schedul length conclud codemot prune keep least one optim solut search space section summar main featur approach organ follow first two subsect show howw support constraint impos advanc choic control third subsect explain method gener complet causal solut last subsect describ type code motion support approach support pipelinedcontrol delay shown approach found literatur assum fix control architectur would produc infeas solut differ control architectur one constraint limit branch capabl control see next subsect anoth impos pipelin control pipelin regist use reduc critic path control data path delay time step condit execut time step guard valu allow influenc data path guard valu avail within time slot complet respect condit figur illustr effect pipelinedcontrol delay assum singl adder pipelinedcontrol delay cycl valu guard g avail execut earli enough shown figur c delay slot b c g a b figur effect pipelinedcontrol delay algorithm consid effect delay slot illustr applic figur b static dynam predic shown oper e condit share adder also oper grey specul execut respect condit c exampl emphas import specul execut fill time slot introduc pipelin latenc support limit branch capabl simpl control use eg sake retarget microcod state transit underli fsm limit branch capabl chosen control figur illustr problem figur show static predic oper exampl two differ schedul present figur b c compar white resourc grey resourc avail g l b c b b a figur effect limit branch capabl schedul figur b implicitli assum way branch capabl shown state machin graph delay execut condit c one cycl obtain schedul figur c requir way branch capabl n n repres duplic oper n observ oper n share white resourc oper l path taken instead path must delay one cycl make overal schedul length figur c longer figur b suggest exampl method handl limit branch capabl build solut control limit branch capabl valu k k n constructor allow n condit time step similar techniqu present gener complet causal solut subsect first show method deal causal complet illustr next method gener causal complet solut onli pathbas approach complet guarante find schedul everi path overlap singlerepres solut given oper controldepend condit causal guarante prevent oper execut prior c k howev lead limit model specul execut allow symbol method accommod overhead trace valid algorithm requir ensur complet causal schedul trace select coexist without conflict execut solut method complet guarante travers bb predic g associ bb investig make sure possibl execut condit cover without need enumer path causal guarante usag dynam predic check condit resourc share test perform and after construct solut time first readi oper attempt use alreadi occupi resourc illustr fact revisit exampl potenti solut gener symbol techniqu shown figur b cdfg a resourc type black grey white assum label duplic oper n solut complet exi schedul resourc preced constraint satisfi howev solut causal decid whether k n execut the valu g avail first step figur c d method use construct two solut two differ permut oper k figur c well oper n figur prevent schedul step check condit resourc share observ g k gm k m also g g c d l l g g l l figur causal construct approach perform trace valid procedur posteriori like test similar effect done increment construct solut describ below schedul one oper method evalu dynam predic updat condit resourc share inform new oper process new oper detect conflict trace previous schedul oper schedul new oper postpon later time step name earliest time step wherein conflict occur anymor dynam evalu predic combin construct natur schedul peroper basi advantag prevent construct noncaus solut like figur b avoid enumer backtrack infeas solut exploit gener code motion subsect summar relationship initi link final assign code motion detail analysi code motion found a b c d duplicationup boostingup unif use figur motion basic code motion figur illustr code motion scope singl condit f repres final assign initi link circl bold repres current bb travers figur a oper initi link bb d assign bb b via f motion requir code compens perform insert assign f result code duplic take place figur b oper move across branch node call boostingup may lead specul execut figur c oper initi link differ mutual exclus bb succe schedul bb a lead unif initi link final assign final figur d oper move bb execut condit call use code motion even though upward motion explicitli shown downward motion implicitli support method initi link encod maxim freedom code motion downward gener code motion figur show gener code motion support approach arrow indic possibl upward motion origin bb destin bb gray circl illustr local code motion handl method either correspond basic code motion figur combin them combin attempt via iter improv insid window contain bb black circl illustr global code motion also support method note compound motion determin permut result success applic basic code motion oppos ps search best code motion insid solut search best solut whose underli code motion induc best overal cost assign determin permut may induc code motion unrestrict type code motion possibl result search space limit restrict natur amount scope code motion figur gener code motion nevertheless fact gener code motion allow suffici guarante gener highqual solut constraint exploit order avoid gener inferior solut perform prune techniqu describ section whose impact shown experi report next subsect method implement neat system use bdd packag develop geert janssen boolean oracl current implement genet algorithm use explor tabl exampl waka a b c tabl method compar other exampl resourc constraint adopt chain shown top tabl result given shadow row term schedul length path solut case good tb hra case b method tb hra reach result better pb case c method tb better hra pb experi summar follow two tabl search perform sever randomli chosen seed use gener random popul explor cpu mean averag search time second use hp workstat tabl benchmark without control constraint a b a b tabl compar result heurist method tb cvl hra one exact method st top tabl show resourc constraint benchmark result shown shadow row result method assembl bottom result schedul length longest path shown averag schedul length assum equal branch probabili tie indic parenthesi note method reach best publish result better averag schedul length found benchmark parkerb notic exact method present guarante optim respect schedul length longest path function schedul length path first indic method highqual solut search space broader class cost function tabl show result benchmark pipelinedcontrol delay constraint approach reach schedul length obtain exact method describ use current localsearch algorithm explor guarante optim spite that optim solut reach case within competit cpu time although certainli need perform experi first result encourag seem confirm method abl find code motion induc better solut tabl benchmark pipelinedcontrol delay rotor a b c d e f g h latenc alu cycl alu mult cycl pipel multipli specul execut allow also perform experi evalu impact codemot prune search space order compar sampl search space without prune fifti permut gener randomli respect solut construct first comparison count number solut distinguish base overal cost valu figur show result black without prune gray height bar repres number solut count differ cost valu waka maha use cost use waka maha exampl waka differ solut identifi without prune prune reduct explain fact that prune appli permut map cost anoth word densiti solut cost increas codemot prune figur reduct number solut second comparison perform look maxim minim cost valu observ maxim cost valu closer minimum prune appli differ maxim minim cost valu call cost rang compact cost rang shown figur normal respect no prune case cost rang ratio prun ingno prune waka maha waka maha figur compact cost rang densiti solut cost increas figur and simultan maxim cost closer minimum figur conclud densiti highqual solut increas codemot prune fact suggest higher probabl reach near optim solut explor whichev choic localsearch algorithm might be final perform experi larger benchmark present previou tabl benchmark sr whose cdfg node borrow use differ set resourc constraint depict case a h first row tabl compar search space without prune permut gener randomli respect solut construct procedur repeat sever randomli chosen seed accur averag valu could evalu experi perform first without codemot prune enabl it sequenc permut use induc solut case figur compact cost rang benchmark sr first measur cost rang set resourc constraint summar figur normal respect no prune case note cost rang reduc least prune enabl second count number solut hit optimum latenc evalu averag percentag respect total number solut percentag repres averag densiti optim solut search space present shadow row tabl nopru pru stand no prune prune respect again result show code motion prune increas densiti highqual solut search space also show tighter resourc constraint are impact codemot prune result interpret follow resourc scarc case a b e f small fraction potenti parallel accommod within avail resourc and consequ code motion prune sinc would ineffici hand resourc abund like case c d g h potenti parallel accommod avail resourc need prune code motion contribut construct highqual solut tabl impact codemot prune densiti optima sr a b c d e f g h resourc latenc densiti nopru densiti pru cpu nopru cpu alu cycl alu mult cycl pipel multipli singleport lookup tabl sinc synthesi asic code gener asip want use resourc possibl like observ practic huge unbal potenti parallel exploit parallel constrain avail resourc fact justifi use codemot prune techniqu order compar impact differ densiti optima search time also measur averag time reach given optimum emul kind random search optim latenc shown tabl averag search time report entri cpu result show codemot prune lead substanti improv search time tight resourc constraint conclus futur work paper show schedul code motion treat unifi problem optim solut kept search space problem approach point view optim process construct solut independ explor altern shown permut use induc unrestrict code motion presenc optim solut search space guarante better control construct procedur shown prune techniqu eas optim process exploit constraint sinc control depend repres obstacl exploit parallel might induc violat often possibl howev conclud control depend also exploit combin resourc constraint data depend order detect prevent ineffici code motion way cast problem experiment result allow us conclud codemot prune increas densiti highqual solut search space even though paper focus problem relat earli phase design flow construct method accommod extens mani altern solut gener possibl extend constructor keep track issu like regist interconnect usag number state issu could captur cost function conveni especi late phase design flow optim take sever design issu account futur work intend cast loop pipelin construct approach loop could easili support method simpl extens model condit loop could broken schedul back edg could restor later state machin graph like howev extens would allow exploit parallel across differ iter loop reason prefer investig loop topic i proof prune techniqu theoremlet solut optim problem describ section assum construct algorithm given let oper assign bb j let delayo solut n obtain move bb j bb alloc exactli extra cycl step accommod execut proof let lk lk schedul length bb k motion respect let p q r bb form path respect schedul length path p n motion a assign q alloc step insid p lplp assign r move alloc step a oper u assign r move alloc step u depend resourc conflict oper assign q topolog permut construct assign r alloc step insid q c assign r alloc step insid p depend resourc conflict oper assign q topolog permut given solut n path length greater equal gener code motion seen compound code motion built basic code motion cost monoton increas conclud without loss gener cost n r function synthesi digit system tass area perform optim path base schedul controlflow versu dataflowbas schedul combin approach adapt schedul system effici orthonorm test synthesi passtransistor selector pathbas schedul synthesi embed system design synthesi optim digit circuit a global resourceconstrain parallel techniqu a data flow exchang standard trace schedul techniqu global microcod compact region schedul anapproach detect redistribut parallel neat object orient high level synthesi interfac applic genet algorithm highlevel synthesi a pathbas techniqu estim hardwar runtim hwswcosynthesi a treebas schedul algorithm control domin circuit a unifi schedul model highlevel synthesi code gener global schedul highlevel synthesi code gener embed processor a schedul algorithm condit resourc share hierarch reduct approach limit control flow parallel time constrain code compact dsp an effici resourceconstrain global schedul techniqu superscalar vliw processor make compactionbas parallel afford uniform parallel exploit ordinari program algorithm complex percol base synthesi a new symbol techniqu control depend schedul repres condit branch highlevel synthesi applic global schedul codemot highlevel synthesi applic a construct method exploit code motion effici superscalar perform boost a resourc share control synthesi method condit branch global schedul independ control depend base condit vector tr combinatori optim algorithm complex region schedul global schedul independ control depend base condit vector repres condit branch highlevel synthesi applic percol base synthesi limit control flow parallel effici superscalar perform boost effici resourceconstrain global schedul techniqu superscalar vliw processor treebas schedul algorithm controldomin circuit global schedul codemot highlevel synthesi applic timeconstrain code compact dsp pathbas techniqu estim hardwar runtim hwswcosynthesi effici orthonorm test synthesi passtransistor selector embed system design controlflow versu dataflowbas schedul italicglobalital resourceconstrain parallel techniqu synthesi optim digit circuit make compactionbas parallel afford unifi schedul model highlevel synthesi code gener construct method exploit code motion area perform optim pathbas schedul ctr aravind vijayakumar f brewer weight control schedul proceed ieeeacm intern confer computeraid design p novemb san jose ca steve haynal forrest brewer automatabas symbol schedul loop dfg ieee transact comput v n p march apostolo a kountouri christoph wolinski effici schedul condit behavior highlevel synthesi acm transact design autom electron system toda v n p juli