t framework combin analysi verif a present gener framework combin program verif program analysi framework enhanc program analysi take advantag user assert enhanc program verif assert refin use automat program analysi enhanc gener produc better way reason program use verif techniqu alon analysi techniqu alon importantli combin better simpli run verif analysi isol combin result last step word framework explor synergist interact verif analysi paper start represent program user assert given analyz program framework describ induc algorithm exploit assert analyz produc gener accur analysi further import featur flexibl number assert use anywher open employ arbitrari analyz modular reason condit correct assert increment tune accuracyeffici tradeoff b introduct abstract success method abstract interpret abstract domain construct given finit set predic program variabl intuit easili though necessarili effici comput within travers method program control flow structur recent success predic abstract enhanc process discoveri copyright notic appear here abstract domain gener known cegar counterex ampl guid abstract refin one major disadvantag predic abstract true mani realiz abstract interpret principl process abstract perform everi step travers phase inde survey section state abstract often defin small part program abstract modelcheck often overapproxim gener easi optim somewhat perform abstract eg sever consecut asign may compress abstract perform accord one composit assign blast system systemat way thi anoth disadvantag aris partli abstract descript limit fix number variabl adhoc method would composit exampl requir elabor extens predic abstract essenti consid second set variabl call symbol constant order describ behaviour function languag predic abstrac tion provid limit form composition paper present gener proof method program reason base predic abstract process abstract intermitt is approxim perform select program point all restrict abstract perform even though termin issu usual restrict choic key advantag a abstract domain requir ensur converg algorithm minim b cost perform abstract inter mittent reduc exampl reason execut x one need know final assign also consid prove follow program snippet i n textbook hoarestyl loop invari loop i proposit predic abstract would howev suffic one fact need know hold two increment c thu gener proper loop invari use could propag inform exactli main challeng exact propag reason requir strongestpostcondit oper associ arbitrarili long program fragment essenti mean deal constraint unbound number variabl describ state start end program fragment hand advantag term effici howev signific less predic need abstract domain also less frequent execut abstract oper import addit featur proof method composit repres proof hoarestyl tripl which given program fragment relat input valu variabl output valu repres formula gener formula must contain auxiliari variabl addit program vari abl gener imposs repres project formula use predefin set vari abl equival possibl perform quantifi elimin consequ order unrestrict composit proof again necessari deal unbound number variabl latter part paper introduc technolog constraint logic program clp basi effici implement briefli advantag clp a handl term contain anonyn primari variabl constraint variabl also arbitrari number auxiliari variabl b effici repres project term c handl backtrack summari show method provid flexibl combin abstract hoarestyl reason predic transform loopinvari composi tional practic implement feasibl relat work import categori tool use program verif technolog develop within framework java model languag jml project jml allow specifi java method pre postcondit class invari exampl program verif tool are jack escjava krakatoa tool employ weakest preconditionstrongest postcondit calculi gener proof oblig reflect whether given postcondit class invari hold end method whenev correspond precondit valid procedur entri point result proof oblig subsequ discharg theorem prover simplifi coq pv hol light system perform exact propag depend userprovid loop invari oppos abstract domain recent emerg system base abstract interpret particular predic abstract exampl blast slam magic murphi amongst other abstract interpret central system employ techniqu automat determin abstract domain need given assert techniqu call cegar see eg descript base iter refin abstract domain failur abstract domain previou iter system perform exact propag systemat way preliminari apart program counter k whose valu program point let n system variabl domain respect paper shall use two exampl domain integ integ array assum number system variabl larger number variabl requir program fragment procedur definit state transit system state or simpli state form kd n pc program point n valu system variabl transit pair state follow defin languag firstord for mula let v denot infinit set variabl type n let denot set func tor p denot set constraint symbol term either constant ari functor form term primit constraint form ft f mari constraint symbol term constraint construct primit constraint use logic connect usual manner constraint write y x denot possibl refer variabl x write x denot existenti closur y away x substitut map simultan replac variabl term constraint ex pression e term constraint write eq denot result appli q e special kind substitut renam map variabl given sequenc say correspond variabl anoth given sequenc say write denot map anoth special kind substitut ground map variabl express valu respect domain thu effect appli ground substitut q express e obtain set eq ground instanc q write denot set possibl ground e constraint transit system key concept program fragment p oper sequenc anonym variabl correspond system variabl variou point comput p particular consid two sequenc n anonym variabl denot system valu execut p target point p respect typic alway target point termin point p proof oblig assert form constraint said variabl possibl includ new variabl like hoaretripl state p execut state satisfi y state target point if ani satisfi note that unlik hoaretripl p may nontermin may refer state point reach infinit often formal below exampl let one system variabl x let p x let target point mean p successor function x similarli p perpetu program true x target point truepx is state x point satisfi zx show amongst thing pariti x alway remain unchang proof method accomod concurr program fix number process n process shall use program point sequenc n program point th program point one come th process next repres program fragment p transit system execut symbol follow definit serv two main purpos first high level represent oper semant p fact repres exact trace semant p second execut specif assert check definit constraint transit system constraint transit p formula k k variabl program point x x sequenc variabl repres system even even figur even count process true process true figur two process bakeri figur ct two process bakeri state constraint x possibl addit auxiliari variabl constraint transit system ct p finit set constraint transit p consid exampl program section call even figur contain ct even consid anoth exampl bakeri algorithm two process figur ct program call bak given figur note use first second argument term bub denot program point first second process respect clearli variabl constraint transit may renam freeli scope local transit thu say constraint transit variant anoth one ident renam subsitut perform further may simplifi constraint transit renam one variabl x express provid ground constraint tran sition exampl may simpli state last constraint transit figur replac variabl origin transit formul program transit familiar literatur purpos defin set transi tion new howev use ct defin symbol transit sequenc thereon notion proof similar logic program use term goal deonot liter subject unfold process order infer logic consequ definit goal queri goal ct k program point sequenc variabl system state constraint variabl x possibl addit variabl variabl x call primari variabl goal addit variabl call auxiliari variabl goal thu goal like conclus constraint transit say goal start goal k start program point similarli goal target goal k target program point run start goal tantamount ask question valu x satisfi lead goal target point idea success reduc one goal anoth result goal target point inspect result next defin mean ct prove goal definit proof step sequenc tree let ct p let xy goal thi proof step g obtain via variant pk transit ct variabl fresh result goal g form y provid constraint y y satisfi proof sequenc finit infinit sequenc proof step proof tree defin proof sequenc obviou way tree complet everi intern node repres goal g succeed node repres everi goal obtain proof step g figur proof tree even count program consid ct figur wish prove fact one proof sequenc start goal equival even i proof sequenc shown figur note counterrepres last goal variabl c valu hereaft shall consid program ct synonym given program p say x start variabl p denot x variabl first constraint transit p definit assert let p program start variabl x let constraint let x denot sequenc variabl repres system state appear p y these repres target valu system assert p wrt x form particular k start program point may abbervi assert use notat intuit clear mean assert hold is execut everi instanc q pk cannot lead target state properti violat exampl abov could prove assert understood final variabl c correspond start variabl c note last occurr n assert mean compar c initi final valu n though exampl two fact same state essenti properti proof sequenc theorem let ct p start point k target x x sequenc variabl figur proof tree process bakeri algorithm partial shown system state assert y hold goal form pk appear proof sequenc goal pk x follow hold theorem provid basi search method remain provid mean ensur termin search toward end next defin concept subsumpt coinduct allow success termin proof sequenc howev gener insuffici next section present version abstract whose purpos transform proof sequenc applic termin criteria subsumpt coinduct subsumpt consid finit complet proof tree start goal goal g tree subsum differ path tree contain goal g g principl simpli memoiz one may termin expans proof sequenc construct proof tree encount subsum goal coinduct principl that within one proof sequenc proof oblig associ final goal may assum proof oblig ancestor goal alreadi met formal explain principl coinduct see eg appendix b importantli simpl form coinduct requir base case wellfound order shall simpli demonstr principl exampl suppos transit px px wish prove assert px evenx x is differ x final valu even consid deriv step may use latter goal fact earlier goal satisfi assert is may reduc obligaton latter goal simpl matter infer whether formula hold gener practic applic coinduct test larg equival test one goal simpli instanc anoth compostion intuit clear sinc proof oblig relat start final valu program equival obey assumeguarante paradigm proof method sequenti composit thu omit formal treatment ct program directli invok program instead next section provid simpl exampl abstract literatur predic abstract abstract descript special data structur monomi abstract oper serv propag structur though small program fragment a contigu group assign test obtain anoth struc ture strength method simplic use finit set predic fix number program variabl basi abstract descript choos follow method howev abstract descript shall distinguish data structur abstract descript goal goal definit abstract abstract appli goal specifi program point pca sequenc variabl vara correspond subset system variabl final finit set constraint preda vara call predic let abstract g goal pk xy x denot subsequ x correspond system variabl vara let x denot remain subsequ x without lose gener assum x initi subsequ x is x abstract ag g is z sequenc fresh variabl renam finit set constraint exampl let is first variabl abstract neg nonneg valu let g p x x x x abstract ag goal form p zx x x simplifi p zx x x note orgin goal ground instanc p n n abstract goal instanc p mn n nonneg m note second variabl x abstract even though tightli constrain first variabl x note valu x unchang is abstract would allow constraint x exampl goal contain constraint propag lemma let abstract g goal critic point abstract goal format goal itself thu abstract goal express power regular goal yet contain notion abstract suffici produc finitest effect again facilit abil reason unbound number variabl consid bubbl program ct figur simplifi skeleton bubbl sort algorithm without array consid subprogram correspond start point whose target point is consid inner loop suppos follow assert alreadi proven bub i j t n is subprogram increment n preserv n j consid proof sequenc goal bub i j t nn want prove program point n proof tree depict figur proof show combin use intermitt abstract composit proof point a abstract goal bub use predic i call abstract set variabl henc variabl correspond respect system variabl i n j ni figur program bubbl bub i j t n bub bub i j t n bub i j t n n bub i j t n bub i j t n n bub i j t n bub bub i j t n bub i j t n j n bub i j t n bub i j t n j n bub i j t n bub bub i j t n bub i j t n j n bub i j t n bub i j t n j n bub i j t n bub bub i j t n bub i j t n n bub i j t n bub i j t n n figur ct bubbl renam fresh variabl mean while variabl j n retain origin valu perform abstract reus proof inner loop abov immedi move program point increment updat j unknown valu howev n retain origin valu result intermitt abstract abov obtain coinduct proof b whole algorithm summar proof method assert suppos start program point p k start variabl p x consid start goal pk increment build search tree path tree construct far lead goal g g either subsum coinduct consid path close ie expand further g goal abstract defin replac g ag g target goal constraint primari variabl x g satisfi yq q renam target variabl coinduct use a satisfi satisfi proof composit intermitt abstract bub i j t nn figur composit proof theorem algorithm appli assert asert hold clp technolog almost immedi ct implement clp given ct p build clp program follow way a everi transit form k use clp rule claus pk ing constraint domain clp implement hand b everi termin program point k use clp fact pk number anonym variabl number variabl x see later key implement challeng clp system increment satisfi problem roughli state problem success determin monoton increas sequenc constraint interpret conjunct satisfi exact propag clphard inform demonstr increment satisfi problem reduc problem analyz straight line path program consid constraint form linear diophantin equat ie multivari polynomi integ without loss gener assum constraint written form integ suppos alreadi sequenc constraint correspond path program control flow suppos add new constraint then one variabl say new add assign x z new variabl creat correspond y remain variabl x z either new correspond variabl x z howev xy z new add statement program variabl correspond x y z respect hereaft pursu branch statement similarli suppos new constraint form correspond possibl new again x new simpli add assign x n x newli creat correspond x otherwis add statement path again pursu branch statement clearli exact analysi path construct lead success travers requir increment solv constraint sequenc n key element clp system clp system attempt find answer initi goal g search valid substitut variabl depthfirst search use path search tree fact involv solv increment satisfi problem along way unsatisfi constraint hand would entail backtrack key issu clp increment satisfi problem mention abov standard approach follow given sequenc constraint determin satisfi repres fact solv form essenti mean new constraint i encount solv form effici combin i order determin satisfi new conjunct constraint method essenti requir represent project set constraint onto certain variabl con sider exampl set x assum new constraint would involv variabl x and happen vastli of ten desir represent x project problem well studi clp system system clpr exampl variou adapt fouriermotzkin algorithm implement project herbrand linear arithmet constraint final mention anoth import optim clp tail recurs techniqu use space procedur call stack recurs call amongst bebefit techniqu allow potenti unbound number recurs call tail recurs particurli relev context recurs call aris ct program often tailrecurs clpr system use implement prototyp engin handl constraint auxiliari variabl effici use techniqu experi perform two kind experi first set perform exact propag look compar abstract run blast system exact run system result present section second set experi present section compar intermitt predic abstract normal predic abstract blast system use pentium ghz system mbram run gnulinux exact run start experi show concret execut potenti less costli abstract execut simpli compar time concret execut use clpbase implement predic abstractionbas model checker also run simpl loop program whose c code shown figur first blast gener predic requir rerun blast provid predic blast took second explor state space machin without abstract verif engin took second comparison spin model checker execut program written promela less second consid synthet program consist initi assign x follow increment x object prove end consid also anoth version program contain singl loop increment counter x time input two program program verifi without use abstract escjava well result shown tabl verifi escjava run x initi initi hope forc symbol execut tabl show verifi run faster nonloop version howev notic slowdown int main int i j x i j x j error figur program loop time in second clp tabl escjava nonloop loop tabl time comparison escjava loop version implement caus fact implement coinduct tabl subsumpt check done base similar program point therefor program point insid loop visit ith time subsumpt check perform result total subsumpt check loop program comparison nonloop version requir subsumpt check howev implement current prototyp stage tabl mechan implement effici way loop version escjava employ weakest precondit propag calculu sinc program small straightforward invari just loop condit comput fast tabl also show almost differ x initi not experi use abstract next show exampl demonstr intermitt approach requir fewer predic let us consid second loop program written c shown figur program postcondit proven provid invari xi i exactli first statement loop bodi outer loop specifi abstract domain follow predic xi i respect negat xi i program point verifi use inform proof process finish less second provid abstract domain verif process finish sec ond intermitt predic abstract requir fewer predic also run program blast provid predic xi i blast would auto int main int i j x i j x j xi x error figur second program loop true figur bakeri algorithm peudocod process matic also consid negat blast finish second addit also produc predic refin run predic given blast finish second further also tri proof method version bakeri mutual exclus algorithm need abstract sinc bakeri algorithm infinitest program pseudocod process shown figur would like verifi mutual exclus is two process critic section program point time version bakeri algorithm concurr program asynchron composit process encod sequenti program nondeterminist choic first encod algorithm process blast nondeterminist choic implement blast use special variabl blast nondet nondeterminist valu show blast code process bakeri algorithm figur within code use program point annot pc consid comment notic program point concurr version encod use integ variabl pc pc further translat blast sequenti version algorithm process ct version shown figur also correspond clp code input prototyp verifi experi attempt verifi mutual exclus properti is two process critic section time perform set run consist run process set use basic set predic x x pc pc int main int pc pc unsign int x x pc pc abstract point pc pc abstract point els pc pc error blast nondet pc els pc els pc els pc els pc els pc figur sequenti process bakeri n number process also negat set use predic abstract everi state full predic set use prototyp system perform ordinari predic abstract abstract everi state encount search here addit basic predic also requir predic shown tabl and negat avoid produc spuriou counterexampl set intermitt predic abstract full predic set second set use intermitt abstract techniqu prototyp implement abstract process i pc hold figur abstract point mark comment abstract point set predic use predic use first experi abov otherwis spuriou counterexampl gener set intermitt predic abstract reduc predic set third set also use intermitt abstract techniqu tabl clp system abstract whenev n process program point process sequenti version condit either pc pc bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx bak pc pcxx figur ct sequenti process bakeri bakeri xx bakeri xx xx xx bakeri xx xx xx xx xx xx tabl addit predic time in second clp tabl blast bakeri bakeri tabl time comparison blast mark comment astract point figur bakeri algorithm n process need basic predic negat without addit predic shown tabl also compar result blast suppli set predic use first second set blast again blast specifi negat explicitli interestingli process bakeri algortihm blast requir even predic avoid refin xx xx xx x xx xx xx suspect due fact precis predic abstractionbas statespac travers depend power underli theorem prover blast gener addit predic need prerun run blast use them sinc run blast refin lazi abstract techniqu effect blast use suppli predic repres abstract state problem use intermitt abstract clp tabl also markedli faster full predic abstract clp blast show time result tabl smallest record time run each first set blast run abstract everi visit state time differ second third set show perform abstract everi visit state expens third set show gain second understand intricaci system acknowledg thank ranjit jhala help blast r automat predic abstract c program polymorph predic abstract coq proof assist refer manualvers v java applet correct developerori approach modular verif softwar compon c escjava unit escjava jml experi predic abstract construct abstract state graph infinit system pv hol light tutori introduct lazi ab straction spin model checker primer refer manual project clpr clpr krakatoa tool certif javajavacard program annot jml principl program analysi pv prototyp verif system proof techniqu relyguarante properti model check program tr constraint logic program method logic prove program base program analysi modern compil implement ml simplif cooper decis procedur abstract interpret systemat design program analysi framework flexibl approach interprocedur data flow analysi program recurs data structur prove safeti properti integr static analysi theorem prove abstract program analysi use mix term set constraint experi theorem prove model check protocol verif power techniqu automat gener invari verifi invari use theorem prove pv