t cooper strategi solv bicriteria spars multipl knapsack problem a hard optim problem difficult design heurist algorithm exhibit uniformli superior perform problem instanc result becom necessari tailor algorithm base problem instanc paper introduc use cooper problem solv team heurist evolv algorithm given problem instanc efficaci method examin solv six difficult instanc bicriteria spars multipl knapsack problem result indic tailor algorithm uniformli improv solut compar use predesign heurist algorithm b introduct one major goal product facil util inventori best possibl way satisfi demand maketoord product system process industri surplu inventori accumul due cancel order reject product unit fail satisfi qualiti requir clearli advantag product facil util surplu inventori plan product acitivit rais problem assign list order product unit inventori object maxim total amount order assign minim total wast product unit manufactur consider compat order product unit term qualiti size etc impos addit assign constraint product oper involv complex process larger product varieti problem becom constrain bicriteria spars multipl knapsack problem consid studi motiv applic paper focu use team heurist algorithm cooper gener nondomin solut problem short comput time although exist sever heurist approach solv multipl knapsack problem exist singl domin algorithm moreov perform heurist vari problem instanc result specif heurist often demonstr poor aggreg perform set problem instanc howev heurist allow cooper ffl solut gener one heurist subsequ improv anoth ffl appropri subset heurist use construct solut given problem instanc aggreg perform collect cooper heurist set problem instanc may greatli improv purpos develop collect fast heurist incorpor ateam architectur provid comput framework implement cooper strategi among heurist present result experiment analysi compar effect heurist work individu cooper within ateam framework addit calibr purpos compar result feasibl solut deriv use integ program formul sinc import consider real applic comput time requir gener solu tion also compar perform cooper problem solv strategi tradit integ program techniqu paper organ follow first formal problem section section provid overview relat work literatur two version problem singl object present collect heurist discuss cooper problem solv strategi use section section summari result experiment analysi final conclud section problem definit given set item ng set knapsack item j n weight w j knapsack capac c associ it w j c posit real number addit item j n set j knapsack hold item j specifi conveni also specifi knapsack set b n item assign knapsack knapsack need choos subset item n assign knapsack i that s disjoint each item assign one knapsack subset b assign restrict satisfi m total weight item assign knapsack exceed capac knapsack w j maxim total weight item assign maxim ii denot set indic non empti due unus portion util knapsack minim refer problem bicriteria spars multipl knapsack problem bsmk without loss gener assum w remov b problem becom trivial j s disjoint p case b s disjoint problem decompos singl knapsack problem thu exclud case consider note assign restrict also repres bipartit graph two disjoint node set graph correspond set n let e correspond bipartit graph then exist edg i represent sparsiti problem refer edg sparsiti bipartit graph g bicriteria problem relev sparser problem constrain problem solut maximum assign weight necessarili small wast relat problem literatur singl object version bicriteria problem slightli modifi form two wellknown problem literatur consid object maxim total assign weight alon problem variat multipl knapsack problem call spars multipl knapsack problem smk object minim total wast alon problem reduc variat variables bin pack problem refer spars bin pack problem sbp classic multipl knapsack problem item go knapsack henc bipartit graph repres problem complet wherea gener problem allow bipartit graph hand multipl knapsack problem gener object function exist posit profit p j assign item j knapsack object function maxim total profit assign item applic motiv us profit assign item assum proport weight item henc maxim total assign weight multipl knapsack problem known np hard strong sens kar mt reduct partit problem still valid object function coeffici equal weight item instanc smk complet bipartit graph represent also np hard strong sens thu object maxim total assign weight problem strongli np hard exist fulli polynomi time approxim scheme smk unless multipl knapsack problem sever exact heurist solut method develop test literatur see martello toth mt survey exact solut method consist branch bound cut plane branch bound method use bound base either lagrangean relax hung fisk hf surrog relax martello toth mt mta problem cut plane method use minim cover dconfigur multipl cover inequ ferreira martin weismantel fmw unfortun exact solut method cannot solv larg instanc aris real applic reason comput time heurist method includ fast greedi algorithm follow local exchang heurist martello toth mtb well nonpolynomi time approach solv singl knapsack problem success martello toth mta obtain feasibl solut surrog relax hung fisk hf consid object minim wast alon produc illpos problem trivial optim solut assign item henc consid relax assign constraint decompos problem singl knapsack problem get linear combin capac constraint result singl knapsack problem version impos condit item n specifi subset n must assign goal use knapsack minimum total capac then problem gener variables bin pack problem allow assign restrict addit bin pack problem known np hard ie gj thu gener problem sbp nphard well binpack problem extens studi literatur one first problem effici approxim algorithm develop recent survey cook garey johnson cover worst averag case analys onlin offlin algorithm previou survey author cgj consid also variat problem exact algorithm develop martello toth mt variables bin pack problem studi friesen langston fl provid modif wellknown bin pack heurist next fit first fit best fit heurist cooper problem solv given nphard optim problem difficult design heurist algorithm exhibit uniformli superior perform problem instanc altern approach tackl difficult problem organ collect heurist algorithm cooper uniformli exhibit superior perform might possibl use separ approach especi attract collect heurist algorithm vari perform problem instanc unpredict way anoth ingredi requir cooper problem solv architectur facilit cooper heurist algorithm control strategi defin rule collabor among heurist follow paragraph discuss detail organ ie architectur control strategi use build cooper problem solv team heurist multipl knapsack problem also discuss detail collect heurist use build cooper problem solv team asynchron team architectur asynchron team ateam tdsm architectur facilit multipl heurist work togeth common problem cooper heurist allow share popul candid solut figur provid schemat architectur architectur similar blackboard system solut post onto blackboard share heurist algorithm heurist access entir popul solut choos appropri partial solut work on heurist use architectur usual classifi three categori base follow ffl constructor heurist use creat initi solut ffl improv heurist take exist partial solut popul modifi produc new solut criteria use decid whether solut ad popul depend choic control strategi pure hill climb approach such genet algorithm solut nondomin would ad popul variant simul anneal might allow entri domin solut popul expect might allow better solut creat later on ffl destroy heurist remov redund solut popul intent manag size popul determin whether solut redund difficult usual destroy design retain redund solut nonzero probabl note destroy typic use control strategi allow inclus domin solut popul domin solut constructor destroy improv domin solut nondomin solut figur schemat ateam architectur typic approach gener solut use architectur involv creat initi popul solut use constructor heurist subsequ evolv popul solut repeat applic improv destroy heurist time set nondomin solut constitut paretofronti provid set nondomin solut problem control strategi solut approach prescrib rule collabor heurist control strategi specifi two rule ffl first rule specifi improv heurist pick solut popul improv ffl second rule specifi criteria incorpor new solut creat improv heurist popul implement use stochast hill climb approach control strat egi stochast hill climb algorithm search space aim find state optim properti algorithm make success improv current state ae s context paper state ae correspond popul solut bicriteria multipl knapsack problem algorithm attempt improv current state ae make transit one neighbor ae s within ateam implement transit made randomli pick improv heurist randomli pick solut popul improv work on new solut gener improv nondomin ad popul correspond new state sinc hill climb approach allow nonimprov move explicitli need worri manag size popul result implement ateam bicriteria spars multipl knapsack problem requir destroy ateam architectur use obtain good feasibl solut variou combinatori optim problem tsp problem talukdar de souzatd schedul problem aris steel paper manufactur industri lee et al lmhm murthi et al marw reader refer talukdar de souza murthi tdsm ateam architectur heurist aim gener nondomin solut bsmk develop collect constructor improv heurist heurist simpl greedi heurist adapt heurist literatur use multipl knapsack variables bin pack problem addit random heurist construct heurist mainli greedi heurist variou item knapsack select rule addit coupl heurist round lp relax solut smk constructor aim maxim total assign weight improv heurist either local exchang heurist aim improv object heurist rearrang assign item among knapsack unassign item purpos minim total wast next two subsect give descript heurist constructor heurist simpl greedi heurist heurist first sort item nonincreas order weight knapsack nondecreas order capac two version first one next knapsack order say i pick next item order say j pick item j allow go knapsack j ie exceed residu capac knapsack i item j assign knapsack i so knapsack pick mani item possibl pack it second version item order pick assign next feasibl knapsack possibl heurist run time on log n m log mnm call heurist greedyknapsack greedyitem greedi heurist variou knapsack select rule heurist decis pick next knapsack depend assign made upto point heurist sort item nonincreas order weight pick next item j pick knapsack j accord one three rule three version base pick knapsack minimum residu capac iti residu capac minimum surplu demand call greedyminrc greedymaxrc greedyminsd respect surplu demand knapsack total weight unassign item b minu residu capac knapsack reason pick knapsack minimum surplu demand smaller surplu demand like item fit knapsack greedymaxrc greedyminsd heurist tend maxim assign without consid wast greedyminrc heurist tend minim wast addit success assign heurist anoth greedi heurist rather pick knapsack item pick item knapsack one one item match knapsack success object maxim total weight item match iter maximum weight bipartit match assign problem solv bipartit graph edg i exist weight w j w j exceed residu capac knapsack i initi bipartit graph g use assign given maximumweight bipartit match solut perform then bipartit graph updat delet assign node edg i j w j exce residu capac knapsack j node degre zero heurist repeat graph remain edg heurist call successiveassign random heurist greedi heurist modifi randomli order break pattern greedi choic suppos item j pick greedi heurist item consid assign probabl p j run item heurist repeat order assign remain item two version base choic p j first one p j proport weight item j is weight itemlambdac c constant factor item larger weight like pick call heurist randomweight second version call randomdegre degre g c degj degre node j g idea defer assign item choic knapsack give prioriti item may go knapsack heurist base lp relax smk heurist solv lp relax problem singl object maxim total assign weight construct feasibl solut round fraction lp solut ip formul smk follow st p variabl x ij denot whether item j assign knapsack i lp relax correspond relax integr variabl although lp relax multipl knapsack problem solut construct easili on time lp relax solut spars problem cannot identifi immedi howev relax still solv effici maximum flow algorithm continu problem reduc maximum flow problem direct graph construct bigraph g follow edg j i g direct item node j knapsack node assign capac sourc node connect item node j via arc s addit sink node connect knapsack node via arc i t capac c then maximum flow equal lp relax valu amount flow arc j i divid w j give valu x ij thu flow assign knapsack i variabl said fraction in correspond solut two version heurist first one simpl greedi heurist use assign item correspond fraction variabl remain amount solv lp relax singl knapsack problem item second version fraction variabl sort nonincreas order valu fraction variabl order assign done feasibl then remain item assign greedili first version two heurist call lpgreedi lpround improv heurist local exchang heurist aim improv object repeat improv occur exchang item assign differ knapsack consid pair item assign differ knapsack swap two item swap feasibl allow unassign item assign one two knapsack exchang item perform pick knapsack whose residu capac increas repetit assign item maximumweight it assign feasibl heurist call exchang replac assign item unassign item replac assign item pair assign item singl unassign item pair unassign item larger weight heurist call replacesingl replacepair base whether singl item pair item replac rearrang rearrang assign item differ knapsack aggreg residu capac one knapsack use aggreg capac assign new item swap two item assign two differ knapsack exchang feasibl maximum residu capac over knapsack increas pair item consid repeat assign new item maximum weight knapsack maximum residu capac feasibl heurist call rearrang heurist reduc wast empti underutil knapsack random heurist two paramet pick randomli minimum allow util maximum allow percentag decreas assign weight cancel assign knapsack util less minimum allow util decreas weight less maximum allow percentag heurist call empti empti knapsack randomli reassign item knapsack util empti knapsack probabl util knapsack then reassign item greedyminrc heurist heurist call emptyandreassign pack variables bin pack heurist cancel assign knap sack reassign origin assign item first fit decreas best fit decreas heurist ie greedyitem greedyminrc heurist heurist call packagainffd packagainbfd respect heurist increas assign weight constructor heurist use improv assign remain item feasibl implement use simpl greedyitem heurist purpos refer assignremain comput experi section examin perform cooper problem solv strategi compar behavior tradit integ program base techniqu problem use comput experi also compar perform cooper strategi individu heurist effort quantifi improv gain cooper final analyz nondomin solut identifi concaten heurist gener good solut data use real data inventori applic problem steel mill industri kdtl instanc avail us number item vari number knapsack sparsiti problem rang size sparsiti instanc summar tabl implement individu heurist code heurist present section c languag use leda librari nu perform test ibm rs machin oper aix first collect solut output constructor improv heurist found nondomin solut among collect solut run improv use solut provid greedyknapsack constructor tot cap tot weight tabl inform reallif data sparsiti denot edg densiti bipartit graph represent percentag number edg complet bipartit graph last two column denot total capac knapsack total weight item input random heurist run time best solut among run output ateam incorpor individu heurist ateam architectur set paramet stop time probabl pick constructor improv initi test probabl improv such replacesingl replacepair empti emptyandreassign effect initi run increas examin converg solut popul run ateam code cycl heurist observ number nondomin solut output maximum averag valu assign weight minu wast nondomin solut decid cycl length ateam run data set statist chosen cycl length given tabl appendix ip base approach order assess perform heurist comput difficulti problem tri solv two ip singl object gener branchandcut method first problem consid compar result spars multipl knapsack problem smk object maxim assign weight onli ip formul smk given section second problem consid object function sum two object maxim assign weight minu wast call problem mkbp combin multipl knapsack bin pack aspect ip formul follow st p introduc variabl z denot whether item assign knapsack i object function equal p lp relax correspond relax integr variabl lp relax smk mkbp problem optim valu optim solut lp relax mkbp zero wast henc refer relax problem the lp relax order obtain best bound possibl reason comput time ad best lower bound obtain heurist ip formul smk mkbp solv gener integ program solver cplex co use default set hour cpu time ad upper bound output cplex formul ran cplex we wait longer larger instanc d repeat procedur better bound found hour comparison lp relax valu upper bound gener branch bound method data set given tabl run time given tabl also give crude idea comput difficulti solv problem exact method took hour get optim solut smk data set d could obtain optim solut problem data lp bound ub gap time hr ub gap time hr tabl comparison lp relax valu best upper bound ub obtain branch bound method smk mkbp problem column gap denot deviat lp bound best avail bound time denot cpu time obtain given bound here note problem get sparser get harder sens solut maxim assign weight necessarili small wast henc choic knapsack item assign becom critic problem get relax that is bipartit graph represent get closer complet graph problem get closer multipl knapsack problem usual maxim assign weight suffic minim wast time sparsiti problem play role also determin strength lp relax sparsiti increas gap lp relax valu optim valu get larger problem also collect feasibl solut output cplex record cpu time obtain solut run provid bound object function initi reran cplex previous obtain bound whenev stop due memori problem stop procedur improv could obtain till comput ran memori one may also consid use best lower bound output individu heurist ip formul oppos cooper strategi howev use heurist way improv upon perform branchandcut method cplex significantli even use better bound output cooper strategi yield optim solut reason comput time as seen tabl addit cooper strategi advantag gener mani nondomin solut two object ip formul specifi one object function compar evalu cooper strategi qualiti solut qualiti solut gener use cooper strategi significantli better one gener individu run especi wast object comparison solut maximum assign weight gener ateam implement individu run provid tabl wast solut also given tabl see cooper heurist use decreas wast solut maximum assign weight also note could obtain solut better assign weight exact solut method use cplex problem except d solut maximum valu assign weight wast gener ateam implement individu heurist cplex given tabl observ signific differ assign weight wast solut gener cooper strategi versu gener individu heurist especi harder instanc d slightli better solut could obtain cplex hour respect larger instanc d feasibl solut output cplex significantli inferior data aw ratio wast wast cpu time ii iii iii ii iii ii iii ii iii ii iii tabl comparison solut maximum assign weight obtain i ateam implement ii individu run heurist iii branchandcut aw assign weight ratio ratio aw best avail bound assign weight object from tabl wast ratio unus capac total capac util knapsack percentag cpu time given second output cooper strategi differ best upper bound avail respect collect heurist abl gener significantli nondomin solut cooper ateam implement heurist abl effect improv object time result individu heurist good enough maxim assign weight capabl minim wast time hand use cooper organ heurist favor maxim assign weight favor minim wast chanc take output one anoth input therefor gener solut better valu object plot nondomin solut gener ateam implement individu heurist given figur appendix note problem d less spars compar problem solut larg assign weight small wast time mani nondomin solut gener attribut fact two object almost parallel problem data awwast ratio aw wast wast cpu time ii iii ii iii ii iii ii ii iii ii iii x tabl comparison solut maximum assign weight wast obtain i ateam implement ii individu run heurist iii branch andcut ratio obtain use best avail upper bound maxim assign weight minu wast obtain tabl cpu time given second run time clearli combin heurist cooper strategi increas run time cycl heurist run howev still run time reason rang significantli smaller compar branchandcut method singl run individu heurist take second depend size problem heurist use run time individu heurist given tabl appendix timeconsum heurist replacesingl heurist take second second d constructor heurist take littl time greedi heurist run less second lpround lpgreedi heurist take slightli time second timeconsum constructor successiveassign take second cpu time ateam implement take time approxim minut hour depend size problem still run time significantli small compar branchandcut approach cplex order hour run time given tabl tabl run time individu heurist total time heurist best solut pick run heurist concaten heurist ateam implement examin nondomin solut pareto frontier shown figur identifi heurist sequenc appli yield particular solut natur question aris whether realli necessari random sequenc heurist act other solut possibl identifi one sequenc or concaten heurist yield paretofronti problem instanc might abandon stochast control strategi construct solut section show concaten heurist use gener paretofronti vari significantli problem instanc illustr need tailor solut strategi problem instanc autom stochast control strategi adopt paper nondomin solut gener ateam implement trace heurist whose output solut use obtain nondomin solut conclud heurist effect repeat more nevertheless observ regular pattern sequenc agent call across differ problem instanc justifi use ateam approach concaten heurist oppos identifi effect pattern use pattern instead ateam implement total number occurr heurist particip gener nondomin solut for problem instanc given tabl appendix see lpround frequent use constructor local exchang heurist replacesingl replacepair wast reduct heurist empti emptyandreassign effect improv gener nondomin solut also give heurist output nondomin solut individu run tabl comparison purpos statist present tabl clearli indic pattern use construct paretofronti vari significantli across problem instanc figur appendix illustr construct nondomin solut gener ateam implement conclus paper introduc bicriteria spars multipl knapsack problem character comput complex problem experiment comput gap lp relax best deriv bound show increas sparsiti make problem difficult integ program techniqu unabl gener solut reason amount time new cooper problem solv techniqu introduc use collect fast heurist algorithm embed cooper problem solv architectur call ateam solut gener use approach shown superior deriv use heurist individu feasibl solut deriv integ program techniqu cooper problem solv strategi shown altern approach autom design heurist hard combinatori problem r approxim algorithm binpack updat survey approxim algorithm binpack survey variabl size bin pack solv multipl knapsack problem cut plane comput intractibilitya guid theori np algorithm multipl knapsack problem reduc among combinatori problem surplu inventori match problem process industri primari product schedul steelmak industri solut zeroon multipl knapsack prob lem bound bound algorithm zeroon multipl knapsack problem heurist algorithm multipl knapsack problem knapsack problem lower bound reduct procedur bin pack problem leda user manual version r asynchron organ multi algorithm problem organ computerbas agent tr ctr jayant r kalagnanam andrew j davenport ho s lee comput aspect clear continu call doubl auction assign constraint indivis demand electron commerc research v n p juli