t faster simpler algorithm sort sign permut revers a give quadrat time algorithm find minimum number revers need sort sign permut algorithm faster previou algorithm hannenh pevzner faster implement berman hannenh algorithm conceptu simpl requir special data structur studi also consider simplifi combinatori structur use analysi b introduct paper studi problem sort sign permut revers sign permut permut integ number also assign sign plu minu revers i j transform minimum number revers need transform one permut anoth call revers distanc them problem sort sign permut revers nd given sign permut sequenc revers minimum length transform ident permut motiv studi problem aris molecular biolog concurr fast progress human genom project genet dna data mani model organ accumul rapidli consequ abil compar genom dierent speci grown dramat one best way check similar genom larg scale compar order appear ident gene two speci thirti dobzhanski sturtev alreadi studi notion invers chromosom drosophila late eighti jerey palmer demonstr dierent speci may essenti gene gene order may dier speci take abstract perspect gene along chromosom thought point along line number identifi particular gene and gene direction sign correspond direct palmer other shown dierenc order may explain small number revers revers correspond evolutionari chang histori two genom numa preliminari version paper present eighth acmsiam symposium discret algorithm attlab research park ave florham park nj usa hklresearchattcom z depart comput scienc sackler faculti exact scienc tel aviv univers research support part grant ministri scienc art israel us depart energi grant no defgera shamirmathtauacil x depart comput scienc princeton univers princeton nj usa intertrust technolog corpor sunnyval ca usa research princeton univers partial support nsf grant ccr ccr oce naval research contract no nj retcsprincetonedu ber revers ect evolutionari distanc speci henc given two permut revers distanc measur evolutionari distanc mathemat analysi genom rearrang problem initi sanko kececioglu sanko gave rst constantfactor polynomi approxim algorithm problem conjectur problem nphard bafna pevzner recent christi improv approxim factor addit studi reveal rich combinatori structur rearrang problem quit recent caprara establish sort unsign permut nphard use combinatori tool develop bafna pevzner hannenh pevzner show problem sort sign permut revers polynomi prove dualiti theorem equat revers distanc sum three combinatori paramet see theorem below base theorem prove sort sign permut revers done on time recent berman hannenh describ faster implement nd minimum sequenc revers on n time invers ackerman function see also studi give on algorithm sort sign permut n element therebi improv upon previou best known bound fact revers distanc r algorithm requir or n addit give better time bound work consider simpli algorithm combinatori structur need analysi follow basic object work implicit represent overlap graph dene later contrast interleav graph overlap graph combinatori simpler interleav graph result easier produc represent overlap graph input maintain search revers consequ abil work overlap graph need perform pad transform work simpl permut deal unori orient part permut separ make algorithm much simpler notion hurdl one combinatori entiti dene dualiti theorem simpli handl symmetr manner search next revers much simpler requir special data structur algorithm comput connect compon onc simpl implement suce obtain quadrat time bound con trast logarithm number connect compon comput may perform per revers use unionnd data structur paper organ follow section give necessari preliminari section give overview algorithm section give detail algorithm summar result suggest research section preliminari section give basic background primarili theori hannenh pevzner base algorithm reader may nd help refer figur main denit illustr start denit unsign permut let permut ng augment permut n vertic ad it pair call gap gap classi two type breakpoint otherwis adjac denot b number breakpoint revers i j permut transform say revers i j act gap c fig a breakpoint graph b permut edg solid gray edg dash orient edg bold b b decompos two disjoint altern cycl c overlap graph ov black vertic correspond orient edg breakpoint graph breakpoint graph b permut edgecolor graph n g join vertic j black edg gray edg i j breakpoint dene onetoon map u set sign permut order n set unsign permut order n follow let sign permut obtain u replac posit element x x neg element x x x sign permut let note b everi vertex either isol incid exactli one black edg one gray edg therefor uniqu decomposit b cycl edg cycl altern gray black call revers i j odd j even even revers revers i j u mimic revers i j thu sort revers equival sort unsign permut u even revers henceforth consid latter problem revers alway mean even revers let c number cycl b figur a show breakpoint graph permut eight breakpoint decompos two altern cycl ie two cycl shown figur b figur a show breakpoint graph seven breakpoint decompos two cycl arbitrari revers permut dene b c c revers permut clear context abbrevi b b c c bafna pevzner observ follow valu taken b c depend type gap i act on two adjac breakpoint adjac two breakpoint belong dierent cycl two breakpoint cycl c a gray edg b exactli one c neither gray edg break c d neither gray edg break c dierent path call revers proper b c ie either type a b d say revers act gray edg e act breakpoint correspond black edg incid e gray edg orient revers act proper otherwis unori notic gray edg orient k l even exampl gray edg graph figur a unori gray edg overlap graph two interv real line overlap intersect nonempti neither properli contain other graph g interv overlap graph one assign interv vertex two vertic adjac correspond interv overlap see eg permut associ gray edg interv i j overlap graph permut denot ov interv overlap graph gray edg b name vertex set ov set gray edg b two vertic connect interv associ gray edg overlap shall identifi vertex ov edg repres interv represent thu endpoint gray edg actual endpoint interv repres correspond vertex ov note endpoint interv represent distinct integ connect compon ov contain orient edg call orient compon otherwis call unori compon figur c show interv overlap graph one orient compon figur b show overlap graph permut two connect compon one orient unori fig a breakpoint graph obtain figur revers or equival revers dene gray edg b overlap graph connect compon overlap graph let x set gray edg b dene xg equival one look interv overlap represent ov mention dene span set vertic x minimum interv contain interv vertic x major object algorithm work ov though ecienc consider avoid gener explicitli contrast pevzner han nenhal work interleav graph h whose vertic altern cycl b two cycl c c connect edg h exist gray edg e c gray edg e c overlap follow lemma corollari impli partit impos connect compon ov set gray edg ident one impos connect compon h lemma set gray edg b correspond connect compon ov minm even maxm odd proof assum minm odd must spanm ie exist l spanm l thu minm neither maximum minimum element set f spanmg henc either maximum element minimum element spanm j minm j maxm denit b must gray edg contradict fact connect compon ov proof maxm odd similar illustr lemma consid figur a let corollari everi connect compon ov correspond set gray edg union cycl proof assum contradict c cycl whose gray edg belong least two connect compon ov assum two compon two consecut gray edg along c sinc span dierent connect compon ov cannot overlap two dierent case consid e e dierent compon cannot overlap thu either right endpoint e even equal maxm left endpoint e odd case contradict lemma disjoint interv wlog assum maxm right endpoint e even equal maxm contradict lemma note particular corollari impli overlap graph cannot contain isol vertic hurdl let subsequ consist element incid gray edg occur unori compon ov order circl cr j let unori connect compon g set endpoint edg unori compon hurdl element em occur consecut cr denit hurdl dierent one given hannenh pevzner simpler sens minim hurdl maxim one treat dierent way use corollari abov one prove hurdl dene ident one dene hannenh pevzner let h denot number hurdl permut hurdl simpl one delet ov unori compon becom hurdl super hurdl otherwis fortress permut odd number hurdl super hurdl follow theorem prove hannenh pevzner theorem minimum number revers requir sort permut b c h unless fortress case exactli one addit revers necessari sucient overview algorithm denot d revers distanc ie fortress follow theori develop turn given permut h one perform permut h t ov unori compon algorithm rst nd revers transform orient compon method clear hurdl use theori develop hannenh pevzner section describ ecient implement process use implicit represent overlap graph ov implement run on time assum ov alreadi partit connect compon recent berman hannenh gave onn algorithm comput connect compon interv overlap graph given implicitli represent use algorithm clear hurdl permut onn time overlap graph ov orient compon section prove neighborhood orient gray edg e orient gray could e revers act e creat new hurdl call revers safe revers develop ecient algorithm locat safe revers permut least one orient gray edg algorithm use implicit represent overlap graph run on time second stage algorithm repeatedli nd safe revers perform long ov empti clearli overal complex or n r number revers requir sort repres overlap graph assum input given sequenc n sign integ repres first permut construct describ section store array also construct array repres straightforward verifi two array determin element whether left right endpoint gray edg constant time case element endpoint gray edg also nd endpoint check whether edg orient constant time thu array compris represent ov algorithm maintain two array carri revers nd time updat array proport length interv revers on shall give highlevel present algorithm use primit like scan orient gray edg increas left endpoint order easi see implement primit use array shall omit detail easi produc list interv represent ov sort either left right endpoint array also possibl maintain without increas asymptot time bound algorithm practic may faster maintain list instead of addit elimin orient compon first introduc notat recal vertic ov gray edg b order avoid confus usual refer vertic ov henc vertex ov orient correspond gray edg orient unori otherwis let e vertex ov denot re revers act gray edg correspond e denot ne set neighbor e ov includ e itself denot one subset ne contain orient vertic une subset ne contain unori vertic section prove orient vertex e exist ov exist orient vertex f one rf proper safe also describ algorithm nd proper safe revers permut contain least one orient edg start follow use observ observ let e vertex ov let obtain ov follow oper complement graph induc ov ne feg ip orient everi vertex ne feg e orient ov remov ov exist orient edg e ov note e orient vertex compon ov feg may split sever compon ov compar gure c b denot compon k e k refer simpli whenev e clear context let c cliqu orient vertic ov say c happi everi orient vertex e c everi vertex f c e f eov exist orient vertex g c g e eov g f eov exampl overlap graph shown figur c f g f g happi cliqu f g not rst theorem claim one vertic happi cliqu dene safe proper revers theorem let c happi cliqu let e vertex c everi e c revers re safe proof let assum contradict e unori assum exist ne c clearli must orient ov sinc c happi must also orient neighbor adjac e ov stay orient adjac ov contradict assumpt unori henc may assum ne let z une vertex z orient ov adjac ov obtain contradict henc z adjac must adjac ov henc obtain une uni ov corollari impli compon cannot contain alon thu must neighbor x x adjac e ov thu obtain x y ov x e ov x unori ov sinc alreadi prove une uni impli une uni contradict choic e exampl theorem impli revers dene gray edg safe proper revers permut figur a sinc correspond vertex maximum unori degre happi cliqu g hand revers dene creat new unori compon yield permut shown figur follow theorem prove happi cliqu exist neighborhood orient edg theorem let e orient vertex ov exist orient vertex f one compon ov orient proof theorem suce show exist happi cliqu c one exist onx oneg is ext contain orient neighbor e orient neighbor outsid one case case ext one feg let cliqu let k j maxim cliqu j dene nal cliqu set straightforward verifi two case c inde happi cliqu next section describ algorithm nd orient edg e re safe given represent ov describ section algorithm rst nd happi cliqu c search vertex maximum unori degre c accord theorem vertex dene safe revers even though theorem guarante exist happi cliqu neighborhood xed orient vertex algorithm search one particular neighborhood prove algorithm guarante nd happi cliqu assum exist least one orient edg therefor algorithm provid altern proof weaker version theorem claim exist happi cliqu somewher graph find happi cliqu section give algorithm locat happi cliqu ov let e orient vertic ov increas left endpoint order algorithm travers orient vertic ov accord order let le re left right endpoint respect vertex e realiz ov travers e algorithm maintain happi cliqu c subgraph ov induc vertic assum jc vertic c vertic c maintain link list order increas left endpoint order exist interv contain interv c algorithm maintain minim interv cliqu c vertex if exist satisfi follow invari invari everi vertex e l c l i le must adjac ie adjac vertex c either adjac interv e p re p le adjac fact c happi subgraph induc e invari initi algorithm set c g initi dene let current interv e i re j guarante happi ov sinc remain orient vertic adjac c henc algorithm stop return c answer see figur a assum le i show obtain c i i consid follow case case interv dene figur b case interv dene re i a obtain ad e i c figur c cliqu c i consist e i alon figur d c previou case c g case i set e j last interv c see figur e follow theorem prove algorithm produc happi cliqu theorem let c l current cliqu algorithm stop c l happi cliqu ov proof straightforward induct number orient vertic travers algorithm prove c l l satisfi invari algorithm stop either re l equal number orient vertic either case sinc c l happi subgraph induc e must happi ov run time algorithm proport number orient vertic travers sinc constant amount work perform vertex search happi cliqu locat happi cliqu c ov need search vertex maximum number unori neighbor section give algorithm perform task e c fig variou case algorithm nding happi cliqu topmost interv alway three thick interv compris c dot interv correspond e i interv c order increas left endpoint order clearli rj thu endpoint j vertic c partit line j algorithm consist follow three stage stage let e unori vertex nonempti intersect interv l rj mark es endpoint index interv contain it stage let array j counter correspond vertex c intent assign valu sum p l oi unori degre vertex e l c counter initi zero unori vertex e overlap interv l rj chang four counter follow let l r interv le re occur respect may assum l r otherwis e adjac vertex c ignor it continu accord one follow case case r j vertic e l e r adjac e increment ol decrement or case j l vertic e l j e r j adjac e increment decrement case l j j r let vertic e e adjac e increment o decrement om vertic e l e j adjac e increment counter ol stage comput jg return e f follow theorem summar result section omit proof straightforward theorem given cliqu c vertex e f c comput algorithm maximum unori degre among vertic c complex algorithm proport size c plu number unori vertic ov henc on clear hurdl case unori compon ov exist sequenc r revers transform t dhe section summar character given hannenh pevzner revers outlin nd use implicit represent ov use follow denit revers merg hurdl h h act two breakpoint one incid gray edg h incid gray edg h recal circl cr dene section endpoint edg unori compon ov order consist order two hurdl h h consecut set endpoint occur consecut cr ie hurdl h eh separ eh eh cr follow lemma essenti prove hannenh pevzner though state dierent paper lemma let permut even number say k hurdl sequenc k revers merg two nonconsecut hurdl follow revers merg remain two hurdl transform orient compon lemma let permut odd number say k hurdl least one hurdl h simpl revers act two breakpoint incid edg h transform k hurdl d fortress sequenc k revers merg pair nonconsecut hurdl follow two addit merg pair consecut hurdl one merg two origin hurdl next merg hurdl creat rst last origin hurdl transform orient compon outlin turn lemma algorithm nd particular sequenc revers r properti describ abov first ov decompos connect compon describ one identifi unori compon hurdl task done travers endpoint circl cr count number element run consecut endpoint belong compon run contain endpoint particular unori compon hurdl similar fashion one check hurdl whether simpl hurdl super hurdl travers cycl list hurdl order occur cr creat next stage list use identifi correct hurdl merg assum given endpoint one locat connect compon constant time easi verifi data maintain possibl theorem given ov decompos connect compon algorithm outlin nd revers appli obtain hurdlefre t algorithm implement run on time proof correct follow lemma time bound achiev alway merg hurdl separ singl hurdl ith merg merg hurdl h h separ h h merg st merg carri merg way guarante span hurdl h overlap two merg revers second elimin h summari figur give schemat descript algorithm algorithm sign revers sign permut comput connect compon ov clear hurdl sort iter begin a nd happi cliqu c ov b nd vertex e f c maximum unori degre perform safe revers e f c updat represent ov output sequenc revers fig algorithm sort sign permut theorem algorithm sign revers nd revers distanc r n time particular on time proof correct algorithm follow theorem theorem lemma algorithm berman hannenh take on time theorem step take on time per revers discuss section intrigu open question whether faster algorithm sort sign permut revers exist certainli might case one nd optim sequenc revers faster date nontrivi lower bound known problem acknowledg thank donald knuth sridhar hannenh pavel pevzner itsik peer comment preliminari version paper r zum hilbertshen aufbau der reelen zahlen sort permut transposit siam journal comput fast sort revers dicult invers chromosom drosophila pseu doobscura algorithm graph theori perfect graph polynomi algorithm comput transloc distanc genom transform men mice polynomi algorithm genom distanc problem transform cabbag turnip polynomi algorithm sort sign permut revers includ parallel invers faster simpler algorithm sort sign permut revers physic map chromosom use uniqu probe tricircular mitochondri genom brassica raphanu revers repeat con evolutionalri signi edit distanc genom comparison base nonloc oper genom diverg gene rearrang tr ctr tannier ann bergeron mariefr sagot advanc sort revers discret appli mathemat v n p april ann bergeron elementari present hannenhallipevzn theori discret appli mathemat v n p march glenn tesler effici algorithm multichromosom genom rearrang journal comput system scienc v n p novemb adam c siepel algorithm enumer sort revers proceed sixth annual intern confer comput biolog p april washington dc usa max a alekseyev pavel a pevzner color de bruijn graph genom halv problem ieeeacm transact comput biolog bioinformat tcbb v n p januari haim kaplan elad verbin sort sign permut revers revisit journal comput system scienc v n p may isaac elia tzvika hartman approxim algorithm sort transposit ieeeacm transact comput biolog bioinformat tcbb v n p octob severin berard ann bergeron cedric chauv christoph paul perfect sort revers alway difficult ieeeacm transact comput biolog bioinformat tcbb v n p januari