t strong normaliz nondeterminist catchthrow calculi a catchthrow mechan common lisp provid simpl control mechan nonloc exit studi type calculi nakano sato formal catchthrow mechan calculi correspond classic logic curryhoward isomorph one characterist point nondeterminist reduct rule calculi repres variou comput mean classic proof paper mainli concern strong normaliz calculi name prove strong normaliz calculi open problem first formul nondeterminist variant parigot calculu show strongli normal translat catchthrow calculi variant sinc translat preserv type reduct obtain strong normal catchthrow calculi also briefli consid secondord extens catchthrow calculi copyright elsevi scienc bv b introduct catch throw mechan provid mean implement nonloc exit follow simpl exampl written common lisp show use catch throw mechan defun multipli x catch zero multipli x defun multipli x if null x if car x car x multipli cdr x rst function multipli set catchpoint tag zero immedi call second function second one multipli perform actual comput recurs given list integ calcul multipl member list found list result must without comput further return throwexpress catchthrow mechan use one want escap nest function call time especi runtim error nakano propos calculi infer rule give logic interpret catchthrow construct lisp calculi dier actual catchthrow construct common lisp follow two way chang scope rule catchconstruct dynam one lexic one exampl express throw zero lexic scope correspond catchexpress indic catchexpress dynam scope common lisp nakano calculi tag variabl rather constant correspond throw catch repres ordinari variabl bind mechan scope binder lexic introduc tagabstract tagappl mechan exist common lisp motiv recov express lost chang scope rule catchconstruct let us see exampl written nakano style defun multipli x catch zero multipli x zero defun multipli x u if null x if car x throw u car x multipli cdr x u modi program catchconstruct lexic scope scope tag zero multipli x zero onli throw object anoth function multipli function abstract tag variabl u use function multipli must provid tag zero second paramet nakano also introduc new type constructor call otherwis tag abstract mechan term type a u tagvari type b abstract u type b characterist point nakano formul l ct restrict side condit implicationintroduct rule exclud term correspond classic proof actual l ct correspond intuitionist calculu curryhoward isomorph l ct allow mani reduct possibl henc nondeterminist not con uent two featur may look strang sinc classic logic said essenti noncon uent intuitionist logic con uent consid classic version l ct obtain remov restrict natur calculu suitabl extract algorithm mean classic proof call l k ct classic version l ct similarli except mechan standard ml dynam scope except mechan standard ml abstractionappl refer girard parigot discuss con uenc classic logic year later nakano second author sato propos anoth formul catchthrow mechan motiv elimin type tag abstract otherwis l ct sinc equival disjunct unifi throwexpress tagabstract mechan obtain simpler calculu nj ct also show l ct interpret nj ct nj ct essenti restrict implicationintroduct rule henc correspond intuitionist logic also dene nk ct throw away restrict show correspond classic logic summari propos four calculi catchthrow mechan author intuitionist logic classic logic nakano l ct l k ct sato nj ct nk ct paper investig strong normaliz sn four calculi particular l k ct nk ct sn l ct prove nakano proof base complex modeltheoret argument previou work prove sn nj ct sn larg fragment l k ct sn full fragment classic calculi l k ct nk ct open problem paper solv problem arm way rst formul nondeterminist variant parigot calculu ad sever reduct rule prove strong normaliz use reduc method translat catchthrow calculi variant sinc translat preserv type well reduct obtain proof strong normaliz four calculi nalli brie discuss secondord extens them catchthrow calculi nakano formul nakano propos sever calculi catchthrow mechan among them l ct given strongest one paper also studi l k ct extens l ct although nakano present l k ct publish paper latter obtain l ct simpli throw away restrict implic introduct rule therefor regard l k ct one nakano calculi follow shall dene l k ct mention dierenc l k ct l ct assum nite mani atom type we use k metavari atom includ falsiti denit type denit _ type function space product sum curryhoward isomorph may identifi logic connect implic conjunct disjunct connect introduc give type tag abstract usual abbrevi a assum that type a innit mani individu variabl x type innit mani tag variabl u type a use x z individu variabl u v w tag variabl regard u u b dierent tag variabl b impli may sometim use variablenam dierent entiti dierent type preterm l ct l k ct dene follow denit preterm among preterm abov construct catch throw tapp introduc nakano repres catch throw mechan refer follow tabl correspond similar construct common lisp standard ml ct common lisp standard ml note introduct tag common lisp except name standard ml repres tagvari rather constant preterm ut tagabstract mechan like abstract xt preterm tappt u tagappl mechan like function applic applyt u sometim omit type variabl also write applya b ab individu variabl bound construct caseconstruct tag variabl bound catchconstruct construct identifi two term equival renam bound individualtag variabl fvt ftvt denot set free individu variabl set free tag variabl t respect type infer rule given natur deduct style list tabl infer rule use deriv judgment form nite set form fx g nite set form g set understand variabl appear onc context individu variabl context tag variabl l ct implicationintroduct rule mark restrict free tag variabl b l k ct restrict intuitionist calculu l ct preterm x b welltyp x essenti occur scope throwconstruct b one nakano main result that restrict neatli correspond intuitionist proposit calculu curryhoward isomorph actual actual nakano use word tapp rather simpli wrote tu tappt u paper use dierent function symbol dierent termconstruct clarifi syntax tabl type infer rule l ct l k ct restrict complex due exist caseconstruct paper give precis denit essenti occurr refer detail among infer rule rst ten standard rule throw catch ect intend semant name abort current context term type regardless type b type catchu a also type possibl thrown term term u b a tagabstract assign new type b convers type b appli tag variabl u b gener term type a exampl type infer follow which correspond doubl negat ag one type infer gure l k ct l ct becaus format x throwu x abstract variabl x occur free throwu nakano restrict let a b c metavari term deriv infer rule say term type context onestep reduct rule l ct l k ct given tabl tabl onestep reduct rule l ct l k ct x x fv a denit c repres context hole dene usual also substitut abx avu dene usual instanc follow reduct tappvthrowv instead onestep reduct like catchu athrowu bx b catchthrow mechan split two step follow sinc restrict evalu strategi reduct l k ct nondeterminist moreov con uent instanc follow reduct sequenc put catchu dene b zero step reduct b one step reduct usual theorem nakano subject reduct properti hold l ct l k ct sato formul sato propos anoth formul catchthrow mechan primari motiv get rid logic connect l k ct yet obtain system power l k ct logic point view redund sinc equival disjunct sato success elimin calculu unifi two binder tag variabl catch shall give denit nk ct follow nj ct obtain nk ct restrict introduct rule way l ct l k ct type l ct delet preterm dene follow denit preterm individu variabl bound caseconstruct tag variabl bound construct construct replac catch l ct construct replac throw l ct tapplyconstruct replac tapp l ct type infer rule new construct given tabl tabl type infer rule nj ct nk ct infer rule construct throw l ct term u may construct even type dier b mean u b a that comput end normal return return inj a term b thrown comput a return inj b henc u b a type _ b type a tapplyconstruct may dicult understand invers oper tag abstract tapplyu b reduc av b u b type infer rule construct befor calculu restrict implic introduct rule call nj ct one without restrict nk ct former correspond intuitionist logic latter classic logic onestep reduct rule new construct given follow a if u ftva last reduct may look strang use write concis proof necessari simul reduct tappva u auv l ct l k ct theorem sato subject reduct properti hold nj ct nk ct nondetermin classic logic four calculi catchthrow mechan nondeterminist reduct rule con uent think defect becaus far strong normaliz concern good mani reduct rule possibl corollari strong normaliz strongest calculu obtain strong normaliz subcalculu classic logic said inher nondeterminist order express possibl comput classic proof calculu nondeterminist later choos one answer xing evalu strategi murthi gave exampl show classic proof may contain multipl comput mean second author show murthi exampl express nk ct style calculu nondeterminist variant parigot section give nondeterminist variant parigot target translat catchthrow calculi parigot calculu secondord proposit calculu classic logic naturaldeduct system whose sequent multipl consequ calculu quit nice formul classic logic time comput interest sinc variou control structur repres construct whose type given follow import reduct rule construct call structur reduct is afc cbg term obtain substitut cb everi subterm form c free a refer denit calculu simul simpli version catchthrow mechan l k ct construct follow catchu a uua throwu a vua where v appear ua howev catchthrow calculi consid con uent moreov one term reduc dierent variabl x saw previou section sinc calculu con uent calculu direct simul catchthrow calculi possibl possibl solut add reduct instanc callbyvalu version structur reduct the symmetr structur reduct howev known system structur reduct symmetr structur reduct strongli normal instead naiv ad reduct rule slightli modifi calculu add nondeterminist reduct name classifi use three case uua uva u ftvva uva u v u ftva need simul catchconstruct throwconstruct respec tive need extend reduct rule reduct rule remain same need simul catchthrow calculi term construct exclud anoth modic calculu longer distinct individu variabl tag variabl name term ua repres ordinari applic ua modic directli abstract variabl correspond name key simul tagabstractiontag applic mechan l k ct represent essenti due de groot formal except mechan ml fujita recent studi similar calculu except mechan notat conveni write ua term uua abortva term uva also extend reduct rule abortconstruct nondeterminist featur call result system nd nondeterminist calculu nd type nd dene follow denit type recent fujita indic system shown strongli normal translat barbanera berardi symmetr calculu restrict system rstorder howev need secondord version paper sinc nd secondord type redund logic point view we howev includ primit type sinc want interpret dierent xx type variabl x bound type abstract x identifi two type ident modulo renam bound type variabl abbrevi a preterm follow note adopt currystyl implicit type nd calculu henc attach type variabl consid reduct rule denit preterm contrari origin one sort variabl variabl x may use ordinari variabl also name a tagvari sens also distinct ordinari term name term variabl bound construct identifi two term dier bound variabl preterm abortt new nd explain abov judgment nd form nite set form g type infer rule deriv judgment shown tabl tabl type infer rule nd introduct rule mark x may occur freeli deriv use rule say typabl term type sometim written a reduct rule deriv calculu ad sever rule abort make nd nondeterminist sinc shall use substitut parigot also dene churchstyl system tabl onestep reduct rule nd form xuxbu mani time abbrevi b u use notat alway assum x fresh variabl also abbrevi composit substitut often write b sequenc hb b n i henc success applic ab b n abbrevi b success substitut last case assum b b n contain u free also use simultan substitut b x um mutual distinct c contain u befor use notat b b follow lemma prove easili lemma let substitut b x um b b strong normaliz nd subsect prove strong normaliz sn nd proof slight modic parigot origin proof sn nevertheless give proof complet let set preterm nd sn set strongli normal preterm nd note restrict nd subset typabl term follow a maximum length reduct sequenc start sn unden sn f let f set nite sequenc element f name particular f contain empti sequenc hi let f g subset subset introduc follow notat special case g denit reduc candid reduc candid subset induct dene follow sn reduc candid f g reduc candid f g ff g ii famili reduc candid nonempti set i reduc candid note index set may innit set reduc candid denot rc lemma f rc follow four claus hold f sn variabl contain f sn aborta f exist set sn claus ad parigot origin proof mean aborta strongli normal term contain reduc candid main dierenc proof parigot that case term form caborta may reduc aborta alway consid aborta reduct howev term contain reduc candid strongli normal lemma therefor alway handl term easili proof prove four claus simultan induct f rc case f sn claus prove take fhig s claus trivial case f g induct hypothesi abbrevi ih x prove claus ih g sn exist set sn take g g prove claus let x variabl sn b sinc reduct form xb n abortdbk b prove claus also abortab prove claus case f easili prove ih also ih sn g prove claus ut claus lemma put f largest s name preterm neutral either variabl form bc lemma f rc follow two claus hold f f neutral f f proof lemma prove induct f rc key case f g h shall prove claus onli suppos neutral g h take arbitrari preterm b g shall prove ab h induct a b sinc b sn preterm ab reduc one step either one b with ab with abortcx abortd with b b abortdx easili prove four term belong h ih ab h consequ g h ut denit interpret type interpret map type variabl reduc candid note exist interpret map type variabl sn interpret natur extend type follow way interpret fx dene x lemma let a b type interpret lemma prove induct structur a lemma let f rc x u variabl a b term c sequenc term abx f b sn xab f u ad udc sn c c sn u sn proof prove claus induct abx b use lemma lemma must take care reduct xab may form abortc case treat use claus lemma prove claus induct u ad udc claus abov prove ubc sn b f sinc prove analyz reduct rule ut theorem assum deriv nd assum also interpret b rst look statement theorem look ambigu instanc given proof x c d a may split lefthand side two way result follow conclus hold b c b d hold b c c d actual theorem impli hold ambigu aris state proof theorem proof theorem prove induct type infer a let substitut b x case assumptionrul case x prove x a two subcas i x x i c x b assumpt b c x a ii x u i d x zu zc lemma x d case introduct case x c b c c term type c suitabl renam x c take b ih henc lemma x cd c henc c case elimin case bc henc bc a case introduct case x b b deriv let f rc fx sinc type variabl x occur freeli b m henc ih b final x b case elimin case x b bcx x b ih henc cxb lemma bcx case introduct case ub b a suitabl renam u b ih henc b c sn therefor claus lemma u b c sn claus lemma u bc sn consequ case elimin case abortb ih b abortb a ut choos x m theorem abov obtain a term type interpret sinc exist interpret a sn follow theorem corollari nd strongli normal translat catchthrow calculi nd section give translat catchthrow calculi nd follow give translat classic catchthrow calculi l k ct nk ct translat work also l ct nj ct sinc subcalculi translat nakano calculu shall translat l k ct nd translat standard encod proposit logic secondord logic except catchthrowconstruct first translat type other l k ct variabl nd point type ab translat b a translat ect intent abstract translat abstract translat preterm l k ct nd assum that individu variabl x l k ct x variabl nd tag variabl u l k ct u variabl nd also assum map variabl inject preterm translat follow x x aborta aborta x a xa ab ab a axyx a xyxa tappa translat extend context variabl follow way let context individu variabl fx context tag variabl l k ct dene note type tag variabl negat translat translat preserv type reduct shall see lemma preserv type assign deriv l k ct deriv nd proof sinc translat proposit connect standard verifi case onli ih a sinc fu ag fu ag a ua deriv fu ag catchu a introduct rule throw ih a sinc fu ag a abortua deriv elimin rule elimin rule ih a sinc b b a deriv introduct rule tapp ih elimin rule deriv lemma translat compat substitut name abx abx av b avu lemma prove straightforward induct construct a omit lemma preserv reduct b typabl term b l k ct b nd proof lemma prove induct structur term a prove key case onli x x fva lemma athrowu bx aabortubx induct term a aabortcx abortc c aabortubx abortub catchu a u ftva sinc u fv a catchu a ua a catchu throwu catchu throwu a uabortua u fva tappua tappua v uav reduc avu lemma avu avu henc done ut lemma follow theorem theorem system l k ct strongli normal henc l ct strongli normal remark translat l k ct nd realli need second order quantier name elimin add _ nd translat ct modi calculu sinc prove sn modi calculu elementari method also prove sn l k ct elementari method howev need second order quantier translat nk ct shall see next section therefor prove sn l k ct base reduc method translat sato calculu subsect translat nk ct nd dene translat tri give naiv translat nk ct l k ct explain fail natur candid translat is type tapplya type c suppli type infer term moment let us ignor obtain c translat interpret one reduct rule nk ct except follow one lefthand side interpret tapplyua v casecatchu inj necessarili reduc avu henc naiv translat nk ct ct fail moreov seem dicult nd suitabl extens l k ct strongli normal reduc term avu howev situat chang consid secondord calculu disjunct type primit dene _ b shall see later term tapplyua v reduc avu encod let us dene translat nk ct nd translat type translat l k ct nd translat preterm except same translat new construct dene follow tapplya assum x use term a translat may look complex result secondord encod naiv translat nk ct ct translat extend context individu variabl way befor context tag variabl need chang translat sinc tag variabl type b translat variabl type c _ b c type bodi enclos express word cannot determin type c reach enclos express solv problem introduc map set tag variabl in nk ct set type nd make translat context tag variabl depend let context tag variabl fu b g map fu b n g type nd dene denit _ abbrevi dene c _ x result translat _ lemma preserv type assign deriv nk ct then map whose domain contain tag variabl deriv nd proof prove induct deriv verifi key case deriv fix map suppos otherwis proof shorter bg let map v v v u u a ih deriv a bg also fact deriv desir type infer introduct rule deriv fix ih deriv b abortuxyya deriv desir type infer elimin rule deriv ih deriv _ b bg tapplya u b axxyabortuzwwi calcul type term deriv desir type infer ut next lemma use prove preserv reduct translat lemma let typabl term nk ct let substitut xvxt v v result translat tag variabl v b nk ct xx yabortuzwwi auv nd proof prove lemma induct structur term a state key case onli case v follow reduct sequenc case tapplyb v b follow reduct sequenc lemma preserv reduct b typabl term b nd b nd proof check key case the tapplyexpress follow put xx yabortuzwwi tapplyinj tapplyinj tapplyinj tapplyinj a abortuzwwa last term u b a tapplyva u have tapplyva u vzwzat auv henc desir properti ut lemma follow theorem theorem system nk ct and henc nj ct strongli normal remark proof use second order quantier indispens give translat nk ct sinc nk ct rstorder system one may think proof use strong method sn nk ct could prove elementari method present answer question trial appli elementari method nk ct success extens catchthrow calculi given translat nd easi introduc secondord quantier four catchthrow calculi without loss nice properti strong normal sinc catchthrow calculi formul churchstyl variabl explicitli label type introduc termconstruct type abstractionappl usual let xa denot former ax latter type rule given follow introduct rule mark x may occur freeli also reduct rule xab abx ad ad rule l k ct obtain secondord catchthrow calculu l k ct similarli obtain nk ct calculi l k ct nk ct enjoy nice properti subject reduct strong normal brie mention express calculi structur integ binari tree encod secondord quantier dene function catchthrow mechan variou data type extend calculi instanc function multipli mention type follow int uufttuuf intlist wwfttwwf timesa b multipl two integ b dene usual int intlist iter type int intlist term int a zb x x fv b ifthenels express name reduc x b otherwis easili seen function multipli comput one given introduct sinc represent free structur good comput may consid anoth direct extens name may add induct data type rst author alreadi propos add induct data type nj ct without loss sn calculu show higherord function use catchthrow mechan repres extend calculu howev fulli studi direct classic catchthrow calculi left futur work conclud remark investig four catchthrow calculi nakano sato particular calculi correspond classic logic curryhoward isomorph dene nondeterminist variant parigot calculu prove strong normaliz variant gave faith translat catchthrow calculi variant corollari obtain strong normaliz four calculi also discuss extens brie y recent fujita studi exc callbynam variant de groot formul except mechan standard ml calculu subcalculu rstorder version calculu sinc catchthrow mechan except mechan essenti same motiv similar main dierenc calculu nd calculu con uent nondeterminist comput use rstorder version actual implic use secondord version calculu two sort variabl reminisc individu variabl tag variabl use one sort variabl thu directli abstract tag crolard also studi con uent calculu catchthrow mechan sinc calculu translat parigot calculu similar fujita formul thu dier calculi studi paper extract algorithm content classic proof quit activ research area mani research area aim obtain con uent calculi classic logic howev classic logic said inher nondeterminist name classic proof may contain multipl comput mean therefor want repres mani comput mean possibl natur begin nondeterminist calculi approach design studi nondeterminist calculi rst studi con uent subcalculi believ catchthrow calculi present paper good basi approach barbanera berardi calculu anoth nondeterminist calculu classic proof calculu could also good basi studi extract comput mean classic proof left futur work acknowledg would like express heart thank hiroshi nakano makoto tatsuta izumi takeuti help comment earlier work also thank kenetsu fujita point refer error anonym refere valuabl comment improv author support part grantinaid scientic research ministri educ scienc cultur japan no no r proof type cambridg univers press a classic catchthrow calculu tag abstract strong normaliz tr common lisp languag proof type formulaeastyp notion control intuitionist classic natur deduct system catch throw rule lambdamycalculu extract construct content classic logic via controllik reduct simpl calculu except handl classic brouwerheytingkolmogorov interpret ctr emmanuel beffara vincent dano disjunct normal form local except acm sigplan notic v n p septemb