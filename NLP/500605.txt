t learn onevari pattern languag effici averag parallel ask queri a pattern finit string constant variabl symbol langaug gener pattern set string constant symbol obtain pattern substitut nonempti string variabl studi learnabl onevari pattern languag limit respect updat time need comput new singl hypothesi expect total learn time taken converg correct hypothesi result follow first design consist setdriven learner that use concept descript pattern achiev updat time onlogn n size input sampl best previous known algorithm comput descript onevari pattern requir time onlogn cf angluin j comput system sci second give parallel version algorithm requir time ologn onlogn processor erewpram third use modifi version sequenti algorithm subroutin devis learn algorithm onevari pattern whose expect total learn time ollogl provid sampl string drawn target languag accord probabl distribut expect string length l probabl distribut must string equal length equal probabl arbitrari otherwis thu establish first algorithm learn onevari pattern languag expect total learn time provabl differ updat time constant factor onli final show algorithm descript onevari pattern use learn onevari pattern polynomi number superset queri respect onevari pattern queri languag b introduct pattern string constant symbol variabl symbol languag gener pattern set string obtain substitut string constant variabl cf pattern languag variat thereof wide investig cf eg continu interest pattern languag mani reason among learnabl full version paper avail technic report cf limit pattern languag text cf moreov learnabl pattern languag interest respect potenti applic cf eg given thi effici becom central issu howev defin appropri measur effici learn limit difficult problem cf variou author studi effici learn term updat time need comput new singl guess realli count applic overal time need learner converg ie total learn time one show total learn time unbound worstcas thu studi expect total learn time purpos motiv shortli summar known regard pattern languag learn output descript pattern hypothes cf result learn algorithm consist setdriven learner setdriven iff output depend rang input cf eg gener consist setdriven consider limit learn capabl cf eg polynomi time algorithm comput descript pattern known henc alreadi updat time practic infeas moreov find descript pattern maximum possibl length npcomplet cf thu unlik polynomialtim algorithm comput descript pattern maximum possibl length therefor natur ask whether effici pattern learner benefit concept descript pattern special case eg regular pattern noncross pattern union k regular pattern languag k priori fix studi case descript pattern polynomialtim comput cf eg thu learner achiev polynomi updat time noth known expect total learn time anoth restrict obtain priori bound number k differ variabl occur pattern kvariabl pattern open polynomialtim algorithm comput descript kvariabl pattern fix k cf hand kvariabl pattern paclearn respect union kvariabl pattern hypothesi space cf lang wiehagen provid learner lwa pattern languag may output inconsist guess lwa achiev polynomi updat time setdriven cf even iter thu beat angluin algorithm respect space complex lwa expect total learn time exponenti number differ variabl occur target pattern cf moreov point converg lwa definit depend appear suffici mani shortest string target lan guag algorithm mention least correspond correct proof depend it thu follow problem aris natur exist effici pattern languag learner benefit concept descript pattern therebi depend present suffici mani shortest string target languag still achiev expect total learn time polynomi bound expect string length provid complet affirm answer studi special case onevari pattern believ case natur choic sinc nontrivi there may exponenti mani consist pattern given sampl sinc first case polynomi time algorithm comput descript pattern known cf angluin algorithm find descript pattern run time on log n input size n alway output descript pattern maximum possibl length awar possibl improv run time certain special case hope studi would provid insight uniform improv present improv ie algorithm comput descript onevari pattern on log n step key idea achiev goal give necessarili find descript pattern maximum possibl length note result concern difficulti find descript pattern depend addit requir comput one maximum possibl length cf eg thu result may least support conjectur effici learner may aris one definit tri find descript pattern maximum possibl length descript one instead moreov algorithm also effici parallel use ologn time on n processor erewpram previous effici parallel algorithm learn onevari pattern languag known main result version sequenti algorithm still learn onevari pattern languag expect total learn time o log sampl string drawn target languag accord probabl distribut expect string length arbitrari except string equal length equal probabl particular shortest string may probabl note expect total learn time differ constant factor time need updat actual hypothes hand could prove olog mani exampl suffici achiev converg final deal activ learn learner gain inform target object ask queri oracl show algorithm descript onevari pattern use learn onevari pattern ask polynomi mani superset queri anoth algorithm learn pattern languag polynomi number superset queri known use much power queri languag ie pattern one variabl even target pattern onevari pattern cf pattern languag induct infer set natur number let real number x defin bxc greatest integ less equal x let finit alphabet contain least two element denot free monoid a denot set finit nonnul string a ie denot empti string let ing infinit set variabl pattern string length string pattern denot jsj jj respect pat denot set pattern i denot ith symbol eg i call constant otherwis i x ie i variabl use si denot ith symbol var denot number differ variabl occur x denot number occurr variabl x kvariabl pattern pat k denot set kvariabl pattern case denot variabl occur x denot string obtain substitut u j occurr x j tupl call substitut everi pattern pat k defin languag gener pat k denot set kvariabl pattern languag denot set pattern languag a note sever problem decid even effici solvabl pat undecid npcomplet pat exampl gener pattern languag word problem npcomplet cf inclus problem undecid cf problem decid linear time onevari pattern languag hand pat still incompar regular context free languag finit set call sampl pattern consist sampl l onevari pattern call descript consist consist one pattern l ae l next defin relev learn model start induct infer languag text cf eg let l languag everi infinit sequenc string text l textl denot set text l let text r in set r initi segment length r denot rang r ie rg defin induct infer machin abbr iim algorithm devic take input initi segment text t output everi input pattern hypothesi cf definit pat call learnabl limit text iff iim everi l pat everi textl r in t r defin pat almost r in t r learnabl onevari pattern languag defin analog replac pat pat pat pat respect deal setdriven learner often technic advantag describ depend relev set r ie sampl obtain input let refer n size sampl s studi noneras substitut eras substitut also consid variabl may replac lead differ languag class cf pat well pat constitut index class l uniformli recurs languag ie effect enumer l j jin l recurs function f j fj except section use prammodel assum model comput represent pattern next defin updat time total learn time let iim everi l pat least number r stage converg t tm t r denot time comput t r call tm t r updat time total learn time taken iim success input defin final defin learn via queri object learn element index class l assum index class h well fix effect enumer hypothesi space l clearli h must compris l hypothesi h describ target languag l iff sourc inform target l queri oracl distinguish membership equival subset superset disjoint queri cf input membership queri string s output ye l otherwis queri input index j output ye queri disjoint queri otherwis repli no counterexampl return too ie string lh j the symmetr differ l h j respect alway assum queri answer truth definit angluin let l index class let h hypothesi space it learn algorithm exactli identifi target l l respect h access certain type queri alway halt output index j note learner allow one hypothesi must correct complex queri learner measur number queri ask worstcas improv sequenti algorithm present algorithm comput descript pattern pat sampl input without loss gener assum shortest string s algorithm run time on js j log js simpler much faster angluin algorithm need time log js j angluin algorithm comput explicitli represent set consist onevari pattern output descript pattern maximum possibl length avoid find descript pattern maximum possibl length thu work polynomials subset consist pattern next review establish basic properti need later obtain substitut pattern pat x pattern consist s must string ff obtain substitut ff x given consist pattern set fff denot ff moreov sampl call prefixfre jsj string prefix string s note distinct prefixfre sampl nonprefix free sampl well pay off lemma prefixfre exist descript pattern pat least two string ff start differ symbol proof let u denot longest common prefix string s pattern ux consist u shorter everi string s sinc prefixfre consequ exist descript pattern pat know exist pattern pat longest common prefix string s conclud a henc least two string ff ux must start differ symbol g conss subset consist pattern s prefixfre lemma let prefixfre sampl conss everi maximum length descript s proof let prefixfre accord lemma exist descript pattern belong conss thu conss now suppos maximum length descript s thu and moreov exist pattern pat l well l ae l henc lemma know obtain substitut pattern x sinc least two string ff start differ symbol immedi get x moreov least two string ff must also start differ symbol henc conss note jj sinc otherwis contradict l ae l final jj may conclud contradict maximum length thu pattern exist henc descript next explain handl nonprefixfre sampl algorithm check whether input sampl consist singl string s happen output termin otherwis test whether prefix string case output ux pat u prefix length js termin clearli lux suppos pattern l l ae lux lemma appli ie thu l consequ ux descript otherwis jsj prefix string s thu lemma suffic find output longest pattern conss improv algorithm prefixfre sampl base fact jconssj bound small polynomi let k l in k call pattern x l occurr constant k lpattern k lpattern length k thu k lpattern conss satisfi js refer length string substitut occurr x relev k lpattern obtain therefor bj jkc possibl valu l fix valu k henc number possibl k lpair k lpattern conss exist bound algorithm consid possibl k lpair turn describ algorithm one specif k lpair k lpattern conss string ff ff must satisfi substr length start first posit input string differ js i consist k lpattern comput perform k lpair follow lemma show k lpattern conss uniqu exist all lemma let prefixfre sampl everi given k lpair one k lpattern conss proof lemma directli yield algorithm below either return uniqu k lpattern conss nil k lpattern conss assum subprocedur take input sampl s return longest common prefix u algorithm input k l u follow l b k c l els l l return els return nil fi note minor modif algorithm perform consist test even construct put lemma fact oj possibl k lpair togeth directli obtain lemma prefixfre sampl g use algorithm subroutin algorithm find descript pattern prefixfre sampl follow strategi exemplifi abov thu simpli comput pattern conss output one maximum length input size n overal complex algorithm on js j log js on log n sinc oj j log js test must perform time complex on each algorithm input follow pi k js output maximumlength pattern p note number k lpair process often smaller oj sinc condit js restrict possibl valu k string equal length also advantag process k lpair order nonincreas k l algorithm termin soon find first consist pattern howev worstcas complex improv descript pattern x final summar main result obtain follow theorem theorem use algorithm subroutin pat learn limit setdriven consist iim updat time on log n input sampl size n effici parallel algorithm wherea ram model gener accept suitabl model develop analyz sequenti algorithm consensu yet reach area parallel comput pram model introduc usual consid accept compromis pram consist number processor local memori execut local program commun exchang data share memori variant pram model differ constraint simultan access memori locat differ processor crewpram allow concurr read access concurr write ac cess eas present describ algorithm crewpram model algorithm modifi run erewpram howev use standard techniqu comput descript onevari pattern known previous algorithm effici parallel use wellknown techniqu includ prefixsum treecontract listrank subroutin cf parallel algorithm handl nonprefixfre sampl way algorithm check singleton prefix string requir time olog n use on log n processor thu may assum input sampl prefixfre addit assum prefixtest return first posit input string differ index t parallel algorithm handl oj j log js possibl k lpair par allel k lpair algorithm comput uniqu candid k lpattern conss exist check whether l again suffic output obtain pattern maximum length next show effici parallel two step given k lpair algorithm use string calcul uniqu candid k lpattern conss reduc processor requir modif lemma show candid pattern remain uniqu posit j said bcorrespond posit j k mean bcorrespond posit follow suppos consist k lpattern fs posit j correspond i i jj b occurr x left i i correspond posit comput candid pattern algorithm calcul entri array equalj b boolean valu first j rang js j b k equalj b true iff symbol posit j symbol bcorrespond posit thu array defin follow equalj array equal okj entri calcul constant time thu use okj log n processor equal comput time olog n moreov direct graph g forest binari intre built equal candid pattern calcul g use treecontract prefixsum listrank detail omit due space restrict thu prove lemma let sampl n size given array equal uniqu candid k lpattern conss nil pattern exist comput erewpram time ologn use okj processor now algorithm either discov k lpattern exist obtain candid k lpattern latter case test whether consist s lemma given candid pattern consist sampl size n check time ologn use on log n processor crewpram put togeth obtain follow theorem theorem exist parallel algorithm comput descript onevari pattern time ologn use oj n processor crewpram sampl size n note product time number processor algorithm time spent improv sequenti algorithm larger product exce time sequenti algorithm factor less oj analyz expect total learn time now deal major result present paper ie expect total learn time sequenti learner let target pattern total learn time algorithm tri infer unbound worst case sinc infinit mani string l mislead it howev best case two exampl ie two shortest string x x alway suffic learner output descript pattern guess henc assum string present algorithm drawn l accord certain probabl distribut comput expect total learn time algorithm distribut must satisfi two criteria two string l equal length must equal probabl expect string length must finit refer distribut proper probabl distribut design algorithm la infer pattern pat expect total learn time o log advantag calcul descript pattern time new string read instead algorithm la read certain number string start perform comput all wait length sampl string smaller number sampl string read far least two differ sampl string read first two phase output first sampl string guess sampl string read far same x otherwis constant pattern correct hypothesi alway output algorithm never reach third phase otherwis algorithm use modifi version algorithm calcul set p candid pattern enter phase precis calcul whole set p onc instead use function first cand obtain longest pattern p function next cand repeatedli obtain remain pattern p order nonincreas length substanti reduc memori requir pattern obtain call first cand use current candid new string compar l output otherwis next cand call obtain new candid now current candid output independ l longest common prefix sampl string includ shorter sampl string exclud s howev first cand call new list candid pattern consid thu algorithm la may output inconsist hypothes algorithm la shown figur let defin follow string w fvxg otherwis denot u longest common prefix set pattern comput algorithm omit consist check henc p conss conss defin section p necessarili contain pattern s l longest common prefix longest constant prefix assum t first cand s return return i sinc omit consist check call first cand subsequ call next cand either correct pattern found prefix chang perform time ojsj log jsj show algorithm la correctli infer onevari pattern languag text limit correctli infer onevari pattern languag text probabl sampl string drawn l accord proper probabl distribut theorem let arbitrari onevari pattern algorithm la correctli infer text limit note learn languag l limit learn l string drawn l accord proper probabl distribut same r repeat r r string sr string sr f phase g shortest string fs prefix fs string fs longer els string fs differ posit juj first candss forev read string u prefix common prefix first candss els output hypothesi od fig algorithm la theorem let pat sampl string drawn l accord proper probabl distribut algorithm la learn probabl proof output read first string converg otherwis let string gamma constant symbol pat fg algorithm la read two string differ posit d pattern one candid set p implicitli maintain algorithm string r r satisfi d r d probabl jaj gamma jaj event must happen probabl that long current candid differ probabl next string read belong l least cf lemma below henc candid pattern discard probabl current candid output that algorithm converg lemma let ux onevari pattern constant prefix u arbitrari juj let pattern p fs gener string drawn l accord proper probabl distribut probabl least jaj gamma jaj now analyz total expect learn time algorithm la obvi ousli total expect learn time o target pattern henc assum follow contain least one occurr x next recal definit median establish basic properti use later er denot expect random variabl r definit let r random variabl ranger in median r number ranger prr prr proposit let r random variabl ranger median satisfi er lemma let proper probabl distribut let l random variabl take valu length string drawn l respect d let median l let expect then expect number step perform algorithm la phase o proof let l random variabl whose valu length ith string read algorithm clearli distribut l l let r random variabl whose valu number string algorithm la read phase let l sigma lr number symbol read algorithm la phase let w random variabl whose valu time spent algorithm la phase obvious w claim have el el l must least provid r i equat prove follow similarli shown el r furthermor clear el r now rewrit el sigma el el sigma r el sigma use well equat obtain el fi use equat obtain el use r assumpt lemma estim expect number step perform phase follow lemma phase expect number step perform algorithm la o final deal phase again let l lemma then averag amount time spent phase estim follow lemma phase expect number step perform call function first cand next cand o log lemma phase expect number step perform read string o log proof denot w rthe number step perform read string phase make distinct string read correct set candid pattern consid string read afterward end phase former account random variabl v latter v correct set candid pattern ie set contain yet consid probabl new string forc correct set candid pattern consid denot k random variabl whose valu number string read phase correct set candid pattern consid have assum correct set candid pattern p contain pattern consid pattern pattern probabl string drawn l accord proper probabl distribut languag either addit variabl addit constant symbol lemma denot v step perform read string ith pattern p consid log r obtain oel log oelr log r henc ew r lemma phase expect number step perform check whether current candid pattern gener newli read sampl string o log put togeth arriv follow expect total learn time requir algorithm la theorem sampl string drawn l accord proper probabl distribut expect string length expect total learn time algorithm la o log learn superset queri pat learnabl polynomi mani queri equival membership subset queri allow provid result may easili extend pat howev posit result also known first pat exactli learnabl use polynomi mani disjoint queri respect hypothesi space pat fin fin set finit languag cf proof techniqu easili extend pat too second angluin establish algorithm exactli learn pat respect pat ask ojj jjjaj mani superset queri howev requir choos gener pattern ask queri definit work hypothesi space pat henc natur ask exist superset queri algorithm learn pat respect pat use polynomi mani superset queri use result previou section abl answer question af firm nevertheless wherea pat learn respect pat restrict superset queri ie superset queri return counterexampl queri algorithm need counterexampl interestingli need counterexampl everi queri answer neg instead two counterexampl alway suffic next theorem show onevari pattern learnabl polynomi number restrict superset queri theorem algorithm exactli identifi l pat gener pattern length n respect pat use restrict superset queri restrict equival queri must make least jaj ngamma ngamma queri worst case furthermor show learn pat polynomi number superset queri imposs algorithm may ask singl counterexampl onli theorem algorithm exactli identifi onevari pattern languag restrict superset queri one unrestrict superset queri need least queri worst case k length counterexampl return new algorithm ql work follow see figur assum algorithm learn pattern first ql ask whether l hold case iff answer ye ql know right result otherwis ql obtain counterexampl c l ask answer no ql comput g know start c ith posit ask l lc determin case a sinc would impli ql use counterexampl queri l lc i x construct set xg construct two counterexampl differ ith posit coincid first posit els l lc i x els fc cc i xg r conss repeat maxr r r n fg l l fig algorithm ql algorithm learn pattern superset queri queri form l l pat chosen algorithm answer queri l l no algorithm ask counterexampl c w i denot prefix w length maxr maximumlength element r algorithm section comput coincid first narrow search set r candid let length shortest counterexampl s log m lemma now task left find among pattern r find remov pattern r use follow lemma lemma let impli ql test l l maximum length pattern r remov r l l iter process final yield longest pattern l l lemma guarante thu have theorem algorithm ql learn pat respect pat ask superset queri queri complex ql ojjm log m mani restrict superset queri plu two superset queri these first two queri answer no everi languag l pat length shortest counterexampl return thu queri complex ojjm log m learner compar well angluin learner which ojjjaj restrict learn pat use much power hypothesi space pat long length shortest counterexampl return larg acknowledg substanti part work done second author visit kyushu univers visit support japanes societi promot scienc grant no fifth author kindli acknowledg support grantinaid scientif research c japan ministri educ scienc sport cultur grant no r find pattern common set string induct infer formal languag posit data machin learn effici learn onevari pattern languag posit data relat two pattern compar languag parallel random access machin languag identif limit introduct parallel algorithm time infer gener pattern languag inclus undecid pattern languag polynomialtim algorithm learn kvariabl pattern languag exampl note twovari patternfind problem system learn introduct learn theori cognit comput scientist induct infer pattern eatc bulletin return pattern pattern infer formal principl languag acquisit lang wiehagen pattern languag learn algorithm averagecas analysi respect total learn time guid tour across boundari learn recurs languag tr theori learnabl system learn introduct learn theori cognit comput scientist complex induct infer pattern languag exampl queri note twovari patternfind problem determinist simul ideal parallel comput realist one prudenc condit formal languag learn polynomialtim algorithm learn italickitalicvari pattern languag exampl polynomialtim infer arbitrari pattern languag effici pram simul distribut memori machin introduct parallel algorithm lang wiehagen pattern languag learn algorithm queri concept learn polynomi time infer extend regular pattern languag inclus undecid pattern languag polynomi time infer gener pattern languag relat two pattern compar languag pattern infer guid tour across boundari learn recurs languag induct infer unbound union pattern languag posit data monoton nonmonoton induct infer function pattern parallel random access machin ctr john case sanjay jain rdiger reischuk frank stephan thoma zeugmann learn subclass regular pattern polynomi time theoret comput scienc v n p novemb thoma zeugmann learn limit stochast finit learn theoret comput scienc v n p novemb