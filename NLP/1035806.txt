t random name use waitfre share variabl a name protocol assign uniqu name key everi process set commun process construct random waitfre name protocol use waitfre atom readwrit regist share variabl process intercommun primit process privat regist read other addressesnam one use other possibl differ process ipi iqi address regist process iri way known other ini process protocol use name space size ini ioiini log ini log log ini run time readwrit share bit probabl least ioi ioiinilogsupsupini overal expect run time protocol base waitfre implement novel testsetonc object randomli fast select winner set iqi contend probabl least face strongest possibl adapt adversari b introduct name protocol concurr execut process subset n process select host process uniqu name common name space name space small prefer size n process may may name start with do result variant name problem call renam problem distribut concurr system distinct name use sometim mandatori varieti situat includ mutual exclus resourc alloc leader elect choic coordin case name protocol put good use process creat termin dynamicallya common occurr distribut concurr systemsth name space may grow number process remain bound renam procedur use size name space exampl network protocol crash duplic name perform effici small name rang found name protocol also use alloc ident resourc name permit resourc sinc algorithm waitfre see below also highli faulttoler manag assign resourc compet process correspond repetit variant name problem sequel also write key name key rang name space interprocess commun use interprocess commun share memori allow arbitrarili initi share memori dirti memori model share memori primit waitfre atom readwrit regist wide use theori distribut algorithm determinist protocol execut n process waitfre finit function f everi nonfaulti process termin protocol execut number fn step regardless process execut speed or crash failur word waitfre solut resili process crash failur random protocol waitfre fn upper bound expect number step expect taken random system execut worstcas adversari class adversari consid in result adapt adversari construct use singlewrit multiread waitfre atom regist construct use also write share variabl regist anonym commun model everi regist written exactli one process read processesthi way write process send messag process process use common index scheme process regist an initi consist number among process call optim name trivial everi process rank number among valu choos ranknumb key make problem nontrivi everi process privat regist read regist process use possibl differ index scheme is process p q address regist own process r possibl differ way known other may happen larg dynam chang system consist requir difficult imposs maintain cryptograph system consist avoid model cannot use consensu protocol testandset implement outlin symmetr share memori anoth way prevent trivial rank use symmetr share memori model share memori symmetr consist set ident process commun pool share variabl read written complex measur comput complex distribut determinist algorithm use share memori commonli express number type intercommun primit requir maximum number sequenti readwrit singl process system execut local comput usual ignor use waitfre atom readwrit regist primit primit must ultim implement waitfre singleread singlewrit waitfre atom readwrit bit that turn implement mathemat version hardwar flipflop effici implement use reduc multius multivalu regist singleread singlewrit multivalu regist reduc latter singleread singlewrit waitfre atom readwrit bit standard complex make comparison algorithm unambigu express time space complex term readwrit elementari share bit random algorithm execut process random process flip coin access random number gener random algorithm answer alway correcteach process alway get uniqu keybut small probabl protocol take long time finish use customari assumpt coin flip subsequ write share memori separ atom action express comput complex algorithm use i worstcas complex probabl ii expect complex system execut respect random process worstcas schedul strategi adapt adversari previou work agreement problem determinist model comput share memori messag pass unsolv presenc fault sur prisingli show renam problem requir nontrivi form interprocess agreement solvabl messag pass model solut tresilientup crash failur toleratedand use name space size nt take exponenti time in n protocol later transform two solut asynchron share memori model waitfre achiev run time n key rang size recent demonstr waitfre longliv share memori implement renam k n process use achiev key rang size ok determinist waitfre solut asynchron share memori model key rang size n gamma necessari result use asymmetr share memori form singlewrit multi reader waitfre atom readwrit regist step read write one regist moreov global address regist known all plethora work name problem use share memori cite discuss relev paper shown use bound symmetr share memori determinist solut random waitfre solut adapt adversari appendix imposs give waitfre random unbound symmetr share memori solut fair adapt adversari key rang size n logarithm expect number roundstim unit everi process make least one stepassum log nbit regist show unbound memori also necessari adapt adversari also give olog n expect time solut key rang size n fair oblivi adversari use on share memori consist log nbit regist independ gave random solut bound symmetr memori model key rang size n run expect on fair oblivi adversari use on share atom multiwrit multiread bit summar asynchron bound share memori determinist waitfre solut expens in term achiev key rang asymmetr case imposs symmetr case even allow random assum adapt adversari remain case treat below result show random yield waitfre inexpens solut term time space key rang asynchron asymmetr bound share memori model singlewrit multiread waitfre atom share regist use anonym commun model process initi name equival global consist index processor construct requir sever algorithm end give random waitfre name algorithm assum adapt adversari the strongest adversari first algorithm implement fftestsetonc object oneshot test andset guarante among q n compet process invok it uniqu winner probabl ff ff paramet chosen arbitrarili close object safe is one process winner invok q out n process use olog q writer nreader share bit per process run time on log q readwrit bit properti shown theorem applic typic n high probabl use complex primit object implement a use n copi writer nreader olog log q bit readwrit regist run time on log q readwrit regist b singl nwriter nreader writerpercompon ncompon composit regist log log nbit compon snapshot memori run time olog q readwrit composit regist second algorithm waitfre name algorithm segment use fftestsetonc object given ffl segment use name space size ffln n number process protocol alway correct sens nonfaulti process receiv distinct name run time random variabl whose valu on log n log log n bit oper high probabl high probabl mean probabl run time exce valu o quantiti tend n grow lemma fact prove maximum run time among noncrash process on log n log log n bit oper probabl still possibl expect run time coin flip sequenc infinit next theorem show minor modif proof similar lemma demonstr expect run time modifi protocol involv process bound on log n henc segment waitfre paper organ follow section appendix spell assumpt model comput appendix b show simpl approach work motiv introduct fftestsetonc object section object use section obtain name protocol preliminari sequenti execut finit program bound local variabl commun singlewrit multiread bound waitfre atom regist share variabl latter common model interprocess commun share memori discuss briefli section detail see use motiv distribut protocol see share regist anonym commun atom everi readwrit regist own one process owner regist write it process read it one step process either i read valu regist ii write valu one regist iii flip local coin invok random number gener return random bit follow local comput commun anonym process privat regist read other addressnam use other possibl differ process p q address regist process r way known other requir system atom everi step process thought take place indivis instanc time everi indivis time instanc one step one process execut atom requir induc actual system execut total order set step differ process set step everi individu process set readwrit oper execut individu regist state system give process content program counter content local variabl content own share regist sinc process execut sequenti program state everi process singl step execut next step enabl state adversari schedul demon state decid enabl step execut next thu determin sequenc step system execut two main type adversari oblivi adversari use fix schedul independ system execut much stronger adapt adversari dynam adapt schedul base past initi segment system execut result hold adapt adversaryth strongest adaversari possibl comput complex random distribut algorithm adversari set correspond notion waitfre requir care definit distract reader deleg rigor novel formul adversari restrict measur set system execut appendix a believ interest right use elsewher assum notion system execut waitfre adapt adversari expect complex familiar random distribut algorithm waitfre expect number readwrit share memori everi particip process bound finit function fn n number process expect taken probabl measur random system execut worstcas adapt adversari obviou strategi work appendix b analyz name strategi first come mind show work sens fn bound expect number readwrit share memori least exponenti name soon one process claim key adversari make process fail problem resolv testandset mechan ensur winner among set claim process howev exist construct requir process consist numberingth model anonym point introduct would render name problem trivial rank number choos rank key see also resolv problem introduc probabilist fftestsetonc object select winner high probabl requir consist initi number among process probabilist fftestsetonc object fftestsetonc object share n process probabilist waitfre object function everi ff construct object concurr invok subset user process select winner probabl ff q n process compet object maximum number share bit access perform process expect on log q typic q olog n expect on log log n object base follow properti geometr distribut suppos refere point collis resolut analysi distribut network algorithm q random variabl x ident geometr distribut prx then good probabl uniqu maximum j i synchron algorithm consid n process number n n theta matrix n enter competit express initi set p fill remaind zero entri game divid round k round everi process still game independ flip ident coin probabl success gamma failur round k everi process p kp coin p s coin flip success step forward set kp round three mutuallyexclus possibl outcom i exactli one process step forward other backoffth process declar winner game end ii process backoff case game end winner iii one process step forward case game continu one two aforement event occur let fq denot probabl game end winner initi number q compet process exact behavior fq seem hard analyz fortun next lemma give easi proof statement good enough purpos defin ii q fq f proof suppos first coin flip k q initi process step forward sinc number row avail game unbound probabl winner point exactli fk let x random variabl denot number process step forward then probabl game end winner is recal equat rewritten as paper appar address differ issu method analys one present here probabl exactli k q process step forward next row given case two equat give impli first part lemma prove second part lemma induct base case f f trivial induct step assum fk f k q use follow induct hypothesi last inequ equival verifi use next lemma show that high probabl game end quickli winner probabl winner within r row least ns r proof let w r event winner within r row valu q prthere prthere winner r row process make least r row ns r an import corollari lemma that choos r appropri probabl winner within olog q row set arbitrarili close word infinit mani row need but simplifi analysi want probabl success need satisfi ns r set number row need would r ffl lognffl instanc need r need asynchron implement let entri matrix correspond state writer nreader bit let r row r theta n matrix jth bit array written process j read process definit process step forward row row k first set privat bit row k read bit row k process said luckyatrow k even though asynchron system process cannot determin whether reach certain row alon whether slower process eventu reach row suffic determin whether lucki geometr distribut ensur process backedoff mani row say k log n is high probabl one left trivial luckyatrow k k r necessari winner and show lucki row r suffici winner theorem everi fftasonc protocol implement fftestsetonc object select uniqu winner among set invok process probabl least never select one winner object invok repeatedli key assign provid crash occur object invok q n process invoc use on log q writer nreader atom singl bit regist worst case run time on log q readwrit share bit proof figur process p own array atom bit denot ar pone bit row game ith row ai n one bit ai p own process n initi line figur process check whether object current occupi process tri grab key whether initi memori dirti possibl previou competit so exit report failur way line line reset bit ai p r own process clean own possibl dirti memori futur tri of cours need done start process add line code effect line implement follow algorithm determin lucki current row ye step forward probabl otherwis probabl s valu process process win luckyatrow r otherwis fail show one process win henc protocol safe exit report failur protocol clean up privat bit row line done make object reusabl process win crash occur eventu everi non faulti process get name probabilist point view immateri whether coin flip synchron asynchron coin flip independ rate process back remain essenti unchang key probabilist analysi asynchron process anoth main ingredi proof simpl upper bound number lucki process per row notic also process actual winner rowal process back offfrom step one row next probabl relev properti protocol are live everi non faulti process execut protocol bound number step regardless process speed crash failur safeti one process win and number row olog q probabl among q n compet process winner ffa paramet set arbitrarili close fftasonc waitfre use nr r readwrit writer nreader share bit proof process p invok protocol either back immedi execut join competitit then either win execut nr step back lose execut nr remaind section consid system q n process execut protocol figur execut system crash occur show case process get keyand henc capturedwith probabl ff set process back execut let b jbj row number lucki process b one outsid b proof process exit right away execut line call compet process everi row row row r everi still compet process p first set arow p execut writearow p line protocol subsequ case crash need bother estim probabl adversari forc sacrific process everi invok either process crash one process win game probabl ff given enough object nonfaulti process sooner later get key problem discuss below make happen fast process use object possibl fshare declarationsg param r int fnumber row game olog qg param s var share array boolean far p own process p g procedur invok processg var var tmpn array boolean begin row startedmemori dirtyg od row fjoin gameg fcheck content row g fif alon rowg els row r goto l els goto ll probabl s l row writearow p figur protocol fftasonc q n process p invok process read bit row execut loop line suppos way contradict two process p p back luckyatrow row assum p execut writearow p p execut writearow p sinc back off bit stay order atom event contradict p lucki arow time p read it consequ among process back off one lucki certain row process back off could lucki consid instanc process stand row row suppos adversari freez first two possibl b step ahead luckyatrow row eventu b process ahead b b back off reiniti bit zero line protocol figur afterward b could unfrozen adversari lucki row row later on one process win proof process luckyatrow r backoff particular clean row bit line protocol henc two lucki process row r contradict consid set execut process crash occur bit fftestsetonc object initi correctli then success probabl fftasonc q n invok process least ff proof intuit aim adversari prevent process win bound probabl adversari succe increas power sinc assum crash occur two way adversari prevent win occur either two process reach row r process back prior row r make two copi game allow adversari play both is consid two object invok number process one game adversari tri maxim probabl first two spoil event occur tri maxim probabl second spoil event adversari succe win least one two game clearli upper bound probabl succe play one game consid first case focu subset c process backoff adversari bring one process p row r probabl probabl anoth process p c reach row r process c reach row r definit claim row one process c lucki therefor p reach row r sequenc coin toss bring process p row row anoth process p row row on process might differ but case probabl consecut success r henc probabl adversari spoil game case prsome reach row r reach row reach row consid case sinc assum crash occur particip process must toss coin either back reach row r long take immateri coin flip independ sinc interest probabl back row r disadvantag adversari process step forward probabl inde probabl event increas number forward step process henc probabl winner bound synchron game name ns r set r log q theorem proven analysi use writer nreader bit regist intercommun primit cours use complex primit complex figur decreas corollari everi implement fftestsetonc object succe probabl least ff invok q n process use n copi writer nreader olog log qbit share readwrit variabl run time on log q readwrit share bit proof replac array ar p fftasonc singl olog log qbit variabl use counter count log q modifi protocol obviou way implement would impli slightli higher run time measur access writer reader share bit advantag fftasonc point view space complex share variabl implement use writer reader share bit notion composit regist snapshot object construct multius waitfre atom readwrit regist composit regist use obtain snap shot state set or all share variabl system waitfre readwrit regist r written process without chang process atom read r atom linearli order definit read process give snapshot content share variabl r corollari everi implement fftestsetonc object succe probabl least ff q n process use singl nwriter nreader writerpercompon ncompon composit regist log log nbit compon run time olog q readwrit composit regist proof array counter previou corollari replac composit regist aka snapshot object defin improv complex figur would simplifi protocol given avail snapshot object implement waitfre name protocol base waitfre random name protocol fftestsetonc object compet process key space consist fftestsetonc object one key param n int fnumber processesg param ffl real fspecifi keyrang g f segment size l bc delta log ncg procedur var start begin start l bstartl cl fbegin segment g repeat fphase tri get key within segmentg succeed fftasonc key succeed fphase linear searchg succeed fftasonc key od figur protocol segment process p simpl hard analyz strategi first glanc simpl strategi as appendix b may suffic process repeatedli invok object select uniformli random succe get key and process get key averag expect ffm object fire correctli sens assign key one invok process choos nfffi take care random fluctuat ensur everi process eventu get key run time simpl strategi seem hard analyz point time set process still vy key match set avail object key number avail object determin probabl get key the randomli select object must least avail turn probabl determin number round need slowest process get key problem number empti object given round depend adversari doe process stop let go occupi object clear us frame possibl adversari strategi trickier easi analyz strategi segment impos littl bit structur way object invok possibl come simpl effici protocol segment amen clean analysi set ff reliabl fftestsetonc object fi paramet take care random fluctuat show fi therefor set taken arbitrarili small but must fix divid key space segment length l c constant specifi later ln denot natur logarithm think segment ring object ith il th object segment same protocol shown figur follow process select random key start automat determin segment whose initi posit denot l process start invok key walk around segment is process first tri get key invok fftestsetonc object correspond first random choic start then necessari invok next modulo l object ring on get back start point start shall see high probabl everi process get key reach point extrem unlik event process find key segment whole key rang scan repeatedli key found phase protocol ensur process eventu get name lemma everi solv name problem n use fftestsetonc object protocol safe correct run time on log n log log n readwrit writer nreader share atom bit proof show that high probabl process segment captur find key crash insid segment therefor everi fftestsetonc object invok ol time high probabl well consequ appli theorem q olog n nonfaulti process mean find key within segment first show process distribut evenli among segment let segment s then prprocess p select l prprocess p select sinc segment chosen independ invok chernoffbound estim tail binomi distribut follow form see exampl set c ensur probabl segment receiv ffl process also need ensur everi segment captur process need take care adversari basic problem follow whenev object invok adversari may may crash process object invoc happen say object corrupt consid case one process walk around whole segment without find key happen object segment invok number corrupt object then l gamma amani noncorrupt object succe probabl ff independ object word consid l gamma bernoulli trial probabl success equal ff success mean invok process given key notic small valu l gamma a larg deviat mean like therefor advantag adversari crash process therebi corrupt object hope segment captur process while aim ensur segment captur process show appropri choic constant c almost sure never happen notat recal definit captur expect number captur process least at least corrupt object adversari must crash least one process chernoff bound true number captur process least probabl least know high probabl segment p process straightforward comput show p a everi long left verifi that matter chosen adversari segment captur process high probabl end notic p therefor impli probabl segment fail captur process bound independ adversari straightforward comput show except probabl n provid sinc ml n segment probabl segment fail togeth equat give probabl process find key within olog n object invoc similarli everi object invok ol time probabl theorem everi object invoc run time olog log n readswrit writer nreader bit atom regist probabl protocol safe everi process obtain distinct key everi circum stanc process fail find key segment scan whole key space key found saw section fftestsetonc object safe never give key one process sinc object process noncorrupt object invok repeatedli assign key sooner later everi correct process find key with probabl lemma proven prove maximum run time among noncrash process on log n log log n bit oper probabl impli averag run time coin flip sequenc outcom use process involv the expect run time on log n log log n bit operationsth expect run time may still infinit expect bound meet definit wait freeness protocol achiev bound expect run time requir waitfre protocol need use on log n bit oper per object invoc rather on log log n see problem recal theorem state object succe probabl ff provid on log q bit use q number compet process thetan on log n bit must use or otherwis bound given lemma becom worthless although unlik event entir possibl linearli mani process fail segment start scan whole key space case averag run time high would take exponenti long time scan process get key will use on log n bit per fftestsetonc object averag run time still on log n bit oper theorem everi solv name problem use fftestsetonc object protocol waitfre safe correct expect run time on log n readwrit writer nreader share atom bit proof saw proof lemma probabl process resort scan whole key space o denot total number corrupt key time process scan whole space corrupt object fire independ probabl ff then probabl least a bound independ a least object assign key impli gamma correct process receiv uniqu key defin p kn fffflkng then probabl p n second scan need on averag run time bit oper on log n clear togeth claim claim impli protocol segment waitfre solut process name problem even averag sens theorem proven remark practic protocol much faster key expect number process per object first random object select mn also larg fraction process need one invoc get wellknown result martingal inequ state n process select random key key fraction key chosen process nearli henc high probabl nearli ffn gamma e process get key one invoc fftestsetonc object result hold implement fftestsetonc object writer n reader olog log nbit share readwrit variabl nwriter nreader writerpercompon ncompon composit regist log log nbit compon acknowledg thank refere construct comment result substanti improv present system execut adversari comput complex system execut infinit sequenc altern step state c satisfi enabl state c igamma c configur system execut technic process halt enter infinit mani time distinguish idl state c idl step regist initi zero content uniqu start state c initi dirti share memori regist arbitrari initi content set system execut denot omegagamma adversari best explain identifi condit probabl densiti function as c je initi segment e step enabl state c igamma c state result execut step state c igamma probabl initi execut segment realiz given e igamma happen adversari random cs asc je summat taken differ enabl step state c igamma state c result step s singl state random state random step a coin flip adversari determinist choos determinist step cs asc je start e c adversari induc measur legal system execut defin ae lim i adversari adapt sinc schedul process execut next step base complet knowledg initi segment system execut includ random outcom past coin flip arbitrarili delay process even crash execut enabl step particular process express strongest adversari adapt infinit comput power on probabl measur set execut without loss gener assum random step protocol use fair coin flip assum notat adapt adversari probabl measur initi execut segment summat enabl step state c c result execut step state c coinflip step c h state result c outcom head c state result c outcom tail denot finit initi segment execut andomega set infinit execut e tradit notat instead ae cylind g use first two conditionsalreadi impli notion probabl measurear includ complet third condit ensur adversari control outcom fair coin flip outcom equal like definit readili gener bias coin multibranch decis adversari de fine defin expect length ee process p j s final execut follow finit initi execut segment e let e infinit execut start number nonidl step process definit assum notat defin sinc summat includ case expect length infinit but necessarili if set infinit histori oper execut infinit mani event posit measur normal wrt e give adversari free choic start configur run time determinist protocol maximum number nonidl step taken legal execut execut non faulti process definit implement concurr object share n process wait free finit bound fn adversari expect length ee approach work relat observ made respect symmetr commun model case use method bound differ mobd suppos n independ random variabl x take valu finit set let measur function if vector b differ ith coordin use ballandbin scenario x denot bin end measur thing number bin exactli k ball number bin least k ball like case easi see c bound becom n process name space size name algorithm good want c run time small possibl param n int fnumber processesg param c real fspecifi key rangeg var m share int share array boolean feach bm p own process pg procedur begin readbkey i writebkey p returnfailur fi fnot aloneg od procedur simpnam int fmg begin repeat key random fmg figur simpl approach name protocol process p obviou name algorithm work follow process choos uniformli independ tent random key check whether process claim key so process secur key otherwis tri anoth random key on check whether process claimant key use follow mechan key k vector bk n bit bk p own process p p n bit read process upon choos specif key valu k process set bit bk p subsequ read bit vector see whether claimant figur process alon success return otherwis failur notic bit bk p reset case failur process tri again easi verifi solut safe sens two process ever get key difficult see run time unsatisfactori c adversari strategi forc process take exponenti mani step high probabl problem adversari know key k chosen process p execut subsequ writebk p step therefor adversari postpon execut step process q choos key k point adversari schedul step p q secur key k adversari strategi step writebkey p enabl process p adversari delay execut say p frozen p chosen k yet execut writebk p say process claim k let c adversari schedul process turn perform first random choic defin event at least ffln key chosen exactli two process standard applic mobd show probabl occur e gammac n c constant depend ffl adversari select ffln key freez set f correspond process adversari schedul oper remain process claim one remain key key claim one process if one process claim one key adversari schedul event one back tri uniqu claimant key point least gamma claim uniqu process call red key process f unfrozen adversari schedul oper first attempt fail second tent random key choic defin event b ffln red key claim exactli one process f let f set process claim key each key claim exactli two process jf adversari repeat scenario f substitut f tediou standard applic mobd show probabl b occur e gammac n where again c constant depend ffl therefor high probabl adversari abl forc process tri exponenti number key r atom snapshot share memori elect anonym network distribut comput fast random consensu use share memori random consensu expect on log n oper per processor renam asynchron environ tree algorithm packet broadcast channel free synchron access packet broadcast channel feedback estim multipl conflict speed resolut multipl access channel imposs distribut consensu one faulti processor distribut algorithm acm tran random waitfre concurr object asynchron comput theorem tresili task lasvega processor problem how uniqu distribut comput share concurr waitfre variabl solv processor ident problem on space memori requir agreement among unreli asynchron process method bound differ random algorithm choic coordin problem optim time random consensu make resili algorithm fast practic elus atom regist revisit comput network construct atom variabl random waitfre testandset tr sharedmemori vs messagepass asynchron distribut environ renam asynchron environ fast random consensu use share memori processor ident problem waitfre synchron random waitfre concurr object extend abstract optim time random consensusmyampersandmdashmak resili algorithm fast practic atom snapshot share memori immedi atom snapshot fast renam asynchron comput theorem italictitalicresili task elus atom regist random algorithm imposs distribut consensu one faulti process longliv renam made fast share concurr waitfre variabl distribut algorithm comput network construct atom variabl extend abstract waitfre testandset extend abstract ctr harri buhrman alessandro panconesi riccardo silvestri paul vitanyi import ident or consensu realli univers distribut comput v n p februari jame aspn faith ellen fich eric ruppert relationship broadcast share memori reliabl anonym distribut system distribut comput v n p februari john tromp paul vitnyi random twoprocess waitfre testandset distribut comput v n p juli