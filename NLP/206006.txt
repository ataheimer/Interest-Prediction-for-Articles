t planar strong connect help parallel depthfirst search a paper prove strongli connect planar direct graph size n depthfirst search tree root specifi vertex comput ologn time nlogn processor previous planar direct graph may strongli connect best depthfirst search algorithm run ologn time n processor algorithm run parallel random access machin allow concurr read concurr write share memori case write conflict permit arbitrari processor succeed b introduct depthfirst search one use tool graph theori depthfirst search problem follow given graph distinguish vertex construct tree correspond perform depthfirst search graph start given vertex parallel depthfirst search studi numer author reif show lexicograph depthfirst search pcomplet even gener undirect graph unord depthfirst search smith gave first nc algorithm planar undirect graph processor complex algorithm reduc linear yesha independ jaja kosaraju shannon also achiev result aggarw anderson gave random nc algorithm gener undirect graph kao studi problem direct graph found nc algorithm use n processor planar direct graph size n follow random nc algorithm aggarw anderson kao gener direct graph recent kao klein gave algorithm comput depthfirst search tree olog n time use n processor planar direct graph may strongli connect paper show strongli connect planar direct graph size n depthfirst search tree root specifi vertex comput olog n time use n log n processor algorithm run parallel random access machin allow concurr read concurr write share memori case write conflict permit arbitrari processor succeed algorithm paper kao klein use direct graph separ defin kao follow framework random nc algorithm gener direct graph algorithm paper achiev superior complex exploit topolog properti strongli connect planar direct graph strongli connect compon key subgraph creat cours algorithm regular structur major task algorithm recurs maintain util structur paper organ follow section review basic definit relev fact planar direct graph depart comput scienc duke univers durham nc support part nsf grant ccr section quot previou result report new result comput strongli connect compon direct span tree section discuss direct graph separ detail discuss separ given appendix section detail paper depthfirst search algorithm strongli connect planar direct graph basic planar direct graph planar direct graph one embed plane edg intersect common end vertic start vertic embed planar direct graph one given planar embed subtl technic reason planar graph paper may multipl edg loop edg strong graph breviti strongli connect embed planar direct graph least one vertex simpli call strong graph goal paper effici comput depthfirst search span tree strong graph root specifi vertex face boundari orient let g connect embed planar direct graph vertic edg g delet embed plane plane divid disconnect region exactli one region infinit other finit region call face g infinit region call extern face finit region call intern face let f face g boundari f denot bf set edg vertic surround f g contain least two vertic connect bf arrang uniqu undirect cycl observ stay insid f walk around bf onc cycl call boundari cycl f may edgesimpl let e boundari edg f orient e respect f defin follow ffl case f extern face edg e posit or neg respect f point counterclockwis resp clockwis direct boundari cycl f ffl case f intern face edg e posit or neg respect f point clockwis resp counterclockwis direct boundari cycl f hole boundari orient let g connect embed planar direct graph let h connect subgraph g vertic edg h remov embed plane g plane divid disconnect region exactli one region infinit other finit region call hole h infinit region call extern hole finit region call intern hole let x hole h boundari x denot bx set vertic edg surround x h contain least two vertic connect bx arrang uniqu undirect cycl observ stay insid x walk around bx exactli onc cycl call boundari cycl x may edgesimpl let e boundari edg x orient e respect x defin follow ffl case x extern hole h edg e posit or neg respect x point counterclockwis resp clockwis direct boundari cycl x ffl case x intern hole h edg e posit or neg respect x point clockwis resp counterclockwis direct boundari cycl x combinatori embed data structur let g connect planar direct graph algorithm planar embed g encod boundari extern face clockwis cyclic order edg incid vertex encod call combinatori planar embed g topolog planar embed uniqu specifi correspond combinatori embed cyclic edg incid combinatori embed encod follow data structur vertex doubli link circular list consist edg incid vertex clockwis order list use effici trace boundari cycl face g also use trace boundari cycl hole connect subgraph given connect planar direct graph size n combinatori planar embed comput ologn time use n log log n log n processor determinist arbitrarycrcw pram planar embed induc vertex contract paper vertex contract contract connect vertex subset connect embed planar direct graph ensur planar preserv technic reason multipl edg creat vertex contract kept loop edg delet let g connect embed planar direct graph let h subgraph induc connect vertex subset g let g graph construct g contract h vertex h h consist one vertex g g same otherwis planar embed g specifi follow ffl everi vertex u h clockwis cyclic order edg incid u g g ffl edg around nonempti hole x h stay togeth around h clockwis cyclic order around h cyclic order around boundari cycl x neg direct x ffl uncontract edg boundari extern face g remain g orient respect extern face ffl h contain boundari vertex extern face g h boundari extern face g gener planar embed uniqu planar embed fit construct suitabl purpos paper lemma given connect embed planar direct graph size n planar embed induc contract disjoint famili connect vertex subset comput olog n time use n log n processor remark vertex contract requir delet multipl edg creat comput induc embed may take linear space achiev olog n time n log n processor proof edg around new vertex g collect process doubli link circular list combinatori embed g comput take olog n time n log n processor use optim parallel algorithm list rank prefix comput tree contract planar connect strongli connect compon direct span tree section quot previou result report new result comput strongli connect compon direct span tree direct span tree theorem kao shannon strong graph size n direct span tree root specifi vertex comput olog n time use n log n processor determinist arbitrarycrcw pram compact strongli connect compon let g connect embed planar direct graph let h h two nonempti connect subgraph g h enclos h h intern hole h compact strongli connect compon g one enclos strongli connect compon theorem kao let g connect embed planar direct graph let n size g let ff number noncompact strongli connect compon g then strongli connect compon g comput odlog use n log n processor determinist arbitrari crcw pram new result comput strongli connect compon next three theorem discuss comput strongli connect compon graph obtain delet contract subgraph embed planar direct graph may connect strongli connect compon compact compact connect compon contain it delet vertex subset strong graph let g direct graph let h subgraph vertex subset g let g gamma h subgraph obtain remov vertic h incid edg theorem let g strong graph size n let h subgraph g number connect compon h let ff number noncompact strongli connect compon g follow statement true ff fl strongli connect compon g comput determinist odlog fl use n log n processor proof first statement obtain count argument base follow fact ffl let w noncompact strongli connect compon g planar strong connect g least one connect compon h enclos w g ffl let w w two noncompact strongli connect compon g planar g connect compon h enclos g w w either w one enclos g ffl let w noncompact strongli connect compon g strong connect planar g connect compon h enclos g w noncompact strongli connect compon g enclos w g prove second statement first comput connect compon g take ologn time use n log n processor next comput strongli connect compon connect compon via theorem second statement follow first statement theorem delet edeg subset strong graph theorem let g strong graph size n let u vertex subset g let subset edg g incid u let g graph obtain delet g edg d let number vertic u let ff number noncompact strongli connect compon g follow statement true ff strongli connect compon g comput determinist odlog use n log n processor proof second statement follow directli first statement theorem thu suffic prove first statement follow let w noncompact strongli connect compon g vertex absorb w g either vertex w enclos w g definit first statement obtain count argument base follow fact ffl let w noncompact strongli connect compon g planar strong connect g u u absorb w g ffl let w w two noncompact strongli connect compon g planar g vertex u u absorb w w g either w one enclos g ffl let w noncompact strongli connect compon g strong connect planar g vertex u absorb g w one noncompact strongli connect g enclos w g contract connect vertex subset acycl graph theorem let g acycl connect embed planar direct graph let h subgraph g let g graph obtain g contract connect compon h vertex let n size g let fl number connect compon h let ff number noncompact strongli connect compon g follow statement true ff fl strongli connect compon g comput determinist odlog fl use n log n processor proof noncompact strongli connect compon contain least two ver tice thu acycl g noncompact strongli connect compon g contain least one contract connect compon h therefor first statement true second statement follow theorem direct graph separ intuit separ graph subgraph whose remov disconnect graph small piec cycl separ kpath separ work parallel depthfirst search reli find form graph separ algorithm planar undirect graph employ undirect cycl separ algorithm gener undirect graph use path separ procedur mergetwopath input strong graph g twopath separ output path separ g begin let largest index strongli connect compon z g gamma fu heavi g remark exist return let p path u remark p q form twopath separ let smallest index strongli connect compon z g heavi g exist return let q path v remark p q form twopath separ comput direct path r z z u v remark z z strongli connect let direct path form p r q remark vertexsimpl return s end fig procedur merg twopath separ path separ notion direct graph separ origin introduc depthfirst search planar direct graph use gener direct graph tailor strongli connect direct graph g ffl vertex subset call heavi g contain two third vertic g ffl separ g set vertic strongli connect compon g gamma heavi g ffl cycl separ vertexsimpl direct cycl whose vertic form separ singl vertex consid cycl length zero thu remov vertex separ graph vertex cycl separ ffl posit integ k kpath separ set k vertexdisjoint vertex simpl direct path whose vertic form separ path separ simpli call path separ kao show everi direct graph direct path separ direct cycl separ result includ appendix a graph size n proof yield sequenti algorithm comput path separ optim on time algorithm comput cycl separ on log n time aggarw anderson kao improv on sequenti time comput direct cycl separ also show comput cycl separ comput depthfirst search tree ncequival comput cycl separ strong graph lemma given strong graph size n twopath separ comput olog n time use n log n processor proof let direct span tree given graph work lipton tarjan exist two vertic x two tree path root x root form separ twopath separ easili obtain tree path kao teng toyama gave algorithm comput x olog n use n log n processor thu lemma follow theorem lemma given strong graph size n path separ comput olog n time use n log n processor proof let g given graph first use lemma obtain twopath separ g then use algorithm mergetwopath fig comput path separ proof correct mergetwopath similar theorem a appendix a complex suffic show mergetwopath run olog n time use n log n processor z z comput binari search theorem olog n time use n log n processor r obtain comput diverg direct span tree root u subgraph induc z z use theorem take olog n time use n log n processor thu complex mergetwopath state theorem given strong graph size n cycl separ comput olog n time use n log n processor proof proof similar lemma theorem a parallel depthfirst search section give overview paper algorithm perform depthfirst search strong graph section discuss key techniqu use algorithm section detail algorithm overview let g strong graph let r vertex g goal construct depthfirst search span tree root r g tree recurs construct use cycl separ first comput cycl separ g then comput path separ start r find direct path r cycl separ path cycl separ form path separ appropri edg cycl separ remov branch final depthfirst search tree ie remain graph search s suppos search continu g start vertex r end vertex edg point last vertex s time search recurs subgraph b r consist vertic reachabl r via direct path g graph b r call dangl subgraph see x separ g everi strongli connect compon g contain two third vertic g howev b r may contain sever strongli connect compon consequ b r may still larg small depth recurs avoid problem set direct path remov g remain direct graph small dangl subgraph remov path form subtre call partial depthfirst search tree final depthfirst search tree see x dangl subgraph strong graph special kind graph call bubbl graph structur bubbl graph exploit effici process dangl subgraph see x strong graph fact special case bubbl graph depthfirst search algorithm paper actual take bubbl graph input comput depthfirst search tree recus bubbl subgraph see x bubbl graph strongli connect compon direct graph sink compon outgo edg strongli connect compon let b embed planar direct graph b call bubbl graph root vertex r follow condit hold ffl everi vertex b reach r via direct path ffl vertex r boundari vertex extern face b everi sink compon b contain least one boundari vertex extern face remark assum bubbl graph specifi root breviti root explicitli mention unless risk ambigu lemma let b bubbl graph root r let n size g follow statement true strongli connect compon b comput olog n time use n log n processor direct span tree b root r comput olog n time use n log n processor proof first statement follow theorem fact bubbl graph noncompact strongli connect compon second statement shown follow let b graph obtain b ad direct edg sink compon b r via extern face b then direct span tree b root r also one b complex first statement lemma b comput olog n time use n log n processor b strong graph desir direct span tree b comput via theorem olog n time use n log n processor heavi bubbl graph split compon let k integ bubbl graph call kheavi or klight resp vertic let b kheavi bubbl graph let w w two distinct strongli connect compon w call descend compon w w reach direct path direct graph g vertex subset or vertex h g let rhg set vertic reach h via direct path g let w strongli connect compon b let rwb set vertic b reach w via direct path w call split compon b rwb consist k vertic descend compon w satisfi condit depthfirst search algorithm paper find cycl separ split compon b use separ break b bubbl subgraph smaller split compon comput split compon via st graph acycl embed planar direct graph call st graph uniqu sourc uniqu sink boundari extern face theorem given kheavi bubbl graph size n split compon comput olog n time use n log n processor proof let b kheavi bubbl graph split compon b comput convert b st graph follow graph obtain ad vertex extern face b direct edg point sink compon b graph obtain b contract strongli connect compon b vertex vertic b assign weight weight vertex w contract strongli connect compon w b weight w number vertic w note b st graph sink t sourc contract strongli connect compon b contain specifi root lemma b comput olog n time use n log n processor next cardin rwb strongli connect compon w b comput olog n time n log n processor comput appli b descend count algorithm tamassia vitter st graph cardin rwb comput split compon b identifi straightforward manner ologn time use n log n partial depthfirst search tree dangl subgraph let b bubbl graph partial depthfirst search tree b subtre depthfirst search tree b tree root specifi root b let partial depthfirst search tree b let x vertic list postord travers sequenc depthfirst search ie sequenc x mark right descend mark x let vertic end vertic edg point x order arbitrari postord use search start x vertex may sever differ indic adjac sever x vertic dangl subgraph b denot di j respect i subgraph induc vertic reach ij vertex ij intend postord travers sequenc vertic ie di jg nonempti di j direct edg x ij call dangl edg associ di j next two lemma provid natur way extend complet depthfirst search tree recurs nonempti dangl subgraph parallel lemma let r specifi root b let h connect subgraph b contain r let u vertex h adjac h subgraph b induc ru bubbl graph root u proof let b u subgraph b induc ru first definit b u vertex u reach everi vertex b u via direct path b u next r boundari vertex extern face b connect h relationship r h u vertex u boundari vertex extern face b u let w sink compon b u follow discuss show w contain boundari vertex extern face b u b bubbl graph contain direct path w boundari vertex extern face b two case base whether q intersect h not ffl case q intersect h q lie b u w sink compon b u path q lie w therefor w contain last vertex q boundari vertex extern face b u ffl case q intersect h let first vertex q h boundari vertex extern face b adjac h sgamma vertex sgamma boundari vertex extern face b u furthermor w sink compon b u vertex sgamma w lemma letomega set dangl subgraph b respect let l set associ dangl edg follow statement true nonempti di j bubbl graph root ij henc ij chosen specifi root di j dangl subgraph disjoint depthfirst search tree b form l depthfirst search tree dangl subgraph least two vertic proof first statement obtain recurs appli lemma two statement straightforward comput dangl subgraph respect path section show comput dangl subgraph respect partial depthfirst search tree path comput base two bisect strategi use subroutin fig fig analyz subroutin fig next two lemma analyz subroutin fig lemma let set end vertic edg b point proof proof two direct contain direct path q p y note q contain edg d hand strongli connect direct path q p intersect one vertex q contain outgo edg edg d let q direct path form q q q goe p p becom direct cycl contain w q contain edg d remain direct cycl therefor contain vertexsimpl direct path r w z let r direct path correspond r intersect p one vertex x note x start vertex r construct ad incom edg r edg remov vertex x p edg r therefor z ry lemma let b bubbl graph size n procedur fig correctli comput output specifi olog n time use n log n processor proof second fourth output properti procedur straight forward two properti shown below subgraph b induc rx therefor lemma b bubbl graph root x q then obtain bubbl graph contract connect vertex subset bubbl graph root x p ffl properti lemma nonempti dangl subgraph associ dangl edg b respect p exactli b respect p respect p may may bubbl graph b contract instead delet contract b x q may add new edg b procedur subonecomputedsg input bubbl graph b root r vertexsimpl direct path output two graph b b construct b two path bubbl graph root x dpe x p respect p p vertexsimpl direct path respect b start specifi root nonempti dangl subgraph associ dangl edg b respect p exactli b respect p b respect p total size b b size b begin let let p subpath p form x let p subpath p form x let set edg b point p b strongli connect let els let graph obtain b ad direct edg sink compon r via extern face b let graph obtain contract p vertex remark edg outgo edg w let graph obtain delet edg d let w strongli connect compon contain super vertex w let b subgraph b induc w graph obtain b contract x q end fig first subroutin comput dangl subgraph procedur subtwocomputedsg input bubbl graph b root r k edg outgo r output two graph b b construct b follow properti bubbl graph root r nonempti dangl subgraph associ dangl edg b respect r exactli b b respect r r consid path singl vertex outdegre r b b dke bkc respect total size b b size b begin let let k end vertic outgo edg r b let set edg r b b strongli connect let els let graph obtain b ad direct edg sink compon r via extern face b let graph obtain contract vertex w remark edg outgo edg w let graph obtain delet edg d let w strongli connect compon contain super vertex w let b subgraph b induc w gamma without edg d let b graph obtain b contract r end fig second subroutin comput dangl subgraph x q howev contract creat new edg b x q edg would point b thu end vertic would includ b therefor contract b x q chang nonempti dangl subgraph associ dangl edg respect p complex step done olog n time use n log n processor step done via lemma olog n time use n log n processor step done via lemma olog n time use n log n processor step done olog n time use n log n processor strong graph remain strong graph edg adjac w theorem w comput olog n time use n log n processor step done ologn time use n log n processor step done via lemma ologn time use n log n processor thu total complex procedur fig state analyz subroutin fig next lemma analyz subroutin fig lemma let b bubbl graph size n procedur fig correctli comput output specifi olog n time use n log n processor proof proof similar lemma subtl point follow b may contain dangl subgraph b respect vertic empti therefor edg delet b without affect nonempti dangl subgraph delet ensur outdegre r b dke comput dangl subgraph next theorem use procedur fig fig comput nonempti dangl subgraph respect path theorem let b bubbl graph size n let p vertexsimpl direct path b start specifi root nonempti dangl subgraph associ dangl edg b respect p comput olog n time use n log n processor proof comput divid two phase follow ffl first phase iter appli subonecomputedsg b p bisect p ologn iter collect bubbl subgraph b obtain subgraph b contain one vertex p ffl second phase iter appli subtwocomputedsg b bisect outdegre root olog n iter collect even smaller bubbl subgraph b obtain subgraph b root vertex y subgraph b either exactli one outgo edg consist y b consist y correspond dangl subgraph b empti otherwis b gammafyg nonempti dangl subgraph b associ dangl edg outgo edg b correct complex comput follow directli lemma parallel depthfirst search bubbl graph fig detail paper algorithm perform depthfirst search bubbl graph subroutin describ fig fig lemma let b bubbl graph size n procedur fig correctli comput output specifi olog n time use n log n processor procedur splitheavydsg input posit integ m mheavi bubbl graph b vertic output partial depthfirst search tree b either properti below ffl dangl subgraph b respect mheavi ffl dangl subgraph mheavi split compon consist two third vertic split compon b set delta dangl subgraph b respect set k associ dangl edg begin let r specifi root b let w split compon b let c direct cycl separ w let p vertexsimpl direct path b r c p c intersect one vertex u let e edg c point u let vertexsimpl direct path form p c without edg e let delta set dangl subgraph b respect s let k set associ dangl edg return tupl s delta k end fig procedur split heavi dangl subgraph procedur computepartialtre input bubbl graph b vertic output partial depthfirst search tree b dangl subgraph mlight setomega dangl subgraph b respect set l associ dangl edg begin b omega mheavi begin delet dangl edg b l add edg form larger tree add form larger tree add delta omegagamma add k l end return tupl end fig procedur comput partial depthfirst search tree procedur computedfstre input bubbl graph b least two vertic output depthfirst search tree b begin add l form larger tree b omega least two vertic begin add form larger tree end return end fig procedur comput depthfirst search tree proof correct procedur shown follow let set vertic w assum dangl subgraph b b respect mheavi b vertic b m heavi dangl subgraph b respect s then split compon strongli connect compon w gamma separ w output properti procedur hold complex procedur analyz follow step obviou step done via theorem step done via theorem step done use lemma step obviou step done via theorem thu total complex state lemma let b bubbl graph size n procedur fig correctli comput output specifi olog n time use n log n processor proof lemma follow directli lemma fact output properti splitheavydsg number iter computepartialtre ologn theorem let b bubbl graph size n let r specifi root b depthfirst search tree b root r comput olog n time use n log n processor determinist arbitrarycrcw pram proof comput done procedur fig theorem follow directli lemma fact output properti computepartialtre depth recurs computedfstre olog n parallel depthfirst search strong graph next theorem state main result paper theorem let g strong graph size n let r vertex g depthfirst search span tree g root r comput olog n time use n log n processor determinist arbitrarycrcw pram proof extern face g chang r boundari vertex face then strong connect g bubbl graph root r therefor theorem follow theorem fact extern face chang ologn time n log n processor use list rank prefix comput acknowledg author wish thank subhrajit bhattacharya help discuss a graph cycl separ follow discuss use depthfirst search tree comput graph separ a path cycl separ weight graph weight graph one nonneg vertex weight avoid trivial assum least one vertex posit weight let g weight direct graph let h subgraph vertex subset g h subgraph obtain remov vertic h incid edg let wh total weight h set h call heavi g wh wg remark threshold heavi differ x separ g vertex subset strongli connect compon g gamma heavi g cycl or path separ vertexsimpl direct cycl resp path vertic form separ technic uniform vertex consid trivial cycl thu vertex form separ cycl separ empti set consid trivial cycl trivial path thu empti set form separ cycl separ well path separ a comput path separ depthfirst search tree next theorem appli weight undirect graph substitut undirect edg pair direct edg theorem a everi weight direct graph path separ proof let g weight direct graph without loss gener assum g strongli connect otherwis replac g maximumweight strongli connect compon everi path separ compon also one g path separ p g construct follow let depthfirst search span tree g root arbitrari vertex r let z vertic g correspond depthfirst search postord let p smallest index let p tree path r z p let g let p shown path separ follow draw g plane way postord indic j j vertex z either right z j ancestor z j vertex z p either ancestor right everi vertex gl p greater postord indic vertic gl also everi vertex gr right z p postord indic vertic gr greater p p consist z p ancestor therefor everi vertex gr right everi vertex gl depthfirst search edg point left right everi strongli connect compon g gamma p either entir gl entir gr thu weight strongli connect compon g gamma p wgl wgr a comput cycl separ path separ next theorem also appli weight undirect graph edg substitut note separ obtain theorem actual consist either vertex singl vertex least three vertic thu degener undirect edg edg substitut undon theorem a everi weight direct graph cycl separ proof let g weight direct graph let path separ g obtain theorem a p convert cycl separ follow let largest index strongli connect compon z g gamma fu heavi g path u exist empti set trivial cycl separ otherwis continu convers let let smallest index strongli connect compon z heavi g u path u separ two case base whether not t u trivial cycl separ otherwis u z u z z z heavi g strongli connect z z contain vertex z vertex simpl direct path q u via z gamma z z via z gamma z u contain none u path q path u vertexsimpl direct cycl least three vertic cycl separ path u separ r simpl tree contract algorithm random nc algorithm depth first search parallel depthfirst search gener direct graph design analysi comput algorithm determinist parallel list rank new york acceler centroid decomposit techniqu optim tree evalu logarithm time optim tree contract erew model optim parallel algorithm dynam express evalu applic optim parallel algorithm planar graph optim link list prefix algorithm local memori comput graph theori nearli optim parallel algorithm construct depth first span tree planar graph parallel algorithm planar graph relat problem graph cycl separ planar direct depthfirst search dnc toward overcom transitiveclosur bottleneck effici parallel algorithm planar digraph on log nwork nc algorithm depthfirst search undirect planar graph optim parallel evalu treestructur comput rake power parallel prefix parallel prefix comput separ theorem planar graph parallel tree contract applic optim parallel algorithm graph planar linearprocessor algorithm depthfirst search planar graph parallel algorithm depth first search i parallel transit closur point locat planar struc ture graph theori tr