t loop check logic program function a two complet loop check mechan present literatur logic program function oscheck evacheck oscheck comput effici quit unreli often misidentifi infinit loop wherea evacheck reliabl major case quit expens paper develop seri new complet loop check mechan call vafcheck key techniqu introduc notion expand variant captur key structur characterist finit loop show approach superior oscheck evacheck effici oscheck reliabl evacheck copyright elsevi scienc bv b introduct recurs natur logic program lead possibl run innit loop topdown queri evalu innit loop refer innit sldderiv illustr exampl evalu goal pa logic program lead innit loop anoth repres logic program current leav depart comput scienc univers alberta edmonton alberta canada tg h email ydshencsualbertaca fax evalu queri pga gener innit loop loop check long recogn problem logic program although mani loop check mechan propos last decad eg major eg suitabl functionfre logic program determin innit loop check variant goalssubgo sldderiv variant goalssubgo goalssubgo variabl renam henc innit loop like l detect variant goalssubgo occur deriv import fact functionfre logic program innit loop complet avoid appeal tabl techniqu howev innit loop function remain unresolv even tabl system best knowledg among exist loop check mechan two deal innit loop like l one call oscheck for overs loop check evacheck for extend variant atom loop check oscheck rst introduc sahlin formal bol determin innit loop base two paramet depth bound size function size inform os check say sldderiv may go innit loop gener overs subgoal subgoal said overs ancestor subgoal sldderiv predic symbol whose size smaller equal a exampl choos innit loop prove oscheck complet sens cut innit loop howev mere take number repeat predic symbol size subgoal decis paramet without refer inform intern structur subgoal underli decis fairli unreli ie mani nonloop deriv may prune unless depth bound set sucient larg evacheck propos shen determin innit loop base depth bound gener variant inform evacheck say sldderiv may go innit loop gener subgoal gener variant ancestor subgoal subgoal said gener variant subgoal variabl renam except argument whose size increas via set recurs claus recurs claus form like c p one distinct properti repeatedli appli may lead recurs increas size subgoal two dierent topic termin logic program one termin analysi see detail survey loop check see paper studi loop check recurs increas term size key featur innit loop function is innit loop innit larg subgoal gener repeatedli appli set recurs claus due fact evacheck complet much reliabl oscheck sens less like misidentifi innit loop oscheck obviou advantag simplic unreli contrast evacheck reliabl major case comput expens main cost evacheck come comput recurs claus one hand given logic program need determin claus recurs claus hand subgoal sldderiv order determin gener variant a need check deriv appli set recurs claus observ show process timeconsum paper continu explor complet loop check mechan prove quit use stop criteria partial deduct logic program see relat stop criteria partial deduct loop check one hand unlik oscheck fulli employ structur characterist innit loop design reliabl loop check mechan hand instead reli expens recurs claus extract structur inform innit loop directli individu subgoal introduc new concept expand variant captur key structur characterist certain subgoal innit loop inform subgoal expand variant subgoal variant except term ie variabl constant function grow function contain term notion expand variant provid use tool seri complet loop check mechan dene paper develop four vafcheck for variant atom loop check logic program function v af d depth bound loop base expand variant v af d enhanc v af d take account one innit repeat claus v af d enhanc v af d constraint set innit repeat claus v af d enhanc v af d constraint recurs claus reliabl increas v af d v af d comput overhead increas too balanc two key factor choos v af d best practic applic v af d complex oscheck far reliabl oscheck v af d reliabl vast major logic program moreov less reliabl evacheck v af d much ecient evacheck becaus like oscheck comput recurs claus plan paper follow section review basic concept concern loop check section introduc expand variant examin properti section dene four vafcheck prove complet section make comparison vafcheck oscheck evacheck preliminari section review basic concept concern loop check assum familiar basic concept logic program present throughout logic program alway mean posit logic program variabl begin capit letter predic symbol function symbol constant lower case letter let atomfunct size a denot jaj count function symbol variabl constant a use rela refer predicatefunct symbol a use ai refer ith argument a aij refer jth argument ith argument aik refer kth argument ith argument exampl let denit variant sldderiv resp goal subgoal atom function mean deriv resp goal subgoal atom function variabl renam denit let p logic program g top goal comput rule let l set sldderiv p fg g s dene proper subderiv dg l subderiv free simpl loop check comput set l nite sldderiv l close variant subderiv free observ loop check l formal dene certain type innit loop gener s ie sldderiv g said step innit loop g k g l therefor whenev innit loop detect cut immedi g k lead follow denit denit let sldtree p fg g l loop check let sldderiv top goal g g lg appli l obtain new sldtree consist node goal cut prune prune node sldtree mean remov descend order justifi loop check bol et al introduc follow criteria denit let comput rule loop check l weakli sound follow condit hold everi logic program p top goal g sldtree p fg g s contain success branch contain success branch loop check l complet everi innit sldderiv prune l put anoth way loop check l complet logic program p top goal g ideal loop check would weakli sound complet unfortun sinc logic program full power recurs theori loop check weakli sound complet even functionfre logic program mention introduct paper explor complet loop check mechan order compar dierent complet loop check introduc follow concept denit complet loop check l said reliabl complet loop check logic program p top goal g success sldderiv tl less tl vice versa prove evacheck reliabl oscheck introduct mention notion ancestor subgoal denit subgoal sldtree ancestor list ala dene recurs follow root fg let node sldtree select resolv claus child node let ancestor list ala ancestor list alb b n ala fa g ancestor list ala j j ala j obvious subgoal b ancestor list b ie alb proof requir proof b denit let g g k two node sldderiv b select subgoal g g k respect say ancestor subgoal b denot anc b follow result show ancestor relat anc transit theorem anc anc anc proof denit ancestor list subgoal ala ala ala ala thu ala ala impli ala is anc phrase sound loss gener sequel assum leftmost comput rule select subgoal node leftmost subgoal conveni node goal g unless otherwis speci use refer leftmost subgoal g expand variant design complet reliabl loop check rst need determin princip characterist innit loop possess consid innit loop l see introduct again notic subgoal pfffga i th node g i variant subgoal pffga ith node g except function ga g grow function fga g i howev replac ga constant l pfffa g i variant pffa g except constant g grow function fa g i furthermor replac ga variabl x l pfffx g i variant pffx g except variabl x g grow function fx g i anoth exampl consid program let top goal g z get innit loop l depict fig observ subgoal g i variant g except variabl g grow fa g i fig innit loop l observ reveal key structur characterist subgoal innit loop function formal follow denit let two atomsfunct said expand variant a denot wev a variant except may term certain posit aik grow function term like aik call grow term wrt follow result immedi theorem variant b wev b exampl follow line expand variant variant except grow term gt howev follow line expand variant a c c b uniabl fx case px x variant py x exampl px fx expand variant px x might doubt would happen innit loop exampl exampl let p logic program g top goal follow innit loop clearli subgoal i g i subgoal g second x grow fx is i variant except i expand variant follow properti exampl suggest anonym refere theorem let wev a jaj ja j i k jaikj ja ikj variant jaj ja j exist jaij ja ij proof immedi denit is grow term a denit variant a prove final immedi properti use comput expand variant is ja j jaj conclud expand variant a otherwis determin variant otherwis proceed argument recurs nd grow term check variant except grow term relat variant of dene denit yield equival relat exiv ie variant itself symmetr ie variant b impli b variant a transit ie variant b b variant c variant c howev relat wev equival relat theorem wev a wev b impli b wev a wev b b wev c impli wev c impli b wev c proof straightforward theorem counterexampl pfx wev px px w ev pfx immedi let immedi let although wev transit size set expand variant transit decrea ing follow result immedi theorem corollari wev b b wev c jaj jcj concept expand variant provid basi design loop check mechan logic program function claim support follow theorem theorem let innit sldderiv innit larg subgoal innit mani goal g j proof sinc innit justic given bol page innit subderiv form j sinc logic program nite number claus must set claus program invok innit number time set dierent claus use innit number time must innit subderiv form j logic program nite number predicatefunctionconst symbol contain innit larg subgoal must innit sequenc j j anc j j variant j except term j whose size increas note innit increas term size must result claus caus term grow function form fi cycl appli mean j variant j except term grow j fi ie j wev j vafcheck base expand variant dene seri loop check mechan logic program function section present four repres vafcheck prove complet denit let p logic program g top goal depth bound dene goal satisfi follow condit j d j anc j j wev j j d ja j d ja theorem v af d simpl loop check v af d complet wrt leftmost comput rule proof straightforward denit let innit sldderiv sinc p nite number claus must set claus p invok innit note order claus fc j necessarili s say fc may contain duplic claus say fc cg number time deriv let set distinct claus appli innit number time d then proof theorem innit subderiv form j fc distinguish two case i subgoal whose size innit larg logic program nite number predic symbol function symbol constant must innit mani atom variant let fb rst variant then theorem j b j wev b j jb j condit v af d satis lead deriv prune node leftmost subgoal b d ii subgoal innit larg size theorem must innit mani atom expand variant grow term let fb rst j d b j wev b j jb j j jb j j again condit v af d satis deriv prune complet take lead follow immedi corollari theorem corollari innit sldderiv innit subderiv form j satisfi two condit v af d d observ v af d identi innit loop base expand variant select subgoal reliabl loop check built take account claus select gener expand variant denit let p logic program g top goal depth bound dene goal satisfi follow condit j d j anc j j wev j j d ja j d ja j d claus select resolv j same g theorem v af d simpl loop check v af d complet wrt leftmost comput rule proof straightforward corollari innit sldderiv d innit subderiv form satisfi rst two condit v af d sinc logic program nite number claus must claus c k resolv innit mani subderiv let rst resolv c k third condit d satis conclud proof again take lead follow immedi corollari theorem corollari innit sldderiv innit subderiv form j satisfi two condit v af d d d special case v af d sldderiv prune v af d must prune v af d convers true exampl consid sldderiv cut v af v af condit satis lead follow theorem v af d reliabl v af d consid repetit one claus innit sldderiv constrain loop check develop consid repetit set claus denit let p logic program g top goal depth bound dene goal satisfi follow condit j d j anc j j wev j j d ja j d ja j d claus select resolv j same j d set claus use deriv j j same g theorem v af d simpl loop check v af d complet wrt leftmost comput rule proof straightforward corollari innit sldderiv d innit subderiv form satisfi rst two condit v af d obvious third condit satis well sinc logic program nite number claus must innit sequenc l l j subderiv set claus use deriv l j l j same let rst s fourth condit v af d satis take lead follow immedi corollari theorem corollari innit sldderiv innit subderiv form j satisfi three condit v af d d j g obvious sldderiv prune v af d must prune v af d convers true consid sldderiv cut v af v af condit satis lead follow theorem v af d reliabl v af d introduc anoth constrain loop check recal concept recurs claus introduc denit set claus fr call recurs claus form or similar form m q x r uniabl q x r mgu contain rm uniabl q x r mgu contain fx x put anoth way fr set recurs claus start head r replac x x appli success lead infer chain form last atom q f x uniabl head r mgu contain exampl set claus fc g p fc g p fc p fc g p recurs claus recurs claus caus subgoal increas size recurs ie cycl fr appli size q increas constant fr repeatedli appli innit number time subgoal q gener innit larg size note recurs claus repeatedli appli sinc logic program nite number claus exist recurs claus program innit sldderiv innit larg subgoal subgoal increas size recurs mean innit sldderiv innit larg subgoal gener repeatedli appli certain set recurs claus lead follow denit let p logic program g top goal depth bound dene goal satisfi follow condit j d j anc j j wev j j d ja j d ja j d claus select resolv j same j d set claus use deriv j j same j ja contain recurs claus lead size increas g theorem v af d simpl loop check v af d complet wrt leftmost comput rule proof straightforward corollari innit sldderiv d innit subderiv e form satisfi rst four condit v af d d assum j e contain innit larg size innit increas term size e must gener repeat applic recurs claus mean must innit sequenc l l j e claus use deriv l j l j contain recurs claus lead size increas l j l j let rst s j satisfi condit obtain follow corollari theorem corollari innit sldderiv innit subderiv form j g size increas result applic set recurs claus fc k c n j g enhanc v af d sldderiv prune v af d must prune v af d convers true consid program consist claus pfa sldderiv pa c pfa c cut v af v af recurs claus program follow result theorem v af d reliabl v af d exampl let us choos depth bound appli one four vaf check four illustr innit loop introduc earlier cut node is l l l prune g the second node root prune g exampl consid follow listrevers program borrow top goal g z note c recurs claus again let us choos success appli claus c c c get follow sldderiv easi check expand variant continu expand g rst appli c g gener success node appli c g gener node anc wev ja satis stop expand g appli c g gener node obvious anc wev ja j ja j size increas via recurs claus c v af satis again stop expand g sinc v af cut innit branch retain shortest success sldderiv weakli sound g observ condit vafcheck captur one characterist innit loop obvious except condit make sens expand variant captur key structur characterist subgoal innit loop vafcheck weakli sound major repres logic program see exampl howev consid undecid natur loop check problem choos would safer follow exampl although quit artici illustr point exampl consid follow logic program pfa c follow success sldderiv top goal g mention bol question depth bound optim remain open howev experi show v af weakli sound vast major logic program obvious pa anc pfa pfa wev pa c recurs claus choos deriv prune g four vafcheck is v af weakli sound program appar v af weakli sound observ v af d v af d reliabl increas comput overhead increas well therefor need consid tradeo choos among vaf check practic applic suggest choos vafcheck follow d basic reason prefer i experi show v af weakli sound vast major logic program ii check condit v af d take littl time wherea check recurs claus condit v af d rather costli comparison oscheck evacheck oscheck evacheck v af d complet loop check make comparison base two key factor reliabl comput overhead comparison oscheck begin recal formal denit oscheck denit let p logic program g top goal depth bound let size sizefunct atom dene goal j three version oscheck depend sizefunct size dene rst version atom b condit alway hold thu ignor second version atom a third version atom b ariti n jaij jbij obvious third version reliabl rst two version focu third version comparison oscheck complet weak identi innit loop mainli base sizefunct regardless intern structur atom is therefor order increas reliabl choos depth bound larg possibl exampl howev intern structur atom function may vari drastic dierent applic program use larg depth bound togeth sizefunct loop check criterion could gener ineectiveineci exampl appli osc size program would gener lot redund node follow exampl illustr fact exampl consid follow logic program top goal c success sldderiv follow z easi see oscd size weakli sound program unless choos contrast approach common structur featur repeat subgoal in nite loop character expand variant base expand variant vafcheck weakli sound small depth bound eg major logic program instanc v af weakli sound p exampl show dramat dierenc discuss summar follow result theorem let size sizefunct third version oscheck atom b wev b impli sizeb sizea proof immedi theorem theorem v af d reliabl oscd size proof theorem corollari oscd size satis whenev condit v af d hold sldderiv prune v af d prune oscd size well revers true counterexampl sldderiv exampl prune oscd size v af d discuss comput overhead first note oscheck vaf check ancestor check j anc j requir moreov ancestor subgoal j k oscd size comput although comput expand variant littl expens sizefunct process two string ie atom sinc string process far faster ancestor check which need scan goalstack assum two kind string comput take constant time wrt scan goalstack assumpt complex oscd size v af d note check condit vafcheck take littl time sinc check condit vafcheck requir scan goalstack v af d expens oscd size furthermor condit vafcheck ie comput recurs claus quit expens one hand given logic program need determin claus recurs claus hand two subgoal j j ja sldderiv need nd size increas j j result recurs claus mean v af d could much expens oscd size discuss suggest v af d best choic balanc reliabl overhead among oscd size v af d comparison evacheck begin reproduc denit evacheck denit let p logic program g top goal depth bound dene goal j k gener variant j g here subgoal said gener variant subgoal variant except may argument whose size increas via set recurs claus follow character gener variant immedi denit denit theorem subgoal sldderiv gener variant wev ja j jaj size increas via set recurs claus ev ad reli heavili recurs claus complex similar v af d sinc comput recurs claus expens choos ev ad practic applic unless reliabl v af d howev follow exampl show ev ad reliabl four vafcheck exampl consid follow logic program top goal pfa c success sldderiv follow easili seen fc c g fc g two set recurs claus let us choos gener variant ev a cut deriv howev sldderiv never cut v af condit vafcheck satis ie ja conclus develop four vafcheck logic program function base notion expand variant observ key structur featur innit loop repetit of select subgoal claus recurs increas in term size repetit lead variant becaus logic program nite number claus predicatefunctionconst recurs increas introduc grow term notion expand variant exactli catch structur characterist certain subgoal innit loop due thi vafcheck much reliabl oscheck less reliabl evacheck even small depth bound see exampl hand sinc structur inform extract directli individu subgoal without appeal recurs claus vafcheck except v af d much ecient evacheck balanc reliabl comput overhead choos v af d best one practic applic although v af reliabl vast major logic program due undecid loop check problem like complet loop check v af d gener cannot weakli sound xed d way deal problem heurist tune depth bound practic applic method carri heurist tune present interest open problem studi acknowledg thank anonym refere construct comment greatli improv present rst author support part chines nation natur scienc foundat transcenturi train programm foundat talent chines ministri educ r analysi loop check mechan logic program toward ecient loop check loop check partial deduct tabul resolut wellfound semant tabl evalu delay gener logic program elimin unwant loop prolog note loop prolog termin logic program neverend stori redund elimin loop check logic pro gram foundat logic program partial evalu logic program elimin loop prolog xsb programm manual version mixtu approach automat partial evalu full prolog mixtu automat partial evalu full prolog verifi local strati extend variant atom loop check posit logic program linear tabul resolut well found semant abstract approach loop detect problem old resolut tabul power logic memo logic program tr control recurs infer old resolut tabul effici loop detect prolog use tortoiseandhar techniqu foundat logic program nd extend ed recurs queri process power logic analysi loop check mechan logic program partial evalu logic program mixtu approach automat partial evalu full prolog toward effici loop check memo logic program mixtu sound complet partial deduct unfold base wellfound measur redund elimin loop check logic program tabl evalu delay gener logic program extend variant atom loop check posit logic program abstract approach loop detect problem linear tabul resolut wellfound semant ctr yidong shen jiahuai liyan yuan samuel s p shen qiang yang dynam approach character termin gener logic program acm transact comput logic tocl v n p octob etienn payet fred mesnard nontermin infer logic program acm transact program languag system topla v n p march alexand serebrenik danni de schrey infer termin condit numer loop prolog theori practic logic program v n p septemb