t optim minimum span tree algorithm a establish algorithm complex minimum span tree problem equal decisiontre complex specif present determinist algorithm find minimum span tree graph n vertic edg run time otmn t minimum number edgeweight comparison need determin solut algorithm quit simpl implement pointer machinealthough time bound optim exact function describ known present current best bound known t m om mn certain natur invers ackermann functioneven assumpt t superlinear show input graph select gnm algorithm run linear time high probabl regardless n m permut edg weight analysi use new martingal gnm similar edgeexposur martingal gnp b introduct minimum span tree mst problem studi much centuri yet despit appar simplic problem still fulli understood graham hell gh give excel survey result earliest known algorithm boruvka bor invent fibonacci heap central algorithm ft ggst chazel chaz present mst algorithm base soft heap chaz complex ommn log m n certain invers ackermann function recent chazel chaz modi algorithm chaz bring run time om m n later independ work similar algorithm run time present petti pet give altern exposit om m n result tightest time bound mst problem date though known optim updat version utc technic report tr includ perform analysi random graph new refer part work support texa advanc research program grant seth petti also support mcd fellowship algorithm mention work pointer machin tar restrict edg weight may subject binari comparison power model assum mst comput optim fredman willard fw show unitcost ram bitrepresent edg weight may manipul mst comput linear time karger et al kkt present random mst algorithm run linear time high probabl even edg weight subject comparison still unknown whether power model necessari comput mst linear time howev paper give determinist comparisonbas mst algorithm run pointer machin ot m n time m n number edgeweight comparison need determin mst graph edg n vertic addit show algorithm run linear time vast major graph regardless densiti permut edg weight natur algorithm exact run time known might seem paradox rst sourc algorithm optim mysteri run time use precomput mst decis tree whose exact depth unknown nonetheless provabl optim trivial lower bound algorithm m best upper bound ommn due chazel chaz point precomput optim decis tree increas constant factor hidden bigoh notat result nonuniform algorithm optim mst algorithm contrast complexitytheoret result optim veric algorithm problem use construct optim algorithm problem jo though asymptot optim construct hide astronom constant factor prove noth relationship algorithm complex decisiontre complex see section discuss relat issu next section review wellknown mst result use algorithm section prove key lemma give procedur partit graph mst respect manner section give overview optim algorithm discuss structur use precomput decisiontre mst problem section give algorithm proof optim section show algorithm may modi run pointer machin section show algorithm run lineartim whp input graph select random section discuss relat problem algorithm open question actual complex mst preliminari input undirect graph e edg assign distinct realvalu weight minimum span forest msf problem ask span acycl subgraph g least total weight paper assum conveni input graph connect sinc otherwis nd connect compon linear time solv problem connect compon thu msf problem ident minimum span tree problem wellknown one identifi edg provabl msf use cut properti edg provabl msf use cycl properti cut properti state lightest edg cross partit vertex set two part must belong msf cycl properti state heaviest edg cycl graph cannot msf boruvka step earliest known msf algorithm due boruvka bor algorithm quit simpl proce sequenc stage stage execut boruvka step graph g identi set f consist minimumweight edg incid vertex g add edg msf sinc must msf cut properti form graph input next stage gnf graph obtain contract connect compon form f comput perform linear time sinc number vertic reduc least factor two run time algorithm om log n n number vertic edg input graph optim algorithm use procedur call boruvkag f g procedur execut two boruvka step input graph g return contract graph g well set edg f identi msf two step dijsktrajarnkprim algorithm anoth earli msf algorithm run om log n time one jarnk jar rediscov dijkstra dij prim prim refer algorithm djp algorithm brie y djp algorithm grow tree initi consist arbitrari vertex one edg time choos next edg follow simpl criterion augment minimum weight edg x y x cut properti edg msf lemma let tree form execut number step djp algorithm let e f two arbitrari edg exactli one endpoint let g maximum weight edg path e f g cannot heavier e f proof let p path connect e f assum contrari g heaviest edg p fe fg consid moment g select djp let p portion p present tree exactli two edg p p elig chosen djp algorithm moment one edg g edg p choic g must lighter g edg either e f assumpt must lighter g case g could chosen next djp algorithm contradict dens case algorithm algorithm present ft ggst chaz chaz pet nd msf graph linear time graph sucient dens ie sucient larg edgetovertex ratio purpos sucient dens mean n n number vertic graph algorithm run linear time densiti procedur densecaseg f take input nnode graph g return msf f g linear time graph densiti n optim algorithm call densecas graph deriv nnode medg graph contract vertic number vertic reduc factor n number edg contract graph m straightforward see densecas run om n time graph soft heap main data structur use algorithm soft heap chaz soft heap kind prioriti queue give us optim tradeo accuraci speed support follow oper makeheap return empti soft heap insert x insert item x heap s findmin return item smallest key heap s delet x heap s creat new heap contain union item store destroy process oper take constant amort time except insert take olog save time soft heap allow item group togeth treat though singl key item adopt largest key item group corrupt item new key dier origin key thu origin key item return findmin ie item group minimum key key uncorrupt item heap guarante n insert oper n corrupt item heap follow result shown chaz lemma fix paramet begin prior data consid mix sequenc oper includ n insert soft heap amort complex oper constant except insert take olog time n item corrupt given time key lemma procedur robust contract lemma well known tree msf edg contract singl vertex maintain invari msf contract graph plu give msf graph contract algorithm nd tree msf edg corrupt graph edg weight increas due use soft heap lemma given show use inform obtain contract certain corrupt tree particular construct use number step dijkstrajarnikprim djp algorithm idea similar use chazel algorithm chaz explicitli recent algorithm petti pet chazel chaz state lemma need notat preliminari concept let v g eg vertex edg set g n cardin respect let gweight edg weight graph g the g may omit impli context follow denit c subgraph g denot g graph deriv g rais weight edg arbitrari amount these edg said corrupt let mc set edg exactli one endpoint c let gnc denot graph obtain contract connect compon induc c ie replac connect compon singl vertex reassign edg endpoint appropri dene subgraph c g djpcontract execut djp algorithm g number step suitabl start vertex c tree result span tree c lemma let set edg graph g c subgraph g djpcontract wrt g msf g subset msf c msf gnc mc mc proof edg c msfc heaviest edg cycl c sinc cycl exist g well edg msfg need show edg gnc msfgnc mc also msfg henc need show edg h msf h msf g let e heaviest edg cycl h ie e h msf h involv vertex deriv contract c exist g well e msf g otherwis form path p g whose end point say x y c let end edg p x w includ corrupt edg one end point c gweight edg g mweight let span tree c deriv djp algorithm q path connect x y g heaviest edg q notic p q form cycl choic e must heavier x y w z lemma heavier x y w z heavier g mweight g upper bound gweight edg q wrt gweight e heaviest edg cycl p q cannot msf g partit procedur algorithm use partit procedur given below procedur nd djp contract subgraph c edg progress corrupt soft heap let mc contain corrupt edg one endpoint c time complet subgraph c djpcontract wrt graph deriv g sever round contract edg delet c nish contract incid corrupt edg discard appli lemma repeatedli see c built msf g subset msf partit procedur shown figur argument appear semicolon input other output set edg cfc set subgraph g edg appear one mc initi partit set everi vertex live object convert vertex dead signifi part compon c maxsiz vertic part conglomer maxsiz vertic conglomer connect compon graph intuit conglomer collect c s link common vertic scheme grow compon similar one given ft grow c s one time accord djp algorithm except use soft heap compon done grow reach maxsiz vertic attach exist compon clearli compon reach maxsiz vertic link partitiong vertic initi live live vertex increment live vertex creat soft heap consist vs edg use vertic v live jv j maxsiz repeat find delet minweight edg x y soft heap live insert ys edg soft heap vertic v dead corrupt edg one endpoint v dismantl soft heap let c fc z subgraph g induc v z exit figur partit procedur conglomer least maxsiz vertic henc vertic design dead upon complet compon c discard set corrupt edg one endpoint c run time partit domin heap oper depend edg insert soft heap twice onc endpoint extract onc charg cost dismantl heap insert oper creat it henc total run time om log number discard edg bound number insert scale thu jm j m thu lemma given graph g paramet maxsiz partit nd edgedisjoint subgraph a b i jv c j maxsiz c conglomer p d jemj jegj overview optim algorithm overview optim msf algorithm rst stage nd djpcontract subgraph c associ set edg consist corrupt edg one endpoint c second stage nd msf f c msf f contract graph gn msf whole graph contain within note point identi edg msf origin graph g third stage nd msf edg via boruvka step recurs graph deriv contract edg execut rst stage use partit procedur describ previou section execut second stage optim decis tree essenti hardwir algorithm design comput msf graph use optim number edgeweight comparison gener decis tree much larger size problem solv nding optim one time consum aord cost build decis tree guarante one extrem small time make conglomer form c sucient larg msf f contract graph found linear time use densecas algorithm final third stage reduct vertic due boruvka step reduct edg due applic lemma optim algorithm vertic edg reduc constant factor thu result recurs applic algorithm graph geometr decreas size decis tree msf decis tree root tree edgeweight comparison associ intern node eg weightx y weightw z intern node exactli two children one repres comparison true fals leav tree list edg span tree msf decis tree said correct edgeweight comparison encount path root leaf uniqu identifi span tree leaf msf decis tree said optim correct exist correct decis tree lesser depth let us bound time need nd optim decis tree graph r vertic brute forc search fewer r graph graph must check possibl decis tree bound depth r r possibl intern node r r o decis tree check determin decis tree correct gener possibl permut edg weight each solv msf problem given graph simultan check permut decis tree first put permut root move left right child depend truth falsiti edgeweight comparison wrt permut repeat step permut reach leaf leaf permut share leaf agre msf decis tree correct process take longer r decis tree set allow us precomput optim decis tree on time observ highlevel algorithm gave section maximum size compon c sucient small compon organ rel small number group isomorph compon ignor edg weight group use singl precomput optim decis tree determin msf compon group optim algorithm use procedur decisiontreeg f take input collect graph g r vertic return minimum span forest f use precomput decis tree algorithm discuss abov optim msf algorithm follow first precomput optim decis tree graph log n vertic next divid input graph subgraph discard set corrupt edg mc c complet use decis tree found earlier comput msf f c contract connect compon span f ie conglomer singl vertex result graph n log n vertic sinc conglomer least log n vertic lemma henc use densecas algorithm comput msf f time linear m point lemma msf contain edg set f graph appli two boruvka step reduc number vertic factor four comput recurs algorithm given below thi use soft heap partit procedur precomput optim decis tree graph log n vertic n number vertic origin input graph r log jv gj partitiong g apart recurs call use decis tree comput perform opti malmsf clearli linear sinc partit take om log owe reduct vertic call densecas also take linear time number edg pass nal recurs call m give geometr reduct number edg sinc msf algorithm better linear time bottleneck ani must lie use decis tree optim construct concret let m n run time optimalmsf let m n optim number comparison need graph n vertic edg let g optim number comparison need specic graph g recurr relat given below base case note graph recurs call connect input graph connect henc base case graph edg one vertex equal constant straightforward see m n om recurr give m om one also show m n ot m n mani natur function includ n howev show result hold matter function describ m n is need establish result decis tree complex msf problem next section result msf decis tree section establish result msf decis tree allow us establish main result optimalmsf run ot m n time proposit m n m proposit xed proposit obvious true sinc everi edg particip comparison determin inclus exclus msf proposit hold sinc add isol vertic graph obvious aect msf number necessari comparison state properti use lemma properti structur g dictat edgedisjoint subgraph g compon return partit seen graph denit sinc everi simpl cycl graph must contain exactli one c see thi consid simpl cycl let largest index c contain edg cycl sinc c share one vertex contain edg proof follow lemma found prb lemma properti hold g exist optim msf decis tree g make comparison form e f e c proof consid subset p permut edg weight e c hold weight weightf permut p two use properti readili veri first number intercompon comparison shed light rel weight edg compon second span forest compon msf compon permut p consid optim decis tree g let subtre contain leav reach permut p intercompon comparison node must one child rst properti msf leaf deduc use intracompon comparison second properti must determin msf compon correctli thu properti must determin msf graph g correctli henc contract correct decis tree replac onechild node child lemma properti hold g proof given optim decis tree c construct decis tree g replac leaf gener replac leaf i label leaf last tree union label origin tree along path clearli height tree sum height henc g need prove optim decis tree g height less sum height let optim decis tree g intercompon comparison as guarante lemma show transform canon decis tree g height comparison c preced comparison c i i further i subgraph contain comparison within c consist collect isomorph tree establish desir result sinc must contain path concaten longest path optim decis tree c rst prove result case two compon c c assum induct subtre root vertic certain depth transform desir structur c comparison occur c comparison subtre c within subtre root depth isomorph thi trivial case equal height consid node v depth comparison node c comparison c subtre descend node must comput set leav c henc subtre root v convert desir format simpli replac c subtre one minimum depth note two dierent c subtre c subtre descend left right child v must isomorph comparison v c comparison know c subtre root left child x right child must comput set leav c henc pick c subtre smaller height wlog let root x replac v x togeth c subtre root x copi comparison node v leaf posit c subtre copi place one isomorph copi c subtre descend x left subtre c subtre descend right subtre subtre root x depth desir form comput result increas height tree henc induct convert canon decis tree greater height assum induct result hold k compon result easili extend k compon note group rst k compon c let c k c method transform canon tree c k comparison appear leaf subtre strip c k subtre canon tree induct assumpt perform transform remain k compon corollari let c compon form partit routin appli graph g let g edg n vertic then corollari n solv recurr relat run time optimalmsf given previou section corollari corollari proposit c m n for sucient larg c complet induct give us desir theorem theorem let m n decisiontre complex msf problem graph edg n node algorithm optimalmsf comput msf graph edg n vertic determinist ot m n time avoid pointer arithmet precis speci requir underli machin model upon examina tion algorithm seem requir full power random access machin ram bit manipul use arithmet limit increment oper howev procedur decisiontre implement obviou manner requir use tabl lookup thu random access memori section describ altern method handl decis tree run pointer machin tar model allow random access memori method similar describ b ensur time overhead perform tabl lookup call decisiontre linear size current input decisiontre pointer machin distinguish pointer data type oper allow pointer assign comparison equal dereferenc memori organ record hold constant number pointer normal data word integ oat etc given pointer particular record refer pointer data word record constant time nonpoint data usual array logic arithmet binari comparison oper allow rst describ represent decis tree decis tree associ gener graph edg weight decis tree determin mst permut edg weight gener graph intern node decis tree four pointer rst two point edg gener graph compar second two point left right child node leaf list edg span tree gener graph sinc decis tree pointerbas structur construct precomput decis tree by enumer check possibl without use tabl lookup describ represent gener graph vertic gener graph number order integ start represent consist list vertic order start follow adjac list vertex start vertex gener graph pointer root decis tree recal precomput decis tree gener graph log n vertic where n number vertic input graph whose msf need nd gener graph gener store lexicograph sort order note represen tation sort order gener graph appear nondecreas order number vertic graph use decis tree actual graph which must isomorph gener graph decis tree must associ edg actual graph counterpart gener graph thu comparison edg weight gener graph substitut correspond weight actual graph constant time random access machin encod possibl graph singl machin word say adjac matrix index gener graph array accord represent thu given graph nd associ decis tree constant time pointer machin howev convert bit vector integ pointer specic disallow describ method identifi gener graph c ecient assum c speci adjac list represent edg x y pointer occurr y x ys adjac list edg also pointer record contain weight let n number edg vertic rewrit c form gener graph call numer represent let c p vertic note p r assign vertic number p order list adjac list represent rewrit edg pair number indic endpoint edg retain pointer weight separ numer represent chang format graph follow instead list number rang r repres graph list pointer initi link list r bucket label r if numer represent number j appear replac pointer j th bucket transform graph pointer represent travers rst list vertic list edg order travers list bucket simultan replac vertex entri rst vertex entri edg pointer correspond bucket thu edg x y also appear y x appear ptrx y ptri x employ twin pointer replac remain x equival pointer clearli transform perform om time sum size perform lexicograph sort ahu sequenc c s order group togeth isomorph compon represent replac bucket index perform tradit lexicograph sort access bucket pointer place element henc run time pointerbas lexicograph sort o length th vector decisiontre call graph size r olog n sum size graph om henc radix sort perform om final march sort list c s sort list gener graph match appropri need travers initi sequenc sort gener graph contain o r entri order match graph take time om perform random graph even assum mst superlinear complex show algorithm run linear time nearli graph regardless edg weight improv upon expect lineartim result karp tarjan kt depend edg weight chosen randomli result may also contrast random algorithm karger et al kkt shown run om time whp proof depend permut edg weight random bit chosen graph topolog fact none earlier publish mst algorithm appear properti run linear time whp random graph edgeweight use analysi section suitabl soupedup version earlier algorithm ft ggst chaz may obtain high probabl result analysi hing observ spars random graph whp subgraph construct partit routin miniscul number edg excess number span forst edg subgraph mst graph comput linear time henc comput optim decis tree take linear time graph throughout section denot m n theorem mst graph found linear time probabl e graph drawn g nm graph drawn g np hold regardless permut edg weight next section describ edgeaddit martingal g nm model section use martingal azuma inequ prove part theorem part shown follow part edgeaddit martingal consid g nm random graph model graph n label vertic edg equal like analyt purpos select random graph begin n vertic ad one edg time er let x random edg st x graph made rst edg g graph n vertic edg martingal sequenc random variabl prove g graphtheoret function martingal lemma sequenc m martingal g graph theoret function g edgefre graph n vertic g deriv g ad random edg g g g given g xed call sequenc prove martingal lemma edgeaddit martingal contrast edgeexposur martingal g np recal wellknown azuma inequ see eg as theorem azumaa inequ let ym martingal jy m let arbitrari prji facilit applic azuma inequ edgeaddit martingal establish follow lemma lemma consid sequenc prove martingal lemma let g graphtheoret function jgg gg j pair graph g g form averag rang possibl outcom given g g respect identifi outcom equals disjoint set outcom x cover outcom x may regard averag set averag if set correspond outcom p x establish set averag dier gg p lemma follow correspond follow let a outcom x correspond set consist outcom x j rang edg appear g x outcom i q p s associ set sinc graph dier one edg clearli hold well averag outcom q p s associ set analysi dene excess subgraph h jehj jf hj f h span forest h let fg maximum excess graph made intracompon edg set compon rang possibl set return partit procedur recal size compon key observ lead lineartim result pass optim algorithm denit run linear time fg mmn see thi note bound fg hold reduc total number intracompon edg m linear time use log boruvka step then clearli mst result graph determin om time show graph randomli chosen g nm fg mmn high probabl show lemma appli graphtheoret function f appli azuma inequ obtain desir result lemma let two graph set label vertic dier one edg jfg fg j proof suppos wlog fg fg could appli optim set compon g g everi intracompon edg g remain intracompon edg except possibl e reduc excess one contradict possibl e may becom intracompon edg help argument lemma proof notic simpli imposs m intracompon edg assum upper bound f e g expect number indic st edg x complet cycl length k g sinc edg caus f increas must satis criterion probabl x complet cycl length k bound number cycl probabl exist graph n nm recal m n either case f g chosen g nm prfg m e proof appli azuma inequ prjf e gm set give lemma note lemma f insignic readi prove theorem proof examin rst log k pass optim algorithm sinc remain pass certainli take om time lemma assur us rst pass run linear time whp howev topolog graph examin later pass depend edg weight assum boruvka step contract part graph constant rate easili enforc partit graph one pass algorithm correspond partit origin graph compon size less k c xed c use k c place k aect lemma give theorem g nm is part g np note probabl pn edg exponenti pn henc probabl algorithm fail run linear time domin bound part for spars case n theorem part hold probabl n cherno bound part hold probabl e n intrigu aspect algorithm know precis determinist run time although prove within constant factor optim result natur obtain past sensit analysi minimum span tree drt convex matrix search lar also problem triangul convex polygon observ drt altern lineartim algorithm could obtain use optim decis tree small subproblem howev earlier algorithm make use decis tree straightforward way algorithm present here note section construct optim decis tree take sublinear time thu import observ use decis tree result larg constant factor run time further construct optim decis tree perform straightforward bruteforc search henc result algorithm uniform mention introduct optim algorithm construct prob lem given optim veric algorithm problem jo construct produc algorithm enumer program for machin model execut increment whenev one program halt verier check output correct use lineartim mst veric algorithm drt k b construct yield optim mst algorithm howev unsatisfactori sever reason asid truli astronom constant factor roughli exponenti size optim program algorithm optim respect particular machin model say tm ram pointer machin result contrast robust tie algorithm complex mst decisiontre complex limit factor machin model alway case algorithm complex decisiontre complex asymptot equival fact one easili concoct simpl problem nphard nevertheless polynomialdepth decisiontre eg nd lightest edg hamiltonian path see gk pr section two sortingtyp problem whose decisiontre complex algorithm complex provabl diverg conclus present determinist msf algorithm provabl optim algorithm run pointer machin graph n vertic edg run time ot m n m n decisiontre complex msf problem nnode medg graph also random graph algorithm run linear time high probabl possibl edgeweight although exact run time algorithm known shown time bound depend number edgeweight comparison need determin msf data structur issu determin worstcas complex algorithm main open question remain msf problem howev subtler open question given optim uniform algorithm msf problem optim uniform algorithm use precomput decis tree or similar techniqu gener problem precomput necessari one may wish studi issu simpler set say msf veric problem pointer machin still m n factor separ best pointer machin algorithm use precomput decis tree b one tarb one may also ask parallel complex msf problem here resolv recent random worktim complex pr determinist time complex chl msf problem erew pram open question remain obtain determinist worktim optim parallel msf algorithm parallel optim algorithm straightforward although handl decis tree present problem parallel context still need method identifi contract compon parallel base case algorithm perform linear work graphdens log n exist sequenti algorithm suitabl base case one ft also easili paralleliz r design analysi comput algorithm probabilist method faster determinist algorithm minimum span tree minimum span tree algorithm inverseackermann type complex parallel time complex undirect connect minimum span tree note two problem connexion graph fibonacci heap use improv network optim algorithm histori minimum span tree problem optim random algorithm local sort set maxima comput complex program perspect random lineartim algorithm nd minimum span tree linear expectedtim algorithm connect problem simpler minimum span tree veri optim algorithm unknown time complex convex matrix search random timework optim parallel algorithm nding minimum span forest proceedingsproc optim minimum span tree algorithm comput undirect shortest path comparison addit find minimum span tree om shortest connect network gener class algorithm requir nonlinear time maintain disjoint set applic path compress balanc tree tr effici algorithm find minimum span tree undirect direct graph fibonacci heap use improv network optim algorithm optim algorithm unknown time complex convex matrix search verif sensit analysi minimum span tree linear time optim random algorithm local sort setmaxima transdichotom algorithm minimum span tree shortest path random lineartim algorithm find minimum span tree comput complex lineartim pointermachin algorithm least common ancestor mst verif domin applic path compress balanc tree soft heap minimum span tree algorithm inverseackermann type complex concurr thread optim parallel minimum span tree algorithm comput shortest path comparison addit minim random minimum span tree parallel connect set maxima algorithm design analysi comput algorithm random timework optim parallel algorithm find minimum span forest faster determinist algorithm minimum span tree find minimum span tree om alphamn time ctr jess cerquid ramon lpez mntara tan classifi base decompos distribut machin learn v n p june artur czumaj christian sohler estim weight metric minimum span tree sublineartim proceed thirtysixth annual acm symposium theori comput june chicago il usa tzuchiang chiang chienhung liu yuehmin huang nearoptim multicast scheme mobil ad hoc network use hybrid genet algorithm expert system applic intern journal v n p octob seth petti new approach allpair shortest path realweight graph theoret comput scienc v n p januari ran mendelson robert e tarjan mikkel thorup uri zwick meld prioriti queue acm transact algorithm talg v n p octob amo korman shay kutten distribut verif minimum span tree proceed twentyfifth annual acm symposium principl distribut comput juli denver colorado usa