t select memoiz a present framework appli memoiz select framework provid programm control equal space usag identif precis depend memoiz appli accord need applic two key properti framework effici yield program whose perform analyz use standard techniquesw describ framework context function languag implement sml librari languag base modal type system allow programm express program reveal true data depend execut sml implement cannot support modal type system static instead employ runtim check ensur correct usag primit b describ framework context function languag implement sml librari languag base modal type system allow programm express program reveal true data depend execut sml implement cannot support modal type system stati calli instead employ runtim check ensur correct usag primit categori subject descriptor program languag gener f analysi algorithm problem complex gener d program languag formal denit theori d program languag languag construct fea turescontrol structur gener term languag perform algorithm keyword memoiz select programm control perform research support part nsf grant ccr ccr ccr permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut prot commerci advantag copi bear notic full citat rst page copi otherwis republish post server redistribut list requir prior specic permiss andor fee popl januari new orlean louisiana usa acm memoiz fundament power techniqu result reus date back half centuri use extens mani area dynam program increment comput mani other fact lazi evalu provid limit form memoiz although memoiz dramat improv perform requir small chang code languag librari support memoiz gain broad accept instead mani success use memoiz reli applicationspec support code underli reason one control sinc memoiz perform user must abl control perform memoiz mani subtleti memoiza tion includ cost equal check cach replac polici memo tabl make differ exponenti linear run time gener wide applic memoiz framework must provid control three area kind cost equal test ident precis depend input output memoiz code space manag control equal test critic reusabl result identi control ident precis depend import maxim result reus abl control memo tabl individu entri purg critic otherwis user know whether result reus paper propos framework memoiz provid control equal ident depend control space manag studi framework context small languag call mfl provid implement standard ml languag also prove type safeti correct mflie semant preserv respect nonmemo version exampl show analyz perform memoiz version quicksort within framework next section describ background relat work section introduc framework via exampl section formal mfl languag discuss safeti cor rect perform properti section present simpl implement framework standard ml librari section discuss framework might extend allow better control space usag discuss relationship work previou work adapt comput background relat work typic memoiz scheme maintain memo tabl map argument valu previous comput result tabl consult function call determin particular argument tabl so call skip result return otherwis call perform result ad tabl semant implement memo lookup critic perform review key issu implement memoiz efcient equal memoiz scheme need search memo tabl match current argument search will minimum requir test equal typic also requir form hash standard languag implement test equal structur exampl requir travers whole structur cost equal test negat advantag memoiz may even chang asymptot behavior function approach propos allevi problem rst base fact memoiz equal need exactit return unequ two argument actual equal implement could therefor decid skip test equal expens could use conserv equal test locat equal problem approach whether match found could depend particular implement sure evid programm anoth approach reduc cost equal test ensur one copi everi valu via techniqu known hash cons one copi equal implement compar locat fact locat also use key hash tabl theori overhead hashcons constant expect case expecta tion intern random hash function realiti howev rather differ larg memori demand hashcons interact garbag collect fact sever research argu hashcons expens practic purpos altern hash con sing pugh propos lazi structur share lazi structur share whenev two equal valu compar made point copi speed subsequ comparison pugh point out disadvantag approach perform depend order comparison thu difcult analyz note even hashcons method remain critic dene equal type includ real function claim function never equival exam ple satisfactori result call involv function paramet never reus depend maxim result reus result function call must store respect true depend issu aris function examin part approxim paramet enabl partial equal check unexamin part paramet disregard increas likelihood result reus one abl match approxim rather paramet itself exam ple consid code result f depend either xy xz also depend approxim xwhether positiverath exact valu thu memo entri match sinc x posit result depend y sever research remark partial match import applic abadi lampson levi heydon levin yu suggest program analysi method track depend purpos although techniqu like effect catch potenti match provid programm control mechan specifi depend track also program analysi techniqu chang asymptot perform pro gram make difcult ass effect memoiz space manag anoth problem memoiz space requir program execut memo tabl becom larg limit util memoiz allevi problem memo tabl individu entri dispos programm control applic dynam program result reus occur among recurs call function thu memo tabl function dispos whenev ter minat applic result reus less structur individu memo tabl entri purg accord replac polici problem determin exact replac polici use analyz perform effect chosen polici one wide use approach replac least recent use entri other sophist polici also suggest gener replac polici must applicationspec becaus xed polici program whose perform made wors choic framework select memoiz present overview framework via exampl framework extend pure function languag sever construct support select memoiz section use extens mllike languag discuss formal core languag studi safeti sound perform properti section framework enabl programm determin precis depend input result function main idea deem paramet function resourc provid primit explor increment valu includ underli valu resourc increment explor process reveal depend paramet function result increment explor process guid type valu modal type t underli valu type bound ordinari unrestrict variabl let construct creat depend underli valu result valu product type two part bound two resourc use let construct creat depend valu sum type case analyz use mcase construct branch accord outermost form valu assign inner valu resourc mcase creat depend outer form valu resourc key aspect let mcase bind resourc rather ordinari variabl nonmemo memoiz fun fib nint mfun mfib nint n n n n els yint yint fy return fy y els els fz z return fz z figur fibonacci express partial depend explor input function via let mcase let build branch record depend input result function let add branch full valu mcase add kind sum let add noth con sequent branch contain data depend from let control depend from mcase return en counter branch record reveal depend use key memo tabl result found memo tabl store valu return otherwis bodi return evalu memo tabl updat map branch result type system ensur depend made explicit preclud use resourc within return bodi exampl consid fibonacci function fib memoiz counterpart mfib shown figur memoiz version mfib expos underli valu paramet resourc perform two recurs call usual sinc result depend full valu paramet bang type memoiz fibonacci function run linear time oppos exponenti time memoiz partial depend input result function captur use increment explor techniqu exampl consid function f shown figur function check whether x posit return fyy fzz thu result function depend approxim x it sign either z memoiz version mf captur rst check x posit expos underli valu y z accordingli consequ result depend sign x either y z thu mf call paramet rst result found memo second time x posit result depend y note mif construct use exampl special case gener mcase construct critic issu efcient memoiz implement memo tabl along lookup updat oper them framework support expect constant time memo tabl lookup updat oper repres memo tabl use hash thi requir underli type modal type t index type index type associ inject function call index function map valu type uniqu integ integ call index valu uniqu properti indic given type ensur two valu equal indic equal framework equal dene nonmemo type irlintr list ks case l c w ks ct els let vv v els v figur memo tabl card complet memoiz type irlintr blist mfun mk cintlirl case unbox l conswvt c w els let vv v els v end memoiz knapsack di index type enabl us implement memo tabl hash tabl key branch consist indic assum primit type come index function exampl integ ident function chosen index function composit type list function must box obtain index type box valu type type tbox box creat assign uniqu locat or tag locat use uniqu index box valu exampl dene box list follow datatyp con a blist box type blist a blist box base box implement hashcons form memoiza tion exampl hashcons box list implement follow mfun hcon ha ta return box consht function take item box list return box list form cons them sinc function memoiz ever call two valu alreadi hashcons result return advantag abl de ne hashcons memoiz function appli select control space usag memo tabl framework give programm way dispos memo tabl convent scop ing framework memoiz function alloc memo tabl thu function goe scope memo tabl garbag collect exampl mani dynamicprogram algorithm result reus occur recurs call function case programm scope memoiz function insid auxiliari function memo tabl discard soon auxiliari function return exampl consid standard algorithm knapsack problem ks memoiz version mk figur sinc result share mostli occur among recurs call mk scope function call mk mk return memo tabl go scope discard note techniqu give partial control space usag particular give control individu nonmemo memoiz fun fil gintbool fun mfil gintbool lint case l case unbox l nil nil nil empti ht consht let let case g h case g h true htt true hconshtt fals tt fals tt let return case l case unbox l nil nil nil nil consht consht let let qs shq g mq shmq g figur quicksort algorithm memo tabl entri purg section discuss framework might extend memo tabl manag accord programm speci cach scheme basic idea requir programm suppli cach scheme paramet mfun maintain memo tabl accord chosen cach scheme memoiz quicksort sophist exampl consid quicksort figur show implement quicksort algorithm memoiz counterpart algorithm rst divid input two list contain key less pivot greater pivot use lter function fil sort two sublist return concaten result memoiz lter function mfil use hashcons ensur one copi result list memoiz quicksort algorithm mq expos underli valu paramet otherwis similar qs note mq build result via hashconsingit output two copi result sinc exampl output mq consum func tion need so even result consum function one choos use hashcons oper insert delet input list sure chang result quicksort memoiz quicksort algorithm call similar in put one would expect result would reus inde show memoiz quicksort algorithm comput result expect linear time input obtain previou input insert new key begin expect permut input list also intern random hash function use implement memo tabl analysi assum without loss gener iti key list uniqu theorem let l list let run memoiz quicksort l l run time quicksort modi list l expect on n length l figur recurs tree quicksort input proof consid recurs tree quicksort input l denot ql label node pivot correspond recurs call see figur exampl consid pivot key p l let lp denot key preced p l easi see key k subtre root p follow two properti satis key k lp k p k k k p k k key subtre p less p left subtre greater p right subtre consid recurs tree ql pivot ql suppos p let k key left subtre p ql sinc k p two properti k left subtre p ql similarli p k right subtre p ql also right subtre p ql sinc ltere preserv respect order key input list p p a input recurs call correspond left child same similarli p a input recurs call correspond right child same thu sort l recurs call nd result memo therefor recurs call correspond root children node rightmost spine left subtre root children node leftmost spine right subtre root may execut the two spine shown thick line figur furthermor result call adjac spine found memo consid call whose result found memo worst case call along two spine consid size input node spine dene random variabl x xk xi least number recurs call node perform input size becom n less i rst becom n less sinc k dlog ne total expect number oper along spine dlog ne dlog ne sinc probabl pivot lie middl half list exi dlog ne iecn ni thu bound hold spine therefor number oper due call whose result found memo on sinc oper includ hashcons take expect constant time total time call whose result memo on now consid call whose result found memo call spine adjac it thu expect ologn call sinc memo tabl lookup overhead expect constant time total cost ologn conclud quicksort take expect on time sort modi list l easi extend theorem show on bound hold insert anywher list although bound better complet rerun would take onlogn would like achiev ologn section discuss combin memoiz adapt may use reduc expect cost random insert ologn section studi small function languag call mfl support select memoiz mfl distinguish memoiz nonmemo code equip modal track depend data structur within memoiz code modal central approach select memoiz focu attent here main result sound theorem state memoiz affect outcom comput compar standard nonmemo semant also show memoiz mechan mfl caus constant factor slowdown compar standard nonmemo semant abstract abstract syntax mfl given figur metavari x rang countabl set variabl metavari b rang overf countabl set resourc the distinct made clear below metavari l rang countabl set locat assum variabl resourc locat mutual disjoint bind scope convent variabl resourc would expect syntact form usual identifi piec syntax differ choic bound variabl resourc name term express resourcefre contain free resourc variablefre contain free variabl close term express resourcefre variablefre otherwis open type mfl includ unit int product sum recurs data type ut memoiz function type bang type h mfl distinguish index type denot h accept inject function call index function whose codomain integ underli type bang type h restrict index type int type ident serv index constant function chosen index function nonprimit type index suppli box valu type box valu would alloc ix type type mcase mfun f att iseend j figur abstract syntax mfl store uniqu locat box would serv index underli valu extens index type would dene although support box type critic practic purpos formal focu main idea syntax structur term express terminolog pfen davi roughli speak term evalu independ context ordinari function program ming wherea express evalu rel memo tabl thu bodi memoiz function express wherea function term note howev applic function term express correspond encapsul memoiz function updat memo tabl benign complet languag would includ case analysi project form among term sake simplic includ express would also includ plain function bodi term note everi term trivial express return express inclus static semant type structur mfl extend framework pfen davi necessit modal h use track data depend select memoiz modal correspond monad interpret memoiz effect t notat pfen davi though one could imagin ad modal languag introductori eliminatori form necess standard name t introduct letxhbet ineend elimin modal demand distinguish variabl re sourc variabl mfl correspond valid unr strict context modal logic wherea resourc mfl correspond truth restrict context analog may also made judgment present linear logic variabl correspond intuitionist context resourc linear context note howev impos linear constraint type system re pair g fun g funval appli bang inl inr unrol figur type judgment term inclus returnt term express analogu pure modal logic specic interpret memoiz comput effect type rule returnt requir resourcefre ensur depend argument memoiz function made explicit code comput return valu function rst instanc resourc aris paramet memoiz function resourc introduc increment decomposit use let mcase addit resourc track usag asyetunexplor part data structur ultim complet valu resourc may access use let construct bind valu variabl may use without restrict practic mean part argument memoiz function whose valu function depend given modal type howev essenti resourc modal type comput depend upon everi resourc modal type static semant mfl consist set rule deriv type judgment form gd express judgment g variabl type assign nite function assign type variabl resourc type assign nite function assign type resourc rule deriv judgment given figur return let case figur type judgment express dynam semant dynam semant mfl formal select memoiz evalu parameter store contain memo tabl track behavior function program evalu function express caus empti memo tabl alloc associ function applic memoiz function affect by may affect associ memo tabl function valu becom inaccess also associ memo tabl henc storag requir reclaim unlik convent memoiz howev memo tabl key control ow inform rather valu argument memoiz function key support select memoiz express evalu essenti explor avail resourc culmin resourcefre term determin valu sinc explor datasensit certain aspect resourc may relev particular outcom exampl memoiz function may take pair integ argument outcom determin independ second compon case rst posit record controlow inform evalu may use provid select memoiz exampl situat describ pair form map result valu irrespect valu v convent memoiz memo tabl would key pair result redund comput perform case function previous call v even though valu v irrelev result framework instead key memo tabl branch record sufcient control ow inform captur gener case whenev encount return statement queri memo tabl current branch determin whether result comput befor so return store valu not evalu return statement associ valu branch memo tabl futur use crucial return term contain resourc assur valu chang across call function dynam semant mfl given set rule deriv judgment form st t vs for term slbe e vs for express rule deriv judgment given figur rule make use branch memo tabl store whose precis denit follow simpl branch list simpl event correspond choic point evalu express simpl event simpl branch eb write bbe stand extens b event e end memo tabl q nite function map simpl branch valu write qb v b domq stand extens q given bind b write qb mean b domq store s nite function map locat l memo tabl write sl q l dom stand extens given bind l l dom write sl q store map l q l slterm evalu larg standard except evalu memoiz function applic argument evalu memoiz function term alloc fresh memo ta ble associ function valu express evalu initi applic memoiz function argument function valu determin memo tabl use call evalu bodi perform rel tabl initi null branch express evalu perform rel current memo tabl branch return statement encount current memo tabl consult determin whether branch previous taken so store valu re turn otherwis argument term evalu store current memo tabl branch valu return let mcase express extend current branch reect control ow sinc let signal depend complet valu valu ad branch case analysi howev mere extend branch indic case taken let construct extend branch addit inform glean split pair sound mfl prove sound mfl rel nonmemo semant languag straightforward give pure function semant pure fragment mfl induct denit relat t v e e v t e v pure sens may involv subscript function valu underli term t mfl term t obtain eras locat subscript function valu occur within t sound mfl consist show evalu memoiz yield outcom evalu without memoiz theorem sound t t vs full proof given statement theorem must strengthen consider account term expr sion take account nonempti memoiz context proof proce induct evalu easi show nonmemo semant mfl type safe use complet convent techniqu follow unit s t s number sn t ns sntn t vnsn pair l dom se t vs funval appli bang st t vs inject sinlttt t inltt vs sinrttt t inrtt vs unrol figur evalu term memoiz semant also typesaf not would close valu type canon type how ever erasur preserv reect canon form henc sound theorem mfl must also type safe perform show memoiz slow mfl program constant factor expect respect standard nonmemo semant even result reus result reli repres branch sequenc integ use sequenc key memo tabl implement hash tabl repres branch integ sequenc use properti mfl underli type h bang type h index ret not found slbvava e vs let slbletaa bet ineend t vs case figur evalu express type sinc valu index type integ index repres branch depend sequenc integ correspond indic lete valu zero one inl inr consid nonmemo semant return rule alway evalu bodi neither look updat memo tabl store consid mfl program let denot time take the number evalu step evalu program respect nonmemo semant let denot time take evalu program respect mem oiz semant worst case result reus thu differ due memot lookup updat done memoiz semant bound time these consid memo tabl lookup updat branch b let jbj length branch sinc branch sequenc integ lookup updat perform expect ojbj time use nest hash tabl repres memo tabl note nonmemo semant take jbj time build branch thu cost lookup updat charg evalu build branch b ie evalu let mcase furthermor evalu let mcase charg exactli one return thu conclud expect case implement describ implement framework standard ml librari aspect mfl languag reli syntact distinct resourc variabl cannot enforc static standard ml therefor use separ type resourc employ runtim check detect violat correct usag signatur sig express type a expr val return unit a a expr resourc type a re val expos a re a bang type a bang val bang a int a a bang val letbang a bang a b expr b expr product type ab prod val pair a b ab prod val letx ab prod a re b re c expr c expr val split ab prod a b c c sum type ab sum val inl a ab sum val inr b ab sum val mcase ab sum a re c expr b re c expr c expr val choos ab sum a c b c c memoiz arrow type ab marrow val mfun a re b expr ab marrow val mfun rec a b marrow a re b expr ab marrow val mappli ab marrow a b signatur type a box val init unitunit val box aa box val unbox a boxa val getkey a boxint figur signatur memo librari box interfac librari shown figur provid type express resourc bang product sum memoiz function along introduct elimin form express type a expr monad return inclus variou form bind induc elimin form letbang letx mcase resourc type a re expos elimin form resourc creat librari thu introduct form resourc avail user introduct elimin form bang type bang letbang introduct elimin form product type pair letx split respect letx form bind monad expr split elimin form term context treatment sum similar product type introduct form inl inr elimin form mcase choos mcase form bind expr monad choos elimin term context memoiz function introduc mfun mfun rec mfun take function type a re b expr return memoiz function type ab marrow mfun rec similar mfun also take paramet memoiz version note result type contain effect exprw encapsul memoiz effect benign within function elimin form marrow memoiz appli function mappli functor buildmemo structur box box structur struct type a list unit a type a re a re expos val val h vbranch susp type val f re x re x datatyp ab sum inl a inr b mcase f val case inr v g re v lrbranchsusp choos f case inl v f v inr v g v type fun mfun rec val val val case memopadextend mpad branch val some vnone v found result similar mfun rec mappli f figur implement memoiz librari figur show implement librari without runtim check correct usag incorpor runtim check one need sophist denit resourc order detect resourc expos context ie function instanc addit interfac must updat rst paramet letbang letx mcase occur suspend form allow us updat state consist certain ag forc term structur struct type a util fun ibang fibonacci letbang expos n fn n return fn els mappli f ibangn mappli f ibangn mappli mfun rec mfib n box list datatyp a con a a blist box type a blist a blist box hash con letx expos x fn ht letbang expos h fn h letbang expos t fn return fn box consht val hcon mfun hcon knapsack letx expos arg fn cl letbang expos c fn c letbang expos l fn l return fn case unbox l conswvt c w mappli mk pair ibang c bbang t els let val ibang c bbang t val mappli mk arg val ibang cw bbang t val mappli mk arg v v v els v fun mk mappli mfun rec mk x quicksort val val hcon mfun hcon case unbox l consht f h mappli hcon pair ibang h bbang fil f t els letbang expos l fn l return fn case unbox l consht let val val val mappli qs bbang ll val mappli qs bbang gg mfun rec qs figur exampl section sml librari implement extend oper semant mfl languag section box bang primit take valu inject function call index function map valu integ call index index valu use key memo tabl restrict indic uniqu enabl us implement memo tabl nest hash tabl support updat lookup oper expect constant time primit letbang take valu b bang type bodi appli bodi underli valu b extend branch index b function letx take pair p bodi bind part pair two resourc appli bodi resourc oper semant letx extend branch function mcase take valu sum type bodi branch outer form bind inner valu resourc appli bodi resourc extend branch depend outer form s elimin form sum product term context split choos standard return primit naliz branch return bodi suspens branch use mfun rec mfun key memo tabl result found memo tabl suspens disregard result reus otherwis suspens forc result store memo tabl key branch mfun rec primit take recurs function f paramet memoiz f associ memo pad subtl issu f must call memoiz version recurs therefor f must take memoiz version paramet note also memoiz function intern convert paramet resourc appli f it interfac librari provid introduct form re sourc inde resourc creat librari insid letx mcase mfun rec mfun function expos elimin form resourc if exampl one would like appli letbang resourc must rst expos re sourc expos underli valu figur show exampl section written sml librari note memoiz fibonacci function mfib creat memo tabl everi time call mfib nish tabl garbag collect the appli mk quicksort provid function mq return instanc memoiz quicksort appli instanc memo tabl note also mq creat local instanc hashcon function instanc memoiz quicksort memo tabl hashcons exampl use sum type provid librari repres box list need to gener one use provid sum type instead ml counterpart for exampl mcase need exampl figur implement use follow denit box list datatyp a roll unit a a boxlist box prod sum type a boxlist a boxlist box chang code figur work denit box list requir sever straightforward modic discuss space cach manag framework associ separ memo tabl memoiz function allow programm control lifespan memo tabl convent scope somewhat coars degre control sufcient certain applic dynam program ner level control may desir applic result reus less regular applic benet specifi cach scheme individu memo tabl determin size memo tabl replac polici discuss framework extend associ cach scheme memo tabl maintain memo tabl accordingli cach scheme speci form paramet mfun construct evalu construct bind cach scheme memo tabl memo tabl maintain accordingli chang oper semant accommod extens small store map label pair consist memo tabl cach scheme handl return chang store mere expand updat accord cach scheme ad new entri follow show updat return rule denot cach scheme q denot memo tabl updat function denot function updat memo tabl accommod new entri possibl purg exist entri programm must ensur cach scheme violat integr memo tabl tamper store valu not found exampl specifi memo tabl fibonacci function shown figur contain two entri manag use leastrecentlyus replac polici sufcient ensur memoiz fibonacci run linear time extens also incorpor type system describ section would requir associ type memo store also requir develop type system safe updat function enforc cach scheme safe local vs nonloc depend depend track mechan captur local depend input result function local depend function f one creat insid static scope f nonloc depend f creat f pass input function g examin fs input indirectli previou work abadi et al heydon et al show program analysi techniqu track nonloc depend propag depend function caller not howev make clear perform implic techniqu framework extend track nonloc depend introduc applic form memoiz function express context extens would exampl allow depend nonconst length chose support nonloc depend clear util exce perform effect memoiz adapt work present paper motiv previou work adapt comput briey discuss relationship memoiz adapt combin obtain efcient dynam increment algorithm adapt comput maintain dynam depend graph repres data control depend input modi chang propag algorithm updat output depend graph adapt mechan handl deep chang efcient say chang deep affect call occur leav call tree comput contrast chang shallow affect call occur root call tree exampl consid quicksort algorithm pick rst key input pivot insert new key end input list deep chang chang affect last recurs call lter function becom pivot end sequenc recurs call quicksort contrast insert new key begin list shallow chang quicksort new key select pivot immedi rst call quicksort adapt mechan base dynam depend graph handl insert end input deep chang expect ologn time wherea insert begin list shallow chang caus complet rerun take onlogn time use memoiz howev insert begin list handl on time show section chang thought combin shallow deep chang sinc memoiz adapt complement handl deep shallow chang would expect combin two techniqu would handl gener chang efcient exampl quicksort expect insert random posit list would handl expect time combin two techniqu conclus present framework select memoiz programm control framework make explicit perform effect memoiz yield program whose run time analyz use standard techniqu key aspect framework captur control data depend input result memoiz function main contribut paper particular set primit suggest semant along proof sound gave simpl implement framework standard ml languag expect framework implement purelyfunct languag r analysi cach depend adapt function program select memo izat design analysi comput algorithm anatomi lisp dynam program tabul techniqu recurs program acm comput survey elimin redund recurs call acm transact program languag system algorithm increment evalu attribut grammar applic syntax direct confer record th annual acm symposium page increment reduct page hash lemma time complex applic formula manipul cach function call use acm sigplan notic elimin recurs call use small tabl randomli select function valu alphons increment comput program lazi memofunct confer implement dynam program via static static cach increment comput languag system formal system memo function machin learn autom program speedup decid cach wizard tilt ef cient techniqu automat memoiz applic contextfre pars gener increment attribut evalu use cach function constructor increment attribut evalua tion structur cut elimin judgment reconstruct modal logic natur deduct intuitionist noncommut linear logic increment comput via function cach improv replac strategi function cach increment comput via function cach exampl hierarch design proof increment compil via partial evalu autom deriv increment program tr elimin redund recurs call lazi memofunct improv replac strategi function cach increment comput via function cach specif transform program formal approach softwar develop introduct algorithm increment reduct lambda calculu alphons analysi cach depend autom deriv increment program static cach increment comput cach function call use precis depend tabul techniqu recurs program exampl hierarch design proof adapt function program anatomi lisp increment evalu attribut grammar applic syntaxdirect editor design analysi comput algorithm dynam program via static increment natur deduct intuitionist noncommun linear logic use cach function constructor increment attribut evalu structur cut elimin hash lemma time complex applic formula manipul dynam program ctr kedar swadi walid taha oleg kiselyov emir pasal monad approach avoid code duplic stage memoiz function proceed acm sigplan symposium partial evalu semanticsbas program manipul januari charleston south carolina haiy xu christoph j f pickett clark verbrugg dynam puriti analysi java program proceed th acm sigplansigsoft workshop program analysi softwar tool engin p june san diego california usa kevin walsh emin gn sirer stage simul gener techniqu improv simul scale perform acm transact model comput simul tomac v n p april geoffrey washburn stephani weirich box go banana encod higherord abstract syntax parametr polymorph acm sigplan notic v n p septemb darko marinov robert ocallahan object equal profil acm sigplan notic v n novemb neil d jone transform interpret specialis scienc comput program v n p august weingan chin siaucheng khoo neil jone redund call elimin via tupl fundamenta informatica v n p januari umut a acar guy e blelloch robert harper adapt function program acm transact program languag system topla v n p novemb umut a acar guy e blelloch matthia blume kanat tangwongsan experiment analysi selfadjust comput acm sigplan notic v n june k v seshu kumar valu reus optim reus evalu math librari function call compil gener cach acm sigplan notic v n august