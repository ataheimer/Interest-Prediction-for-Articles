t new simpler lineartim domin algorithm a present new lineartim algorithm find immedi domin vertic flowgraph algorithm simpler previou lineartim algorithm rather employ complic data structur combin use microtre memoiz new observ restrict class path compress implement algorithm report experiment result show constant factor low compar standard slightli superlinear algorithm lengauer tarjan much less overhead algorithm run slower real flowgraph reason size percent slower larg flowgraph b introduct consid problem nding immedi domin vertic graph owgraph direct graph r distinguish start vertex path r vertex v vertex w domin vertex v everi path r v includ w w immedi domin idom v denot domin v everi vertex x domin v also domin w everi vertex owgraph uniqu immedi domin aho ullman lorri medlock find immedi domin owgraph eleg problem graph the ori applic global ow analysi program optim aho ullman cytron et al ferrant et al lorri medlock lorri medlock introduc on time algorithm nd immedi domin owgraph success improv materi present thirtieth acm symposium theori com pute author address att lab shannon laboratori park ave florham park nj permiss make digitalhard copi part materi without fee grant provid copi made distribut prot commerci advantag acm copyrightserv notic titl public date appear notic given copi permiss associ comput machineri inc acm copi otherwis republish post server redistribut list requir prior specic permiss andor fee c adam l buchsbaum et al ment time bound achiev aho ullman purdom moor tarjan culmin lengauer tarjan ommntim algorithm standard function invers ackermann function grow extrem slowli n tarjan van leeuwen lengauer tarjan report experiment result show algorithm outperform previou domin algorithm owgraph size appear practic reduc asymptot time complex nding domin on m interest theoret exercis furthermor variou result compil theori reli exist lineartim domin algorithm pingali bilardi give exampl refer harel claim lineartim domin algorithm care examin abstract reveal problem argument alstrup et al detail problem harel approach oer lineartim algorithm employ power data structur base bit manipul resolv problem achiev lineartim domin algorithm relianc sophist data structur add sucient overhead make implement impract present new lineartim domin algorithm simpler alstrup et al algorithm requir complic data structur use depthrst search fast unionnd data structur tarjan van leeuwen topolog sort memoiz implement al gorithm report experiment result show that even extra overhead need achiev linear time constant factor low rst implement lineartim domin algorithm rest articl organ follow section outlin lengauer tarjan approach section give broad overview algorithm dieren tiat previou work section present algorithm detail section analyz run time section present new pathcompress result analysi reli section describ implement section report experiment result conclud section lengauertarjan algorithm outlin lengauer tarjan lt approach lengauer tarjan high level provid detail need algorithm appel provid thorough descript lt algorithm r input owgraph n vertic arc let depthrst search df tree g root r sometim refer vertex x df number particular x mean xs df number less ys let w w ancestor not necessarili proper v d also denot actual tree path similarli w w proper ancestor v repres correspond path tree v parent v let nca u v nearest common ancestor u v drop subscript write pv ncau v context resolv ambigu v path g lengauer tarjan dene p semidomin path abbrevi sdom path x v sdom path u v thu avoid tree vertic u new simpler lineartim domin algorithm a d a a d b fig a owgraph g root r vertex label augment df number b df tree g solid arc tree arc dot arc nontre arc break microtre size result four nontrivi microtre root k j g a vertic nontrivi microtre encircl v semidomin semi vertex v sdom path u vg exampl consid vertex g df tree figur a df number g path e g f g d f g a d f g b d f g b a d f g sdom path g sinc b least df number initi vertic path comput semidomin lengauer tarjan use auxiliari linkev data structur oper follow let tree real valu associ vertex wish maintain forest f contain tree subject follow oper initi f contain arc f let r root tree contain u f return r otherwis return vertex x r minimum valu path r u tarjan a show implement link eval use standard disjoint set union data structur tarjan van leeuwen use link size path compress n link eval nvertex tree perform ommn n time lt algorithm travers revers df order comput semidomin follow initi semiv v revers df order w v adam l buchsbaum et al done linkv done comput immedi domin vertex use semidomin follow fact also use design algorithm lemma lt lem v w path v w g must contain common ancestor v w d lemma lt lem vertex v r idomv semiv lemma lt lem let vertic w v satisfi w v w idomv idomw lemma lt thm let w r suppos everi u semiw lemma lt thm let w r let u vertex semiu minimum among vertic u satisfi semiw outlin lineartim algorithm link eval use lt algorithm make run ommn time elimin m n term exploit sensit rel dierenc n particular slightli superlinear n eg mn becom constant tarjan van leeuwen domin algorithm proce roughli follow comput df tree g partit region discuss partit detail section now suce consid partit collect small vertexdisjoint region call microtre consid separ microtre bottom dthose contain leav dfrom microtre compris interior d vertex determin whether idom microtre and so determin actual idom vertex v idomv vs microtre a comput idomv appli lt algorithm vertic b nd ancestor u v idomu comput appli lt algorithm vertic partit microtre serv two purpos first subgraph induc microtre root achiev ratio mn necessari reduc m n constant second microtre small enough number distinct microtre small compar n m thu perform simpl comput microtre on use precomput tabl memoiz elimin redund comput log i n iter log function log new simpler lineartim domin algorithm comparison previou approach contrast use fact previou approach harel alstrup et al appli lt algorithm d use microtre partit speed link eval harel divid entir tree microtre contain one vertex perform link eval describ lengauer tarjan tree induc microtre root alstrup et al simplifi harel approach harel restrict nonsin gleton microtre bottom d leav upper subtre singleton microtre do perform link eval use two novel data structur well gabowtarjan lineartim disjoint set union result gabow tarjan transform algorithm use precomput tabl process eval intern microtre vertic approach requir inform regard vertic outsid microtre might domin vertic insid microtre deriv ecient encod need tabl lookup techniqu harel present method restrict set outsid domin candid alstrup et al demonstr decienc harel argument correct problem use fredman willard qheap fredman willard manag microtre appli lt algorithm upper portion d combin partit scheme new path compress result show lt algorithm run linear time instead process link eval intern microtre vertic determin use simpl domin algorithm whether domin vertic intern microtre comput directli use memoiz elimin redund comput process vertic domin outsid microtre without perform eval intern microtre vertic approach obviat need determin outsid domin candid intern microtre vertic elimin addit complex alstrup et al requir manag inform thu summar key dierenc variou approach follow harel alstrup et al partit microtre appli standard lt algorithm d use precomput tabl speed comput linkev data structur microtre also partit microtre appli lt algorithm linkev data structur unchang one big region use memoiz speed comput domin microtre word harel alstrup et al take pure data structur approach leav lt algorithm unchang employ sophist new data structur improv run time modifi lt algorithm that although becom slightli complic simpl standard data structur suce implement it minor dierenc two approach regard use tabl harel alstrup et al precomput answer possibl queri mi crotre use tabl lookup answer queri actual domin comput build correspond tabl increment use memo izat comput entri actual need given instanc two approach ident asymptot time complex memoiz tend outperform priori tabul practic former comput adam l buchsbaum et al answer queri never need microtre consid follow procedur mark certain vertic d paramet g given initi vertic unmark x revers df order child x sy sx g mark children x endif done mark rootd vertex v let nmav nearest mark ancestor not necessarili proper v nma function partit vertic microtre follow let v mark vertex vg microtre contain vertic x v nearest mark ancestor x say root microtre v vertex x microx microtre contain x see figur v v g descend children v mark there fore microtre size g call microtre nontrivi contain leaf d nontrivi microtre contain one vertex subtre process use memoiz remain microtre call trivial compos singleton intern vertic d vertic compris upper subtre d addit children vertex form trivial microtre microtre root call vertex v form trivial microtre special child v root nontrivi microtre in figur b c e special vertic remov nontrivi microtre d special vertic would leav result tree sinc special vertex g descend descend two special vertic form disjoint set ong special vertic note alstrup et al dene microtre includ leav our nontrivi microtre wherea denit make everi vertex member microtre could adopt alstrup et al denit dene microtre vertex allow uniform discuss particularli statement proof lemma theorem gabow tarjan pioneer use microtre produc lineartim disjoint set union algorithm special case union known advanc work microtre combin microset precomput tabl gener microset dixon tarjan introduc idea process microtre bottom tree path denit v path g dene p extern domin path abbrevi xdom path p sdom path domin path simpli semidomin new simpler lineartim domin algorithm path resid wholli outsid microtre target vertex until hit target vertex extern domin vertex v xdom path u vgg particular vertex v form singleton microtre dene p push extern domin path abbrevi pxdom path nontrivi microtre occur bottom d pxdom path v cannot exit reenter microv would requir travers back arc proper ancestor rootmicrov therefor pxdom path v a xdom path vertex x microv caten b xtov path insid microv either a b may null path push extern domin vertex v pxdom path u vg note pxdomv microv sinc arc p rootmicrov rootmicrov caten tree path rootmicrov pxdom path v pxdomv pd rootmicrov exampl consid vertic l h df tree figur b df number l path sdom path r l xdom path path c j l xdom path c l xdom path exist r l p pxdom path howev r b e n xdom path r n microl n l path intern microl thu semil continu df number h sdom path h g h path b d f g h pxdom path h howev gener vertex semi xdom pxdom valu need match use follow lemma note similar lemma lemma lemma vertex v form singleton microtre semiv proof let v pxdom path u v v form singleton microtre so denit pxdom x v k without loss gener howev sinc u minimum vertex pxdom path v assum x v k therefor p semidomin path semiv u semidomin path howev pxdom path fact lemma idomv microv idomv pxdomv proof let observ abov u microv denit pxdom path u v avoid vertic other u tree path u therefor idomv microv idomv cannot lie tree path next section give detail algorithm detail lineartim algorithm high level abstract algorithm follow adam l buchsbaum et al f a f b fig a microtre consist vertic a d f figur b well incid arc extern b induc graph augt use memoiz reduc run time determin vertex v so actual valu idomv use lt algorithm comput idom v idomv microv remaind section provid detail behind approach clariti describ separ phase resolut idomv microv question comput pxdomv overal algorithm comput idomv discuss section unit phase one travers d comput intern domin begin show determin whether idomv microv and is nd actual valu idomv vertex v compris singleton microtre decis trivial idomv microv nonsingleton microtre dene follow augment graph let gt subgraph g induc vertic let augt graph gt plu follow vertex t call root augt rootaugt arc t v v exist arc u v call blue arc note blue arc t roott vertex repres contract ignor arc exit see figur use augment graph captur intuit remov arc exit microtre chang domin relationship dene intern immedi domin iidom vertex x iidomx immedi domin x augmicrox show iidomx convers comput iidom use memoiz augmicrov thu yield fast procedur deter exit microu v microu new simpler lineartim domin algorithm x a z x b fig augmicrox plu incid extern arcspath g solid line arc dot line path a case t z y z microx eg gure path x augt use blue arc t v avoid y gure path intern microt z x avoid y either case contradict assumpt iidomx b similar case z path p augt x avoid z p contain blue arc path g contradict z idomx mine whether idomv microv v give detail memoiz procedur below lemma iidomx rootaugmicrox proof let idomx z z y full graph g exist path p z x avoid y use p demonstr path p augt z ft zg x avoid y contradict assumpt v last arc p u augt arc p yield immedi contradict otherwis arc u v induc blue arc t v augt arc togeth subpath p v x provid path p see figur a hand z path p augt x avoid z hypothesi t p contain blue arc there arc t p therefor p also path g contradict z idomx figur b lemma proof let t path p augt x avoid z p contain blue arc path origin graph contradict claim z idomx p contain blue arc t v v g arc u v u tree path rootg caten arc u v subpath p v x give path g x avoid z x fig augmicrox plu incid extern arcspath g solid line arc dot line path case t path p augt x avoid z p contain blue arc follow path b around z contradict z idomx p exist g p contain blue arc t v path g x use arc u v u again p avoid z contradict z give contradict see figur memoiz comput iidomv follow rst time comput intern immedi domin augment graph augt store result tabl index graph augt vertex v encod augt bit string correspond adjac matrix repres rowmajor order comput bit string travers augt df order assign df valu one root augt use df valu vertex identi refer canon encod augt subsequ microtre augment graph isomorph encod ident simpli look iidom valu augt tabl obviat recomput iidom augt simpli map iidom valu store tabl rel canon encod augt current instanti augt vertex x augt correspond vertex x rootaugt canon encod augt comput push extern domin prove follow procedur label vertic pxdom show process allow us avoid perform link eval within nontrivi microtre initi d use linkev data structur labelv valu vertex v see theorem pxdomv v becom link linkev valu thu pxdom microvg extern neighbor v vertic outsid microv arc v procedur process microtre new simpler lineartim domin algorithm revers df order c labelv minfvg lemma prove label v xdomv v set vertic path consist arc gt set labelv min yy v flabelyg call push v push done comput strongli connect compon gt process topolog order theorem prove push label v pxdomv trivial microtre linkv due push step pxdom valu nonincreas along path microtre root allow us perform eval parent microtre root pxdom push eectiv substitut eval vertic insid microtre prove procedur correctli label vertic microtre assum induct procedur alreadi label pxdom vertic tree preced revers df order base case vacuous true lemma step proof let show labelx w labelx w consid xdom path p w x let microx last vertex p x let z least vertex exclud w p touch tree path w els p xdom path prex p p w z semidomin path otherwis exist u w p u z lemma p contain common ancestor u z contradict assert z least vertex p tree path y therefor pxdomz semiz w induct labelz w z microy labelz got push y thu labe w note step z microy c step contain valu greater labelz due previou link via step either case label consid x via y x arc greater labelz w figur consid arc y x microx let pxdom path p w y p caten arc y x xdom path similarli pxdom path p w labelz z p caten tree path z arc y x form xdom path w x either case figur demonstr potenti path theorem step adam l buchsbaum et al x fig microtre contain x y incid extern path solid line arc dot line path sdom path w z ncay x thu gure labe w z microy gure labelevalrootmicroy w proof argu analog proof lemma let show w consid label x via intern push path w consid valid pxdom path w x consid pxdom path p w x let v rst vertex p insid step w push x via path v x consid w push x w xdom pxdom vertex valid pxdom path w x comput domin use inform comput section give algorithm comput immedi domin algorithm proce like lt algorithm fact subtre induc trivial microtre exactli lt algorithm algorithm reli follow two lemma lemma v exist w microv proof proof proce follow rst nd appropri vertex w tree path rootmicrov v show new simpler lineartim domin algorithm x a x b fig graph induc microv plu incid extern arcspath g solid line arc dot line path pxdom path x v w least vertex p path rootmicrov v a prex p p x w includ vertic greater v except w b p includ descend w less v must take back arc w either case p sdom path x w sinc w least vertex p path rootmicrov v argu resolv postul final prove idomw microx impli postul consid pxdom path p x v let w least vertex p tree path rootmicrov v argu prex p p x w semidomin path not vertex x p w sinc w v must microv otherwis violat pxdom path denit sinc allow v p microv lemma subpath p w contain common ancestor z w sinc w must z w y must also z microv els z violat pxdom path denit impli z tree path rootmicrov v contradict assert w least vertex p therefor semiw x see figur argu semiw x not semidomin path p x w p caten tree path w v howev form pxdom path v contradict assumpt similarli argu semidomin path also pxdom path pxdomw x pxdom path p x howev p caten tree path w v pxdom path contradict assumpt x thu shown denit pxdom pxdomw rootmicrow therefor semiw impli semiw microw lemma therefor idomw microw thu lemma lemma let w v vertic microtre adam l buchsbaum et al fig graph induc microv plu incid extern arcspath g dot line path idomv idomw sdom path idomw x idomw tree path x v x lie tree path idomw w gure howev contradict denit idomw x lie tree path w v gure contradict proof condit lemma impli idomv idomw particular idomv w lemma impli idomv idomw idomv idomw path p idomv v avoid idomw must contain semidomin subpath p idomw x idomw x v x cannot lie tree path idomw would contradict denit idomw x cannot lie tree path w v would impli pxdomv pxdomw by lemma idomw pxdomw p exist see figur lemma impli follow formal proof theorem consid path microtre root leaf vertic path partit pxdom pxdom valu monoton nonincreas vertex w top partit thermor idomw microw anoth vertex v partit w either idomv actual partit els outsid microtre see figur impli algorithm devolv lt algorithm upper subtre consist trivial microtre comput immedi domin algorithm idom given figur v d idom either comput idomv determin proper ancestor new simpler lineartim domin algorithm x z c fig microtre incid extern path dot line path y vertic tree path w pv pxdom y path x b prex xdom path aect pxdom valu wpv part partit vertic partit need share idom howev pictur y u v descript straightforward postprocess phase resolv latter ident idom use second linkev data structur pxdomv valu vertex v begin idom link done theorem algorithm idom correctli assign immedi domin proof lemma show assign idomv iidomv iidomv microv correct assum iidomv microv thu idomv microv lemma consid process vertex v bucketu assum rst child u tree path u v claim z vertex tree path u v minimum semi assum claim true observ w microv w pxdomw semiw thu v claim hold hand vertex tree path pd rootmicrov minimum pxdom claim hold sinc pxdomu consid remain case pxdomv semiv lemma show exist w microv w rootaugmicrov pxdomw w place bucket algorithm idom revers df order processv done fug trivial microtre revers df order linku done processv iidomv microv els add v bucketpxdomv endif z v els z evalp rootmicrov endif idomv u els endif done fig algorithm idom idom therefor idom comput valu idomv idomw previou argument comput correct valu idomw analysi analyz run time algorithm clear gener initi df tree divis microtre perform linear time discuss section comput iidom recal memoiz comput iidom describ section iidom comput run linear time overal augment graph must small enough uniqu descript possibl graph augt comput ojaugt j time immedi domin possibl augment graph comput linear time after comput immedi domin augment graph futur tabl lookup take constant time each requir descript augt one comput word assum hold log n bit recal microtre g vertic paramet g thu augment graph g vertic without aect time bound we use g place g assum augt g vertic therefor augt g arc new simpler lineartim domin algorithm uniqu describ string g bit one comput word travers augt comput bitstr identi ojaugt j time assum initi comput word set bit comput word o time assum vertic number jt j jt j number vertic part df g assign secondari df number v rel rootmicrov satisfi label constraint total time gener bitstr identi thu microtre sinc vertex respect arc g attribut one vertex respec tive arc exactli one augment graph one extra root vertex augment graph express rst encount particular augt use naiv domin algorithm comput immedi domin polyg time store valu iidomv v augt tabl time ojaugt j worst case would memoiz iidom valu possibl distinct graph g fewer vertic g graph total time o polyg induc constraint polyg n simpl analysi show use memoiz comput need iidom valu on m time comput pxdom step comput initi label vertex v process vertex arc g throughout label vertic v addit step perform one eval oper trivial microtre root per arc g step implement comput strongli connect compon scc subgraph g induc microtre initi assign vertex scc minimum label among vertic scc push label scc topolog order comput scc done linear time tarjan topolog process scc step link roott trivial microtre thu time comput pxdom sum microtre n plu time perform n link eval oper analyz linkev time section comput idom implement bucket associ vertex link list take constant time look iidomv either assign idomv place v bucketpxdomv process vertex v bucketpxdomv requir constant time plu time perform eval pd rootmicrov vertex appear one bucket process bucket take time on plu time n eval trivial microtre root sinc pxdomv microv trivial microtre root bucket again perform linkv trivial microtre root total time taken idom om n plu linkev time summari analysi total time requir comput immedi domin owgraph g n vertic arc omn plu time perform link eval d next prove sinc link eval trivial microtre root total linkev time om n appropri choic paramet g disjoint set union bottomup link recal link eval base disjoint set union yield m n term lt time bound show restrict tree appli link eval leav result correspond set union oper requir linear time let u set n vertic initi partit singleton set set subject standard disjoint set union oper c name set oper unit set b name result c ndu return name set contain u well known tarjan van leeuwen n union intermix nd perform ommn n time set repres tree forest union oper link root one tree root anoth oper ndu trace path u root tree contain u link smaller tree child root larger tree union compress path u root tree contain u ndu time bound achiev show given sucient restrict order union improv time bound know previou result base type restrict previous gabow tarjan use priori knowledg unord set union implement union nd oper om time requir advanc knowledg union themselv order constrain result improv bound path compress buchsbaum et al loebl nesetril luca gener restrict order nd union perform n vertic design l special remaind n l ordinari follow theorem show requir union favor small set vertic time bound becom linear theorem consid n vertic l special remain n l ordinari let sequenc n union nd new simpler lineartim domin algorithm union involv least one set contain least one special vertex oper perform omm l proof restrict union ensur time sequenc process set either contain least one special vertex singleton set contain ordinari vertex observ prove induct number union follow algorithm use maintain set standard unionnd data structur creat contain special vertic singleton set recal data structur consist forest root tree built vertic one tree per set root tree contain name set also array index name map set name root correspond tree call smaller data structur u denot union nd union nd ordinari vertic kept separ ordinari vertex contain pointer initi null oper perform follow x name set contain least one special vertex perform union x suppos one x y say y singleton set contain ordinari vertex set pointer ordinari vertex point root set x relabel root z ndx x special vertex execut nd x x ordinari null pointer return x it singleton set x ordinari nonnul pointer special vertex y return nd y intuit simpl unless ordinari vertex x form singleton set equat special vertex oper involv o step plu possibl oper unionnd data structur u contain l vertic let k total number oper done u total run time okk lmn omm ln conveni implement algorithm complet within framework singl standard unionnd forest data structur use path compress union size follow initi special vertic given weight one ordinari vertic given weight zero recal size vertex sum weight descend includ itself see implement essenti equival describ theorem observ follow point first induct number oper ordinari vertex alway leaf unionnd forest union bysiz rule ensur whenev singleton ordinari set unit set contain special element ordinari vertex made child root set standard nd oper done follow parent pointer root reset vertic path point root henc leaf vertex particular ordinari vertex remain leaf forest ordinari vertex thu either singleton root contain pointer special vertex proof theorem furthermor sinc ordinari vertic weight zero aect size decis made unit set contain special vertic nd ordinari vertex equival adam l buchsbaum et al nd parent special vertex proof theorem dierenc pointer ordinari vertex possibl chang point dierent special vertex root add o run time bottomup link let sequenc union u describ root undirect union tree vertex correspond element u edg label zero one initi label zero vertic connect path edg label one set label edg fv pvg one correspond unit set contain v pv union sequenc bottomup link properti edg fv pvg label one edg subtre root v label one corollari let union tree l leav bottomup link properti n union nd perform omm l time proof let leav class special intern vertic class ordinari union indic edg fx pxg occur descend x particular least one leaf set x therefor union sequenc properti hypothesi theorem alstrup et al prove variant corollari mm l term replac l log l m suce purpos deriv weaker result process long path unari vertic outsid standard set union data structur appli standard set union data structur directli need weight leav one intern vertic zero applic domin recal denit special vertic section vertex special children root nontrivi microtre theorem n link m eval perform comput pxdom algorithm idom requir on m time proof consid subtre induc trivial microtre root link eval perform vertic special vertic precis leav view union tree induc link link perform bottomup due revers df process order shown section ong special vertic thu ong leav choos log n suce comput iidom linear time corollari linkev time thu omm n log n n theorem follow sinc n m algorithm complet gener run linear time input owgraph g corollari howev impli that implement unionnd describ abov standard lt algorithm lengauer tarjan actual run linear time class graph correspond df tree follow properti number l leav sucient sublinear m new simpler lineartim domin algorithm implement section describ implement dier somewhat earlier descript algorithm ecienc reason input owgraph adjac list format ie vertex v associ list successor figur present toplevel routin initi comput perform depthrst search partit df tree microtre comput domin initi code creat initi memoiz tabl partit code assign df number initi vertic store array vertic df order comput size subtre root vertex identi microtre use subtre size vertex mark plain mtroot trivmtroot depend whether nonroot vertex microtre root nontrivi microtre root trivial microtre also vertex assign weight use linkev comput special vertic recal vertex special children root nontrivi microtre weight one ordinari vertic weight zero see lengauer tarjan implement link eval final initi array pmtroot contain parentv v array eventu store parentrootmicrov v initi vertex parent updat vertic nontrivi microtre processmt below code comput domin given partit df tree dier earlier present two way first combin process vertic bucket singl pass elimin pass vertex set lengauer tarjan second separ code process trivial microtre code process nontrivi microtre allow us special algorithm situat result simpler ecient code chang simpl rearrang code alter time complex algorithm computedom call processv handl trivial microtre processmt handl nontrivi microtre processv shown figur comput xdom pxdom v store v appropri bucket link v parent process bucket vs parent code exhibit chang first follow lt approach combin process vertic bucket link v p parent process ps bucket immedi follow process v vertic subtre root v ps bucket ad link v p complet path vertex p allow us process bucket second exploit idomv guarante outsid vs microtre therebi elimin condit express processmt figur perform similar step complex process entir microtre onc rst step nd microtre root sinc vertic microtre contigu df number nd root search backward v vertic array rst vertex mark nontrivi microtre root microtre root updat pmtrootv appropri v microtre comput xdom vertex microtre encod augment graph correspond microtre comput iidom comput pxdom adam l buchsbaum et al initi comput partitionroot statusroot trivmtroot computedomroot partitionvertex v assign df number v mark v visit bucketv null linkv null labelv dfsnumv statusv plain successorsv visit endif add v predecessorss done sizev g vs children plain mark plain children v df tree mtroot statusv trivmtroot endif computedomvertex root revers df order processvv elseif v process processmtv endif done df order samedomv null endif done fig pseudocod comput domin new simpler lineartim domin algorithm processvvertex v labelv dfsnumv labelp labelv labelv labelp endif dfsnump dfsnumv evalnod labelevalnod labelv labelv labelevalnod endif endif done add v bucketverticeslabelv z els samedomw z endif delet w bucketparentv done fig pseudocod process trivial microtre process bucket parent microtre root comput xdom microtre encod togeth comput examin predecessor arc microtre encod simpl two bit pair microtre vertic plu one bit blue arc computa tion also identifi special class microtre microtre isol target blue arc microtre root use inform speed comput pxdom iidom comput use memoiz maintain linear time bound increas eectiv remov unnecessari bit elimin unnecessari inform microtre encod use index memoiz tabl first remov bit selfloop second exploit blue arc v impli iidomv microv none inform vs intern arc use particular sinc know root microtre alway target blue arc elimin encod bit arc root chang reduc size iidom encod g g bit from bit six addit reduc size encod reduc number popul slot memoiz tabl use observ blue arc nonroot vertex w zero remain bit arc it irrelev processmtvertex v find mtroot vertic start v initi encod isol true labelv dfsnumv includ p v encod els includ blue arc v encod v mtroot isol fals endif labelp labelv labelv labelp endif dfsnump dfsnumv evalnod labelevalnod labelv labelv labelevalnod endif endif endif done done iidomencod reduc encod iidommemoiidomencod dene iidommemoiidomencod computeiidomencod endif iidom iidommemoiidomencod isol els endif delet w bucketparentmtroot done fig pseudocod process nontrivi microtre new simpler lineartim domin algorithm isolatedpushmicrotre mt int iidom mtroot mt labelv labelmtroot done add mtroot bucketlabelmtroot fig pseudocod push isol microtre remov bit want xedlength encod the bit extra blue arc w comput reduc encod look memoiz tabl determin futher comput necessari determin iidom use on time bitvector algorithm aho et al augment exploit blue arc necessari iidom express term df number augment graph translat augment graph vertex correspond vertex current microtre ad secondari df number primari df number root microtre implement two form push rst shown figur simpli form use isol microtre absenc blue arc nonroot vertic impli xdom microtre root pxdom vertic microtre immedi domin nonroot vertic local microtre that is rootmicrov root vertex nonloc idom simpli add bucket pxdom second shown figur handl gener case first comput strongli connect compon scc use memoiz case memoiz use ecienc iidom calcul use reduc encod scc scc encod use g g bit includ selfloop blue arc sinc neither aect comput comput scc use lineartim twopass algorithm cormen et al given scc either memoiz tabl comput them process topolog order nd minimum xdom vertic within scc incom pxdom assign valu vertex pxdom given vs pxdom iidom either assign idomv directli put v appropri bucket push nish process bucket pmt parent mi crotre root vertex bucket must pmt immedi domin denit pxdom vertex v microtre minimum pxdom along path pmt v result skip eval vertex pmt bucket assign pmt immedi domin directli result section describ experiment result would interest compar algorithm bkrw alstrup et al ahlt judg rel constant factor ahlt reli atom heap fredman willard adam l buchsbaum et al mtroot mt sccencod reduc encod sccmemosccencod dene sccmemosccencod computesccmtroot encod endif topolog order iidomssecdfsnumv mt add v bucketlabelv els endif done done fig pseudocod push gener case atom heap turn compos qheap store log n element given on preprocess time atom heap construct requir qheap store log n element atom heap thu ahlt algorithm run linear time therefor n must exceed fredman altern one consid ahlt run linear time impract high addit constant term alstrup et al provid variant algorithm use atom heap none run linear time thu implement lineartim algorithm therefor compar implement bkrw implement lt algorithm deriv paper lengauer tarjan perform two set experi rst set use owgraph collect spec benchmark suit spec use cfg librari machin suif compil holloway young harvard six le integ suit could compil machin suif v omit data second set use larg graph collect lab perform experi one processor eightprocessor sgi origin mb memori process node r processor kb data instruct cach mb uni secondari cach implement compil mongoos c compil version report aggreg number spec test set contain larg number owgraph tabl report size owgraph averag benchmark tabl ii contain averag run time lt bkrw microtre size two three figur display scatter plot machin suif extens suif compil amarasingh et al stanford use machin suif version new simpler lineartim domin algorithm tabl i graph size averag flowgraph benchmark spec flowgraph benchmark number averag averag flowgraph vertic arc cint suit compress ijpeg vortex perl cfp suit fpppp sucor hydrod turbd tabl ii run time spec flowgraph averag flow graph benchmark number parenthes measur dier enc two algorithm comput follow formula lt posit number indic lt better neg number indic bkrw better benchmark lt bkrw cint suit li us us us compress us us us ijpeg us us us vortex us us us us us us go us us us gcc us us us perl us us us cfp suit fpppp us us us us us us mgrid us us us sucor us us us hydrod us us us wave us us us turbd us us us us us us tomcatv us us us adam l buchsbaum et al number vertic number vertic number flowgraph fig rel dierenc run time bkrw lt for point top plot owgraph gener spec benchmark bottom plot display number owgraph respect number vertic note yaxi bottom plot repres logarithm scale point repres run time bkrw with microtre size two three rel lt singl owgraph plot show overhead bkrw larger lt small graph dierenc tail quickli gure combin data integ oatingpoint suit separ two tabl ii would yield two similar plot tabl iii list larg test graph come varieti sourc along new simpler lineartim domin algorithm tabl iii graph size larg test graph graph vertic arc ati phone size ati nab pw graph deriv weight nitest automata use automat speech recognit pereira riley pereira et al remov weight label multipl arc phone graph repres telephon call pattern augment binari graph ab ab gener synthet build binari tree given size shown tabl graph label replac leaf sub graph see figur ab graph use subgraph shown figur b ab graph use subgraph shown figur c graph design distinguish bkrw lt subgraph treat isol microtre bkrw mean nonroot vertic microtre domin within microtre back cross arc handl cheapli without eval bkrw particular call eval relat arc avoid bkrw result link linkev forest compress bkrw observ that expect bkrw perform fewer link eval lt run time tell metric howev present run time experi tabl iv speech phone graph overhead process microtre includ initi memoiz tabl comput iidom comput microtre encod push outweigh save call link eval bkrw outperform lt larger augment binari graph expect sinc bkrw substanti fewer call eval compress zero link graph addit overhead process microtre low isol note improv bkrw lt decreas graph get larger benet gain algorithm small rel cost due page increas graph get larger ab c fig a k kdepth binari tree augment binari graph ab respect ab gener replac leaf subgraph shown b respect c tabl iv run time larg test graph number parenthes measur dierenc two algorithm comput follow lt posit number indic lt better neg number indic bkrw better graph lt bkrw ati ms ms ms ms ms ms ms ms ms phone ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms new simpler lineartim domin algorithm given overhead bkrw pay comput microtre encod push small bkrw surprisingli competit even small owgraph experi suggest lt algorithm choic current practic applic lt simpler bkrw perform better graph bkrw perform better graph high percentag isol microtre conclus present new lineartim domin algorithm simpler previou algorithm implement algorithm experiment result show constant factor low rather decompos entir graph microtre harel approach domin pathcompress result allow microtre process restrict bottom tree travers graph appli techniqu buchsbaum et al simplifi previou lineartim algorithm least common ancestor minimum span tree mst veric random mst construct also show buchsbaum et al appli techniqu pointer machin tarjan b allow implement pure function languag acknowledg thank bob tarjan mikkel thorup phong vo help discuss glenn holloway help machin suif jame abello provid phone graph r compil principl theori pars domin linear time manuscript avail ftpftp suif compil scalabl parallel machin modern compil implement c introduct algorithm optim parallel veri program depend graph use optim lineartim algorithm special case disjoint set union linear time algorithm ow analysi transform librari machin suif fast algorithm linear strong postord object code optim postord disjoint set union linear speech recognit composit weight finitest languag process weight ration transduct applic human languag process optim control depend comput roman chariot problem algorithm immedi predomin direct graph find domin direct graph applic path compress balanc tree class algorithm requir nonlinear time maintain disjoint set accept june tr worstcas analysi set union algorithm compil principl techniqu tool linear algorithm find domin flow graph relat problem program depend graph use optim introduct algorithm postord disjoint set union linear effici comput static singl assign form control depend graph transdichotom algorithm minimum span tree shortest path datastructur bootstrap linear path compress caten heapord doubleend queue linear unprov set union problem strategi optim control depend comput roman chariot problem modern compil implement java lineartim pointermachin algorithm least common ancestor mst verif domin applic path compress balanc tree fast algorithm find domin flowgraph immedi predomin direct graph h object code optim theori pars translat compil ctr adam l buchsbaum haim kaplan ann roger jefferi r westbrook corrigendum new simpler lineartim domin algorithm acm transact program languag system topla v n p may g ramalingam loop domin domin frontier acm sigplan notic v n p may loop domin domin frontier acm transact program languag system topla v n p septemb andrzej s murawski ch luke ong fast verif mll proof net via imll acm transact comput logic tocl v n p juli louka georgiadi robert e tarjan find domin revisit extend abstract proceed fifteenth annual acmsiam symposium discret algorithm januari new orlean louisiana louka georgiadi robert e tarjan domin tree verif vertexdisjoint path proceed sixteenth annual acmsiam symposium discret algorithm januari vancouv british columbia effici algorithm find doublevertex domin circuit graph proceed confer design autom test europ p march adam buchsbaum yihfarn chen hual huang eleftherio koutsofio john mocenigo ann roger michael jankowski spiro mancoridi visual analyz softwar infrastructur ieee softwar v n p septemb ren krenz elena dubrova fast algorithm find common multiplevertex domin circuit graph proceed confer asia south pacif design autom januari shanghai china elena dubrova structur test base minimum kernel proceed confer design autom test europ p march