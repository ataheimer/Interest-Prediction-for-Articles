t effici algorithm detect restor minim extens regular restrict resolut a given binari resolut proof repres binari tree said iminim resolut cannot reorder gener irregular proof minim extend tseitin regular restrict still retain complet lineartim algorithm introduc decid whether given proof minim algorithm use deduct system avoid redund retain minim proof thu lessen relianc subsumpt gener expens techniqueani irregular binari resolut tree made strictli smaller oper call isurgeri run time linear size tree surgeri result prove new tree nonstrictli gener origin result fewer violat regular restrict furthermor nonminim tree made irregular linear time oper call isplay thu combin splay surgeri effici reduc nonminim tree minim onefin close correspond claus tree recent introduc author binari resolut tree establish sens work provid first lineartim algorithm detect minim perform surgeri claus tree b introduct regular restrict binari resolut state resolut step resolv given liter use deduc claus contain liter word resolut step ancestor claus binari deriv tree extend restrict appli also reorder resolut bring claus step use rotat edg binari tree reorder resolut step requir rotat neither weaken prove increas size tree binari resolut proof cannot made irregular rotat call minim extens regular depend sequenc rotat thu appear expens comput howev character condit check effici examin static tree condit state term histori path binari resolut tree histori path tell stori given liter tail histori path leaf tree tell liter introduc input claus histori path said close node liter resolv away one histori path close node occur anoth histori path two path disjoint say first histori path directli preced other preced relat histori path reflex transit closur directli preced histori path preced relat basic understand binari resolut tree behav rotat perform provid simpl condit histori path character one node rotat anoth we say visibl other one node cannot rotat anoth we say support other examin histori path static tree decid much cannot accomplish sequenc rotat particular say whether rotat convert regular tree irregular one theorem prover use abil screen proof build retain minim one sinc everi claus nonminim proof subsum claus minim proof theorem prover use minim lessen relianc sub sumption runtim full subsumpt grow number retain claus may becom larg detect minim depend linearli size proof tree typic much smaller instead use minim simpli filter theorem prover convert nonminim proof minim one use oper defin paper consid branch irregular deriv tree make irregular branch contain node given liter resolv and down contain claus liter occur resolv liter away reappear later remov resolut otherwis reconstruct branch close possibl origin liter appear addit claus construct tree smaller result prove least gener origin one call oper surgeri defin second oper splay rearrang nonminim tree irregular oper run time linear size tree combin oper eventu reduc nonminim tree minim one first section present regular restrict binari resolut tree section introduc surgeri oper irregular binari resolut tree minim binari resolut tree introduc section also discuss rotat set rotat equival tree tree gener given tree sequenc rotat follow sec tion discuss preced relat histori path use defin hold relat node relat hold visibl show nearest common descend two given node hold one them one seen other ie cannot rotat other base condit give effici algorithm decid visibl show theorem prover restrict retain minim proof disregard nonminim one decreas number proof must consid show splay oper effici convert nonminim proof irregular one surgeri convert minim one thu anoth theorem prover effici convert nonminim result minim one desir next section use histori path character support condit one node binari resolut tree must descend anoth sequenc rotat minim surgeri first develop claus tree claus tree tool develop idea autom reason binari resolut tree effici compact data structur implement claus tree second last section show close relat binari resolut tree claus tree thu paper provid first effici algorithm surgeri claus tree close remark relat claus tree binari resolut tree relat work paper extens binari resolut tree use standard definit atom liter substitut unifi gener unifi follow claus unord disjunct liter use set notat want multipl occurr liter collaps singl liter automat ical thu claus view multiset atom occur claus c either a one disjunct claus claus c subsum claus exist substitut c as set multiset variabl renam substitut one everi replac variabl map anoth variabl two variabl map variabl two claus c equal variabl renam exist variabl renam substitut two claus standard apart variabl occur both given two parent claus standard apart a variabl renam substitut may requir resolv claus c c gener unifi g atom resolv upon set resolv liter g conveni defin map ae liter resolut oper use later defin histori path resolut map resolut oper defin resolut map ae occurr liter c parent claus either atom resolv upon c resolv liter otherwis occurr c resolv reader may miss usual factor oper claus consist appli substitut unifi two liter sign remov one liter oper need binari resolut tree howev sinc claus contain two ident unifi liter resolv upon whenev claus use resolut allow sever liter resolv on instead merg resolu tion one type intern node binari resolut tree instead two de nivel use resolut node factor node moreov implement free merg factor liter desir factor may seen optim factor claus use sever resolut step sinc factor done onc binari resolut deriv commonli repres binari tree drawn root bottom edg join parent node drawn edg child node drawn it ancestor descend node defin reflex transit closur parent child relat proper ancestor proper descend node ancestor descend equal node itself h node tree patht h uniqu path h here call tail h head definit binari resolut tree set input claus label binari tree node n tree label claus label denot cln node either two parent claus label result resolut oper claus label parent parent label instanc input claus s case resolut atom resolv upon use anoth label node atom label denot aln substitut gener resolut appli label tree claus label root binari resolut tree call result tree resultt binari resolut tree close result empti claus ad abd dbce ebcfg ca bbfg a bbfg bfg abe cd efg abc ha b g ah h figur irregular binari resolut tree binari resolut tree figur gg label node n display besid name node separ colon eg node n atom label c claus label b b f g order parent node defin instead label intern node atom one label edg complement liter resolv upon binari resolut tree would becom semant tree leav binari resolut tree would becom failur node semant tree use resolut map ae resolut oper tree trace happen liter occurr claus label leaf tree resolv away clearli liter eventu map atom label intern node claus label root empti case sound resolut claus label leav b ad dac caab ab cd abc b ah h figur surgeri oper figur unsatisfi set thu primarili concern trace histori liter start appear leaf definit histori path let node n occur binari resolut tree n leaf whose claus label contain liter a parent n let ae resolut map parent n n let occur cln suppos n n either root child n ae map resolut n atom resolv upon n n histori path a histori path said close n n exist n written closep node n n head leaf n tail liter p written headp tailp literalp respect exampl figur m c close n two histori path b figur correspond two occurr b m close n close one f definit regular binari resolut tree regular exist node n descend n aln occur clm tree figur irregular aln occur cln irregular tree never necessari resolv away twice one could choos leav resolut n leav claus resolut necessari not necessari later resolv away done n oper make idea formal new binari resolut tree construct ancestor possibl remov howev leav also leav thu everi histori path correspond histori path convers cannot true sinc histori path exist new sequenc n n defin either n remov n correspond n oper surgeri irregular tree let irregular binari resolut tree path node n root n n first node path whose claus label contain a let n igamma igamma parent n parent occur claus label n sign cln procedur ancestor n m ancestor remov let n k node histori path p n j close k exist histori path contain n correspond histori path close n put igamma ancestor new node child n let resolut n defin histori path close n correspond histori path close let histori path correspond p also close n k that is liter far possibl resolv n n one possibl addit els histori path contain n correspond path close n m igamma ancestor remov endif endfor note occurr n j never resolv away ie histori path continu root two liter correspond may occur root howev least gener a figur show effect surgeri figur surgeri perform use n n j need insist occurr close node ensur result not thu n close histori path n theorem let irregular binari resolut tree set claus construct oper also binari resolut tree s smaller result subsum result proof use follow lemma claus c c resolv give claus c subsum c either resolut c c possibl c subsum r possibl result assum liter c resolv first resolut also resolv second furthermor liter c resolv second resolut correspond in subsumpt liter c resolv first resolut leaf label leaf therefor defin s also intern node defin resolut parent binari resolut tree note cln subsum cln cln contain liter cln except possibl a use repeat applic lemma follow cln cln j sinc occur cln j cln result subsum sinc sinc node taken follow fewer node theorem complet unsatisfi exist close regular binari resolut tree s furthermor smallest close binari resolut tree regular proof unsatisfi exist close binari resolut tree irregular appli oper repeatedli regular process must termin sinc tree smaller step smallest close binari resolut tree regular surgeri appli it make smaller close tree figur binari tree rotat minim binari resolut tree rotat edg binari tree common oper exampl avl tree appli binari resolut tree review oper binari tree given binari tree fragment left figur rotat reassign edg tree right figur produc parent c becom child e parent b c becom parent e e child c take child word edg b c c e e f exist replac edg b e e c c f necessari oper edg rotat let binari resolut tree edg c e intern node c parent e c two parent b further suppos histori path close e result rotat edg binari resolut tree defin resolv clb cld ale give cle resolv cle cla alc give clc histori path close c close c similarli histori path close e close e also child e exist child c rotat may introduc tautolog claus label intern node instanc alc occur cld cle may tautolog howev claus label root chang corollari prove slightli gener result first also use later definit let two binari resolut tree defin set input claus close histori path similarli onetoon onto map node that n leaf n leaf label instanc input claus thu natur one one cor respond liter cln cln moreov map liter provid map histori path defin start liter input claus variabl renam repres two map also requir histori path p tailp variabl renam everi histori path p p close node n close n thu two binari resolut tree close histori path similarli resolv liter other albeit possibl differ order lemma two binari resolut tree close histori path similarli result result same variabl renam proof note resultt resultt compos entir liter histori path close sinc histori path close each liter resolv away also composit mgu uniqu variabl renam sinc given node n liter unifi n n variabl renam corollari given binari resolut tree intern node c child e oper gener new binari resolut tree cle variabl renam proof observ oper produc tree close histori path similarli rotat chang order two resolut tree rotat invert rotat histori path close c anoth rotat e c done gener origin tree again say two binari resolut tree rotat equival one gener sequenc rotat instanc first binari resolut tree figur produc rotat edg n n figur second tree figur figur rotat figur produc rotat edg m n thu tree rotat equival figur rotat equival equival relat surpris rotat equival binari resolut tree must close histori path similarli convers true well theorem two binari resolut tree rotat equival close histori path similarli proof sinc one rotat creat binari resolut tree close histori path similarli it sequenc rotat creat convers prove induct number intern node suppos close histori path similarli must number n intern node sinc number leav rotat possibl theorem hold let n node parent l l leav n proper ancestor l l also leav n close histori path tail l l creat rotat edg l l parent n alreadi case let c either parent n let b parent c l l ancestor c neither ancestor parent n n must close histori path parent contradict thu edg c n rotat sinc b contain histori path close n rotat reduc total number nonleaf ancestor n finit number rotat parent n leav call tree let leav l l delet let leav close histori path similarli sinc close histori path similarli induct rotat equival sequenc rotat convert also convert rotat equival we focu set rotat equival tree contain irregular binari resolut tree tree set said minim sinc surgeri cannot appli make smaller definit binari resolut tree minim sequenc rotat edg gener tree irregular theorem binari resolut tree nonminim exist minim binari resolut tree smaller result subsum result proof minim appli oper oper regular tree produc tree minim let tree otherwis repeat begin defin process must termin tree get smaller applic oper also old result subsum new result step thu smallest binari resolut tree minim goerdt shown smallest regular binari resolut direct acycl graph dag may exponenti larger irregular binari resolut dag thu consid regular minim binari resolut dag theorem prover may find smallest proof henc may requir infer prove given theorem howev case believ space minim binari resolut dag much smaller space binari resolut dag consider time save restrict minim one similar argument made restrict resolut includ setofsupport hyperresolut check minim determin whether given binari resolut tree minim seem labouri sinc straightforward applic definit done proof theorem check everi possibl sequenc rotat exponenti mani section give effici algorithm determin visibl node rotat decid minim effici definit visibl given binari resolut tree intern node n say visibl n n see exist sequenc rotat descend n otherwis invis n thu node see node rotat it although properti defin term rotat possibl inspect static tree without rotat determin visibl thi visibl comput linear time static properti hold defin one concept preced definit directli preced histori path q p q node common p close node q write p oe q moreov say p preced q sequenc histori path p directli preced p i histori path p preced node n n close histori path q p oe q preced relat reflex transit closur directli preced particular histori path preced itself even though directli preced itself also note preced defin partial order set histori path case rotat chang preced relat histori path lemma let histori path p preced histori path q binari resolut tree let p imag respect rotat edg c e definit suppos head q c p preced q proof let td subtre root a b c respect closep headq one subtre rotat effect whether p q know headq proper descend closep also headq c headq must descend e tailp tailq subtre rotat affect p oe q node q p preced also subtre let p path close node thu p oe p oe q case illustr figur tailq tailp close c rotat one node longer close c p oe otherwis tailp td let p denot path b close c rotat p oe p tailq tb tailp rotat p oe otherwis tailp td rotat p oe p tailq td sinc path close e know tailp thu tailp tb rotat directli hold intern node binari resolut tree first node occur p q ie parent occur both say p q hold exist histori path p directli hold node n hold p q hold p q close n also p q hold set histori path say set hold follow theorem relat invis properti depend rotat equival tree held properti check examin one tree interest figur case lemma theorem nearest common descend n hold invis n proof show nearest common descend hold rotat possibl new nearest common descend n hold thu never descend n nearest common descend would node cannot hold itself case proof forward direct figur let f nearest common descend n let rotat edg c e let node a b adjac defin oper let p q hold close f p directli hold p oe p q oe q consid case f e rotat f still nearest common descend n lemma p suppos e rotat still first common node p f still hold suppos without loss gener assum p contain c q contain d case a p contain b rotat p hold e f hold case b p contain consid path close c rotat p p hold e f hold suppos consid case case ancestor c n either e ancestor d sinc histori path contain c close e c reason p q contain b close e case a ancestor path directli preced p q close c hold thu c hold rotat nearest common descend n c c still hold case b otherwis ancestor b rotat nearest common descend n e e still hold final consid case case ancestor d case a n either e ancestor b rotat hold still nearest common descend n case b n c ancestor a consid path r head b close c rotat nearest common descend n c r directli preced rotat convers suppos held nearest common descend f n descend n therefor visibl f child edg rotat make descend f therefor n assum exist path n case case r r q q q case case case r r case figur case theorem n igamma k igamma parent n use induct n without loss gener n chosen aln occur cln thu histori path n close n exist ng histori path n igamma close n edg n rotat shown rotat figur say n rotat side pathm f closer f theorem hold induct thu path n igamma close n j ng n j held f particular n ngamma held edg n rotat distanc nearest common descend n theorem hold induct choos smallest j ng n j held f note j assumpt histori path k j gamma close n j path path n j gamma close n j directli hold thu held f contradict definit j therefor path k j gamma exist edg rotat illustr rotat figur closer f rotat say n j rotat top pathm f theorem hold induct otherwis consid histori path n j gamma close n j one includ anoth includ k j gamma n j gamma held f rotat mean n j gamma held f rotat contradict definit j thu edg n j gamma n j rotat result rotat n j rotat either side pathm f closer second induct distanc n j n eventu rotat top side thu distanc f decreas construct sequenc rotat sequenc rotat construct proof theorem rotat visibl node node n see it thu tree regular nonminim rotat would make irregular expos nonminim part use surgeri remov nonminim section tree reconstruct minim tree piec left behind unfortun number rotat requir expos non minim may quadrat length path tree sinc tree balanc quadrat size tree worst case later give linear time oper call splay bring visibl node descend next section howev detect avoid nonminim tree rotat side f f rotat top f f figur rotat proof theorem minim restrict turn attent theorem prover keep minim binari resolut tree sinc everi nonminim tree subsum minim tree strategi use minim criteria reduc redund lessen relianc subsumpt definit let binari resolut tree atomst falnjn node tgi call set atom subbrt binari resolut tree whose node set consist node call root subbrt ancestor subbrt node visibl root tg call set visibl atom theorem let binari resolut tree consist root node r two subbrt minim minim atom clr atomst proof assum minim minim would sequenc edgerot would make subbrt irregular sequenc perform would make irregular well henc first condit true second condit fals would irregular immedi assum third condit fals two node whose atom label same visibl r henc rotat r without rotat edg descend n make irregular fourth condit symmetr third convers assum minim sequenc rotat creat irregular tree node n descend aln occur clm sinc rotat chang clr aln occur result occur clr violat second condit thu aln occur clr descend n n violat first condit assum n differ sinc rotat visibl n theorem held nearest common descend r n thu visibl r therefor alm vist aln atomst gammai theorem prover base binari resolut keep minim tree alreadi satisfi first condit theorem newli construct tree sinc minim tree use construct easi check new result contain atom atomst left find easi way calcul atom subbrt visibl root idea procedur node visibl subbrt held root theorem node n need calcul histori path go preced root path go one parent n go other n held root otherwis n visibl root procedur call visiblen pn first argument n node tree want know whether held root initi one parent root travers upward becom instanti ancestor parent invari maintain second argument pn set path includ n preced root path parent root preced root simpli whose head parent invari easi establish first place suppos n parent b calcul path pb b preced root start pn remov path go ani none pb pn path pn a need add pb path head b sinc path preced path a thu preced root sinc know path pn must go least one parent n assum b parent procedur visibl given node n binari resolut tree set pn histori path preced root tree visn pn return atom label node n visibl root procedur visn pn n leaf return oe let b parent n partit pn pa pb set path go b respect assum without loss gener b chosen pb nonempti let ca cb histori path head b respect pa nonempti n held return els n held visibl return endif third fourth condit theorem requir us calcul done call visr root binari resolut tree r r parent r r set path head r procedur run number set union calcul proport number node tree hash oper principl perform time proport size claus henc vi linear time algorithm fast one could expect implement prototyp theorem prover proposit logic resembl otter retain minim binari resolut tree so recurs call first condit theorem need wherea proof built otter correspond nonminim tree case implement actual build binari resolut dag instead tree save space import bottomup theorem prover limit space well time note procedur travers entir implicit tree may visit singl store node onc thu runtim guarante linear size dag prototyp includ anoth restrict discuss ensur set rotat equival binari resolut tree exactli one found restor minim two basic way restor minim binari resolut tree irregular surgeri oper remov non minim binari resolut tree regular nonminim rotat need done make irregular call expos nonminim irregular involv two intern node n resolv upon atom neither descend at least one visibl other suppos visibl n rotat n one parent becom descend n sinc occur parent claus label surgeri n done proof convers theorem gave quadrat length sequenc oper move visibl node becom descend oper call splay perform linear number rotat relat splay oper binari tree bring node closer root case splay binari resolut tree divid descend two set observ see nonobserv cannot rearrang tree node ancestor leav node descend thu brought close root possibl done way guarante n ancestor surgeri accomplish first step splay determin descend see comput procedur procedur ob given node binari resolut tree p complet set histori path contain one parent p path contain return set proper descend see call observ procedur obsm root return oe els let child k parent d let c path p close c path p close d let k path contain k d hold return els c return fdg obsd k els endif endif invari procedur everi pair path one p p hold ever find descend close member each hold cannot see otherwis see maintain invari go d close path p need add p path k come k d one path preced path contain close path p noth add p either case remov p path close sinc contain d oper use code procedur but procedur itself decid resolut reorder new tree parent consid stub built upon observ put one two queue q q nonobserv put q along node put queue also put subtre root parent node resolut reconstruct later put q becom descend q becom descend done two subtre join resolut correspond final node q made descend resolut done histori path close node given tree close node construct tree thu result tree close histori path similarli given tree oper splay splay intern node binari resolut tree produc new binari resolut tree descend cannot see oper initi three empti queue initi p set histori path one parent p set histori path parent call splaym return processq procedur splaym root return els let child let k parent d let c path p close c path p close d let k path contain k d hold enqueu subtre root k q els c enqueu subtre root k els enqueu subtre root k endif endif resolut must done result binari resolut tree close histori path similari procedur processqt q q empti return els dequeu n q leav q construct resolv make parent n return endif exampl binari resolut tree figur show result perform splay node n second tree figur subtre leav label a b c h respect descend n n n put q put q end n result tree nonobserv n put q end n lemma binari resolut tree intern node result splayt m binari resolut tree defin set claus size result proof close histori path similarli oper splay surgeri let binari resolut tree contain pair mn node alm aln n see procedur descend n return surgeryn els return endif see splay actual bring n surgeri possibl suppos nearest common descend n thu either n nearest common descend n differ branch n either ancestor k point splay also know n see must put one queue q q cannot part q thu tree ad abd dbce ebcfg abe cd efg abc a bbf b g a bbf g ca bbfg ha ah figur result oper n figur rebuilt n put process either q q put q q empti n return exampl splay node n figur n surgeri n done result surgeri shown figur notic exampl also option splay n surgeri n sinc n also visibl n result tree would differ would requir leaf a h h result would f thu surgeri alway produc gener result alway produc smaller tree splay surgeri linear number set oper sinc n resolut step n length branch perform surgeri number resolut limit length branch thu effect linear time algorithm support often node visibl anoth rotat descend sometim sequenc rotat bring node anoth case say node support other sinc alway beneath it support like visib properti depend entir set rotat equival tree section character support term histori path check examin static tree definit support node n binari resolut tree support node everi sequenc rotat ancestor n definit tightli hold two histori path tightli hold node n exist two sequenc histori path directli hold pair head p equal head q j node n tightli hold p q close n tightli hold special case hold two path sequenc head except bottom two turn exact condit one node anoth everi sequenc rotat theorem node n tightli hold n support proof show n tightli hold rotat also afterward thu must descend consid rotat edg c e node a b c e defin definit indic imag histori path p rotat p first assum fc eg disjoint fmng rotat head path sequenc distinct must distinct rotat unless new path either sequenc one case new path occur in lemma new path introduc tailq case head new histori path pathm n thu head path new sequenc p distinct except headp also still directli held n tightli hold suppos fc eg disjoint fmng case without loss gener let p contain q contain b know p close e sinc rotat possibl suppos first q close e figur a rotat c directli held p tightli held n suppos q close e figur b note must exist q sinc otherwis e hold n q p close rotat possibl cn qm pn qn case b case case case case b cn pm qn qn case figur case show tightli hold invari rotat case case figur case show support impli tightli hold rotat c directli held p still tightli held n case close n either includ a figur a includ b figur b either case rotat n tightli hold sequenc p case assum without loss gener c p q also p figur a path head b p oe p rotat sequenc ensur n tightli hold b p figur b rotat path p q tightli hold case final either pm q n contain c contain d contain c note contain parent b c els rotat possibl rotat b parent e although p one node shorter befor n tightli hold path p contain d rotat chang histori path thu n tightli hold induct length pathm parent n i parent n rotat edg m n possibl unless exist histori path tightli hold close n suppos k first assum case n k support first half theorem n k tightli hold edg n rotat sinc must remain ancestor n must ancestor b rotat shown figur thu path n shorter induct tightli hold new binari resolut tree rotat edg back again one see n tightli hold tightli hold invari rotat case cover assum n k support n kgamma next assum case n k support n kgamma n support n kgamma otherwis n k support n kgamma support n kgamma and transit support contradict first half theorem may rotat edg n kgamma n kgamma may rotat edg n kgamma n k sinc n k tightli hold n kgamma second rotat n k must remain descend n kgamma must shown third binari resolut tree figur thu pathm n shorter induct n tightli hold tightli hold invari rotat n tightli hold also assum n k support n kgamma similar argument assum n k support n case edg m n rotat pathm n shorter result tree induct n tightli hold sinc tightli hold invari rotat n tightli hold final edg m n cannot rotat path parent close n know induct tightli hold n assum p path make so assum without loss gener includ q must includ parent n sinc n first node p q common matter parent p path close n contain s parent call path q sinc head q distinct head p q j sequenc thu tightli hold path q final theorem relat notion visibl support theorem binari resolut tree node invis node n iff support pathm n proof let nearest common descend n consid path sequenc hold consid least j headp let node p q j close j must exist sinc headpm head path distinct tightli hold thu support sequenc path tightli hold sinc pathm n descend must ancestor nearest common descend n thu path r r r k close d thu hold via sequenc relat claus tree result paper develop understood claus tree primarili mean implement claus tree eventu found idea claus tree could express binari resolut tree binari resolut tree simpler way sinc easier implement often claus tree easier use explor new idea particular visibl support read almost directli claus tree wherea properti held tightli held somewhat harder see binari resolut tree use whichev appropri section relat two refer exampl rotat equival binari resolut tree figur correspond first claus tree figur binari resolut tree figur correspond second claus tree figur reader familiar claus tree note second claus tree figur construct directli first ad merg path atom node surgeri remov subtre beyond tail new merg path correspond binari resolut tree claus tree obviou leav binari resolut tree claus node claus tree label instanc input claus intern node binari resolut tree atom node claus tree histori path binari resolut tree associ liter correspond label edg claus tree also associ liter histori path close correspond edg incid atom node leaf close histori path correspond edg incid close atom node _ c e f _ _ c _ _ _ figur claus tree correspond figur figur minim claus tree correspond minim binari resolut tree whose result contain two ident atom minim condit claus tree allow legal unchosen merg path legal tautolog path includ leaf leaf path minim binari resolut tree may correspond claus tree legal unchosen leaf leaf merg path legal leaf leaf tautolog path regular condit binari resolut tree requir one node intern final visibl resp support intern node binari resolut tree correspond visibl resp support close atom node claus tree tabl show number correspond notion tabl i correspond notion claus tree binari resolut tree claus node leaf node intern atom node intern node edg histori path open leaf atom node liter result clt internaltointern surgeri splay surgeri internaltoleaf surgeri surgeri merg path two histori path close togeth equival class revers equival equival class rotat equival minim up leaftoleaf minim visibl intern atom node visibl support intern atom node support path revers structur chang structur chang rotat chang deriv merg set histori path close given node relat past futur work regular one import restrict form use mani theorem prove method relat resolut includ tableau variant model elimin permut infer step investig kleen context gentzen sequenc calculu classic intuitionist kleen permut sometim increas size proof interest note defin ancestor relat instanc formula infer allow state instanc formula deduct belong given instanc end sequent analag notion histori path context binari resolut deriv de nivel two type node resolut node two parent factor node one defin four type edg rotat depend type node incid edg disallow rotat factor node parent resolut node case size deriv must increas applic construct resolut game use show variou complet result restrict resolut base order liter de nivel paper show basic properti resolut may expos consid set tree equival modulo permut main contribut paper present minim restrict resolut origin develop term claus tree use well known proof format binari resolut deriv origin motiv implement bottom algorithm construct minim claus tree direct implement base structur definit claus tree done new tree need storag space visibl algorithm cumber some remedi problem use notion binari resolut deriv implement new claus tree singl storag cell two parent claus tree for proposit logic solv space problem sinc tree use part tree surpris result visibl express easi ly requir linear algorithm use data structur determin explain much claus tree work could use binari resolut tree make access reader familiar resolut task turn difficult discov edg rotat histori path preced relat histori path fundament concept need relat visibl support histori path use hold tightli hold relat retrospect author still believ easier work conceptu claus tree anecdot evi denc graduat cours autom reason given two time second author claus tree binari resolut tree follow claus tree intuit support visibl quit understand use either data structur present develop full theorem prover describ here one use minim restrict anoth use splay surgeri improv proof construct resolut redund elimin subsumpt alway import consider theorem prover unfortun minim restrict complet full subsumpt instanc one refut minim binari resolut tree one resolv p pq gener q use back subsumpt remov resolut p q p q done latter resolut part minim binari resolut refut claus former resolut step lead binari resolut tree p resolv two differ node one branch howev discov one retain complet give power minim without give power subsumpt space minim binari resolut tree interest follow reason refut complet extend well known regular restrict resolut contain smallest binari resolut tree nonminim subtre identifi time linear size tree nonminim tree reduc minim one effici r algorithm organizaton inform symbol logic mechan theorem prove resolut game nonlift resolut order regular resolut versu unrestrict resolut claus tree tool understand implement resolut autom reason bottom procedur construct minim claus tree onc permut infer mechan theorem prove model elimin otter user guid machineori logic base resolut principl extend regular restrict resolut nonlinear subdeduct complex deriv proposit calculu tr