t comput given rotat reliabl effici a consid effici accur comput given rotat f g posit real number simpli amount comput valu appar trivial comput merit closer consider follow three reason first definit c r seem obviou case two nonneg argument f g enough freedom choic one f g neg zero complex lapack auxiliari routin slartg clartg slargv clargv comput rather differ valu c r mathemat ident valu f g elimin unnecessari ambigu bla technic forum chose singl consist definit given rotat justifi here second comput accur valu c r effici possibl reliabl despit overunderflow surprisingli complic complex given rotat effici formula requir one real squar root one real divid as well sever much cheaper addit multipl reliabl implement use work precis number case sun ultra new implement slightli faster previou lapack implement common case time faster correspond vendor refer atla routin also reliabl previou code occasion suffer larg inaccuraci due overunderflow real given rotat also improv speed accuraci though strike third design process led reliabl implement quit systemat could appli design similarli reliabl subroutin b introduct given rotat wide use numer linear algebra given f g given rotat by unitari matrix rc s s c fact rc s unitari impli s c c comput scienc divis univers california berkeley ca dbindelcsberkeleyedu materi base upon work support nation scienc foundat graduat research fellowship comput scienc divis mathemat dept univers california berkeley ca demmelcsberkeleyedu materi base part upon work support advanc research project agenc contract no daah via subcontract no ora univers tennesse depart energi grant no defger contract no weng via subcontract no argonn nation laboratori nation scienc foundat grant asc asc nsf infrastructur grant no cda cda comput scienc divis mathemat dept univers california berkeley ca wkahancsberkeleyedu nersc lawrenc berkeley nation lab osninerscgov see real f g real posit wide accept convent let howev neg c r also satisfi condit satisfi also satisfi c r determin uniqu slight ambigu led surpris divers inconsist definit literatur softwar exampl routin slartg clartg slargv clargv level bla routin srotg crotg well algorithm get significantli dierent answer mathemat ident input avoid unnecessari divers bla basic linear algebra subroutin technic forum design new bla standard chose pick singl definit given rotat section present justifi design bla technic forum also provid refer implement new standard case comput given rotat kernel routin intermedi overunderflow straightforward implement make output inaccur or stop execut even caus infinit loop attempt scale data desir rang even though true mathemat answer might unexcept comput c r ecient possibl reliabl despit overunderflow surprisingli complic particularli complex f g squar root divis far expens real float point oper current machin easi see one real squar root one real divis or perhap singl reciprocalsquar root oper necessari comput c r littl algebra manipul also show singl squar root divis also sucient along sever much cheaper addit multipl comput c r complex case contrast algorithm crotg routin fortran refer bla use least squar root divis perhap divis depend implement complex absolut valu function cab howev formula c r use one squar root one divis suscept overunderflow must store intermedi result precis f g defin systemat identifi valu f g formula reliabl ie guarante underflow way unnecessarili lose rel precis overflow gener set simultan linear inequ log f log g defin polygon region for safe log f log g space formula may use common situat call case algorithm case new algorithm run faster lapack clartg routin nearli time faster crotg routin vendor bla sun ultra atla bla fortran refer bla log f log g lie outsid s two possibl scale f g constant fit insid s use dierent formula scale may interpret geometr shift parallel diagon line log log g log f log g space region cover shift imag ss shadow region scale possibl part shadow case algorithm scale f g lie insid use previou formula remain region log f log g space includ space outsid ss shadow consist region log f log g dier much f round either f case algorithm case replac f either f g simplifi algorithm dierent formula use addit case simpler one f andor g zero three dierent way deal multipl case first way test branch depend f g appropri formula use portabl method use work precis the precis inputoutput argument one explor detail paper second method use except handl ie assum f g fall common case case use correspond formula float point except rais overflow underflow invalid altern formula use sucient fast except handl avail method may fastest third method assum float point format wider expon rang avail store intermedi result case may use main new formula case without fear overunderflow greatli simplifi algorithm the case f andor g zero remain exampl ieee doubl precis with bit expon use input f g ieee singl precis number with bit expon sun ultra mixedprecis algorithm nearli exactli fast case singl precis algorithm describ abov usual rather faster case intel machin doubl extend float point with bit expon use singl doubl precis input would algorithm choic howev doubl precis input machin like sun ultra without doubleextend arithmet doubl precis much slower singl precis new algorithm case best know addit new algorithm significantli faster previou routin accur earlier routin input exhibit larg rel error wherea alway nearli fulli accur rest paper organ follow section present justifi propos definit given rotat section detail dierenc propos definit exist lapack level bla code section describ assumpt float point arithmet section present algorithm complex case simpl case present algorithm common complex case assum neither overflow underflow occur case section show altern formula complex given rotat f g dier greatli magnitud case section describ scale f g compar magnitud larg small case section compar accuraci new complex given routin sever altern accur case section discuss perform complex given routin section discuss algorithm accuraci time real given rotat rather easier section draw conclus actual softwar includ appendix given rotat use follow function defin complex variabl x follow signx clearli continu function away x x real definit simpli state introduct need extra requir besid order determin c and henc r uniqu least one f g nonzero deduc first compon rc sf g real fact c must real deduc f state befor chosen arbitrarili long satisfi extra requir initi chosen bla technic forum help resolv choic sign follow definit real complex data consist real data pass complex algorithm result answer modulo roundo real algorithm current lapack subroutin use given rotat continu work correctli new definit current lapack subroutin slartg clartg which comput singl real complex given rotat resp satisfi requir furthermor lapack subroutin slargv clargv comput multipl given rotat comput answer slartg clartg resp dierenc describ section below chang practic need consist definit inde origin motiv bla technic forum simpli adopt lapack definit unchang howev immedi resolv choic sign proceed add requir r map f g c s r continu whenev possibl continu c function f g possibl everywher real f g approach along real line sin c must discontinu consid c s r function f increas ie f travers unit circl complex plane consid common convent c increas remain equal sinc c real continu impli c stay fix henc continu desir thu requir r impli c must nonneg togeth impli f obvious defin f g r continu away simplifi attract r ident matrix use multipli arbitrari pair vector requir work light requir r sinc c continu signf chang arbitrarili small complex neighborhood cannot hope defin continu argument includ complex f instead ask c s r continu function real f complex g ie continu f approach zero right limit easili seen take definit final consid case imposs defin continu sinc f g approach direct instead add requir r given choic c s choos requir least work rc s typic use multipli pair vector r requir work thi set summari algorithm complex real f g follow algorithm comput given rotat includ case must nonzero els f g nonzero endif f g real algorithm slightli simplifi replac g g except case algorithm run ieee float point arithmet possibl input might nan notanumb symbol section discuss valu c r case insist routin must termin return output valu case say complex number nan least one real imaginari part nan say complex number infinit least one real imaginari part infinit neither nan first suppos least one nan occur input semant nan binari unari arithmet oper nan return nan extens routin ought return nan well see definit necessarili thi sinc implement might reason still return sinc requir arithmet oper comput rather specifi exactli happen input nan insist least r nan perhap c well implementor discret permit discret nan hope rare comput insist test case might slow code much common case illustr challeng correct portabl code nan consid comput maxa b need comput f g max implement in hardwar softwar if a b els b max nan return nan maxnan return hand equal reason implement if a b b els a instead return nan respect thu implement might mistakenli decid miss nan g model implement work implement max next suppos least one occur input nan case reason return limit valu definit exist nan otherwis exampl one might return sinc cannot welldefin r g be one could simpli return nan even limit exist exampl return avoid overspecifi rare case therebi possibl slow common case leav implementor discret approach take insist least r either infinit nan assidu reader note algorithm leav ambigu sign zero treat includ dierent implement free return whenev zero deliv seem littl gain insist exampl would actual comput r multipli vector dierenc current lapack bla code short summari dierenc algorithm algorithm lapack earlier version level bla lapack algorithm question slartg clartg slargv clargv level bla routin srotg crotg lapack releas test code pass well new given rotat old one inde one test failur old code disappear new rotat new definit given rotat satisfi requir r return comment slartg save work mean lapack bidiagon svd routin g nonzero slartg return neg valu c r return algorithm algorithm mathemat ident clartg numer ident see section below return return return return g clargv return r g quantiti z one reconstruct c otherwis besid dierenc r assign sign g long either f g nonzero rather sign f or comput quantiti like z crotg set g nonzero match algorithm mathemat numer assumpt float point arithmet lapack routin slamch dlamch avail return variou machin constant need particular assum machin epsilon avail power machin radix machin ieee float point arithmet either singl doubl also use safmin intend smallest normal power radix whose reciproc comput without overflow ieee machin underflow threshold singl doubl howev machin complex divis implement compil fastest riski algorithm expon rang eectiv halv sinc c even though true quotient near machin safmin may set safmin indic thi result scale algorithm make assumpt proxim safmin actual underflow threshold inde tini valu rather less lead correct code though closer safmin underflow threshold fewer scale step need extrem case algorithm also work correctli accur whether underflow gradual import processor default fast mode replac underflow quantiti zero mean eectiv underflow threshold safmin sinc underflow x caus rel error safminx roundo scale algorithm use quantiti z safmin round nearest power radix thu use z eectiv underflow threshold z overflow threshold note may safe add subtract mani quantiti bound magnitud z without incur overflow repeat algorithm work correctli slowli conserv estim safmin use ie one larg power z use softwar comput first call save reus later call valu z power ieee machin safmin equal underflow threshold follow singl precis doubl precis z z input includ nan assum semant ieee arithmet use later discuss denot actual overflow threshold ov underflow threshold un smallest posit number m un machin gradual underflow un otherwis complex algorithm follow use convent capit variabl name c r data comput f g use notat ref imf mean real imaginari part f w maxr w im w complex number w begin elimin easi case least one f g zero variabl f g r complex rest real algorithm comput given rotat includ case els g must nonzero scale g power z z g z unscal r power z els f g nonzero use algorithm describ endif note even though easi case need scale g avoid overunderflow comput regimg except case discuss except handl notic speed code implement test g f precomput use later test whether sg sf describ section either test might succeed even though real imaginari part f g nan therefor logic algorithm must chang slightli shown below algorithm e comput given rotat except handl includ case case g nan make sure r els g must nonzero scale g power z z g z limit number scale step case g infinit nan unscal r power z case f nan make sure r els f g nonzero use algorithm describ endif test scaleg succeed one part g nan must return instead r f make sure input nan propag output r note output c s even nan infin input similarli branch taken g nan infin mean loop scale g and scaleg rang might termin written without upper bound maximum number step take maximum essenti maxlog z ovlog z m time depend strongli implement detail scale use unrol loop structur etc algorithm use could probabl improv tune particular compil architectur c alway zero nan g either infinit nan r infinit precis g infinit complex algorithm f g nonzero assum f g nonzero comput c r follow code fragment employ one divis one squar root last column show algebra exact quantiti comput line code assum realcomplex multipl perform two real multipl the fortran implement explicitli rather reli compil variabl f g r complex rest real algorithm fast complex given rotat f g well scale f ref g reg fg f c fd f f r fd f f f g conjg f f recal z safmin z eectiv overflow threshold z eectiv underflow threshold region algorithm run reliabl describ follow inequ number correspond line algorithm logarithm base assum f z prevent overflow comput f assum g z prevent overflow comput g line safe given previou assumpt a assum z f prevent underflow f consequ divis zero comput b assum f z prevent overflow f term ffg comput c assum fg z prevent overflow f g term ffg comput either d z e z fg prevent underflow ffg consequ divis zero comput line safe given previou assumpt c underflow deserv gf z prevent overflow fg sinc gf larg line safe given previou assumpt return r roughli z z smaller compon r underflow deserv un log f log z log g log z un b a c d e figur inequ describ region unnecessari overunderflow un ov overunderflow threshold smallest represent posit number line safe given previou assumpt return s roughli z smaller compon may underflow error small compar compon s line safe given previou assumpt underflow deserv note inequ list describ half plane log f log g space exampl inequ becom log g log f log z region describ inequ shown figur inequ describ thin line mark arrow indic side inequ hold heavi line border safe region satisfi inequ algorithm safe use remain say decid whether point lie s boundari complic time test membership nontrivi accordingli use simplest test like succeed first use expens test particular easiest test threshold comparison f g test membership subset label figur follow algorithm f z f z g z f g region endif call case softwar region contain data f g terribl far magnitud between z singl z doubl expect argument especi doubl complement region shown bound dash line figur harder test for boundari requir threshold test product fg could overflow test membership region explicitli case someth els instead except case consid consequ nan infin easi see either f g infinit test membership region cannot succeed suce consid nan test like ab evalu fals either b nan case occur nan input f g nan occur describ section examin algorithm see nan f g lead fg c r nan complex algorithm f g dier greatli magnitud g round f formula c r may greatli simplifi accur approxim f f region close approxim region g f mark figur call case softwar instead f round g formula c r may greatli simplifi accur approxim g f g g f g f g region close approxim region f g mark figur call case softwar import dierenc formula versu formula independ homogen f g word scale f g independ instead scalar order evalu safe thu shadow region formula safe cover f g pair contrast formula f g must scale valu algorithm implement without scale note even requir squar root algorithm comput complex given rotat gf use formula without scale gf endif algorithm comput complex given rotat fg use formula without scale fg endif may appli analysi last section formula deduc linear inequ log f log g must satisfi order guarante safe accur execut simpli summar result here case get region boundari that like s set line segment may vertic horizont diagon wish restrict test f g alon rather product which might overflow mean identifi smaller safe region like region within figur membership easili test safe region algorithm set satisfi z f z z g z safe region algorithm smaller set satisfi z lead follow algorithm incorpor scale algorithm comput complex given rotat gf use formula scale gf scale f power z z f z scale g power z z g z unscal power z undo scale f g algorithm comput complex given rotat fg use formula scale fg scale f power z z f z scale g power z z g z unscal c r power z undo scale f g endif note algorithm valu uneect independ scale f g except case first consid case ie algorithm possibl either f g nan sinc f g may be neither nan f infinit sinc test gf gf care must taken assur termin scale f g even nan infinit case c independ whether input infinit nan nan either f g nan infinit simpli get rf r nan or infinit precis f nan or infinit word r might nan g is model implement ensur r nan either f g nan instead comput comput s next consid case ie algorithm analog comment possibl valu input appli care must taken assur termin scale case either input nan three output nan g infinit f finit r nan complex algorithm scale region b point f g lie region figur use follow algorithm scale f g point scale f scale g lie s appli algorithm scale f scale g yield c s r unscal get rscale scale figur correspond shift f g parallel diagon line log scale lie s geometr appar set point scalabl region a bof figur lie set diagon translat s ie shadow s scale lie s inde point region mani but all point region scale lie s region cheaper formula discuss last section avail first suppos f g lie region a let scale f g z eventu f g lie union two arrowshap region figur then still exce z ie f g a multipli f g z put a thu guarante scale f g a safe use algorithm next suppos f g lie region b let scale f g z eventu f g like union two parallelogram b b figur then still less z ie f g b multipli f g z put b thu guarante scale f g b safe use algorithm consider lead follow algorithm algorithm comput complex given rotat f g region a b scale code execut f g region a b scale f g power z maxfg z maxfg z scale f g z els scale f g power z f z f z scale f g z endif comput given rotat use algorithm undo scale r caus scale f g call overal algorithm new clartg distinguish old clartg part releas entir sourc code includ appendix contain noncom line oppos refer crotg implement except case either input may nan may simultan infinit case three output nan befor care must taken scale accuraci result complex given rotat algorithm run valu f g real imaginari part f g independ took dierent valu rang overflow threshold intermedi valu chosen threshold valu determin edg corner figur thu bare satisfi or satisfi possibl branch algorithm correct answer input comput use straightforward implement algorithm use doubl precis arithmet overflow underflow possibl argument test maximum error r c comput follow r comput singl use new algorithm r comput straightforwardli doubl precis subscript c variabl analog mean absenc gradual underflow error metric finit represent r gradual underflow maximum taken nonzero test case true r overflow on subset mathemat definit c r use clartg crotg agre note safmin smallest denorm number analog metric comput c routin first test sun ultra use f fast o flag mean gradual underflow use ie result less safmin replac therefor expect measur un log g log z log f log z a b figur case code f g un log g log z log f log z figur scale f g region a un log g log z log f log z figur scale f g region b least hope littl bigger mean error r r either machin epsilon time true result small multipl underflow threshold inher uncertainti arithmet routin also test without optim flag mean gradual underflow use expect stringent measur close result follow gradual underflow routin max error r max error max error c old clartg refer crotg nan nan nan modifi refer crotg atla crotg nan nan nan limit atla crotg vendor crotg nan nan nan limit vendor crotg gradual underflow routin max error r max error max error c old clartg refer crotg nan nan nan modifi refer crotg old clartg fail accur first consid situat without gradual underflow g z f below algorithm decid scale unnecessari result f may nonneglig rel error underflow creat nonneglig rel error r c consid situat gradual underflow error occur dierent one occur g f f denorm algorithm scale result f suer larg loss rel accuraci round nearest denorm number c f g larg loss accuraci refer bla crotg fail even though tri scale avoid overunderflow scale factor f comput intern overflow even not consid situat without gradual underflow sine comput f multipl done first three quantiti parenthes quit accur entri ff less one caus multipl underflow true exce repair insert parenthes f divis done first exclud case f insert parenthes get error line modifi refer crotg consid situat gradual underflow round intermedi quantiti nearest denorm number caus larg rel error c equal instead atla vendor version crotg run full optim suggest author mean gradual underflow enabl also return nan larg argument even true answer represent modifi routin instead ran limit subset exampl f g less overflow still occasion larg error underflow caus larg rel error even true valu quit larg summari systemat procedur produc provabl reliabl implement wherea error previou implement yield inaccur result without warn fail unnecessarili due overflow latter occur true r close overflow hard complain much former problem deserv correct time result complex given rotat complex given rotat compar new algorithm describ abov old clartg lapack crotg refer bla time done sun ultra use f compil optim flag fast o routin call time argument throughout f g plane see figur averag time taken argument f g rang time f g typic percent case tri all exercis path new clartg code input data shown tabl below note time result optim code entir predict sourc code exampl small chang way scale implement make larg dierenc time proper behavior presenc infin nan input issu finit termin propag infin nan ot output scale part code could simplifi probabl acceler time result figur six algorithm compar new clartg algorithm present report use test branch select correct case old clartg algorithm lapack ref crotg refer bla atla crotg atla bla vendor crotg sun vendor bla simpli new clartg doubl precis see below figur show absolut time microsecond figur show time rel new clartg vertic tick mark delimit case code describ tabl below common case case left plot see new clartg faster old clartg nearli time faster version crotg get absolut speed limit also ran version algorithm work case ie omit test scale f g simpli appli algorithm appropri case ultim version ran microsecond time new clartg price reliabl altern system fast except handl one could run algorithm check underflow overflow divisionbyzero except occur recomput rare case experi perform doug priest report result here sun enterpris server mhz clock except handl use save clear float point except entri clartg run case without argument check check except flag see divisionbyzero overflow underflow invalid oper occur use case except restor except flag exit way argument fall common usual case run faster new clartg priest note essenti use inlin assembl access except flag rather librari routin such ieee flag take cycl descript algorithm call simplifi new clartg doubl precis avoid need scale fastest overal architectur ieee singl precis input test case use algorithm ieee doubl precis three extra expon bit elimin overunderflow machin algorithm take microsecond nonzero input f g nearli exactli case entir singl algorithm attract singl precis machin sinc fast much simpler cours would work input data doubl sinc wider format avail architectur input data time complex given rotat case case code f g case microsecond time comput complex given rotat old clartg atla vendor refer doubl figur time comput complex given rotat comput real given rotat f g nonzero follow algorithm minim amount work algorithm real given rotat f g nonzero without scale endif may appli kind analysi appli algorithm summar result here time comput complex given rotat rel new clartg case time time new old clartg atla vendor refer doubl figur rel time comput complex given rotat algorithm real given rotat f g nonzero scale scale z scale f g scale power z scale z elseif scale z scale f g scale power z scale z endif endif unscal r necessari algorithm one divis one squar root contrast srotg routin fortran refer bla squar root divis comput quantiti contain noncom ment line code oppos line refer bla srotg line exclud describ below contain appendix accuraci result real given rotat accuraci varieti routin measur way entir analog way describ section result shown tabl below first consid result absenc gradual underflow three version srotg use scale factor f g overflow even r not elimin extrem valu f g test yield result line label limit gradual underflow let f g equal smallest posit denorm number yield instead larg rel error best machin approxim true result m divid get c s respect slightli larger f g yield slightli smaller but still quit larg rel error c gradual underflow routin max error r max error max error c old slartg refer srotg nan nan nan limit refer srotg atla srotg nan nan nan limit atla srotg vendor srotg nan nan nan limit vendor srotg gradual underflow routin max error r max error max error c old slartg refer srotg nan nan nan limit refer srotg time result real given rotat six routin comput real given rotat test way entir analog manner describ section test argument time result shown tabl figur below three version srotg refer atla sun vendor version origin comput s c r comput singl scalar z one reconstruct c defin f g c f g c three case distinguish examin valu z c reconstruct permit exampl qr factor matrix overwrit given rotat use comput q case household transform capabl use lapack neither version slartg comput z make time comparison fairer therefor remov two line code comput z refer srotg time test below howev modifi atla sun perform librari anyway routin work necessari input data time real given rotat case f g case microsecond time comput real given rotat old slartg atla vendor refer doubl figur time comput real given rotat see figur common case case scale need new slartg faster old slartg time faster version srotg get absolut speed limit also ran version algorithm work case ie omit test scale f g simpli appli algorithm appropri data larg small ultim version ran microsecond time new slartg price reliabl experi doug priest use except handl avoid branch show improv common case scale need final doubl precis version slartg simpli test case run algorithm doubl precis without scale nearli fast new slartg common case scale need faster scale need conclus justifi specif given rotat put forth recent bla technic forum stan dard shown implement new specif way faster previou implement reliabl use systemat design process kernel could use whenev accuraci reliabl overunderflow ecienc simultan desir side eect approach algorithm much longer must implement precis argument fast arithmet wider rang avail avoid overunderflow algorithm becom simpl reliabl least fast time comput real given rotat rel new slartg case time time new old slartg atla vendor refer doubl figur rel time comput real given rotat r faster numer algorithm via except handl matrix comput basic linear algebra subprogram fortran usag privat commun tr algebra eigenvalu problem implement complex elementari function use except handl matrix comput rd ed appli numer linear algebra implement complex arcsin arccosin function use except handl basic linear algebra subprogram fortran usag faster numer algorithm via except handl perform improv lapack cray scientificlibrari ctr luca gemignani unitari hessenberg qrbase algorithm via semisepar matric journal comput appli mathemat v n p decemb milo d ercegovac jeanmichel muller complex squar root operand prescal journal vlsi signal process system v n p octob frayss luc giraud serg gratton julien langou algorithm set gmre routin real complex arithmet high perform comput acm transact mathemat softwar tom v n p june