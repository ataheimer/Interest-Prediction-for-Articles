t lightweight context recoveri effici accur program analys a comput accur inform effici program use pointer variabl program analysi must account fact procedur may access differ set memori locat procedur invok differ callsit paper present lightweight context recoveri techniqu effici determin whether memori locat access procedur specif callsit paper also present techniqu use inform improv precis effici program analys empir studi show lightweight context recoveri quit precis identifi memori locat access procedur specif callsit distinguish memori locat access procedur differ callsit significantli improv precis effici program analys program use pointer variabl b introduct softwar develop test mainten activ import expens thu research investig way provid softwar tool improv ecienc thu reduc cost activ mani tool requir program analys extract inform program exam ple tool debug program understand impact analysi use program slice eg focu attent part softwar influenc particular statement support softwar engin tool eectiv program analysi must sucient ecient tool reason respons time accept throughput more over program analysi must sucient precis use inform hidden within spuriou inform int x fint p fint q int fz fq int main int fy printfdw figur exampl program mani program analys eectiv comput program inform program use pointer variabl howev appli techniqu program use pointer variabl sever issu must consid first program use pointer vari abl two dierent name may refer memori locat program point exampl program figur pointer derefer p variabl name refer memori locat statement phenomenon call alias must consid comput safe program in format exampl without consid eect alias program analysi would ignor fact referenc p statement thu conclud incorrectli procedur f modifi y second program use pointer variabl procedur access dierent memori locat pointer derefer procedur invok dierent callsit exampl f access x call statement access w x call statement program analysi cannot distinguish memori locat access procedur context specif callsit might comput spuriou program inform callsit exampl program analysi might report y z w modifi f f call statement furthermor program analysi propag spuriou program inform throughout program unnecessarili ineci mani exist techniqu eg comput safe program inform account eect alias analysi howev techniqu eg distinguish memori locat access procedur context specif callsit techniqu use condit analysi attach condit inform gener program analysi exampl p refer w statement figur p alias w entri f thu program analysi report w modifi statement condit determin whether w modifi f statement execut program analysi determin whether p alias w entri f check alia inform statement q alias w statement p alias w entri f f invok statement thu program analysi report w modifi statement execut although techniqu use condit analysi distinguish memori locat access procedur specif callsit thu avoid comput spuriou program inform ineci first requir condit alia inform current provid expens aliasanalysi algorithm eg second increas cost comput program inform exampl without use condit analysi complex comput interprocedur reach definit on v n size program v number name refer memori locat wherea use condit analysi complex on comput accur program inform without use expens condit alia inform ad complex program analysi develop new approach two part first examin way memori locat access proce dure ecient identifi set memori locat access procedur specif callsit second use set memori locat reduc spuriou inform propag procedur callsit callsit procedur ecient identifi memori locat access procedur specif callsit develop techniqu lightweight context recoveri techniqu base observ that context callsit formal paramet procedur typic point set memori loca tion throughout procedur actual paramet bound formal paramet pointer given memori locat access exclus pointer derefer formal paramet memori locat access procedur specif callsit memori locat access callsit pointer derefer actual paramet bound observ allow techniqu identifi memori locat access procedur specif callsit reduc spuriou inform propag across procedur boundari program analys also develop techniqu use inform memori locat comput lightweight context re coveri callsit program inform memori locat identifi access call procedur need propag callsit call procedur call procedur callsit thu techniqu improv precis ecienc program analys paper present new first present lightweight context recoveri algorithm section illustr use interprocedur slice techniqu use inform provid lightweight context recoveri improv program analys section main benefit approach ecient use alia inform provid ecient alia analysi algorithm liang harrold andersen lightweight context recoveri almost ecient modif side eect analysi use inform provid lightweight context recoveri program analysi add littl cost program analysi second benefit approach that mani case identifi larg number memori locat whose inform need propag specif callsit thu provid signific improv precis ecienc program analysi third benefit approach orthogon mani techniqu improv ecienc program analys thu use techniqu improv ecienc program analys paper also present set empir studi investig eectiv use lightweight context recoveri improv ecienc precis program analys section studi show number interest result mani program studi lightweight context recoveri algorithm comput rel littl increas cost significantli smaller number memori locat modifi callsit comput tradit modif side eect analysi algorithm sever program use alia inform provid liang harrold algorithm andersen algorithm lightweight context recoveri algorithm report almost modif sideeect callsit landi ryder zhang algorithm must use condit alia inform use inform provid lightweight context recoveri reduc size slice comput use reusedriven slice algorithm time requir comput slice section first give definit present lightweight context recoveri algorithm definit memori locat program referenc object name object name consist variabl possibl empti sequenc derefer field ac cess object name contain derefer object name direct object name otherwis object name indirect object name exampl xf direct object name wherea p indirect object name direct object name obj repres memori locat refer lobj say object name n extens object name construct appli possibl empti sequenc derefer field access n case denot n en refer n prefix n empti n proper extens n n proper prefix n n formal paramet actual paramet bound n callsit c defin function c e n return object name ea exampl suppos r pointer point struct field f e r r e f r rf r proper prefix r r formal paramet function f q actual paramet bound r callsit c f c e f r qf given object name obj statement s alia analysi determin set memori locat may alias obj s refer set obj access set s denot set asetobj s exampl figur asetp landi ryder algorithm use given memori locat loc procedur p name set loc p contain object name use refer loc p exampl name set f figur p memori locat loc support object name obj statement valu loc may use resolv derefer obj s ex ampl suppos q point r r point x statement s r support q s lightweight context recoveri identifi memori locat access procedur p specif callsit lightweight context recoveri consid nonloc memori locat p name set nonloc memori locat loc contain direct object name techniqu report loc access callsit p name set loc contain singl indirect object name techniqu comput addit inform determin whether loc access specif callsit p case ecienc techniqu assum loc access callsit p suppos indirect object name obj object name name set nonloc memori locat loc procedur p then loc referenc p must referenc obj none memori locat support obj statement p modifi p p execut obj refer memori locat point p case obj extens formal paramet p call callsit c obj must refer memori locat one referenc c obj c thu loc referenc p c loc must referenc c obj c program analysi must propag inform loc p c c obj alias loc c properti memori locat give us opportun avoid propag ie filter spuriou inform inform propag procedur callsit program analys say that loc properti p loc elig filter callsit p say loc candid precis loc candid p follow condit hold condit loc name set p contain singl indirect name obj condit obj proper extens formal paramet p condit memori locat support obj statement p modifi p exampl figur name set w f contain p proper extens formal paramet p valu p chang f thu w candid f p w need propag inform w f statement howev p z need propag inform w f statement lightweight context recoveri process procedur revers topolog bottomup order call graph identifi memori locat candid procedur figur show algorithm contextrecoveri perform process nonloc memori locat loc referenc procedur contextrecoveri comput mark markp loc whose valu unmark u elig inelig default markp loc initi u loc candid p markp loc case obj object name loc name set contextrecoveri store obj objp loc loc candid p markp loc objp loc contextrecoveri also set modp loc true loc modifi statement p check whether memori locat support object name modifi p contextrecoveri examin way loc access p call updat variou point eg line algorithm contextrecoveryp input p program global markp map memori locat procedur p mark whether memori locat modifi memori locat object name declar list procedur sort revers topolog order begin contextrecoveri foreach procedur p intraprocedur phase foreach statement p foreach object name obj obj direct updatep lobjf els foreach memori locat loc asetobj s updatep loctobj endfor endif endfor set modp memori locat modifi endfor add p w endfor w interprocedur phase take first procedur p w foreach callsit c r p foreach nonloc memori loc referenc r markr loc updatep locf elseif locasetac objr loc c ac objr loc indirect updatep loctac objr loc els updatep locf endif endif updat modp loc endfor endfor valid object name objp modp markp modp updat add p s caller w endwhil contextrecoveri procedur updateqlmo input q procedur l memori locat boolean object name global markq mark memori locat q array object name begin updat markq l objq l extens formal markq l objq l els markq l objq l endif elseif t markq oobjq l markq l objq l endif updat figur algorithm identifi candid memori locat comput markp loc objp loc updat input procedur q memori locat l boolean flag m object name o contextrecoveri detect memori locat access statement p memori locat access indirect object name algorithm call updat true otherwis memori locat access indirect object name algorithm call updat f fals updat set valu markq l objq l accord current valu markq l f l candid q condit violat thu markq l updat objq l updat line current valu markq l u updat check see whether extens formal paramet q line so l candid accord inform avail point computa tion thu markq l updat objq l updat otherwis l candid condit violat thu markq l updat objq l updat line markq l updat check whether objq l line same l access q one object name violat condit thu l candid markq l updat objq l updat line case markq l objq l remain unchang contextrecoveri comput mark obj mod use intraprocedur phase interprocedur phase intraprocedur phase contextrecoveri process object name appear statement procedur p line object name obj direct contextrecoveri call updatep lobjf line obj indirect memori locat loc asetobj s contextrecoveri call line memori locat l modifi s contextrecoveri also set modp l true line exampl contextrecoveri process statement f figur check p p indirect name asetp thu algorithm call updatefytp updatefztp updatefwtp contextrecoveri also check x statement x direct name contextrecoveri call updatef xf f process mark f obj f follow valu mark f mark f mark f interprocedur phase contextrecoveri process callsit c procedur r procedur p line use worklist w nonloc memori locat loc referenc r contextrecoveri check markr loc line markr loc contextrecoveri assum loc access r callsit r includ c thu contextrecoveri call updatep locf indic loc access r c unknown way line otherwis markr loc contextrecoveri check whether loc aseta c objr loc c line loc loc referenc r c object name c objr loc context recoveri call updatep locta c objr loc c objr loc indirect call updatep locf c objr loc direct line loc loc referenc r c contextrecoveri noth case interprocedur phase memori locat loc process modr loc true modp loc also set true line exampl contextrecoveri process callsit f statement figur first check x mark f x thu algorithm call updatefxf algorithm check y mark f y algorithm check whether thu algorithm call updatefytq algorithm final check z w noth z w asetq valu mark f obj f chang mark f mark f mark f mark f statement process interprocedur phase contextrecoveri also valid indirect object name appear objp make sure memori locat support indirect name p modifi p line suppos indirect name obj assign objp loc memori locat l support obj statement p modp l true loc inelig condit vi olat thu contextrecoveri updat markp loc objp loc contextrecoveri process p interprocedur phase modp markp updat algorithm put p s caller w line contextrecoveri continu w becom empti tabl show result comput contextrecoveri exampl program figur mark obj mod mark f mark f mark f mark f mark f mark f markmain markmain tabl mark obj mod exampl program given n size program complex contextrecoveri on absenc recurs on presenc recurs complex contextrecoveri algorithm comput modif side eect procedur improv slice section show inform comput use contextrecoveri improv interprocedur slice program analys comput interprocedur reach definit construct system depend graph improv similar way interprocedur slice program slice techniqu identifi statement program aect valu variabl v statement s v call slice criterion program slice use support task debug regress test revers engin one approach program slice first comput data control depend among statement build systemdepend graph comput slice solv graphreach problem graph approach one use reusedriven interprocedur slice algorithm use precomput controldepend inform comput datadepend inform demand use controlflow graph cfg procedur use reusedriven slice algorithm exampl show program analysi improv use inform provid lightweight context recoveri reusedriven slicer comput interprocedur slice criterion s v invok partial slicer procedur program reusedriven slicer first invok partial slicer p procedur contain s identifi subset statement p procedur call p subset input p may aect v s refer v partial slice standard use partial slicer denot s v refer subset statement identifi partial slicer partial slice respect s v also refer subset input identifi partial slicer relev input respect s v p main function program statement procedur call p might also aect slice criterion s v relev input s v therefor p process callsit c call p reusedriven slicer bind relev input f back c creat new partial slice standard c given bound f c reusedriven slicer invok partial slicer c identifi statement p c includ slice algorithm continu addit partial slice standard gener algorithm return union partial slice comput partial slicer program slice s v figur show call graph program figur x x f main figur call graph annot partial slice standard x solid line show graph edg dot line show relationship among partial slice standard graph annot partial slice standard creat reusedriven slicer comput slice x reusedriven slicer first invok partial slicer f respect x partial slicer comput partial slice relev input set x f process reusedriven slicer creat new partial slice standard x x callsit f f partial slice standard x callsit f main invok partial slicer standard partial slicer comput relev input set x x x partial slicer finish process x x reusedriven slicer creat partial slice standard x callsit f main invok partial slicer standard result slice x union partial slice comput process partial slicer comput partial slice standard s v propag memori locat backward throughout p use p s cfg node n cfg p partial slicer comput two set memori locat n entri n n exit n n comput use n inform n n comput union set n s cfg successor partial slicer iter comput node fix point reach formal paramet nonloc memori locat p s entri relev input respect s v n callsit partial slicer comput consid n memori locat whose valu modifi use n memori locat n modifi n n statement n control depend ad slice n callsit procedur q partial slicer must process q comput n identifi statement q inclus partial slice figur show processcal procedur process callsit c q processcal use cach store partial slice relev input partial slice standard creat reusedriven slicer memori locat u c processcal bind u u line u modifi q proce procedur processcallc inout input c call node call q set c output set c global cach v pair pslice relinput previous comput computepslic s v begin processcal foreach u u modifi q pocedur call q els cacheqexit u null cacheqexit endif add cacheqexit u pslice slice endif endfor figur procedur process callsit use cach dure call q processcal simpli add u c line otherwis processcal creat partial slice standard qexit u qexit exit q processcal check cach qexit u line cach contain inform qexit u processcal invok computepslic qexit u store partial slice relev input return computepslic cach line processcal merg partial slice program slice line call backbind not show bind relev input back c add c line c process statement includ slice c statement c control depend ad slice exampl comput slice w slicer first propag w statement statement callsit slicer propag w f creat new partial slice standard w slicer invok partial slicer w comput partial slice relev input xyzwp slicer bind x y z w p back statement put xyz w in slicer keep process add statement slice interprocedur slice use inform provid lightweight context recoveri precis ecienc reusedriven slicer improv identifi set memori locat modifi procedur specif callsit thi slicer propag memori locat callsit call procedur first check whether memori locat modifi procedur callsit memori locat cannot modifi procedur callsit reusedriven slicer propag memori locat call procedur similarli precis ecienc reusedriven slicer improv identifi set memori loca procedur processcallc inout input c call node call q set c output set c global cach v pair pslice relinput previous comput computepslic s v begin processcal foreach u u modifi q c els cacheqexit endif add cacheqexit u pslice slice endif endfor function backbindev ar c p input ev ar memori locat reach entri p c call node call p output memori locat callsit begin backbind foreach memori locat l ev ar l formal paramet add memori locat bound l c calleev ar elseif l referenc p c old els add l calleev ar enif endfor return calleev ar backbind figur processcal modifi backbind tion referenc procedur specif callsit slicer propag call procedur callsit memori locat referenc callsit improv reduc spuriou inform propag across procedur boundari thu improv precis effici reusedriven slicer exampl consid action reusedriven slicer w figur two improv describ abov made improv slicer first propag w statement statement modifi w invok statement improv slicer propag w statement f creat partial slice standard w improv slicer invok partial slicer w add statement partial slice identifi x y z w p relev input improv slicer check statement find x w referenc f invok statement thu add x w in improv slicer propag x w f modifi neither x w invok statement improv slicer propag x w directli in without propag f improv slicer continu add statement slice exampl show use specif callsit inform help reusedriven slicer comput precis slice modifi processcal figur use set memori locat modifi procedur specif callsit reduc spuriou inform propag callsit call procedur figur show modifi processcal line replac line origin version u c new processcal first check whether u modifi q c line u modifi q c new processcal add u c line u modifi q c new processcal bind u u q creat partial slice standard qexit u continu comput usual way line u modifi q c impli u modifi q new processcal need check u also modifi backbind use set memori locat referenc procedur specif callsit reduc spuriou inform propag procedur callsit figur show modifi backbind line chang backbind check memori locat l input ev ar line l formal paramet backbind add memori locat bound l c calleev ar line otherwis new backbind check whether l referenc p invok c line so backbind put l calleev ar line final backbind return calleev ar line use markp objp modp comput contextrecoveri determin memori locat modifi p callsit c nonloc memori locat loc p modp loc true markp loc loc may modifi p callsit p includ c modp loc true markp loc loc loc modifi p c otherwis loc modifi p c exampl accord result tabl mark f thu f modifi f invok statement figur contain y howev f modifi f invok statement aseta ie asetw contain y use similar approach determin memori locat referenc p p invok c memori locat loc markp loc loc referenc p c markp loc objp loc obj loc aseta c obj c loc referenc p c otherwis loc referenc p c also use condit alia inform determin memori locat may modifi p c howev approach might expens larg program perform sever studi evalu eectiv ness use lightweight context recoveri improv precis ecienc program analys implement contextrecoveri reusedriven slice algorithm use inform provid contextrecoveri use prolang analysi framework paf studi compar result comput alia inform provid liang harrold algorithm lh andersen algorithm and gather data studi sun ultra workstat mb physic memori gb virtual memori left side tabl give inform subject program cfg lh program node loc ci cr ci cr loader dixi learn assembl smail simul arc space larn espresso moria twmc tabl inform subject program left time second contextinsensit modif side effect analysi ci contextrecoveri cr right goal studi evalu ecienc algorithm cr compar time requir run cr program time requir comput modif sideeect procedur program contextinsensit algorithm ci make comparison time comput modif sideeect rel small compar time requir mani program analys algorithm use instead ci comput precis modif sideeect requir mani program analys right side tabl show result comput use alia inform provid lh algorithm algorithm tabl see that subject studi cr almost ecient ci suggest time ad algorithm might neglig mani program analys goal studi evalu precis algorithm identifi memori locat modifi procedur specif callsit mod see detail comparison two algorithm simul eect librari function use new stub greater detail data report studi subject program dier report previou work figur averag size mod callsit callsit compar size mod callsit comput tradit contextinsensit modif sideeect analysi algorithm the cimod al gorithm algorithm reduct size mod callsit indic eectiv techniqu filter spuriou inform call site also compar result comput algorithm result comput landi ryder zhang modif side eect analysi algorithm the lrz algorithm use condit anali si result comput lrz algorithm view lower bound algorithm use implement cimod algorithm algorithm use implement lrz algorithm provid paf figur show result studi graph total length bar indic either lh repres averag size mod callsit comput cimod algorithm use alia inform provid algorithm lh al gorithm bar length slant segment repres averag size mod callsit comput algorithm use alia inform provid correspond alia analysi algorithm ex ampl use alia inform provid algorithm cimod algorithm report callsit modifi memori locat space use alia inform howev algorithm report callsit modifi memori locat graph show subject program stud i algorithm comput significantli precis mod callsit cimod algorithm thu expect use inform provid algorithm significantli reduc spuriou inform propag across procedur boundari figur also show averag size mod callsit comput lrz algorithm graph length bar indic lrz repres averag size mod callsit comput lrz algorithm exampl lrz algorithm report callsit space modifi memori locat note algorithm use alia inform comput landi ryder algorithm treat structur way field case algorithm report larger mod callsit algorithm space graph show that sever program studi size mod callsit comput algorithm close comput lrz algorithm result suggest algorithm quit precis identifi memori locat may modifi procedur specif callsit graph also show precis mod callsit comput algorithm vari dierent program suggest eectiv ness improv program analys use inform provid algorithm might depend program written studi goal studi evalu eectiv use inform provid lightweight context recoveri improv precis ecienc reusedriven slice algorithm compar size slice time comput slice without use inform provid lightweight context recoveri tabl show result left side tabl show s averag size slice comput use inform provid lightweight context recoveri averag size slice comput without use inform tabl also show ratio percentag tabl see that program use inform provid lightweight context recoveri significantli improv precis comput interprocedur slice howev program see signific improv one explan may that program precis interprocedur slice sensit precis identifi memori locat modifi referenc statement result consist result report refer show precis interprocedur slice sensit precis alia inform right side tabl show averag time comput slice use inform provid data program unavail landi ryder algorithm fail termin within hour time limit set comput alia inform program averag size time second name alia s ss t tt load lh er dixi lh learn lh assem lh smail lh simu lh later arc lh space lh larn lh averag size time hour name alia s ss t tt espr lh sso moria lh twmc lh data collect slice program data collect one slice tabl averag size slice left averag time comput slice right lightweight context recoveri averag time comput slice without use inform provid lightweight context recoveri time measur includ time requir build cfg alia analysi comput modif sideeect context recoveri tabl also show ratio tabl see use inform provid lightweight context recoveri significantli reduc time requir comput interprocedur slice suggest techniqu might eec tive improv ecienc mani program analys flowinsensit alia analysi algorithm ex tend use similar techniqu refer comput polyvari alia inform identifi dierent alia relat procedur dierent callsit use polyvari alia inform program analysi identifi memori locat access procedur specif callsit thu comput accur program informa tion howev comput polyvari alia inform may requir procedur analyz multipl time specif call context requir may make alia analysi ineci observ memori locat point pointer procedur program inform procedur develop techniqu partit memori locat equival class memori locat equival class share program inform procedur therefor procedur analyz inform repres equival class comput inform reus memori locat equival class experi show techniqu eec tive improv perform program analys techniqu present paper improv perform program analys anoth dimens thu use togeth equival analysi improv ecienc program analys horwitz rep binkley present techniqu use set variabl may modifi may referenc procedur avoid includ unnecessari callsit slice techniqu need systemdependencegraph base slicer comput slice precis comput interprocedur slicer eg techniqu dier techniqu use set memori locat may access procedur specif callsit filter spuriou program infor mation thu techniqu improv precis perform mani program analys horwitz rep binkley techniqu cannot appli mani techniqu improv perform program analys eg lightweight contextrecoveri techniqu use mani approach improv perform dataflow analys conclus futur work present lightweight context recoveri algorithm illustr techniqu use inform provid lightweight context recoveri improv precis ecienc program anal yse also conduct sever empir studi result studi suggest that mani case use lightweight context recoveri eectiv improv precis ecienc program analys futur work first repeat studi paper larger program valid conclus second perform studi evalu eectiv combin lightweight context recoveri equival analysi improv e cienci comput interprocedur slice third appli techniqu program analys evalu eectiv program analys fi nalli perform studi compar techniqu condit analysi acknowledg work support nsf grant ccr ccr ohio state univers r program analysi special c program languag program languag research group call graph construct objectori languag interprocedur slice use depend graph safe approxim algorithm interprocedur pointer alias interprocedur modif side e equival analysi gener techniqu improv e interprocedur defus associ c program program slice tr interprocedur slice use depend graph safe approxim algorithm interprocedur alias interprocedur modif side effect analysi pointer alias call graph construct objectori languag effect wholeprogram analysi presenc pointer reusedriven interprocedur slice equival analysi effici pointsto analysi wholeprogram analysi dataflow analysi program fragment interprocedur defus associ c system singl level pointer effect presis pointer analysi reusedriven interprocedur slice presenc pointer recurs ctr donglin liang maikel pen mari jean harrold evalu impact contextsensit andersen algorithm java program acm sigsoft softwar engin note v n januari anatoliy doroshenko ruslan shevchenko rewrit framework rulebas program dynam applic fundamenta informatica v n p januari marku mock darren c atkinson craig chamber susan j egger improv program slice dynam pointsto data proceed th acm sigsoft symposium foundat softwar engin novemb charleston south carolina usa marku mock darren c atkinson craig chamber susan j egger improv program slice dynam pointsto data acm sigsoft softwar engin note v n novemb marku mock darren c atkinson craig chamber susan j egger program slice dynam pointsto set ieee transact softwar engin v n p august michael hind pointer analysi solv problem yet proceed acm sigplansigsoft workshop program analysi softwar tool engin p june snowbird utah unit state baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slice acm sigsoft softwar engin note v n march