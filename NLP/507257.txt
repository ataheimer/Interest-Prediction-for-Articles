t regular viewpoint paprocess a pa process algebra allow nondetermin sequenti parallel composit recurs suggest view paprocess astre usingtreeautomata techniqu verif problem pa main result set iter predecessor regular set paprocess regular tree languag similarli iter successor furthermor correspond tree automata built effect polynomi time mani immedi applic verif problem paprocess among simpl gener modelcheck algorithm b introduct veric innit state process activ eld research today concurrencytheori commun cours alway activ petrinet com muniti research involv process algebra modelcheck realli becam interest innit state process proof bisimul decid norm bpaprocess bbk prompt sever research investig decid issu bpp bpa with without normed hypothesi see chm mol be partial survey bpa bpp pa bpa inondetermin recursionj fragment process algebra bpp inondetermin parallel composit recursionj fragment pa from beh combin much less tractabl year ago decid result bpp bpa present pa still beyond reach current techniqu mayr show decid reachabl pa process mayc extend decid modelcheck pa wrt ef fragment ctl mayb import breakthrough allow mayr success attack power process algebra maya decid result pa present research eg ku ku jkm eld ask new insight decid proof mayb and follow paper certainli trivial construct quit complex hard check easi see direct result andor proof could adapt gener without much troubl probabl complex cannot avoid techniqu current avail eld believ point import look new insight concept techniqu simplifi eld rather tri extend alreadi exist result contribut paper show treeautomata techniqu greatli help deal pa main result two regular theorem state post l resp pre l set congur reachabl resp allow reach congur l regular tree languag l is give simpl polynomialtim construct associ automata mani import consequ follow directli includ simpl algorithm modelcheck paprocess work regular post l pre l could obtain combin two main insight treeautomata techniqu prove power sever eld see cksv use processalgebra commun well all pa simpl termrewrit system special contextsensit rewrit strategi unlik headrewrit presenc sequenti composit oper rr n syntact congruenc use simplifi notat simpl process algebra help one get closer intend semant process break regular behavior decid result much simpler one introduc syntact congruenc later stage besid gener approach plan paper start recal basic treeautomata theori introduc denit pa process algebra explain set pa process seen tree languag give simpl proof show post t pre t regular tree languag start list applic veric problem move post l pre l l regular languag main technic result devot import applic modelcheck end extens reachabl modelcheck constraint simpl import techniqu allow deal pa process modulo structur equival relat work sever recent work eld use treeautomata describ behaviour system use describ set congur set reachabl congur pushdown automaton form regular word languag proven bc extend cau applic modelcheck pushdown automata propos fww bem decid rstorder theori rewrit relat induc ground term rewrit system reli ground tree transduc dt note pa dene condit ground rewrit system among applic develop regular theorem sever suggest mayr work pa mayc mayb andor earlier work rpp ksa ksb regular tree languag tree automata recal basic fact tree automata regular tree languag detail reader refer classic sourc eg cdg rank alphabet nite set symbol f togeth ariti function partit f accord ariti set term f call nite tree tree tree languag f subset f nite bottomup tree automaton tupl hf q f ri f rank alphabet nite set state f q subset nal state r nite set transit rule form fq ariti jf symbol f f tree automata rule also allow transit rule form transit rule dene rewrit relat term built f q see state q nullari symbol work bottomup rst nullari symbol leav inria regular viewpoint paprocess replac state q quasileaf symbol immedi top leav q replac state q write rewritten in number step q q say accept rewritten nal state a write la set term accept a tree languag coincid la regular tree languag regular tree languag close complement union etc exampl let f given f ffg automaton accept set occur even number time t given q g let gfga b rewrit follow gfga b gamma gfgq henc gamma q f la replac r automaton accept set even number gs along everi path root leaf size tree automaton denot jaj number state augment size rule rule fq paper shall never precis count jqj number state automata notic that xed f largest ariti jaj ojqj tree automaton determinist transit rule distinct lefthand side and rule otherwis nondeterminist given nondeterminist tree automaton one use classic isubset constructionj build determinist tree automaton accept languag construct involv potenti exponenti blowup size tell whether la empti nonnecessarili determinist tree automaton done time ojaj tell whether given tree accept given nonnecessarili determinist done time polynomi jaj tree automaton complet speci also complet f fn q q rule fq ad sink state obviou rule extend complet one accept languag pa process algebra present pa explicitli refrain write term modulo simplic law eg neutral law henc use isnil predic see below inspir chr viewpoint agreement earliest work gener process algebra like cc acp etc key condit result next section clearli prevent consid term modulo structur congruenc later stage demonstr section rr n dlugiez phschnoebelen syntax set action name set process variabl set paterm given follow abstract syntax t given epa write vart set process variabl occur subtermst set subterm includ t guard pa declar nite set ng process rewrit rule note x s need distinct write var delta set process variabl occur delta subterm delta union subtermst right lefthand side rule delta rule ix tj deltag deltax aact delta x var set variabl delta provid rewrit follow assum xed var delta semant pa declar delta dene label transit relat delta epa theta act theta epa alway omit delta subscript confus possibl use standard notat abbrevi w induct dene via follow so rule x predic induct dene ae true fals otherwis isnil predic syntact test termin inde lemma follow three properti equival ie termin inria regular viewpoint paprocess proof deriv use x induct prove obviou denit tree languag shall use tree automata recogn set term epa possibl epa f f given f kg cours shall keep use usual inx notat term built ij ikj begin one simplest languag epa proposit t singleton tree languag ftg regular automaton ftg need jtj state similarli immedi consequ lemma corollari l set termin process regular tree languag automaton l need one state regular reachabl set post t def denot set iter predecessor resp set iter successor also call reachabl set t notion take account sequenc w act action name allow move post t inde forget action name section devot pre ct post ct c act given two tree languag l l epa let regular pre dene l tepa innit famili tree languag least solut follow set recurs equat intuit quasiregular equat satis rr n pre t observ equat dene l contain ly s process variabl allow one step transit t lemma epa l proof sketch proof u induct length transit sequenc u t case analysi so rule gave last transit induct structur t proof u l impli u xpoint induct follow case analysi summand equat use reli simpl lemma reachabl equat easili transform regular equat introduc new variabl set ftg denit l tt s now given l depend nite number l u s fug name us subtermst subterm delta corollari epa set l regular tree languag correspond tree automaton ojdeltaj state entail theorem epa pre t pret pre t regular tree languag regular post dene l two innit famili tree languag least solut follow set recurs equat aim l coincid section shall see corollari hold even delta innit but var delta must nite inria regular viewpoint paprocess post t resp post x x again easili turn regular equat again given l l depend nite number l u s fug corollari epa set l l regular tree languag correspond tree automata ojdeltaj state pre t easili show lemma epa l post t l henc corollari theorem epa post t postt post t regular tree languag construct eoeectiv theorem gener section howev found enlighten give simpl proof simplest variant regular result alreadi theorem eoeectiv construct associ automata mani applic applic theorem reachabl problem ii reachabl j p proof combin cost membership test nondeterminist tree automata regular pre t regular post t dioeerent present pa delta mayc show reachabl problem npcomplet section describ get result byproduct approach mani problem solv simpl applic theorem bounded post t innit rr n cover aka controlst reachabl reach resp occur inclus state reachabl also reachabl question modulo regular preserv oper eg project live given delta live if reachabl state least one transit delta red regular post l pre l regular languag section prove regular pre l post l regular languag l notat simplic given two state q q automaton a denot q k q state q q k q possibl use rule regular pre ingredi pre assum al automaton recogn l epa pre new automaton combin sever ingredi ffl a complet speci automaton accept termin process see corollari ffl al automaton accept l ffl also use boolean record whether rewrit step done state pre state pre tupl q q denot set state relev automaton transit rule pre transit rule pre dene follow type rule form gamma q gamma q l type a rule form x gamma q q l true st exist u gamma q l type b rule form x gamma q gamma q l type rule form q type a rule form q state a inria regular viewpoint paprocess type b rule form q lemma epa pre u epa p n p u u a proof structur induct t three case pre rule observ rule type b exactli correspond lemma requir requir that pre type rule q induct hypothesi entail correspond rewrit pre pre use type b rule b use type rule q nal state therefor u l termin process henc t convers assum gamma q l u rst case ind hyp entail pre al pre use type b rule show pre u al l second case al nal state a use type rule show pre case similar previou one actual simpler let nal state pre state q q l nal state al u u accept al ioe pre accept thi use assumpt a complet speci theorem regular l regular subset epa pre l regular furthermor automaton al recogn l possibl construct in polynomi time automaton pre recogn pre l al k state pre need k state rr n proof immedi consequ lemma observ result need nite delta but var delta must nite build pre eoeectiv requir eoeectiv way list type rule done comput product ax automaton post x a al exist u gamma q l ioe languag accept nal state fq nal state ax g notempti give us pair q q l need type rule observ need nite delta build ax s regular post ingredi post assum al automaton recogn l epa post new automaton combin sever ingredi automata a al previou construct time need assum complet speci automata delta complet speci automaton recogn subterm delta state q subterm delta ensur delta take transit rule belong subterm delta addit automaton sink state q obviou transit complet speci automaton ffl again use boolean b record whether rewrit step occur state post state post upl q transit rule post transit rule are type rule form gamma q type rule form x gamma q gamma q l type rule form q rule delta x al gamma q l type rule form type a rule form inria regular viewpoint paprocess type b rule form nal state a lemma epa post u epa u p t u al proof rst prove direct induct length k rewrit post distinguish four case use type type rule take sati requir k last rewrit step use type rule rewrit form z true ind hyp u p st t u exist type rule entail t take requir k last rewrit step use type rule t type rule appli top two rewrit sequenc gamma q ind hyp give us last rule type rule b t take requir otherwis last rule type b rule q nal state a entail termin process henc t again take requir k last rewrit step use type rule case similar actual simpler previou one direct assum u p accompani condit ac proceed induct length transit sequenc ie p follow structur induct u ve case ac ensur use type rule show post like previou case type rule sequenc form x t ac read subterm delta take q rr n dlugiez phschnoebelen st l one q must exist let b fals ioe ind hyp give us post must type rule q use show post combin u addit rewrit a gamma q l u delta use a al l u delta dene b accord p ind hyp entail that post two case l q nal state a post type b rule q use l type rule use similar previou case actual simpler let nal state post state q q l nal state al post accept term ioe u u accept al ioe belong post l theorem regular l regular subset epa post l regular furthermor automaton al recogn l possibl construct in polynomi time automaton post recogn post l al k state pre need okjdeltaj state proof obviou previou construct result relat pre t resp post t natur question ask relat j ie ft u j ug recogniz sens relev notion recogniz relat problem link ground tree transduc gtt short detail sinc shown relat induc ground rewrit system recogniz gtt tri extend result pa case rule ground rewrit rule simpl left hand side notion prex rewrit unfortun prex rewrit entail stabl context natur extens gtt could handl condit rule immedi abl recogn recurs enumer relat modelcheck pa process section show simpl approach modelcheck problem solv mayb see one immedi applic main regular theorem inria regular viewpoint paprocess consid set p atom proposit mod p denot set pa process p hold consid proposit p mod p regular treelanguag thu p could make alabel step right nowj ither least two occur x insid tj ither exactli one occur x nonfrozen positionj logic ef follow syntax semant thu ex read iit possibl reach one step state st j ef read iit possibl reach via sequenc step state st j denit modelcheck problem ef pa input given delta given epa given ef answer ye ioe dene mod def mod mod theorem ef formula mod regular tree languag given treeautomata ap s recogn regular set mod p tree automaton a recogn mod built eoeectiv proof corollari regular theorem give us decis procedur modelcheck problem build automaton mod check whether accept t estim complex approach term jj n alt dene n alt number altern negat tempor connect rr n theorem modelcheck automaton mod comput time jjjdeltaj ojjjdeltaj proof assum automata mod p s size bound a constant construct automaton mod appli usual automatatheoret construct intersect union complement regular tree languag invok regular theorem pre pre construct polynomi except complement polynomi construct would ojj size result automaton negat involv complement caus nonelementari blowup negat push inward except cannot cross tempor connect ef ex one exponenti blowup determin level altern repeat n alt time yield given bound number state henc overal complex procedur describ mayb nonelementari today known lower bound pspacehard observ comput represent mod gener tell whether given belong it observ also result allow modelcheck approch base combin forward backward method while theorem reli standard backward approach reachabl constraint section consid reachabl constraint let c act word languag action name write c reach constraint c extend notat write pre cl post obviou mean observ that even assum c regular problem tell whether c ie whether post ct empti undecid pa algebra prove reduct intersect problem contextfre languag follow let sigma alphabet distinguish symbol use two copi a everi letter sigma fg contextfre languag dene bpa pa without k is contextfre languag l resp l sigma dene pa rule x w w rule overlap introduc regular hold ioe undecid inria regular viewpoint paprocess section give suoecient condit c problem becom decid and comput cconstrain pre regular tree languag recal shue w k w two nite word set word one obtain interleav w w arbitari way denit ffl g nite seqdecomposit c ioe w w act g nite paraldecomposit c ioe w w crucial point denit seqdecomposit c must appli possibl way split word c even appli decomposit ww one c s and one c contain observ formal dioeerenc seqdecomposit paraldecomposit come fact w k w set shue w w usual contain sever element denit famili cng languag act nite decomposit system ioe everi c c admit seqdecomposit paraldecomposit use c s c c act admit nite decomposit even regular case consid ab assum nite paraldecomposit everi k shue k b k c henc must must exist shue w k b k w c possibl henc k s distinct contradict nite simpl exampl nite decomposit system ie set singleton languag word shorter k paraldecomposit fwg ffw gg w s subword w and w correspond remaind exampl show decompos compos pair c appear decomposit member c gener linear weight function form w def n set c k belong nite decomposit system assum c nite decomposit system shall show theorem regular regular l epa c c pre cl post cl regular tree languag subword w w obtain eras letter w posit rr n ingredi post c build post c way post state contain new c c compon state post c state post c upl q transit rule post c transit rule are type rule form gamma q type rule form x gamma q type rule form q rule delta x al appear seqdecomposit c type rule form appear paraldecomposit c type a rule form type b rule form state a st c c appear seqdecomposit c lemma epa post c u epa w c u w t u al proof post c post equip new compon proof follow exactli line proof lemma refer earlier proof explain deal new c compon direct lemma new observ case are take k last rewrit step use type rule use fact w k last rewrit step use type rule use fact cc c k last rewrit step use type rule use fact w c entail exist least one shu w w w st w c inria regular viewpoint paprocess direct lemma new observ case are type rule allow cs contain sequenc form x t must c seqdecomposit c st c w type rule c use type rule need otherwis pair c seq decomposit c st w pair give us type b rule need shue w w therefor paraldecomposit c st w pair give us type rule need let nal state post c q nal state al post c accept term ioe post ct the set nal state easili adapt recogn post ingredi pre c construct pre addit c c compon state pre state pre tupl q nal state q nal state al c constraint satisfi transit rule pre transit rule pre dene follow type rule form gamma q type a rule form x gamma q q l true c st exist u u a gamma q l type b rule form x gamma q type rule form appear paraldecomposit c rr n type a rule form nal state a c c appear seqdecomposit c type b rule form lemma epa pre c u epa u u a proof pre c pre equip new compon proof follow exactli line proof lemma refer earlier proof explain deal new c compon x condit c compon exist rule type b agre statement lemma pre type rule c also ind hyp give type b case w c type case use c either rst case appli induct hypothesi c c contain use type b rule second case must seqdecomposit c w use ind hyp type rule case similar previou one direct use pair accout w paraldecomposit c direct use crucial fact whenev shu w w w particular w c must contain applic modelcheck result let us appli modelcheck method section extend ef logic allow hci formula decompos c semant given mod hci def inria regular viewpoint paprocess decompos c quit gener condit exclud undecid situat would exist gener regular case immedi includ extens propos mayb observ possibl combin decompos constraint alreadi modelcheck algorithm c c c decompos deal hc directli ie without construct nite decomposit system contain c c obviou extend construct pre c pre cc sever c compon dealt simultan also deal hc c i hcc i directli sinc pre c c l pre cc l pre cl pre c l pre cpre c l c c l structur equival pa term section investig congruenc j induc pa term follow equat choic equat motiv fact sever recent work pa and extens consid process upto congruenc techniqu could deal variant use explain denit pa compar denit use mayc mayb consid transit system term epa term mayr consid transit system seen equival class modulo j epa term write t j set ft g transit relat use mayr coincid transit relat dene follow speak ipaj j mean transit system one obtain jclass term state transit given approach gener sens dene approach framework contrast one reason modulo j right start one lose inform requir revert approach exampl reachabl problem ido u j theorem ask precis form u reachabl problem solv mayc ask u modulo j framework state igiven u rr n dlugiez phschnoebelen see below framework imposs state problem but cours rst motiv framework allow two regular theorem rest section devot applic treeautomata approach problem paj aim exhaust rather simpli want show framework allow solv not state problem framework variant structur equival regular associativitycommut axiom satis k call permut axiom write p u permut equival axiom dene neutral element k call simplic axiom write u u simplic t ie u obtain appli simplic axiom left right posit t note wellfound partial order write gamma simplic normal form t written t uniqu u one obtain simplifi much possibl no permut allow axiom classic rewrit extens studi bn j coincid p permut axiom commut simplic axiom let us decompos question j question p question start p lemma t set t p ug regular tree languag automaton t p need mm state proof sketch t p nite set m element the exponenti blowup cannot avoid simplic axiom nice properti allow nite mani combin behav better wrt regular write l fu j lemma regular l set l l l regular tree languag automaton al recogn l build automata size ojaj three languag polynomi time proof l u l ioe u l addit s simpli out henc automaton accept l obtain al ad new state q subterm simpli also add rule gamma q q k q gamma q inria regular viewpoint paprocess accept subterm and q al rule qq gamma q q q gamma q simul simplic simpli simpl way obtain automaton l synchron automaton al accept l complet automaton recogn term built k onli two state q q two automata synchron gamma q q gamma q simul simplic nullabl term addit rule name whenev rule q add rule q add symmetr rule q instead k routin induct length deriv show gamma q q ioe l gamma q l simplest way see regular note l note regular l l p l j necessarili regular gd howev proposit t set t j regular tree languag automaton need mm state proof combin lemma structur equival behaviour see term modulo j modifi observ behaviour follow standard result proposit j bisimul relat ie j u proof standard tediou shall give proof sketch proof singl equat l r denit j show set floe roeg instanc equat bisimul relat complet proof take better part p book mil equat dealt similarli note isnil compat j remain prove gener congruenc bisimul standard so rule pa obey format ensur behaviour term depend behaviour subterm syntax may dene new transit relat term u u amount it j simplest way translat rr n problem paj problem set term adopt usual abbrevi proposit w act w proof induct length w use proposit reachabl modulo j easi prove decid reachabl problem modulo j post t recal u j post t regular treelanguag one build eoeectiv henc decid whether nonempti intersect give us simpl algorithm use exponenti time becaus size u j actual better result theorem reachabl problem paj igiven u np proof npeasi straightforward automata framework u st note ju j juj simpl algorithm comput u guess nondeterminist permut u build automata u post t automata polynomials remain check whether nonempti intersect know whether requir u exist corollari reachabl problem paj npcomplet proof nphard reachabl bpp prove esp proof idea reus framework reduc sat reachabl paj consid instanc p sat p variabl n claus everi gammag dene follow r ij note j r rule pick valuat v x r s r rule use v list satis claus r rule discard unnecessari element final applic possibl eg first prove mayc inria regular viewpoint paprocess proposit bounded problem paj decid polynomialtim proof t j reach nite number state paj ioe reach nite number nonj term pa permut axiom allow nite mani variant given term post l contain nite number nonj process ioe post l nite modelcheck modulo j modelcheck problem solv mayb consid ef logic paj translat framework amount interpret tempor connect term instead write mod j interpret modulo j mod addit consid atom proposit p compat j ie j u impli u modelcheck paj simpl modelcheck pa lemma efformula mod j proof structur induct use prop closur wrt j hci case immedi corollari use exactli approach modelcheck pa without j conclus paper show treeautomata techniqu power tool analysi pa process algebra main result two gener regular theorem numer immedi applic includ modelcheck pa extend ef logic treeautomata viewpoint mani advantag give simpler gener proof help understand problem solv ptime other nptime etc quit versatil mani variant pa attack approach acknowledg thank h comon r mayr numer suggest remark question work rr n dlugiez phschnoebelen r decid bisimul equival process gener contextfre languag innit result verifi innit state process sequenti parallel composit reachabl analysi pushdown auto mata applic modelcheck rewrit that regular structur prex rewrit tree automata applic decid subset cc decid decomposit process algebra applic tree automata rewrit theori ground rewrit system decid petri net direct symbol approach model check pushdown system extend abstract reachabl problem ground tr extens model recursiveparallel program formal framework analysi recurs parallel program combin petri net paprocess model check paprocess tableaux method paprocess commun concurr tr decid bisimul equival process gener contextfre languag process algebra regular structur prefix rewrit petri net commut contextfre grammar basic parallel process tree languag rewrit effici algorithm pre post interprocedur parallel flow graph automatatheoret approach branchingtim model check commun concurr formal framework analysi recursiveparallel program combin petri net paprocess bisimul equivanl decid norm process algebra decid firstord transit logic paprocess decid bisimulationlik equival finitest process reachabl problem ground tr extens reachabl analysi pushdown automata parallel sequenti process infinit result model check paprocess automatatheoret approach interprocedur dataflow analysi regular decid norm pa process polynomi time tableau method paprocess ctr ahm bouajjani javier esparza tayssir touili gener approach static analysi concurr program procedur acm sigplan notic v n p januari vineet kahlon aarti gupta analysi interact pushdown system acm sigplan notic v n januari ann labrou philipp schnoebelen automatatheoret approach reachabl analysi rpp system nordic journal comput v n p summer marku mllerolm precis interprocedur depend analysi parallel program theoret comput scienc v n p januari antonn kuera philipp schnoebelen gener approach compar infinitest system finitest specif theoret comput scienc v n p august deni lugiez philipp schnoebelen decid firstord transit logic paprocess inform comput v n p novemb kamal lodaya regular viewpoint process algebra acta cybernetica v n p januari