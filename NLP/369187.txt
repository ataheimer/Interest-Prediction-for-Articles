t optim sequenc hybrid round a sequenc hybrid sbh method reconstruct sequenc small finit alphabet collect probe substr substr queri arrang array sbh chip combinatori method use construct sequenc collect probe technolog constraint limit number substr queri place singl sbh chip develop idea margar skiena propos algorithm use seri small sbh chip sequenc long string number probe use match inform theoret lower bound constant factor b introduct consid follow problem let alphabet letter given string drawn uniformli random n abil ask queri type is x substr s minimum set question one ask high probabl one reconstruct s problem abstract problem occur sequenc dna molecul dna strand seen sequenc drawn four letter alphabet nucleotid fa c g tg sequenc hybrid sbh bain smith drmanac et al lysov et al propos altern tradit gilbertsang method sequenc gel electrophoresi survey chetverin cramer pevzner lipshutz give overview technolog algorithm aspect method method appli complementari watsoncrick base pair dna molecul given singl strand dna molecul hybrid complement strand sbh base use chip fabric use photolithograph techniqu activ area chip structur matrix region assign specic oligonucleotid biochem attach chip surfac solut uoresc tag target dna fragment expos chip fragment hybrid complementari fragment chip hybrid fragment identi use uoresc detector hybrid or lack thereof determin whether fragment substr target string formul assum hybrid chip give us answer ternari queri whether string occur occur occur onc classic sequenc chip design cm contain singl strand oligonucleotid xed length m pevzner algorithm pevzner reconstruct use classic sequenc chip interpret result sequenc experi subgraph debruijn graph eulerian path correspond possibl sequenc reconstruct therefor uniqu unless eulerian path uniqu exampl found show order uniqu reconstruct member n use classic sequenc chip cm need greater nsee skiena sundaram pevzner et al show experiment classic c chip contain oligonucleotid suce reconstruct nucleotid sequenc case dyer et al arratia et al shown independ cm eectiv random string length n need chosen greater log n word constant probabl reconstruct string length n drawn uniformli random n use classic hybrid chip chip must contain least substr compar inform theoret lower bound number ternari queri need distinguish n element n varieti dierent method suggest overcom neg result classic sbh chip use assumpt univers dna base synthes preparata et al preparata et al preparata upfal give scheme size chip optim ie on broud et al suggest gener posit inform along hybrid inform psbh psbh analyz algorithm hannenh et al hannenh et al show nphard gener problem give ecient algorithm posit inform constant model analyz bendor et al bendor et al drmanac et al suggest sequenc larg sequenc obtain spectra mani overlap fragment model analyz algorithm arratia et al give bound probabl uniqu reconstruct shamir tsur recent improv analysi arratia et al furthermor gave algorithm case fals neg error occur hybrid sequenc hybrid round interact sequenc hybrid rst consid margar skiena assumpt sequenc queri done adapt result one hybrid round known new chip construct origin paper margar skiena give number upper lower bound number round need depend number probe allow round among result algorithm reconstruct sequenc high probabl use olog n chip contain on queri main result paper improv result paper written isbh skiena sundaram show singl queri could ask round nround necessari n round sucient string reconstruct kruglyak kruglyak gave algorithm worst case perform guarante show olog n round sucient queri place chip round follow theorem main result paper theorem high probabl string drawn uniformli random n reconstruct sequenti use seven hybrid chip contain on substr queri notic result optim number queri inform theoret sens constant multipl algorithm proce follow manner initi step ask substr queri correspond classic sbh chip construct debruijn graph way suggest pevzner proceed ask target queri order unravel string main result paper mathemat although may eventu practic relev sequenc chip similar classic chip alreadi product hyseq inc hold sever patent procedur drmanac crkvenjakov chip use success denovo sequenc drmanac et al sequenc ing sequenc unknown given mani organ sequenc anoth problem practic import resequenc hybrid drmanac et al peer shamir problem templat sequenc known goal sequenc determin specic mutat variant sequenc machin produc oligonucleotid array use inkjet printer technolog pioneer blanchard et al current manufactur agil technolog technolog may prove particularli use interact sequenc hybrid review dierent technolog dna array manufactur see blanchard schena relev technolog includ aymetrix type array lockhart et al fodor et al southern array maker develop oxford gene technolog southern note technolog constraint need consid practic implement method develop paper particular realist case fals posit neg error occur experi need consid organ paper follow next section give overview previou work motiv algorithm give simpli version it section give complet algorithm verifi correct section prove complex result section demonstr comput experi ctg figur debruijngraph construct substr length agc gct tgc ctg gca cat one occur onc motiv basic algorithm debruijn graph section review debruijn graph construct rst consid pevzner unknown target string given answer ternari queri string r length m whether r occur s onc all construct associ edgelabel digraph follow manner vertex set consist edg x g case edg label x occur x occur s follow call debruijn graph s figur show construct debruijn graph also label node node x label in outedg label one inedg one outedg label label otherwis let x denot label nodeedg x note uniqu path substr x k name path start x end x k m x travers edg x x g denot path px refer path correspond x special case k refer nodeedg correspond x pevzner show correspond eulerian path graph dene eulerian path graph walk travers edg label exactli edg label least twice graph figur tell origin string agctgcat gc gc gca gc gca gcat gc gca figur exampl map px ctg figur debruijngraph construct substr length agc gct cgc gcg tgc ctg gca cat one occur onc debruijn graph may howev one eulerian path case construct string ambigu see figur simpli algorithm algorithm proce construct debruijn graph substr xed length m use inform graph construct set substr queri enabl us determin substr length number larger m iter process notic probabl path increas m ie attempt elong string correspond node debruijn graph motiv algorithm let us look ambigu elong process notic node x debruijn graph label string correspond in outedg occur s elong string correspond inedg x henc unambigu determin append last charact string correspond outedg exampl graph tagt know string catagt occur s howev node x one in outedg need pair inedg outedg atac figur node two in outedg graph figur tell two string cataca catacg gacaca gacacg occur one determin substr length six would ask substr queri string central question remaind paper determin condit number queri gener way larg edg graph label would uniqu elong determin elong string catac k charact would sucient determin whether catac elong cataca catacg determin elong ataca atacg charact howev catac elong catacg atacg occur two time atacg two elong length k cannot determin elong catac see determin elong particular edg e k charact sucient determin path e either length k shorter end edg multipl one motiv denit cluster collect node edg label eulerian path pass node edg label determin string am biguou set cluster graph set ambigu part graph denit cluster contain x clx maxim connect subgraph contain x node edg task determin thought determin eulerian path start node end node notic intern node edg label uniqu occurr s therefor uniqu elong assum know node start node end node reconstruct determin path start node edg label determin continu eulerian path edg uniqu elong either anoth edg label end node motiv follow algorithm reconstruct s let c posit constant q set queri place dna chip algorithm step classic sbh chip ne ask queri q construct step resolv ambigu let c c choos node x c let c clx c let q set string g step reconstruct debruijn graph answer queri q potenti pitfal let us look complic may face analysi algorithm cycl debruijn graph cannot determin whether given string pass cycl past add queri possibl string may caus us ask larg number queri cycl exampl figur loop aaa edg aaa aac label cannot determin graph aaaa figur exampl cluster along edg cluster node edg label two string taaaca taaact taaaaca taaaact caaaca caaact caaaaca caaaact occur s algorithm add queri taaaa caaaa taaaca taaact caaaca taaaca aaaaca aaaact edg aaaa occur graph rst determin whether taaaa caaaa occur determin occurr taaaaca taaaact caaaaca taaaact string aaaaca aaaact occur s cluster contain cycl number queri gener algorithm grow number inedg time number outedg cluster cluster contain cycl may abl determin often given path travers cycl contain multipl cycl hold true one them number queri gener algorithm may therefor grow exponenti number cycl cluster notic occurr string correspond node graph highli correl occurr string correspond neighbor interdepend make algorithm dicult analyz complex cluster requir larg number queri reason probabl occur averag number queri gener algorithm may fact larg modi algorithm modifi previou algorithm make limit number queri initi given node graph use two round queri may henc abl determin s show high probabl seven round sucient use follow modic step notic also modi version assum prior knowledg start end node add queri start node cluster termin node let k time let q set string ask queri q construct correct algorithm let us clarifi statement theorem denit say event occur high probabl whp occur probabl o n lemma number substr queri gener algorithm satisfi condit theorem optim inform theoret sens constant multipl proof n string length n high probabl sequenc string must abl distinguish string possibl answer ternari queri n algorithm gener o queri verifi algorithm correct ie whp reconstruct s lemma a singl iter step allow us construct b appli step whp reconstruct s proof a substr x length add queri possibl elong either length k x string multipl one case elong x determin uniqu elong y b follow result arratia et al dyer et al whp debruijn graph random n complex analysi proceed estim expect number queri iter main goal section prove follow lemma lemma expect number queri q gener singl iter step on start dene normal node section show queri gener origin normal node form tree section bound number tree section consid relationship tree substr s section summar upper bound expect number queri gener origin normal string section show rare node normal henc prove lemma final section show concentr expect number queri normal substr denit everi node x dene subgraph l x edg vertex set set edg vertic reachabl x path x g say x l x normal l x tree contain end substr p maxim map l x occur disjointli s notic denit normal refer substr s ie node normal depend string s exampl figur l taa graph shown except node caa edg caaa l taa normal sinc contain cycl figur show laac count number tree bound expect number queri q whose initi string x l x normal notic case algorithm step gener one queri initi string x everi node l x x ie collect fy substr relat aaca aca act figur exampl figur consid laac normal form aacaaact denot string normal form aacaact sinc two string overlap children also notic by denit l x normal contain cycl must therefor tree denit say ari tree each node children b i ltree b branch node node one child singl child node l leav children node consid order make distinct two children node base order count expect number queri whose initi string x count number dierent b i ltree section estim probabl l x tree lemma number distinct b i ltree proof number tree b branch node l leav most k sinc less number ari tree size k see knuth ex insert intern nonbranch node tree subdivid one exist edg tree ad new singl child root node choic put intern node done ik way outedg intern node chosen way tree string estim probabl l x take form tree multipli number queri gener l x take form avoid signic overcount number queri initi string x count number queri termin leaf node queri initi string x termin intern node count estim number queri gener l x take form one subtre dene partial order tree partial order ensur count queri intern node well denit subtre label tree incub subtre if node v either none children v occur note denit children given node must remov time rephras descend seri incub oper children given node appear oper purpos proof import thing note node leaf node incub subtre follow observ immedi denit normal denit lemma given collect c node normal l x predecessor z exist disjoint substr correspond node c particular collect leav incub subtre l x collect relat tree l x substr s follow definit give minim requir occurr string correspond node l x denit say collect c string string decomposit tree string correspond edg occur substr c string correspond edg incid root leav occur twice substr c string requir label tree dene label e root edg edg branch node leaf otherwis e le e b le show upper bound probabl l x take form four step first give algorithm return particular type string decomposit bound number possibl string decomposit gener algorithm xed tree go bound probabl contain disjointli given string decomposit s final show l x normal take form incub subtre contain disjointli substr form one string decomposit gener algorithm let us x node x x given b xed integ b l furthermor let us dene map subgraph complet debruijn graph name root node x let us name node graph follow notic denit b i ltree node children make distinct two base preden order children therefor talk k th child node k number possibl greater number xs children z k th child node name edg k th letter alphabet follow algorithm gener string decomposit algorithm label use string requir label def preorder node t initi c empti collect e le let v lowest order node posit label outedg e choos v nonleaf choos e one outedg v append charact correspond e add collect c return c rst upper bound number string decomposit gener algorithm lemma number possibl string decomposit gener algorithm bound r i number intern nonbranch node r dene denit proof let us count number choic made algorithm let v branch node k sum label vs outedg algorithm arriv k time v whenev v chosen outer loop one vs outedg label get decreas one sinc inedg v label two arriv twice v inner loop rst time arriv v inner loop outedg v posit label one decreas second time arriv v inner loop may choos edg chosen befor last time arriv v outer loop choic edg travers time choic edg travers number choic clearli less arriv node singl child choic edg travers next number string decomposit therefor b set branch node inequ veri note label outedg node one child alway two except case root one child upper bound probabl string decomposit lemma c collect string gener algorithm probabl string c occur disjointli substr upper bound l r proof let set string lemma jdj l origin chosen string length furthermor append least r extra charact note probabl string length j occur n probabl string occur bound by xd jxj l xd jxj l r relat l x string s lemma incub subtre normal l x contain disjointli one collect gener algorithm proof base actual string show algorithm made construct collect disjoint substr s denit normal incub subtre l x l x normal e edg label k algorithm must contain least k disjoint substr correspond e outer loop algorithm henc alway choos substr disjoint previous chosen let correspond y inner loop make choic e base next charact s j onward s ie j k e chosen kth child v sinc l x normal end string occur l x choic child henc alway well dene sinc incub subtre l x choic never return edg termin leaf node number normal queri combin result lemma give follow lemma lemma probabl l x contain b i ltree incub subtre l i l lemma let larg enough e expect size set queri qn ad q correspond normal string x bound ne proof estim expect number queri multipli number node x probabl l x b incub subtre number leav l sum b notic l b get expect number queri q multipli number node sum possibl ks is number queri ad tree b multipli probabl tree possibl ks is number way choos initi node x ejqn x ne second inequ follow seri algebra manipul note k e k second equal well known ident geometr seri rst equal less well known observ dierenti ident geometr seri k time slomson shown on queri gener node x graph l x normal remain case show unlik l x normal use fact maximum number queri gener algorithm initi string correspond given node graph bound let us introduc terminolog denit say string core string correspond node node string substr x occur substr node string l x ie x k case l x normal end occur l x l x cycl string decomposit l x consist string nondisjoint s end occur l x x number queri contain string correspond end substr henc bound on depth l x bound k contain cycl period cycl must also bound k core x must therefor period k occur node string l x core x period less k call x lowperiod core string simplifi present also consid string period period less log ne lowperiod core string extens node string x appear disjointli core x occur twice s start posit j ji jj mk length node string current iter step condit may therefor rewritten ji jj olog n happen say core x selfrepetit count expect number queri q consid four case first count expect number queri stem string lowperiod core expect number elong string selfrepetit core given core lowperiod remaind string normal termin string occur l x count number queri q origin low period core string number node string core period k determin degre freedom outsid core k plu degre freedom insid core k therefor k k number extens lowperiod core node string henc log ne log nek on look number queri string origin node string whose core selfrepetit lowperiod expect number core selfrepetit lowperiod number place rst core start number place second core start rst core bound n olog n log ne log n expect number string selfrepetit core henc bound on log n expect number queri ad q case henc bound on use lemma shown lemma expect number queri gener step bound ne concentr expect use azuma inequ see alon spencer show high probabl step linear number queri lemma high probabl on queri ad q iter step proof view sequenc n independ random trial one charact want bound number queri may ad remov q chang one charact chang one charact may eect m ne log n string denot length node string current iter step seen rst choos posit charact chang queri string note length queri string c charact chang let r m r charact immedi preced follow c q queri string aect charact chang length q path q correspond must pass one node correspond substr length contain c particular charact chang occur jth posit q j q charact posit charact posit charact rst posit charact charact case string aect azuma equal log n put complet proof comput result choic k log ne previou section done eas present may chosen slightli larger decreas number round test practic method implement variant algorithm present stringent algorithm analyz closer origin algorithm step variant limit length queri largest l total number queri round limit on instead limit length xed k word step modi to line let q set string v l chosen larg possibl ask queri q tabl show number sbh chip use base pair gener randomli number queri round signicantli lower number round guarante worstcas perform guarante algorithm see initi use classic sbh chip contain oligonucleotid size dlog ne nish sequenc dna less n extra queri use singl chip exampl tabl show number sbh chip use sequenc arbitrarili chosen viru sequenc one exampl algorithm sequenc dna use classic chip contain string length log extra round n queri acknowledg author would like rravi magnu m halldorsson dan iel f gudbjartsson anonym refere review paper alan m friez support part nsf grant ccr bjarni v halldorsson support merck comput biolog chemistri program graduat fellowship merck compani foundat r probabilist method poisson process approxim sequenc repeat novel method nucleic acid sequenc determin complex posit sequenc hybrid paterson synthet dna array oligonucleotid array new concept possibl dna sequn determin hybrid strategi ecien larg scale sequenc probabl uniqu solut sequenc hybrid posit sequenc hybrid art comput program fundament algo rithm multistag sequenc hybrid express monitor hybrid highdens oligonucleotid array spectrum align ecient resequenc hybrid toward dnasequenc hybridiza tion improv chip sequenc hybrid journal biomolecular structur dynam optim reconstruct sequenc probe dna microarray larg scale sequenc hybrid reconstruct string substr journal comput biolog dna chip analyz sequenc hybrid oligonucleotid larg scale tr art comput program volum rd ed sequencingbyhybrid informationtheori bound toward dna sequenc chip reconstruct string substr round ctr steven skiena sagi snir restrict sbh ambigu via restrict enzym discret appli mathemat v n p april eran halperin shay halperin tzvika hartman ron shamir handl long target error sequenc hybrid proceed sixth annual intern confer comput biolog p april washington dc usa