t maximum edgedisjoint path problem bidirect tree a bidirect tree direct graph obtain undirect tree replac undirect edg two direct edg opposit direct given set direct path bidirect tree goal maximum edgedisjoint path problem select maximumcardin subset path select path edgedisjoint problem solv optim polynomi time bidirect tree constant degre apxhard bidirect tree arbitrari degre everi fix varepsilon polynomialtim varepsilonapproxim algorithm present b introduct research disjoint path problem graph long histori recent year edgedisjoint path problem brought focu attent advanc field commun network mani modern network architectur establish virtual circuit sender receiv order achiev guarante qualiti servic connect request accept network must alloc suffici resourc link along path sender receiv edgedisjoint path problem heart aris resourc alloc problem studi maximum edgedisjoint path problem medp bidirect tree network bidirect tree direct graph obtain undirect tree replac undirect edg two direct edg opposit direct bidirect tree network studi intens good model optic network pair unidirect fiber link adjac node medp bidirect tree defin follow given bidirect tree e set p simpl direct path goal find subset p path p edgedisjoint cardin p maxim say algorithm aeapproxim algorithm medp alway output subset edgedisjoint path whose cardin least aefract cardin optim solut conflict graph set direct path bidirect tree undirect graph vertex path edg two vertic correspond path intersect ie share edg one view medp bidirect tree maximum independ set problem conflict graph assum given tree root arbitrari node node v let pv denot parent v level node defin distanc root node root level zero say path touch node begin node pass node end node level path minimum level node touch uniqu node path whose level equal level path least common ancestor lca path preliminari version articl appear proceed th annual intern symposium algorithm comput isaac lnc page institut fr informatik tu munchen munchen germani erlebachintumd z idsia lugano corso elvezia lugano switzerland klausidsiach denot path begin node u end node v u v lca lcau v result first x determin complex medp bidirect tree medp solv optim polynomi time bidirect tree constant degre bidirect star max snphard bidirect tree arbitrari degre main result paper summar follow theorem theorem everi fix polynomialtim approxim algorithm maximum edgedisjoint path problem bidirect tree approxim ratio descript algorithm proof claim approxim ratio inde achiev appear x x discuss result gener weight version problem maximum path color problem relat work path color bidirect tree previou work bidirect tree focus path color problem given set direct path bidirect tree assign color path path receiv differ color share edg goal minim total number color use problem nphard even binari tree best known approxim algorithm use dle color l maximum load the load edg number path use edg thu lower bound optim solut previou algorithm use l color l color worst case special case alltoal path color shown optim number color equal maximum load multicommod flow tree garg et al studi integr multicommod flow problem undirect tree gener medp undirect tree show problem unit edg capac equival medp undirect tree solv optim polynomi time undirect tree edg capac one two prove problem max snphard also present approxim algorithm integr multicommod flow tree work consid demand order nonincreas level lca satisfi greedili approxim algorithm adapt medp bidirect tree also give approxim main idea lead improv approxim algorithm medp bidirect tree consid path lca simultan instead one one onlin algorithm medp tree medp also studi onlin scenario path given algorithm one one algorithm must accept reject path without knowledg futur request preemption allow easi see determinist algorithm competit ratio better diamet tree case awerbuch et al gave random algorithm competit ratio olog n undirect tree n node algorithm work also bidirect tree improv random algorithm competit ratio olog d undirect tree diamet given medp topolog medp studi arbitrari graph algorithm must solv rout problem select problem arbitrari direct graph edg medp recent shown nphard approxim within gamma approxim algorithm approxim ratio o p m known unweight case weight case better approxim ratio achiev restrict class graph class edgedisjoint path bidirect tree planar graph contain twodimension mesh network oapproxim algorithm devis complex result medp bidirect tree nphard gener prove reduct dmatch similar reduct use garg et al prove nphard integr multicommod flow undirect tree edg capac one two omit detail modif straightforward reduc bound variant dmatch problem reduct lreduct apreduct impli medp bidirect tree max snphard apx hard show polynomialtim approxim scheme problem nevertheless medp solv optim polynomi time input restrict certain way first consid case maximum degre given tree bound constant optim solut comput dynam program case process node tree order nonincreas level everi node v record possibl subset edgedisjoint path touch v parent note jsj maximum number path contain subtre root v accept addit path s node v process valu known children enumer possibl edgedisjoint subset path touch v subset look correspond valu store children v updat valu store v accordingli note polynomi mani subset consid node root node process optim solut easili construct anoth special case solv optim polynomi time case given bidirect tree star ie contain one node degre greater one medp bidirect star reduc maximum match problem bipartit graph follow first assum without loss gener everi given path use exactli two edg star path use one edg add new node star extend path one edg without chang set solut now observ everi path use exactli one edg direct toward center one edg direct away center star construct bipartit graph g includ vertex everi edg star ad edg two vertic u v g everi path use edg correspond u v two path edgedisjoint correspond edg g share endpoint set edgedisjoint path correspond match g maximum match g comput polynomi time latter result actual gener star spider spider bidirect tree one node the center degre greater two medp bidirect spider solv polynomi time use algorithm maximumweight bipartit match problem subroutin bipartit graph g construct path touch center spider weight edg e g specifi mani fewer path touch center spider accept path correspond e accept detail left reader approxim optim solut fix let instanc maximum edgedisjoint path problem given bidirect tree set t erlebach k jansen p direct path denot p arbitrari optim solut given instanc algorithm proce two pass first pass process node order nonincreas level ie bottomup assum algorithm process node v let p v denot subset path u w p intersect path accept algorithm previou node use edg reserv fix algorithm see below sake simplic assum without loss gener u otherwis could add addit child v path p v start end v make path start end new child instead everi path use exactli two edg incid v refer two edg top edg p say two path equival use two edg incid v ie top edg same set q path lca defin partit q differ equival class path natur way algorithm process node v tri determin path p v whether includ solut these path call accept these path call reject sometim howev algorithm cannot make decis right away case algorithm leav path intermedi state resolv later on possibl path intermedi state i undetermin path ii group defer path iii group exclus path iv group exclus path refer undetermin path path group exclus path group exclus path unresolv path path group defer path defer path statu unresolv path resolv later node first pass second pass algorithm proce topdown accept one path group defer path path intermedi state follow give explan regard possibl group path intermedi state first algorithm sometim leav singl path p p v undetermin state p v one equival class path accept path might caus algorithm miss chanc accept two path smaller level than v later on henc algorithm could best achiev approxim therefor instead accept reject path p v right away algorithm pick one make undetermin path path p v ani reject undetermin path accept reject later node second situat algorithm accept reject path right away sketch fig here follow pair opposit direct edg drawn undirect edg figur situat algorithm decid accept one sever intersect path p v defer decis one accept intersect path call group defer path path group defer path use edg incid v child c v figur edg c v the case defer path share edg v c symmetr furthermor defer path use also edg v c connect v child c c defer edgedisjoint path bidirect tree e c fig group defer path c c fig possibl configur group exclus path lefthand side situat exclus path block righthand side path use edg algorithm decid creat new group defer path mark edg c v reserv assur path accept node process v use edg leav edg v c children avail reserv edg indic dash arrow fig motiv introduc group defer path follow first reserv edg block one path smaller level could accept optim solut second matter path use edg pv v accept node process v path use one edg v c still least one defer path use particular edg v c algorithm pick defer path second pass process later node first pass algorithm actual treat group defer path like singl accept path use reserv edg defer path group exclus path sketch fig lefthand side group consist one path q call lower path contain subtre root child c v one path p call higher path lca v intersect q one two path accept algorithm pick wrong one choic caus algorithm accept one path optim solut would accept path one two addit path henc algorithm defer decis path accept later node now mark t erlebach k jansen fig group exclus path consist pair independ group exclus path top edg path q intersect p fix fix edg indic dot arrow figur obvious group exclus path follow properti properti e one path touch v use fix edg accept later node either p q still accept two path touch v accept later node block p q accept righthand side fig show two path accept later node block exclus path process later node algorithm tri avoid whenev possibl last type unresolv path sketch figur group exclus path consist set four path two accept precis first possibl group exclus path consist two independ group exclus path fig ie two group exclus path fix edg one group direct toward root fix edg group direct toward leav furthermor two group must either contain disjoint subtre as shown fig lower path contain disjoint subtre higher path intersect other pair independ group exclus path two fix edg fix edg group second possibl group exclus path consist group exclus path contain subtre root child v two path lca v intersect exclus path but fix edg way accept p p would block exclus path accept fig two edg mark fix name top edg higher exclus path intersect path lca v top edg lower exclus path intersect path lca v difficult show case analysi group exclus path follow properti properti e one path touch v use fix edg accept later node two path group exclus path still accept two path touch v use fix edg accept later node least one path group exclus path still accept process later node algorithm tri avoid accept two path touch v one path group exclus path accept edgedisjoint path bidirect tree vfig configur group exclus path invari x present detail algorithm proce first pass time show approxim ratio achiev algorithm order establish thi prove induct follow invari maintain invari hold first node process hold time addit node process node v call root process subtre node v alreadi process parent not invari a everi root v process subtre path subtre accept reject defer except one follow case occur i subtre contain one undetermin path path contain subtre accept reject defer edg subtre mark fix ii subtre contain one group exclus path path contain subtre accept reject defer edg mark fix subtre one group exclus path iii subtre contain one group exclus path path contain subtre accept reject defer edg mark fix subtre two group exclus path accept path edgedisjoint contain reserv edg everi unresolv path edgedisjoint accept path contain reserv edg everi defer path contain exactli one reserv edg reserv edg group defer path path belong defer path p intersect accept unresolv path q level q smaller p invari b let set path alreadi accept algorithm let f set path p whose lca yet process block accept path reserv edg fix edg let number group defer path contain process subtre let u set undetermin path let x union group exclus path group exclus path subset f u x edgedisjoint path satisfi follow condit a jp j b everi group exclus path contain one path group everi group exclus path contain two path group intuit set repres subset p contain edgedisjoint path could still accept algorithm follow properti algorithm accept least fraction path in addit t erlebach k jansen path alreadi accept output approxim optim solut observ invari satisfi initi easi see descript algorithm invari inde maintain throughout first pass special care must taken prove invari b maintain well second pass invari satisfi root node process joj time still one undetermin path which can need contain o therefor joj f g case one group exclus path from contain exactli one path one group exclus path from contain two edgedisjopint path undetermin path algorithm accept it group exclus path algorithm accept one arbitrarili group exclus path algorithm accept two edgedisjoint path arbitrarili algorithm accept least joj addit path way result set accept path satisfi ja and therefor jp j second pass algorithm process node tree revers order ie accord nondecreas level topdown node v lca least one group defer path accept one path group defer path path edgedisjoint previous accept path other alway done due definit group defer path henc number path accept algorithm increas second pass set path accept algorithm end satisfi ja theorem detail first pass assum algorithm process node v recal p v p set path lca v intersect previous accept path fix reserv edg let u v set undetermin path contain subtre root children v let x v set path group exclus path group exclus path contain subtre root children v follow explain algorithm process node v determin path p v u v x v accept reject defer left or put unresolv state observ given set path lca v problem determin maximumcardin subset edgedisjoint path equival solv medp star thu done polynomi time comput maximum match bipartit graph cf x whenev use express like comput maximum number edgedisjoint path p v follow impli comput carri employ reduct maximum match use follow properti bipartit graph fact maximum match bipartit graph g cardin impli vertic g everi edg incid least one vertic the properti hold arbitrari valu known konig theorem see eg book berg pp observ child current node v root process subtre can invari a contain one follow one undetermin path one group exclus path one group exclus path let k number children v undetermin path subtre let edgedisjoint path bidirect tree number children v group exclus path let number children v group exclus path use express subtre exclus path refer subtre root children v either group exclus path group exclus path note one main difficulti lie determin path u v accept reject k bound constant possibl combin accept reject path u v x v tri polynomi time k larg algorithm must proceed differ way order make suffici good decis exact threshold determin k consid larg and consequ runningtim algorithm depend constant let f u x denot quantiti defin x instant algorithm process node v let f u x denot respect quantiti right node v process furthermor denot v number path newli accept process v v number group defer path newli creat process v assum set f u x edgedisjoint path satisfi condit a b invari b v process everi singl case follow case analysi show construct set satisfi invari b v process obtain replac path remov path insert path requir particular must set edgedisjoint path satisfi f u x therefor path intersect newli accept path reserv edg newli creat group defer path must remov o note two path smaller level v path smaller level must use edg v pv pv v path reject algorithm must remov replac o new group exclus path group exclus path creat must contain one two path respect group condit b invari b maintain furthermor must ensur jo j smaller joj valu jajd increas v v process ie ja impli condit a invari b hold also v process ie case g algorithm tri combin accept reject unresolv path subtre root children v undetermin path two possibl accept reject path group exclus path two possibl accept lower path accept higher path group exclus path either four possibl in case pair independ group exclus path shown fig page accept lower higher path one group lower higher path group two relev possibl in case shown fig page accept lower higher path group exclus path contain group exclus path edgedisjoint path among remain two path note accept path group exclus path remain two path block path f two possibl henc need consid third possibl accept two edgedisjoint path group henc number possibl combin bound k o combin fl algorithm comput maximum number fl edgedisjoint path p v intersect u fl path u v x v tent accept combin let maximum u taken combin fl note cardin maximumcardin subset edgedisjoint path algorithm noth proce next node otherwis distinguish follow case case case one equival class path pick one them say p arbitrarili make undetermin path henc u reject path p v contain path p p p v replac p p obtain in order ensur j obvious invari satisfi p v one equival class path must edg e incid v share path p v as consequ konig theorem make p v group defer path reserv edg e contain one path intersect edg e either path p v path smaller level suffic remov path order obtain valid set get invari satisfi case one child c v undetermin path p lca w subtre possibl algorithm noth leav p undetermin state p v path p v must intersect p edg say edg u w the case intersect p edg w u symmetr algorithm pick arbitrari path q p v make fp qg group exclus path fix edg u w henc path p v reject must ensur contain p q order satisfi condit b invari b contain path p v u v properti e either q insert remov one path smaller level contain path p p v u v alreadi path replac p q invari satisfi case one child v group exclus path subtre path p v could combin path group exclus path obtain two edgedisjoint path assum must henc algorithm noth node v leav group exclus path intermedi state case observ k mani subcas case algorithm yield v contain one path remov path two path smaller level clearli suffici obtain valid set subcas therefor repeat argument everi relev subcas instead discuss case contain two path case subtre root child v contain group exclus path must path p v could combin two path x v form set three edgedisjoint path henc algorithm noth node v leav group exclus path unresolv state case two children v whose subtre contain group exclus path note case path p v could combin one exclus path subtre obtain set three edgedisjoint path edgedisjoint path bidirect tree e fig case pv contain two edgedisjoint path lefthand side case a fix edg e direct righthand side fix edg group exclus path point direct ie direct root leav algorithm accept lower path group exclus path higher path reject edg mark fix anymor three path must remov obtain valid set two path group exclus path contain o one path smaller level use edg v pv whose direct opposit direct formerli fix edg fix edg group exclus path point differ direct ie one direct toward root one toward leav group repres pair independ group exclus path algorithm creat new group exclus path note contain two path new group exclus path alreadi contain one path two group exclus path x v due condit b invari b therefor set invari satisfi case one child v group exclus path subtre one child v undetermin path subtre path p v must intersect undetermin path otherwis path p v could combin undetermin path exclus path obtain set three edgedisjoint path case two edgedisjoint path p v case situat must shown lefthand side fig two edgedisjoint path must intersect group exclus path way block exclus path accept cannot kind path p v algorithm accept lower path group exclus path undetermin path reject path mark fix anymor note combin two edgedisjoint path p v u v x v block least three four top edg path accept algorithm henc contain two path contain one path smaller level intersect path accept algorithm suffic remov three path obtain valid e e fig case b c fix edg e differ direct case path p v intersect edg e undetermin path case a direct e fix edg group exclus path see righthand side fig algorithm accept undetermin path lower path group exclus path path reject edg mark fix anymor contain two path p v use fix edg edg e one path block path accept algorithm becaus path must use edg v pv direct opposit direct e thu suffic remov three path obtain valid set case b direct e differ fix edg path intersect higher exclus path see lefthand side fig algorithm use x v p undetermin path togeth creat new group exclus path consist pair independ group exclus path path p v reject algorithm addit fix edg old group exclus path edg e mark fix note contain one path x v due condit b invari b contain undetermin path path p let contain path p p v replac path either p undetermin path one must possibl contain path p v u v contain path p use edg v pv direct given edg e replac p either p undetermin path one two must possibl contain path p v u v path use edg v pv direct given edg e add either p undetermin path o case invari satisfi particular jo case c direct e differ fix edg path p v intersect higher exclus path see righthand side fig algorithm accept undetermin path lower path group exclus path reject path mark fix anymor contain two path must contain least one two path accept algorithm path use top edg path accept algorithm contain one path smaller level intersect path accept algorithm suffic remov three path order obtain valid set edgedisjoint path bidirect tree epe pp c c c pp p c c c fig case pv contain two edgedisjoint path block exclus path case one child c v group exclus path subtre denot higher lower path group exclus path p q respect assum without loss gener fix edg e group exclus path direct toward root tree as shown fig note distinguish case regard maximum number edgedisjoint path p v case two edgedisjoint path p p p v must intersect exclus path way block accept see fig let p intersect p let p intersect q let c c child v p use edg c v v c let c c child v p use edg c v v c note c top edg p intersect p e let top edg q intersect p e contain two edgedisjoint path everi path p must either intersect edg e intersect edg e intersect p p the latter case possibl c c path p v intersect e use edg c v v c path p v intersect e use edg c v v c case p must use shown righthand side fig case a path p v intersect e use edg c v v c path p v intersect e use edg first assum path p v intersect either e e note exactli two equival class path p v case see fig lefthand side algorithm use group exclus path one repres two equival class path p v creat group exclus path path p v reject fix edg e group exclus path longer mark fix instead edg e e mark fix contain two path p v x v one must x v due condit b invari b replac path new group exclus path otherwis possibl remov path x v one addit path result set contain path p v x v one t erlebach k jansen path smaller level touch v path smaller level intersect fix edg new group exclus path properti e two path new group exclus path insert set obtain invari satisfi now assum path p p v intersect neither e e note abov must c c case p must use edg fig righthand side algorithm accept lower path group exclus path path p reject path edg mark fix anymor note combin two edgedisjoint path block least three four top edg path accept algorithm henc contain two path contain one path smaller level intersect path accept algorithm suffic remov three path obtain valid set case b least two equival class path p v intersect higher path group exclus path algorithm accept lower path group exclus path make path p v intersect higher path group defer path path p v x v reject edg mark fix anymor reserv edg group defer path top edg share path contain two path p v x v note one two path must x v due condit b invari b two path also block top edg lower path group exclus path henc cannot contain path smaller level intersect lower path contain one path smaller level intersect reserv edg newli defer path suffic remov three path obtain valid set case c one equival class path p v intersect higher path group exclus path least two equival class path p v intersect lower path group exclus path algorithm accept higher path group exclus path make path p v intersect lower path group defer path path reject edg mark fix anymor reserv edg group defer path top edg share path contain two path note one two path must x v due condit b invari b two path also block edg e henc cannot contain path smaller level intersect e contain one path smaller level intersect reserv edg newli defer path top edg higher path direct toward leav path must use edg pv v suffic remov three path obtain valid set case p v contain two edgedisjoint path let e edg incid v path p v use edg e case a least two differ equival class path algorithm make path p v new group defer path reserv edg e accept q lower path group exclus path path p reject edg subtre mark fix anymor contain two path p v x v path block two three top edg block algorithm fix edg e group exclus path edg e contain one path smaller level fig case a set two edgedisjoint path use four top edg left hand side case b one equival class path use edg e one class use edg e righthand side intersect path accept algorithm reserv edg new group defer path suffic remov three path obtain valid set case b e v c children c c v p v one equival class path path p intersect q algorithm accept p q path p v intersect q algorithm accept p arbitrari path p v case path p v x v reject edg subtre mark fix anymor assum contain two path p v x v show suffic remov three path obtain valid set algorithm accept p must also contain p path p v thu block least three four top edg path accept algorithm one path block path accept algorithm assum algorithm accept q observ two path must also use edg e e thu block two four top edg path accept algorithm e e direct contain one path smaller level intersect path accept algorithm path must use edg pv v p v one equival class path path p v x v block three four top edg path accept algorithm suffic remov one path smaller level o final consid case p v one equival class path e v c sinc edg e block path smaller level top edg q direct toward leav two path p v x v fact block least mani path smaller level three four top edg path accept algorithm case must two edg incid v path p v use least one two edg by konig theorem let e e two edg case a possibl set two edgedisjoint path p v use four edg incid v see lefthand side fig exampl algorithm pick two arbitrari edgedisjoint path p v accept them reject path p v contain two path p v remov two path suffici obtain valid set use top edg path accept algorithm cannot contain path intersect path accept algorithm follow let set path p v intersect path p v word path p p v p v contain path q edgedisjoint p note case a appli follow either path p v n use edg e use edg e must one fig case c configur two group defer path creat equival class path case b one equival class c path p v n use one equival class path p v n use edg e intersect path c see righthand side fig the case e e exchang symmetr furthermor note case one equival class c path p v n use edg e one equival class path p v n use edg e intersect path c satisfi condit case a algorithm pick path p c arbitrarili accept p make path use edg e intersect p group defer path reserv edg e path p v reject contain two path p v path must also use top edg p newli reserv edg thu remov two path suffici obtain valid set case c one equival class path p v n use one equival class path p v n use edg e case a appli algorithm make path p v n use e group defer path reserv edg e path p v n use e group defer path reserv edg e path p v reject note matter path smaller level accept algorithm later on still two path one two group newli defer path edgedisjoint path smaller level other otherwis case a would appli contain two path p v path use e e well remov two path suffici obtain valid set cannot contain path intersect reserv edg newli defer path case one child v undetermin path p subtre let p denot set path p v intersect p begin make simpl observ first p v must contain two edgedisjoint path henc must edg e incid v share path p v second impli maximum number edgedisjoint path p v two must two edg e e incid v everi path p v use least one two edg let lca undetermin path v let c child v whose subtre contain undetermin path possibl v undetermin path use edg v number subcas regard number equival class p v case a p v empti let p p denot set path p v intersect p edg v edg v respect note algorithm accept arbitrari path p p one equival class path creat new group defer path p otherwis undetermin path p reject edgedisjoint path bidirect tree v v v v v fig case v two children undetermin path subtre contain two path p v u v remov two path suffici block least mani path smaller level newli accept path newli reserv edg case b p v one equival class path algorithm accept arbitrari path p v undetermin path p path p v reject assum contain two path p v u v contain p must also contain path p v suffic remov two path obtain valid set contain p contain path p must also contain path p v intersect p two path block least three four top edg block algorithm suffic remov two path one path smaller level final contain neither p path p must contain two path p v intersect p differ top edg least one intersect also top edg path suffic remov three path obtain valid set case c p v one equival class path let e edg incid v share path p v algorithm accept undetermin path p creat new group defer path path path p v reject assum contain two path p v u v contain p must also contain path v suffic remov two path obtain valid set contain p contain path p must contain path p v intersect two path block least two three top edg block algorithm suffic remov two path one path smaller level final contain neither p path p must contain two path p v intersect p differ top edg again two path block least two three top edg block algorithm suffic remov three path obtain valid set case two children v undetermin path subtre denot undetermin path p q see fig everi path p v must intersect least one undetermin path addit two path p v intersect one undetermin path differ top edg least one must also intersect undetermin path let p p denot set path p v intersect p q respect note case a edgedisjoint path p p p v p intersect p top edg e intersect q p intersect q top edg e intersect p e e differ direct ie one direct toward root direct toward leav algorithm make p q p p group exclus path consist pair independ group exclus path reject path p v edg e e mark fix contain two path new group exclus path alreadi let otherwis possibl replac path path new group exclus path obtain case jo case b condit case a hold algorithm accept p q reject path p v contain two path p v u v contain p q suffic remov two path contain one p q say p must contain path p v intersect q two path block three four top edg block algorithm contain neither p q must contain two path p v least one two path intersect p q two path block least three four top edg block algorithm path intersect one p q must case one intersect p edg e one intersect q edg e e e direct contain one path smaller level intersect path accept algorithm e e differ direct condit case a appli case algorithm accept path reject path subtre mark fix anymor maximum number edgedisjoint path contain path p v u v x v furthermor contain two path f use edg v pv pv v two path could possibl block path accept algorithm henc valid set obtain delet path invari maintain case g case algorithm cannot tri possibl accept reject unresolv path polynomi time instead calcul four candid set edgedisjoint path choos largest them obtain two four set employ method remov path arbitrari set edgedisjoint path p v exclus path x v accept addit path remain s result set edgedisjoint path x v cardin jsj r number path remov s detail method proof present later lemma tool readi describ candid set subset path p v intersect undetermin path u v comput maximum number edgedisjoint path p v obtain take path k undetermin path mani addit edgedisjoint path x v possibl undetermin path least path group exclus path x v due properti e obtain remov r path m exclus path accept contain m exclus path accord lemma r m path remov obtain still contain k undetermin path addit js edgedisjoint path bidirect tree contain k undetermin path u v exclus path obtain first comput maximum number edgedisjoint path p v ad mani edgedisjoint path x v u v possibl js j m contain least path group exclus path x v due properti e obtain remov r path p v m exclus path accept way obtain accord lemma js j ms m algorithm accept path set maximum cardin reject path p v u v x v note v js j maxf g impli a v let number path p v contain v intersect least one k undetermin path observ v contain k gamma b undetermin path u v note maximum number edgedisjoint path p v maximum number edgedisjoint path p v use jo use jo upper bound jo v j lower bound cardin four set prove least one set satisfi jo suffic remov jo path order obtain valid set impli invari maintain jo follow case case ff v js use v js j bound ratio jo v v case v js use v js j bound ratio jo v v t erlebach k jansen c e fig set edgedisjoint path pv case ff get jo m shown jo hold subcas case complet descript case still explain method remov path order obtain respect method take arbitrari set edgedisjoint path p v remov path obtain set everi subtre exclus path touch one path motiv caus path group exclus path block two path intersect correspond subtre properti e similarli one path group exclus path accept must contain two path p v intersect correspond subtre properti e method proce follow consid graph g path vertic edg two path touch child v g maximum degre two consist collect chain cycl note everi edg g correspond child v touch two path s interest maxim part chain cycl consist entir edg correspond children v root subtre exclus path follow possibl part i cycl path cycl endpoint subtre exclus path ii chain path end one endpoint subtre exclus path intern path endpoint subtre exclus path iii chain path one end one endpoint subtre exclus path path endpoint subtre exclus path iv chain path endpoint subtre exclus path note everi maxim part cycl chain length number path least two contain least one edg method remov path proce follow cycl even length chain handl remov everi path s start second path chain cycl odd length handl remov two consecut path one place everi path rest cycl consid exampl depict fig node v eight children name h six c h root subtre exclus path indic edgedisjoint path bidirect tree ea gh ad dc hf fg cb fig graph g repres structur path exclam mark set edgedisjoint path p v sketch graph g obtain set shown fig label vertex g uw correspond path begin subtre root u end subtre root w respect iiv abov g contain cycl type i length three contain path f g gh hf chain type ii length three contain path ad dc cb accord rule given abov three path would remov s two path say f g gh cycl path dc chain length three easi see process alway ensur end contain subtre exclus path one path endpoint subtre henc due properti e e fill edgedisjoint exclus path contain exclus path lemma let v node m children exclus path let p v set edgedisjoint path let set path obtain remov path accord method describ abov let proof let number cycl type i let a length ith cycl denot number chain type ii b length b b denot number chain type iii c length c denot number chain type iv length d note number path contain union chain cycl s p furthermor consid number children exclus path cover chain cycl obtain p latter inequ ad two inequ obtain p take account p sigma iupsilon c da e a lemma follow exampl display fig suffici remov runningtim algorithm runningtim algorithm polynomi size input fix exponenti let bidirect tree e n node set p contain h direct path each path specifi endpoint given arbitrari claim approxim algorithm implement run time detail implement well experiment result report t erlebach k jansen note choos n still achiev runningtim polynomi size input result algorithm achiev approxim ratio therefor asymptot approxim ratio if optim solut contain mani path n must also larg approxim ratio get arbitrarili close gener sever gener medp first meaning consid weight version problem path certain weight goal maxim total weight accept path weight version medp still solv optim polynomi time bidirect star spider by reduct maximumweight match bipartit graph bidirect tree bound degre by minor modif dynam program procedur given x anoth gener medp maxpc problem given bidirect tree set p direct path number w color maximum path color maxpc problem comput subset p p w color p goal maxim cardin p maxpc problem equival find maximum induc w color subgraph conflict graph given path studi maxpc motiv admiss control problem allopt wdm wavelengthdivis multiplex network without wavelength convert everi wavelength color use establish set connect provid path correspond connect edgedisjoint number avail wavelength limit weight variant maxpc interest well maxpc weight maxpc solv optim polynomi time bidirect star use algorithm the weight version of capacit bmatch problem pp number w color maximum degre bidirect tree bound constant maxpc weight maxpc solv optim polynomi time dynam program similar procedur x maxpc nphard arbitrari w bidirect binari tree becaus path color nphard bidirect tree arbitrari degre becaus equival medp case order obtain approxim algorithm maxpc arbitrari number w color techniqu due awerbuch et al employ allow reduc problem w color medp small increas approxim ratio techniqu work maxpc arbitrari graph g discuss tree let instanc maxpc given bidirect tree set p path number w color approxim algorithm arbitrari number w color obtain approxim algorithm one color ie maximum edgedisjoint path problem run w copi give input ith copi bidirect tree set path accept first copi see fig output union w set path output copi path ith set assign color i shown algorithm obtain use techniqu approxim ratio ae approxim ratio ae even differ color associ differ network topolog ident network applic approxim ratio achiev even bound aew smaller gamma e gammaa w bound mention journal version view adapt similar result prove easili use fact select p k path algorithm input bidirect tree set p path number w color output disjoint subset p p w p each p edgedisjoint begin w begin fig reduct mani color one color run k copi still set least jp among remain path next copi accept least aefract number reduct work also weight case sinc optim algorithm medp bidirect tree bound degre approxim algorithm medp arbitrari bidirect tree employ techniqu obtain approxim algorithm bidirect tree bound degre ratio approxim maxpc arbitrari bidirect tree acknowledg author grate stefano leonardi point reduct maxpc arbitrari number color maxpc one color adi rosen inform improv analysi ratio obtain reduct case ident network color suppli preliminari draft journal version r competit non graph hypergraph special issu dens wavelength divis multiplex techniqu high capac multipl access commun system locat bank account optim float analyt studi exact approxim algorithm structur approxim class call schedul tree optim wavelength rout direct fiber tree optim greedi algorithm wavelength alloc direct tree network colour path direct symmetr tree applic wdm rout effici wavelength rout direct fiber tree maximum bound dimension match max snpcomplet approxim algorithm disjoint path problem approxim disjointpath problem use greedi algorithm pack integ program note optic rout tree improv access optic bandwidth tree effici access optic bandwidth comput complex improv approxim edgedisjoint path tr ctr thoma erlebach klau jansen implement approxim algorithm weight unweight edgedisjoint path bidirect tree journal experiment algorithm jea p r sai anand thoma erlebach alexand hall stamati stefanako call control k reject journal comput system scienc v n p decemb thoma erlebach klau jansen convers color algorithm maximum weight independ set algorithm discret appli mathemat v n p