t finitari fair a fair mathemat abstract multiprogram environ fair abstract detail admiss fair schedul distribut environ fair abstract rel speed processor argu standard definit fair often unnecessarili weak replac stronger yet still abstract notion finitari fair standard weak fair requir enabl transit postpon forev finitari weak fair requir everi comput system unknown bound k enabl transit postpon k consecut time gener finitari restrict finf given fair requir fi union ohgrregular safeti properti contain f adequaci propos abstract shown two way suppos prove program properti assumpt finitari fair multiprogram environ program satisfi properti fair finitest schedul distribut environ program satisfi properti choic lower upper bound speed or time processor benefit finitari fair twofold first proof rule verifi live properti concurr program simplifi wellfound induct natur number adequ prove termin finitari fair second fundament problem consensu faulti asynchron distribut environ solv assum finitari fair b introduct interleav semant provid eleg abstract way model concurr comput approach comput concurr system obtain let step one enabl process execut atom instruct interleav comput system satisfi properti properti hold implement program independ whether task multiprogram processor schedul polici use whether system distribut speed differ processor are furthermor interleav model simpl reduc concurr nondetermin preliminari version paper appear proceed ninth ieee symposium logic comput scienc pp leav bell laboratori lucent technolog z support part onr yip award n nsf career award ccr nsf grant ccr afosr contract f arpa grant nag contract dca interleav abstract adequ prove safeti properti system a safeti properti form someth bad never happen exampl mutual exclus howev usual suitabl prove guarante properti a guarante properti form someth good eventu happen exampl termin gener live properti tradit approach establish guarante properti requir fair comput instead comput satisfi properti intuit fair mean individu process ignor forev sinc reason implement system whether multiprogram multiprocess expect fair prove program satisfi properti assumpt fair follow properti hold possibl implement program theori specif verif use differ form fair well understood see exampl lp fra mp fair two major drawback first mathemat treatment fair verif semant complic requir higher ordin second fair weak yield suitabl model faulttoler distribut comput illustr celebr result fischer lynch paterson that standard fair assumpt process cannot reach agreement asynchron distribut system even one process fail quot paper flp result show problem distribut consensu cannot solv practic rather point need refin model distribut comput better reflect realist assumpt processor commun time propos one more refin model introduc notion finitari fair argu finitari fair suffici abstract captur possibl implement context multiprogram context distribut comput suffer either two aforement disadvantag associ standard notion fair justif finitari fair fair requir specifi subset f set possibl way schedul differ process program let us first consid multiprogram environ task schedul singl processor schedul meet given fair requir f program whose languag ie set comput contain f languag program safeti properti ie close limit furthermor schedul finitest languag regular thu captur finitest schedul implement f suffic consid countabl union regular safeti properti contain f sever popular definit f strong fair weak fair etc lp fra everi choic f obtain finitari version finf union regular safeti properti contain f case weak fair f show finitari version finf particularli intuit f prohibit schedul postpon task forev finf also prohibit schedul bound mani consecut time task postpon gener fair requir f regular live properti afk show finitari version finf then still live regular let us consid distribut environ task execut concurr differ processor here finitari fair correspond assumpt execut speed processor stay within certain unknown fix bound formal distribut system model transit system impos lower upper time bound transit hmp show time transit system satisfi properti choic lower upper time bound iff underli untim transit system satisfi properti finitari weak fair correspond theorem establish adequaci finitari fair distribut system addit provid method prove properti time system whose time known priori summar finitari fair abstract detail fair finitest schedul detail independ speed time processor bound drift parametr definit finitari fair also lend gener comput fair comput version comf fair assumpt f countabl union recurs safeti properti contain f multiprogram environ comput fair abstract detail fair comput schedul distribut environ comput fair abstract independ speed processor whose drift bound recurs function benefit finitari fair verif address problem verifi program satisfi properti finitari fair assumpt finf sinc finf regular specifi tempor logic thi howev obstacl verif finitest program show program satisfi temporallog specif finf iff satisfi specif f itself mean finitest program move finitari fair call chang verif algorithm gener program proof rule verifi live properti simplifi use finitari fair suppos wish prove program termin prove comput program termin one typic identifi rank variant function state program natur number rank decreas everi transit program method complet prove termin fair comput first may rank function decreas everi step standard complet verif rule rather reli rank function never increas guarante decreas eventu lp fra purpos one need identifi socal help transit caus rank function decreas second induct natur number complet prove fair termin one may resort induct ordin higher show prove termin program finitari weak fair reduc prove termin comput transform program transform program use new integ variabl unspecifi initi valu repres bound mani consecut time enabl transit may postpon sinc termin comput transform program prove use strictli decreas rank function natur number reason finitari fair conceptu simpler reason standard fair distribut consensu central problem faulttoler distribut comput consensu problem requir nonfaulti process distribut system agre common output valu psl although consensu cannot reach asynchron model one process fail flp practic consensu achiev distribut applic use construct like timeout suggest asynchron model standard fair assumpt use abstract studi faulttoler one propos solut problem consid unknowndelay model also call partial synchron model fix upper bound rel speed differ compon bound known priori dl aat rw asynchron model finitari fair assumpt abstract formul unknowndelay model particular prove asynchron model finitari fair assumpt admit waitfre solut consensu toler arbitrari number process failur show finitari fair substitut time assumpt solut aat inform motiv bound fair introduc gener definit finitari fair section applic sec tion begin motiv finitari version weak fair intuit concept bound fair consid follow simpl program p boolean variabl x integ variabl y initi repeat x x forev k repeat program p consist two process one transit transit l complement valu boolean variabl x transit r increment valu integ variabl y comput p infinit sequenc state start initi state everi state obtain predecessor appli one two transit purpos exampl schedul infinit word alphabet fl rg comput p correspond then schedul specifi order transit taken comput two process p execut either multiprogram distribut environ multiprogram multiprogram environ two process p schedul singl processor schedul set possibl schedul one typic requir schedul fair is shut one two process forev formal schedul fair iff contain infinit mani l transit infinit mani r transit schedul fair iff contain fair schedul set fair schedul restrict set comput program p correspond fair schedul p satisfi properti oe iff everi comput p whose schedul f satisfi oe instanc fair assumpt f program p satisfi properti is fair comput valu x true infinit mani state valu even infinit mani state note comput p correspond unfair schedul satisfi formula oe thu fair assumpt necessari establish program p satisfi properti oe fair requir f abstract admiss reallif schedul name schedul transit eventu nonprobabilist reallif schedul howev finitest therefor must put bound eventu consid instanc roundrobin schedul schedul transit l r altern roundrobin schedul replac fair assumpt f much stronger assumpt f contain two schedul lr rl f program p satisfi properti impli properti oe call f bound schedul gener posit integ k kbound schedul never schedul one transit k time row formal schedul kbound k iff contain neither subsequ l k r k schedul kbound iff contain kbound schedul similar definit consid jay let f k set kbound schedul assumpt f k kbounded is cours suffici abstract k easi build fair finitest schedul kbound let us say schedul bound iff kbound posit integ k schedul bound iff contain bound schedul clearli everi fair finitest schedul bound order prove properti program implement then suffic prove properti bound schedul set bound schedul restrict set comput program p correspond bound schedul p satisfi properti oe iff everi comput p whose schedul f satisfi oe call f finitari restrict fair assumpt f three observ f immedi first finitari version f proper subset f particular schedul fair unbound therefor belong second set f finitest schedul countabl union fair finitest schedul third f live properti sens stepwis schedul cannot paint corner afk everi finit word fl rg extend bound schedul sinc finitari fair assumpt f stronger fair assumpt f program may satisfi properti f consid exampl properti state predic powerof y true state iff valu power comput p satisfi oe must case transit l schedul powerof y hold follow everi posit integ k subsequ length greater k contain r transit schedul belong f and henc program p satisfi properti oe f hand easi construct fair schedul satisfi oe show p satisfi oe f multiprocess distribut environ two process p execut simultan two processor speed two processor may differ one typic requir nonfaulti processor transit consum finit amount time again fair requir f abstract admiss reallif processor name complet transit eventu again fair assumpt f unnecessarili weak assum transit l execut processor i requir least time l time u l two unknown ration number l u l u l l similarli transit r also note set f captur random schedul for given random schedul choos everi step one two transit equal probabl probabl result schedul f hand probabl result schedul f execut processor ii requir least time r time u r r irrespect size four time bound integ k k delta l u r k delta r u l comput correspond then kbound schedul follow finitari fair adequ abstract speedindepend processor note finitari fair adequ speed differ processor drift apart without bound case later gener notion finitari fair finitari fair set infinit word languag alphabet sigma subset set sigma infinit word sigma instanc set comput program languag alphabet program state regular languag regular iff recogn buchi automaton nondeterminist finitest machin whose accept condit modifi suitabl accept infinit word buc class regular languag robust mani altern character see tho overview theori regular languag particular set model formula proposit linear tempor logic ptl regular languag gpss set comput finitest program regular languag set f section fair schedul alphabet fl rg regular languag l r set f k kbound schedul everi k safeti live languag pi sigma let pref pi sigma set finit prefix word pi languag pi safeti properti or limitclos iff infinit word w finit prefix w pref pi w pi ad everi safeti properti pi fulli character pref pi sinc program execut step step set comput program safe languag alphabet program state safeti properti regular iff recogn buchi automaton without accept condit properti defin temporallog formula form p p past formula ptl safe regular everi k set f k section kbound schedul regular safeti properti languag pi live properti iff pref is everi finit word extend word pi set f section fair schedul regular live properti topolog character consid cantor topolog infinit word distanc two distinct infinit word w w largest nonneg integ w close set cantor topolog safeti properti dens set live properti regular languag lie first twoandahalf level borel hierarchi everi regular languag f oeffi g ffioe also tempor character first twoandahalf level borel hierarchi mp let p past formula ptl everi formula form p defin fset everi formula form p gset everi formula form p g ffi set everi formula form p f oe set exampl set f fair schedul g ffi set finitari restrict languag readi defin oper fin finitari restrict finpi languag pi countabl union regular safeti languag contain pi definit finitari restrict everi languag f oe also definit finpi pi follow theorem state properti oper fin theorem let pi pi languag fin monoton pi ae pi finpi ae finpi fin distribut intersect finpi proof first two follow immedi definit fin sinc pi pi contain pi well pi monoton prove inclus definit fin exist regular safeti properti class safeti properti close intersect class regular languag henc regular safeti properti sinc w follow proposit formal claim made exampl section also show finitari restrict regular languag necessarili regular proposit let f set fair schedul section let f set bound schedul f finitari restrict f that is neither regular safe proof recal f union regular safeti properti contain f f k regular safeti properti f k ae f henc consid regular safeti properti g contain f suppos g accept buchi automaton mg alphabet fl rg without loss gener assum everi state mg reachabl initi state everi state accept state sinc g safeti properti wish prove mg k state g f k suppos not word w mg accept w w contain consecut symbol type say l thu sinc mg k state follow first level borel hierarchi consist class f close set class g open set second level class g ffi countabl intersect open set class f oe countabl union close set third level class f oeffi countabl intersect f oe set class g ffioe countabl union g ffi set state mg path initi state label w l k cycl contain whose edg label l impli mg accept word w fair schedul contradict inclus g f observ that k schedul l k extend word f k henc impli f close limit is f safeti properti prove f regular suppos f regular closur properti regular languag set unbound fair schedul also regular know g nonempti it contain schedul properti regular languag follow g contain word w two finit word contain least one l one r symbol mean that contradict assumpt w f word although f countabl union safeti properti defin ptl f neither safeti properti defin ptl defin f tempor logic one would need infinitari disjunct gener oper fin preserv live also is may happen pref howev appli regular properti live preserv theorem pi regular languag pref proof sinc finpi pi pref monoton pref finpi pref pi prove inclus pref pi pref finpi suppos pi regular languag sigma consid w pref pi regular pi follow word w pi w finit word languag contain singl word w regular safe contain pi henc immedi lead follow corollari corollari pi regular live properti finpi live observ languag f regular live henc f also live pref mean execut program fair requir f like origin requir f satisfi finit number step oper fin illustr typic languag below k everi subsequ length k pg k everi subsequ k ps qg transit system standard fair finitari fair concurr program includ sharedmemori messagepass program model transit system mp transit system p tripl q set state finit set transit q q set initi state state q q assign valu program variabl transit binari relat state that is q state q transit let set successor q comput q transit system p infinit sequenc state q q transit q set comput p set pip safe languag q q finit pip regular transit enabl ith step comput q iff q nonempti taken ith step q iff q loss gener assum set program variabl contain everi transit boolean variabl enabl boolean variabl taken let schedul alphabet sigma finit set interpret boolean variabl is sigma power set set fenabl taken j tg given comput q p schedul oeq q project q schedul alphabet set schedul p then safeti properti sigma fair requir f transit system p languag finit schedul alphabet sigma fair requir restrict set allow comput program gener f regular live properti afk requir live ensur that execut program fair requir satisfi finit number step particular requir weak fair wf p set infinit word w everi transit infinit mani integ taken w transit enabl forev without taken specifi follow requir wf regular live requir strong fair sf p set infinit word w everi transit infinit mani step infinit mani step transit enabl infinit often without taken stronger requir weak fair sf ae wf specifi formula weakfair requir wf g ffi set strongfair requir sf neither g ffi f oe lie f oeffi g ffioe sinc set regular finitari restrict finwf finsf belong f oe live corollari next theorem a gener proposit show finitari restrict weak strong fair coincid appropri notion bound fair defin schedul weaklykbound nonneg integ k iff transit p cannot enabl k consecut step without taken is integ integ j enabl w j schedul weaklybound weaklykbound k similarli schedul w stronglykbound iff transit subsequ w contain k distinct posit enabl contain posit taken is integ schedul stronglybound stronglykbound k theorem let p transit system transit set weak strong fair requir wf sf infinit word w sigma w w finsf iff w stronglybound proof consid weak fair set weaklykbound schedul fix k defin formula wf stand disjunct takenen follow set weaklyk bound schedul safe regular k thu everi weaklybound schedul consid regular safeti properti g contain wf suppos g accept buchi automaton mg alphabet sigma without loss gener assum everi state mg reachabl initi state everi path mg accept path suffic prove mg k state everi schedul g weaklykbound suppos not let us say symbol sigma weaklyunfair transit contain enabl contain taken assumpt word w accept mg transit w contain k consecut symbol weaklyunfair sinc mg state follow cycl mg whose edg label symbol weaklyunfair impli mg accept schedul weaklyfair contradict inclus g wf observ exampl program p section rg proposit enabledl true everi state fair requir f equal wf sf impli corollari p transit system least two transit finwf finsf neither regular safe comput q transit system p fair respect fair requir f write pi f p set fair comput p specif phi transit system p set infinit word alphabet q transit system p satisfi specif phi fair requir f iff pi f p phi prove p satisfi phi fair assumpt f p satisfi phi implement f prove p satisfi phi finitari restrict finf p satisfi phi finitest implement f section show prove latter conceptu simpler prove former time transit system time finitari fair standard model realtim system place lower upper time bound durat delay hmp mmt sinc exact valu time bound often known priori desir design program work possibl choic time bound long realiz timingbas model unknown delay differ from often appropri than asynchron model with standard fair dl aat rw show unknowndelay model equival asynchron model finitari fair realtim program model time transit system hmp time transit system p u consist transit system two function u set transit set q posit ration number function associ transit lower bound function u associ upper bound u interleav semant transit system extend time transit system label everi state comput realvalu time stamp time sequenc infinit nondecreas unbound sequenc real number consist given comput q underli transit system p requir transit enabl continu least time taken must stay enabl continu longer time u without taken note transit enabl state q n n j taken state q n continu enabl then time sequenc consist comput q iff everi transit lower bound taken q j step taken q upper bound enabl q k step k k j taken q k step k time comput q t time transit system p u consist comput q p togeth consist time sequenc t first compon time comput p u untim comput p u write pi u p set untim comput p u gener pi u p strict subset pip is time inform u play role fair name role restrict admiss interleav enabl transit q finit then like pip pi u p also regular ad but necessarili safe time comput requir check system satisfi specif refer time untim comput suffic check system satisfi untim specif phi time transit system p u satisfi specif phi iff pi u p unknowndelay model know bound function u rather wish prove transit system p satisfi specif phi possibl choic bound function is wish prove union u pi u p contain phi follow theorem show order verifi system unknowndelay model suffic verifi system finitari weak fair is union u pi u p set pi finwf p theorem let p transit system set transit let wf weak fair requir p let q comput p q pi finwf p iff function u q q pi u p proof consid weaklybound comput q pi finwf p theorem nonneg integ k schedul correspond q weaklykbound let bound function defin consid time sequenc increas everi step clear lower bound requir trivial satisfi sinc q weaklykbound transit enabl k consecut step and henc k taken thu consist requir satisfi q t time comput p u impli prove convers suppos q pi u p choic u let time sequenc q t time comput p u let nonzero minimum lower bound u finit maximum upper bound u let number transit n let k integ k nu claim schedul correspond q weaklykbound suppos not transit enabl taken state q everi step q taken hold transit sinc k nu follow that transit taken hold u distinct state q q ik sinc assumpt satisfi lower bound requir impli violat upper bound requir consist contradict conclus q weaklykbound henc q pi finwf p point lower bound are although arbitrarili small nonzero upper bound finit necessari justifi univers quantifi choic bound function also point reason timingbas model specif bound function ie reason time computationscan significantli complic untim reason hmp analysi show therefor verif specif refer time conceptu simpler unknowndelay model knowndelay model gap finitari standard fair definit finitari fair replac given languag pi union regular safeti properti contain pi definit seem satisfactori practic obviou mathemat gener first observ uncount union safeti properti contain pi pi itself safeti properti howev defin program obtain comput restrict compi pi take countabl union recurs safeti properti contain pi an languag recurs iff languag ture machin clearli compi captur possibl implement pi finitest not typic fall strictli finpi pi comput fair howev two advantag finitari fair name simpler verif rule solvabl consensu problem also altern finpi compi captur implement pi limit comput power recal sampl program p section everi schedul finpi bound unknown fix long transit postpon suppos let bound vari call schedul linearli bound iff bound allow increas linearli time everi bound schedul linearli bound schedul linearli bound bound gener given function fn natur number schedul w ofbound iff exist constant k two transit l r appear least subsequ w n w finitari fair then ofair moreov fair requir f obtain strict hierarchi stronger fair requir ff ff union ofbound schedul contain f algorithm present section modifi solv distribut consensu fair requir ff fix comput choic f applic program verif consid problem verifi program satisfi specif finitari fair assumpt model check program variabl rang finit domain set program state finit problem verifi finitest program satisfi temporallog specif call model check autom tool model check success use check correct digit hardwar commun protocol ck examin effect finitari fair algorithm underli tool untim system consid finitest transit system p state set q set pip comput p regular safeti properti sinc q finit choos schedul alphabet q itself let f q regular fair requir let phi q regular specif given say ptl formula buchi automaton verif question then problem languag inclus p satisfi phi f iff pip problem solv algorithm involv languag regular assum finitari fair need check languag inclus pip is howev obviou check thi finf necessarili regular corollari follow theorem show finitest verif finitari fair reduc verif standard fair theorem regular languag pi pi proof finpi suppos pi pi nonempti sinc pi pi regular contain word w languag contain singl word w safe regular contain pi henc w finpi also finpi impli finpi nonempti corollari obtain model check finitari fair continu use algorithm develop deal standard fair corollari finitest program p set q state regular fair requir regular specif phi fair assumpt f iff satisfi phi fair assumpt finf proof want show let g languag pip assumpt p finitest pip regular sinc phi also regular g pip empti by theorem time system consid finitest time transit system p u set q state suppos specif refer time all given regular specif phi q verifi p u satisfi phi want check inclus pi u p problem solv construct buchi automaton recogn languag pi u p ad method applic bound function u fulli specifi parametr verif problem bound map fulli specifi ahv bound view paramet valu paramet known requir satisfi certain linear constraint such parametr verif problem then specifi finitest transit system regular specif phi set lu consist pair u function q verif problem check that everi choic u lu result time transit system p u satisfi specif phi defin ulu pi u p then want check pi lu p theorem togeth theorem impli parametr verif problem decid set lu consist function pair p finitest transit system phi regular parametr verif problem check inclus pi lu p phi decid parametr verif problem gener undecid class lu constrain allow choic bound map ahv instanc lu requir parametr verif problem undecid proof rule termin turn verif program finitest sinc safeti specif prove independ fair assumpt need concern live specif limit prove termin program or equival prove specif form p state predic p finitari weak fair straightforward extend propos method verif arbitrari temporallog specif finitari version weak strong fair total termin versu termin system standard method prove termin sequenti determinist program adopt prove comput nondet minist transit system p termin call total termin p essenti need identifi wellfound domain w oe rank variant function program state w rank decreas everi program transit exampl consid rule lp rule prove total termin find rank function ae q wellfound domain w oe state predic t state q q figur rule complet prove total termin is comput transit system p termin iff rule applic lp furthermor alway suffici choos set n natur number wellfound domain w consid requir weaklyfair comput p termin call termin p rule obvious sound prove termin complet problem may rank function decreas everi program transit standard solut identifi rank function never increas guarante decreas eventu decreas caus socal help transit whose occurr ensur weakfair requir exampl consid rule j lp rule j prove termin find rank function ae q wellfound domain w oe set r state predic one transit let r union r show state q q q transit transit enabl q enabl q rule j complet prove termin weaklyfair comput transit system p termin iff rule j applic complet howev longer hold requir wellfound domain set n natur number transit system transfinit induct ordin higher need prove termin exampl present method prove termin finitari fair comput let us consid exampl consid transit system p figur state program p given valu two variabl locat variabl rang f g data variabl x nonneg integ initi four transit e shown figur want prove weaklyfair comput p termin initi transit e e continu enabl fair e ensur eventu e enabl long x posit decrement x time fair e ensur figur transform program finp eventu result termin prove termin formal appli rule j wellfound domain choos set nfg natur number togeth ordin choos r e r e empti set state x belong r e belong r e rank function defin as ae x transit e e leav rank unchang e e caus decreas reader check five premis jj rule j inde satisfi notic bound number step p termin unbound nondetermin make mathemat treatment fair difficult prove termin p finitari weak fairnessthat is prove finitari termin p is conceptu simpler recal everi comput finwf integ k transit cannot enabl continu k step without taken theorem follow that finitari weak fair p must termin within bound number step bound depend unknown constant k captur intuit transform program p introduc two auxiliari variabl b c initi valu variabl b unspecifi nonneg integ program transit chang valu integ variabl c use ensur transit enabl b step without taken thu obtain new program finp figur origin program p termin finitari weak fair assumpt finwf iff comput transform program finp termin thu reduc problem prove finitari termin p problem prove total termin is simpl rule induct natur number suffici prove finitari termin state finp tupl x c b appli rule t choos set r set reachabl state x c b r iff b rank function map r natur number defin ae c reader check everi transit appli state r caus rank function decreas notic transform program finp infinit mani initi state given initi state termin within bound number step consequ finp suffer problem caus unbound nondetermin tradeoff prove termin p total termin finp clear rule j use former complex rule use latter program finp complex finitari transform program let us consid gener transform given transit system consist transit finitari transform finp transit system p obtain introduc new integ variabl b transit new integ variabl c thu state space finp q theta n m initi valu b arbitrari initi valu c thu set initi state finp q theta n theta fg everi transit transit system finp contain transit fin follow theorem establish transform fin togeth simpl rule sound complet proof method finitari termin theorem transit system p termin finitari weak fair iff comput transit system finp termin proof suppos program finp nontermin comput q consid project q q statespac p transit rule finp clear q also comput p valu bound variabl b stay unchang throughout q let k furthermor c k invari comput q m sinc transit c increment time enabl taken follow comput q weaklykbound henc p weaklyfair nontermin comput convers consid weaklyfair nontermin comput q p theorem q weaklykbound k defin sequenc q statespac finp follow q j maximum nonneg integ n transit j enabl taken state q n easi check that sinc q weaklykbound transit j enabl taken state q c consequ q nontermin comput finp thu languag pi finwf p finitari weakfair comput transit system p project languag pifinp transform program finp known given transit system p fair requir f exist transit system p requir uncount mani state the transform program p one initi state everi fair comput f yield proof principl wellfound induct n adequ applic distribut consensu consid consensu problem sharedmemori model atom oper allow share regist read write formal consensu problem defin follow n process boolean input valu f g process decid valu v f g execut statement decidev model failur introduc special transit fail process transit fail enabl share regist initi y xr yr xr els skip od r r fi od decideout figur consensu assum finitari weakfair program process p input process p yet decid valu p take transit fail transit disabl p stop particip solut consensu problem must satisfi agreementthat is two process decid conflict valuesand validitythat is process decid valu v v equal input valu process apart two safeti requir want nonfail process decid eventu waitfreedom assert process p eventu either decid valu fail thu process must prevent anoth process reach decis algorithm must toler number process failur implicit fair assumpt asynchron model weakfair requir wf program transit except newli introduc fail transit known that even program satisfi three consensu requir weakfair assumpt wf flp la hand consensu solv unknowndelay model assum upper bound delta memoryaccess time bound unknown process priori solut requir work valu delta aat show consensu algorithm aat unknowndelay model solv fact consensu finitari weakfair requir finwf algorithm shown figur algorithm proce round use follow share data structur infinit twodimension array x bit infinit array y whose element valu decis valu ie valu process decid on written share bit out initi valu addit process p local regist v contain current prefer decis valu local regist r contain current round number process round r prefer v bit xr v never set consequ process decid valu v round r furthermor process decid valu v round r yr never set conflict valu v everi process reach round prefer v round ensur agreement see aat detail proof easi check process initi input v process ever decid v impli requir valid possibl two process conflict prefer round r cannot resolv conflict round r proceed round r conflict prefer happen find yr first line one proce choos prefer next round line one finish assign yr finitari fair requir ensur behavior cannot repeat everi round everi finitarili fair comput bound k everi process neither fail termin take step least everi k step round number exce unknown bound k process execut loop process forc take least one step suffic ensur termin theorem program figur satisfi requir agreement valid wait freedom finitari fair assumpt finwf contrast program satisfi waitfreedom standard fair assumpt wf also observ algorithm use potenti unbound space therefor finitest program result section impli algorithm use fix number bound regist solv consensu finitari fair theorem two process algorithm use finit memori satisfi requir agreement valid waitfreedom finitari fair assumpt finwf or equival unknowndelay model unknowndelay model dl consist distribut process commun via messag deliveri time messag bound known priori establish bound number processfailur toler consensu protocol variou fault model bound establish use finitari weakfair similar observ appli result session problem unknowndelay model rw acknowledg notion similar kbound fair fix k defin sever place jay notion bound fair seem part folklor know publish account thank lesli lamport amir pnueli fred schneider gadi taubenfeld sam toueg pointer literatur help discuss r theori time automata safeti without stutter apprais fair languag distribut program parametr realtim reason defin live decis method restrict secondord arithmet consensu presenc partial synchroni imposs distribut consensu one faulti process tempor analysi fair tempor proof methodolog time transit system commun synchron parallel comput memori requir agreement among unreli asynchron process time constrain automata hierarchi tempor properti tempor logic reactiv concurr system reach agreement presenc fault impact time session problem automata infinit object verif concurr program automatatheoret framework tr fair safeti without stutter consensu presenc partial synchroni hierarchi tempor properti invit paper automata infinit object tempor logic reactiv concurr system impact time session problem parametr realtim reason theori time automata tempor proof methodolog time transit system imposs distribut consensu one faulti process computeraid verif formal method timeadapt algorithm synchron reach agreement presenc fault tempor analysi fair imparti justic fair timeconstrain automata extend abstract design synthesi synchron skeleton use branchingtim tempor logic commun synchron parallel comput