t gener linear extens fast a one import set associ poset cal p set linear extens ecal p paper present algorithm gener linear extens poset constant amort time is time oecp ecp fastest previous known algorithm gener linear extens poset run time on cdot ecp n number element poset algorithm present first constant amort time algorithm gener natur defin class combinatori object correspond count problem pcomplet furthermor shown linear extens gener constant amort time extens differ predecessor one two adjac transposit algorithm practic modifi count linear extens effici comput p x y pair xy time on ecal p b introduct one definit adverb fast in quick success webster collegi dictionari purpos paper show linear extens partial order set poset gener fast fast fact algorithm faster constant factor furthermor constant involv small algorithm extend practic rang poset extens gener count linear extens great interest comput scientist relat sort schedul problem exampl mani npcomplet oneprocessor schedul problem preced constraint one obviou way solv problem gener linear extens preced constraint pick best extens linear extens also interest combinatorist relat count problem result use effici gener standard young tableau given shape altern permut mani combinatori object view linear extens particular poset given poset p two question natur aris gener question ask whether linear extens ep p effici gener count question ask whether ep size set ep effici determin recent result brightwel winkler count question p complet indic count question may easier gener question give best possibl answer gener question sens algorithm gener ep time complex oep asid small amount preprocess say gener algorithm run constant amort time run time on n number object gener case linear extens assum unit cost oracl avail take two poset element b return whether oe b not also assum poset element depart comput scienc univers toronto toronto ontario ms a canada garacsutorontoca research support part nserc research paper took place visit simon fraser univers burnabi canada depart comput scienc univers victoria victoria bc vw y canada fruskeycsruvicca research support part natur scienc engin research council canada grant a label particular manner describ later label carri time on n element poset asid space use poset amount space requir algorithm on constant amort time gener algorithm previous known class combinatori object correspond count problem pcomplet problem gener linear extens poset consid knuth szwarcfit varol rotem kalvin varol paper term topolog sort use instead linear extens effici algorithm appear varol rotem whose time complex given on delta ep n number element poset worth note varol rotem algorithm simpl eleg quit effici practic algorithm awar count linear extens arbitrari poset well appear difficult analyz particular class poset seriesparallel bound width effici algorithm count known see exampl bouchitt habib strategi definit popular strategi effici gener set combinatori object insist success object list differ small prescrib way list combinatori object properti call gener combinatori gray code exampl binari reflect gray code yield method gener nbit string bit string differ predecessor flip one bit gray code found sever class combinatori object mani describ wilf regard linear extens permut element poset gener variou class permut common close criteria success permut differ transposit two element sometim restrict transposit adjac element onli wellknown algorithm steinhau johnson trotter provid gray code list n permut n element permut differ predecessor transposit two adjac element thu say n permut gener adjac transposit permut nset correspond linear extens poset n element antichain gener alway possibl gener linear extens poset transposit adjac not exampl linear extens poset consist two nontrivi chain n odd thu linear extens poset figur two element chain cannot gener transposit linear extens class poset shown gener transposit see open problem character poset properti even linear extens famili poset gener transposit fast algorithm perform gener may exist basic strategi initi algorithm gener linear extens twice extens flag plu minu algorithm keep track sign extens output plu extens thu sens algorithm fall class gener algorithm gener object actual output introduc terminolog notat poset or partial order set p reflex transit antisymmetr relat rp set sp order pair a b rp denot p b or lead confus simpli b oe b mean b b element minim p element b b oe a let minp denot set minim element p oe b exist c sp oe c oe b say b cover a let covera denot set element cover a element b said incompar b b a write akb indic b incompar pair element sp incompar p total order p total order x oe x j j sometim use xn denot p extens p poset q extens p total order call linear extens p let ep denot set linear extens p let ep denot jepj let sigmaep denot fl gammal j l epg height hx element x averag posit occupi linear extens thu minimum element height maximum element height jspj p antichain element height jspj probabl x preced denot p number extens x preced divid total number extens connect sort algorithm desir find pair element x p close sp let pnt denot poset set spnt relat set suppos b incompar element sp relationship element sp b precis suppos that c sp c oe c oe b oe c b oe c b call sibl poset p q rp rq antisymmetr let p q denot poset set sp sq relat set transit closur rprq exampl pabc poset set sp fa b cg relat set transit closur rp fa b b cg p say p induc q exampl everi linear extens p oe b oe c therefor say p induc abc element disjoint total order ff fi fl ffi denot poset fffi consid graph ep vertex set two vertic adjac graph whenev correspond linear extens differ singl transposit graph call transposit graph poset p denot gp subgraph gp vertex set contain edg correspond adjac transposit call adjac transposit graph denot g p gener linear extens p adjac transposit equival find hamiltonian path graph gp g p figur show poset transposit graph ff fi linear extens p dff fi denot distanc gp ff fi ff fi denot correspond distanc g p transposit graph bipartit connect partit set gp size hamiltonian cycl graph differ size partit set one hamiltonian path graph thu linear extens p cannot gener transposit ruskey conjectur necessari condit exist hamiltonian path also suffici suggest possibl character fig poset transposit graph fig graph gp theta k poset whose linear extens gener transposit figur partit set size differ two linear extens poset cannot gener transposit g graph let g theta k graph result take two copi g ad edg correspond isomorph two copi differenti copi g prefix vertic one copi g gamma exampl figur show gp theta k p poset shown figur lemma use later section state follow lemma b sibl p gp proof observ ba linear extens l p transpos b l yield anoth linear extens p therefor oper transpos b linear extens provid isomorph total order gp theta k edg purpos induct show exist hamiltonian cycl consid graph hamiltonian cycl sinc hamiltonian path endpoint adjac graph g p theta k hamiltonian proof g p theta k hamiltonian form basi effici algorithm present next section true certain kind poset call bposet shown r r r r r r r r r r r r fig bposet pruess ruskey result use proof gener case definit bposet poset p whose element partit two disjoint chain x oe x j exampl bposet shown figur note linear extens bposet extens call canon linear extens bposet defin mrx largest index j x k bposet figur follow lemma prove lemma let p bposet exist hamiltonian cycl use edg gamma figur show graph g p theta k p bposet shown figur edg correspond isomorph two copi g p omit sake clariti one think travel vertic edg transpos neighbor right travel along horizont edg transpos x one neighbor hamiltonian path gamma shown figur bposet use remaind paper call bposet graph similar shown figur aris whenev call typic case oe g p path call atyp case word typic case occur mra atyp case occur theorem everi poset p graph g p theta k hamiltonian proof proof theorem induct jspj base case induct p poset zero one element case g p theta k edg suppos jspj p uniqu minimum a g p induct hypothesi g pnfag theta k hamiltonian otherwis let p two minim element b induct hypothesi graph g pnfa bg theta k hamiltonian cycl h replac sign linear extens ff h abff replac linear extens gammaff baff result cycl exactli linear extens b preced element sp r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r gammaay r r r r r r r r r r r r r r r r r r r r r r r r r r fig graph g p theta k r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r fig hamiltonian cycl g p theta k is cycl visit linear extens xspnfabg poset p p extend b cover everi element minp fi a poset px bposet lemma hamiltonian path g px fi gammafi substitut occurr fi path h odd i even i substitut revers path occurr fi call result walk h prove h hamiltonian cycl g p theta k necessari show everi vertex cycl h linear extens p true sinc ep ep henc bposet gener extens p also necessari show linear extens l p l gammal occur exactli h suppos l induc order xy fa bg order bg xyi linear extens p l linear extens bposet everi bposet gener either induc order xy induc order i therefor l gammal gener gener ep l gammal gener exactli onc observ refer lemma preced proof strictli necessari bposet occur bposet typic case cycl figur could use atyp case cycl obviou move b right far possibl chang sign move b back left mrb even cycl figur slightli differ use edg aflb gammaaflb cycl use algorithm follow section corollari p poset pair sibl gp hamiltonian proof suppos p pair sibl a b theorem g hamiltonian therefor gp hamiltonian henc lemma gp hamiltonian open problem determin whether g p hamiltonian p poset pair sibl algorithm proof theorem construct section present recurs algorithm implicit induct proof algorithm run constant amort time ie gener linear extens poset p take time oep first give overview algorithm use small exampl give gener understand work give detail algorithm proof correct algorithm inplac algorithm maintain array le contain current linear extens maintain variabl isplu keep track sign gamma go one linear extens next make chang array revers sign main procedur use algorithm call genl recurs basic follow path indic figur everi level recurs associ pair minim element current subposet exampl poset shown figur pair minim element pair minim element g pair determin preprocess describ later procedur move switch use chang current linear extens oper o time follow sign chang is isplu chang transpos call transpos x element left call transpos x element right time new linear extens l p gener call genlei ie time move switch call genlei call call genlei move possibl way l maintain order depend order point call genlei noth exampl start a b b execut call sequenc genl switch genl poset shown figur lead trace call shown figur follow detail implement reader refer pascal procedur genl figur implement algorithm maintain four global array array le linear extens array li invers array b store element b discuss algorithm b consid fix outset unchang throughout run algorithm array maintain ai alway contain valu leftmost ith pair procedur call linear extens fig trace call sequenc poset figur bi contain rightmost also current sign either plu minu gamma maintain boolean function rightx use determin whether element x move right oper o time follow return true bi incompar element right array le return true ai incompar element right array le element right bi describ preprocess success strip pair element element left uniqu minimum element encount simpli delet becom part pair let maxpair index last pair minim element strip p remaind p total order empti preprocess detail figur note maxpair uniqu determin poset depend order element strip p say linear extens l proper order element j b j adjac l l induc order maxpair initi linear extens list must properli order maxpair preprocess figur thi assum right bmaxpair fals initi call simpli genl follow procedur call call call sequenc genl maxpair switch maxpair genl maxpair algorithm consist execut preprocess set isplu plu sq q exactli one minim element x begin els begin let two minim element q ai maxpair fig preprocess routin execut call sequenc pascal procedur implement genl given figur prove follow theorem theorem algorithm genl gener linear extens along hamiltonian path g p theta k proof order prove theorem first prove follow proposit proposit let linear extens array le properli order i linear extens l ep genlei gener l gammal exactli onc furthermor last extens gener gamma last extens gener differ transposit igamma b igamma proof proof proce induct i recurs call genl noth switch chang sign ffia induc p easi confirm algorithm figur strip recurs call switch chang sign simpli follow path indic figur case genl find hamiltonian path gamma g q theta k q bposet p loss gener sign storag genl invok ff fi fl way preprocess select pair assur p induc could empti mention befor basic structur algorithm strip recurs call follow hamiltonian path bposet indic figur switch transpos linear extens e properli order gamma linear extens call l induct procedur genl begin mrb typic fals right bi begin move bi riht genl i mra right ai begin typic true repeat mra move ai riht genl i right ai typic begin x mla begin move ai left genl i typic odd mrb move ai left els switch i x mrb begin move bi left genl i fig pascal procedur genl hypothesi call gener sigmaep respect start l end l end gammal sinc even number vertic product graph edg even number call genlei thu sign final permut unchang rel order igamma b igamma unchang union sigmaep a b let a b amaxpair bmaxpair respect suppos call sequenc execut preprocess poset p proposit first call b transpos sigmaep ba gener therefor ep gener theorem prove analyz time complex algorithm assum right switch move implement constant time easili accomplish long invers li le maintain call move switch gener one linear extens observ call genlei gener least two call genlei iter whileloop forloop algorithm execut move therebi gener linear extens occas genl recurs call linear extens gener happen per linear extens gener therefor algorithm run constant time per linear extens gener sigmaep suppress linear extens prefix gamma gener ep constant amort time anoth way think preced argument consid underli comput tree intern node recurs call leaf linear extens total amount comput divid node assign constant amount comput sinc intern node least two children number leav greater number intern node therefor total amount comput proport number leav observ gener minu gamma vertic occur algorithm genl suggest treat special case minu gamma vertic omit entir simpli skip next plu vertex done save comput list extens produc befor success extens differ larg number transposit one want comput number extens comput save comput number vertic level recurs gener extens explicitli ie never move number vertic extens determin mra mra number mra mrb chang uniti one extens next sinc adjac transposit use lead algorithm whose run time oep n gener lower bound attain oe c b oe c element c p n g upper bound attain b maxim well minim gray code linear extens show linear extens list success extens differ adjac transposi tion first show exist list modifi result previou section show set linear extens poset list success extens differ one two adjac transposit let us say order ff extens p delay c thu go show exist delay order ep furthermor list done constant amort time exist delay order difficult show g graph g k denot graph vertex set g edg everi pair vertic connect path length k g word incid matrix g k incid matrix g k arithmet done mod cube g g squar g g poset p delay k order g p k hamiltonian result sekanina cube everi connect graph hamiltonian sinc g p alway connect g p hamiltonian delay order exist graph g p alway connect otherwis exist delay order would impli result fleischner state squar everi connect graph hamiltonian even though g p gener connect poset connect transposit graph easi character first consid question transposit graph pendant vertic p consist two disjoint chain g p two pendant vertic p bposet disjoint union two chain g p one pendant vertex otherwis g p pendant vertic lemma everi poset p graph hp connect hp pendant vertic may proven show everi pair incid edg hp cycl lemma help us find effici algorithm list delay order ep instead prove appli theorem follow lemma lemma g bipartit g theta k hamiltonian g hamiltonian proof let g bipartit graph n vertic let hamiltonian cycl g theta k v consid sequenc vertic sinc g bipartit g theta k thu vertic vertic one partit set g theta k also vertex u g u u adjac therefor differ partit set g theta k therefor vertex g appear exactli s i vertic v v i either distanc one g distanc two g if x therefor hamiltonian cycl g conjectur lemma may extend graph bipartit conjectur g theta k hamiltonian g hamiltonian graph class hs t close walk visit everi vertex least time time see thu h class hamiltonian graph observ g theta k hamiltonian g h just consid walk result two copi g identifi convers true g triangl pendant edg ad vertex g h g theta k hamiltonian theorem show everi poset p graph g p h gener graph hamiltonian make conjectur conjectur g h g hamiltonian exampl k show convers conjectur fals proof lemma construct appli construct g p yeild follow result theorem linear extens poset gener delay constant amort time proof run algorithm genl given figur instead suppress linear extens neg sign suppress everi linear extens ie gener list l output list l proof lemma delay list linear extens run time genl ie constant amort time remaind section discuss use algorithm comput use version genl gener extens exactli twice success extens differ adjac transposit predecessor first discuss comput p let us defin xyrun maxim sequenc success extens x preced y maintain two array integ call valu sx y sum length previou xyrun valu x y iter current xyrun start iter exactli one adjac pair say xy transpos occur tth iter sx y increment gamma x y y x set t termin algorithm divid ep sinc constant amount updat done iter total comput on comput hx proceed similar fashion xrun maxim sequenc extens x occupi posit valu sx weight sum length previou xrun x iter current xrun start iter exactli one adjac pair say xy transpos occur tth iter y sz increment pz set t pz posit z occupi extens termin valu hx sx divid ep conclud remark algorithm given section gener linear extens poset constant amort time improv on amort time algorithm fastest previous known algorithm refin work present would gener linear extens loopfre algorithm ie constant comput worst case produc new extens current one fulli implement count gener algorithm c found quit effici practic sun sparcstat slc program gener extens element fenc poset second extens count euler number count took second extens element fenc count second gener second extens grid gener second extens count catalan number enumer linear extens poset recent shown pcomplet algorithm section constitut first constant amort time algorithm gener natur defin class combinatori object associ count problem pcomplet lead interest question complex gener combinatori object count pcomplet pcomplet problem admit constant amort time gener algo rithm ask question assum initi object suppli part input exampl hamiltonian cycl input would consist graph g hamiltonian cycl g similarli paper assum linear extens input poset intuit exist question difficult npcomplet gener question difficult well answer even formal intuit even exist question easi in p mani problem complex gener unknown exampl ideal given input poset gener constant amort time count ideal pcomplet find ideal trivial gener span tree graph constant amort time find span tree count number tree p one discov constant amort time algorithm gener span tree there fact interest relationship constant amort time gener algorithm complex exist andor count relat question variou polynomi time complex measur instead constant amort time consid johnson yannakaki papadimitri acknowledg would like thank derek corneil mike fellow carla savag help discuss malcolm smith work figur especi ken wong implement algorithm care read manuscript note ad proof point l babai privat commun easi contriv pcomplet object gener quickli start pcomplet object pump number instanc take union easilycount easilygener numer object exam ple given poset p n vertic consid set fx x ideal pg fx x g set pcomplet count and given appropri represent easi gener constant amort time counterexampl twentyfour vertic conjectur recent found j van den heuvel privat commun r webster new collegi dictionari combinatori theori calcul invari order set count linear extens gray code restrict densiti hamilton path minim chang algorithm squar everi twoconnect graph hamiltonian gener maxim independ set gener permut adjac transposit gener topolog sort structur program gener topolog sort ar rangement complex machin schedul problem gener hamilton gener linear extens certain poset transposi tion adjac interchang gener combin order set vertic connect graph hamilton path graph linear extens union poset one hundr problem elementari mathemat algorithm perm algorithm gener topolog sort arrang element combinatori comput combinatori algorithm tr ctr scott effler frank ruskey cat algorithm gener permut fix number invers inform process letter v n p jeanluc baril vincent vajnovszki minim chang list luca string graph theoret consequ theoret comput scienc v n p novemb j sawada oracl vertex elimin order theoret comput scienc v n p septemb l s chandran l ibarra f ruskey j sawada gener character perfect elimin order chordal graph theoret comput scienc v n p octob karel de loof han de meyer bernard de baet exploit lattic ideal represent poset fundamenta informatica v n p august gang wang wenrui gong ryan kastner instruct schedul use maxmin ant system optim proceed th acm great lake symposium vlsi april chicago illinoi usa russ bubley martin dyer faster random gener linear extens proceed ninth annual acmsiam symposium discret algorithm p januari san francisco california unit state karel bertet jen gustedt michel morvan weakord extens order theoret comput scienc v n p juli larri huston rahul sukthankar rajiv wickremesingh m satyanarayanan gregori r ganger erik riedel anastassia ailamaki diamond storag architectur earli discard interact search proceed rd usenix confer file storag technolog march san francisco ca martin charl golumb ron shamir complex algorithm reason time graphtheoret approach journal acm jacm v n p nov