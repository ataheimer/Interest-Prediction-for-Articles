t formal verif complex coher protocol use symbol state model a directorybas coher protocol sharedmemori multiprocessor complex verif techniqu base autom procedur requir establish correct state enumer approach wellsuit verif cach protocol face problem state space explos lead unaccept verif time memori consumpt even small system configur one way manag complex make verif feasibl map system model verifi onto symbol state model ssm sinc number symbol state consider less number system state exhaust state search becom possibl even largescal sytem complex protocolsin paper develop concept notat verifiy properti directorybas protocol design nonfifo interconnect network compar verif protocol ssm stanford mur verif tool enumer system state show ssm much effici term verif time memori consumpt therefor hold promis verifi much complex protocol uniqu featur ssm verifi protocol system size therefor provid reliabl verif result one run tool b introduct cach data close processor dynam import techniqu reduc latenc memori access sharedmemori multiprocessor system multipl copi memori block may exist cach coher protocol often maintain coher among data copi largescal system directorybas protocol remain solut choic reli effici broadcast mechan moreov optim adapt variou share pattern current trend toward complex protocol usual implement softwar protocol processor flexibl propos even exist let user defin protocol perappl basi one major problem prove protocol correct sever coher transact bear block initi time differ processor messag may enter race condit protocol behavior often hard predict protocol design visual possibl tempor interleav coher messag autom procedur verifi protocol therefor highli desir sever approach verifi properti cach protocol recent paper survey approach one import class verif techniqu deriv state enumer method reachabl perturb analysi explor possibl system state gener method start system model finit state machin specifi behavior compon protocol global state composit state compon state expans process start given initi state exercis possibl transit lead number new state process appli repeatedli everi new state new state gener end global state transit diagram reachabl graph show transit relat among global state report major drawback state enumer approach size system state space increas quickli number complex compon protocol often creat state space explos problem verifi system increas number cach becom rapidli impract term comput time memori requir protocol becom complex clear whether verifi smallscal system model provid reliabl error coverag system size recent introduc new approach call ssm symbol state model address state space explos problem appli simpl snoopi protocol singl bu ssm gener framework verif system compos homogen commun finit state machin thu applic verif cach protocol homogen sharedmemori multiprocessor ssm take advantag equival among global state precis respect properti verifi data consist ssm exploit abstract correspond relat among global state met astat repres larg set state base observ behavior cach character finit state machin cach state combin class global state compos class moreov number cach state class abstractli repres set repetit constructor indic multipl instanc cach class abstract global state repres famili global state effici expand expand abstract state equival expand larg set state ssm verifi properti protocol system size therefor verif reliabl verif reli state enumer small system size develop tool appli new approach illustr applic concret case verifi paper three import coher properti protocol design nonfifo interconnect network nonfifo network network messag two node receiv differ order sent therefor number possibl race among coher messag much larger system fifo net work demonstr effici tool compar murj show ssm much effici term verif time memori consumpt therefor hold promis verifi much complex protocol paper structur follow section provid outlin protocol nonfifo network verif model correct issu mechan detect variou type error discuss section develop verif method section result studi section section contain conclus directorybas protocol nonfifo network protocol inspir censier feautrier writeinvalid protocol everi memori block associ directori entri contain vector presenc bit indic whether cach copi block presenc bit set copi first load cach reset copi invalid replac multipl copi exist differ cach must ident memori copi extra dirti bit per block directori entri indic whether dirti cach copi exist case cannot one cach copi say copi exclus cach exclus copi also often call owner line enforc ownership block invalid must sent cach presenc bit set final replac share copi silent sens presenc bit reset memori protocol applic gener ccnuma cachecoher nonuniform memori access machin ccnuma share memori distribut equal among processor node cach privat cach processor case directori attach memori partit cover memori block alloc it thu block home memori directori entri resid implement conceptu simpl protocol requir care synchron cach directori involv mani cach state memori state messag cach memori complet specif design found coher messag exchang memori cach given tabl messag basic two type control data control messag includ request acknowledg messag role selfexplanatori except sack synchron messag whose role becom clear later follow describ salient featur protocol use verifica tion simplifi follow descript refer state block cach state cach convent appli state block directori state machin throughout paper cach state cach three stabl state invalid i share s clean copi potenti share cach owner o modifi cach copyalso call exclu sive howev sinc cach state transit instantan three transient state ad keep track request issu cach yet complet readmisspend rmp state block frame empti pend recept block read miss writemisspend wmp state block frame empti pend recept block ownership write miss coher messag type messag action memori inv request invalid local copi invo request invalid local copi write back memori updm request updat main memori copi chang local copi share state oship ownership grant data block copi suppli memori control nack neg acknowledg indic request reject lock directori entri cach reqsc request share copi reqo request ownership reqoc request ownership block copi dxm block copi suppli owner respons updm messag memori doxmr block copi suppli owner replac doxmu block copi suppli owner respons invo messag memori iack acknowledg indic invalid complet sack synchron messag writehitpend whp state block frame contain share copi pend recept ownership right complet write access state suffici system fifo network nonfifo network possibl race exist coher request sent time two differ cach block request serial home node respons gener may enter race reach cach order consid follow case assum two process node p p issu request exclus copi block time request p reach home node first grant copi request p process home invalid sent p nonfifo network possibl invalid reach p exclus copi similar scenario occur p request share copi time p want exclus copi p request exclus copi p want share copi deal three race condit protocol use three addit transient cach state synchron interact cach memori state are transient ownertoinvalid txoi transient sharedtoinvalid txsi transient ownertoshar txo resolv race two process node request exclus copi cach state wmp move state txoi receiv invalid that receiv data block execut pend write write block back memori invalid copi end state i state txsi txo solv two race similar fashion memori state stabl memori state indic presenc dirti bit directori share exclus uncach memori block stabl state free unlock mean memori control may accept new request block howev memori state transit instantan time directori control start process incom request time consid request complet directori entri transient state lock maintain semicrit section memori block request reach lock busi directori entri nack three correspond transient memori state are xdata xown xownc indic transact progress share copi ownership right exclus copi respect typic system fifo network protocol base intervent forward process node request copi block exclus remot cach home node first request copi dirti block updat memori forward request owner victim modifi copi replac memori state remain exclus writeback messag reach memori control transmiss recept writeback messag memori control may receiv request share copi issu anoth cach forward owner memori control receiv block copi sent time replac believ block copi sent respons forward request meanwhil forward request still pend problem also identifi solut suggest count presum owner ignor forward request how ever largescal system unpredict network delay intract problem caus forward request outpac messag directori state transit synchron owner memori solv problem ambigu writeback messag use differ messag id cach write back caus replac doxmr invalid doxmu see tabl moreov add two transient state directori synch synch memori control unlock directori entri receiv replac data block synchron messag exampl memori control receiv request share copi reqsc request forward owner memori state chang xdata presum owner written back block repli synchron messag receiv request forward memori memori control receiv block messag type doxmr synchron messag sack owner directori enter transient state synch wait synchron messag sack writeback messag doxmr owner respect state synch take care similar case origin request messag reqoc shown figur protocol model correct properti system model first step verif construct system model manag verif complex model leav detail peculiar implement retain featur essenti properti verifi earli stage protocol design approach also facilit rapid design modif model section describ system model use verif protocol first singl block model suffici check properti relat cach coher replac take place time model processor access second abstract directorybas ccnuma architectur system model figur a appropri sinc model singl block model consist directori xdata reqoc doxmu sackor sackor sackor sackor reqsc doxmr doxmr doxmr doxmr multipl processorcach pair processor associ one messag send channel ch one messag receiv channel ch model messag flow cach main memori messag channel preserv execut order memori access in order model nonfifo interconnect messag never lost may receiv differ order issu cach protocol treat differ messag local processor remot processor model figur a equival model figur b home memori model independ activ entiti use system model figur b throughout paper verif model directorybas ccnuma architectur third valu data copi track abstract first propos cach may data block one three statu nodata the cach valid copi fresh the cach uptod copi obsolet the cach outofd copi ch ch home memori directori fullmap ch ch ch ch base machin ch ch home memori ch ch ch ch home node a abstract model ccnuma multiprocessor singl block b refin model protocol machin memori copi either fresh obsolet cours verif expans process keep track statu block copi conform protocol semant third abstract necessari discov verif smp protocol which differ protocol use paper consid protocol transact illustr figur initi cach dirti copi block replac it perform writeback home node cach keep valid copi block receiv acknowledg memori order guarante memori receiv block safe meanwhil cach b send request exclus copi home subsequ cach process dataforwardrequest home consid acknowledg prior writeback request send block b b execut write replac block due miss shown figur race condit exist two writeback request writeback b win race stale writeback overwrit valu updat b note exampl state transit permiss overcom problem verif model need maintain global variabl rememb writeback carri latest valu stale writeback error formal protocol model given architectur model figur formal defin constitu finit state machin interact protocol conveni languag specifi machin csp messag transmiss repres postfix messag recept postfix definit receiv channel receiv channel machin record messag receiv memori transit cach structur rchm q r r xm r xc set memorytocach messag tabl messag memori home writeback exclusiverequest dataforwardrequest exclusiveforward writeback messag cach messag issu memori control consum cach respect definit send channel send channel machin record messag issu cach transit memori control structur schm q xc xm set cachetomemori messag tabl messag cach messag memori messag issu cach consum memori respect state channel machin made messag transit state expans step receiv or send channel may record command sent memori or cach may propag command cach or memori behavior cach control given definit definit cach machin state machin character cach behavior structur cm q c r xc c xc c coher messag defin definit xc xc messag consum produc cach respect upon receiv messag cach control may may respond gener respons messag accord c addit emb processor machin cach machin processor may issu access local cach may caus cach state chang issuanc coher messag specifi c finit state machin main memori protocol formal follow definit memorydirectori main memori machin keep directori structur messag defin definit xm xm cachestomemori memorytocach command respect memori machin consum messag respons messag may may sent cach q bm denot set possibl state base machin defin below definit base machin base machin composit cach machin two correspond channel machin is bm definit protocol machin protocol machin defin composit base machin memori machin is pm n cach state tabl use verif c c found memori control consum messag cach respond accord block state messag type final state protocol machin also refer global state paper correct properti protocol paper verifi three properti data consist incomplet protocol specif livelock follow definit data consist basic condit cach coher given load must alway return valu updat latest store address formul condit within framework reachabl expans follow definit data consist respect particular memori locat protocol preserv data consist follow condit alway true reachabl analysi famili global state origin g includ g itself consist return load valu written store access write recent valu memori locat bring global state g g valu written store transit t is state reach expand g allow access old valu defin t architectur model figur memori access made sever consecut event thu atom constrain way sequenc access gener processor moreov hardwar distinguish synchron instruct regular loadstor instruct so paper latenc toler mechan processor cach model assum mechan correct enforc proper sequenc order memori access cooper softwar base model data valu section data inconsist detect processor allow read data obsolet valu definit detect data inconsist data copi tag valu set nodata fresh obsolet data transfer emul expans data inconsist detect processor allow read data obsolet valu incomplet protocol specif unforeseen interleav event protocol specif often incom plete especi earli phase develop flaw manifest unspecifi messag recept ie entiti protocol receiv messag unexpect given current state state machin model effect detect unspecifi messag recept procedur simpl directli tie structur reachabl graph unspecifi messag recept detect system state messag receiv transit state specifi protocol descript besid detect error state enumer show path lead erron state deadlock livelock protocol deadlock enter global state without possibl exit livelock situat process interact protocol could theoret make progress trap loop state eg processor keep retri request alway reject anoth processor deadlock easi detect state enumer sinc state without exit state difficult detect livelock level abstract adopt paper protocol compon commun via messag thu detect deadlock livelock deriv servic function iti provid cach coher protocol exampl protocolintrins livelock block processor wait messag eg invalid acknowledg never sent anoth processor protocol specif deadlock livelock condit due particular implement protocol finit messag buffer fair serv memori request cannot detect level abstract definit livelock context coher protocol livelock condit given block lock processor processor perman prevent access block state expans process check follow condit order detect livelock correct protocol condit livelockfre a protocol visit everi state global state transit diagram infinit mani time is global state transit diagram stronglyconnect given global state everi state global state transit diagram reachabl b processor issu memori access block memori access must eventu satisfi eg valu alway return load resum processor execut specifi calli given initi global state cach invalid state must exist reachabl global state cach state becom share dirti read miss access condit a b suffici avoid livelock defin definit assur everi processor read modifi block arbitrari number time condit a stronger necessari assum cach protocol oper steadi state cach protocol machin might start initi state never return later case global state graph would compris two subgraph one subgraph consist initi state would exit second subgraph correspond steadi state oper protocol vice versa special case identifi care analysi state graph livelock report verif method model figur order state base machin global state represent irrelev protocol correct symmetri size state space reduc factor n given system n processor symbol state model ssm exploit power abstract relat symmetr relat order reduc size state space reliabl new abstract must equival system model respect properti verifi equival state transit system gener formal system verifi finit state transit system definit finit state transit system respect cach block behavior cach system local cach automata model finit state transit system ms a initi state set state symbol global state space a subset set oper caus state transit repres state transit function consid state transit system m s a s s d respect properti p verifi want find abstract state transit system correspond m r smaller s error state map error state r definit correspond given two state transit system m s a s s d r correspond exist correspond relat j that r correspond ie r js least one state correspond s ie r js state make transit state enabl oper t state r r correspond state s exist state r r move r r r correspond t figur illustr correspond relat correspond relat definit equival two state transit system r r correspond equival respect properti p verifi iff follow condit verifi step expans r let r current correct state r let r next state r transit t p verifi r p hold state r jt p hold r jt p hold r p hold r must exist state r js r jt p hold t first condit definit establish expans r complet without violat properti p expans would also complet without violat p second third condit definit ensur error state discov expans r iff error state exist error state r correspond error state m follow first specifi abstract machin r correspond protocol machin definit prove r equival respect cor rect properti section abstract ssm model atom memori access ssm method first introduc assumpt atom memori access develop abstract relat among global state base observ that order model cach protocol state must keep track whether exist multipl copi exclus state latest copi data hand number readonli share data copi affect protocol behavior provid least one cach copi symbol state repres use repetit constructor definit repetit constructorsatom memori access null specifi zero instanc singleton specifi one one instanc constructor omit state represent plu specifi one multipl instanc star specifi zero one multipl instanc repetit constructor repres exampl set global state one multipl cach invalid state zero one multipl cach share state metast correspond set explicit state m order relat among repetit constructor repetit constructor order set state repres thu figur order relat extend metast call composit state that exampl contain set global state repres first composit state subset repres second composit state contain relat among composit state composit state contain composit state kept verif end state expans state space collect repres rel small number essenti composit state r ssm model nonatom memori access model protocol nonatom access need defin element form basi repetit abstract add new repetit constructor call univers constructor model figur base machin natur form unit abstract repetit henceforth set base machin state repres c cach state p valu presenc bit directori r number base machin set specifi one repetit constructor abov r state receiv channel state send channel r specifi messag transit channel sinc channel model nonfifo network order messag channel irrelev often confus part notat may omit exampl use notat q combin cach state state two messag channel although singleton plu star use repres unspecifi number instanc given construct such base machin given global state precis enough model intermedi state complex protocol transact trigger event count consid abstract state s write miss occur cach share state must invalid ultim state o processor state exclus dirti copi behavior level state transit done one step memori access assum atom howev access longer atom invalid sent cach state number share copi count onebyon upon receiv invalid acknowledg result need distinguish two state contain metast s two state correspond case either cach state s deal problem first defin inval idationset definit invalidationset invalidationset invset contain set cach presenc bit set must invalid memori grant exclus copi request exclus copi such requestforownership reqo requestfor ownercopi reqoc protocol pend memori copi must invalid state expans process need keep track whether invalidationset empti sinc cach state specifi repetit constructor exact number cach particular state unknown use constructor alon repres number copi may prevent expans possibl state consid follow composit state invalidationset brack et q denot base machin presenc bit reset expans step null nonnul instanc cover constructor memori receiv request exclus copi reqoc cach state c cannot determin whether invalidationset empti definit includ case null nonnul instanc one way solv shortcom notat explor case expans process global state expand two state correspond empti nonempti invalidationset gener expans step shown figur expans step q mean machin state q chang state q other remain q c c c f reqoc f reqoc data f s qc f iack f iack s qc data f f iack cach c acknowledg invalid request c chang c memori receiv iack cach c cach c respond inv c chang c memori receiv iack cach c s suppos memori receiv request exclus copi cach state c two state correspond empti nonempti invalidationset gener s invalid sent cach invalidationset wherea s request obtain exclus copi the new owner invalidationset empti expans s cach state c receiv invalid respond invalid acknowledg chang state c memori receiv invalid acknowledg cach state c s two state empti nonempti invalidationset gener global state s assum cach state c acknowledg invalid incorrect design s acknowledg messag cach state c receiv memori expans may consid invalidationset empti make transit s howev case invalidationset empti also cover must also expand either process never stop error go undetect order solv problem expans process need rememb expans path follow figur transit s s s s correspond empti nonempti invalidationset respect howev invalidationset fact cover three case unfortu nate split state result combinatori explos state space effici solut work state keep track whether invalidationset empti end introduc new constructor call univers constructor u construc tor transit appli nonempti invalidationset form null case gener rather compon insid invalidationset expand one one without consid null case keep track fact expand compon least without consid null case use u constructor compon expans type u constructor similar except transit null case exercis expans inval idationset invalidationset may consid empti form let examin expans step use u constructor see procedur work figur global state s expans process explor path cach respond invalid global state s constructor replac u class cach x n q q remain c next time expand expans process consid null case resolut provid u constructor global state s expans process choos expand class cach state c consid case nonempti set cach state c acknowledg invalida tion process move state s accord condit empti invalidationset pend request exclus copi state never resum becaus cach class c situat easili detect livelock situat protocol trap loop s qc f iack s qc f iack f iack f iack c f iack f iack c f iack data f cach c acknowledg inv cach c acknowledg inv c chang c cach c respond inv c chang c memori receiv iack cach c memori receiv iack cach c memori receiv iack cach c c pend request f reqoc never resum hand cach invalidationset acknowledg memori expans process take anoth path state s s occurr event count writeinvalid protocol collect acknowledg invalid writeupd protocol updat must acknowledg way equival invalidationset could call updateset symbol state model combin basic framework section refin section system unspecifi number cach group base machin state state class specifi number class one follow repetit constructor definit enhanc set repetit constructor null specifi zero instanc singleton specifi one one instanc constructor omit state represent plu specifi one multipl instanc star specifi zero one multipl instanc howev case zero instanc explor transact depend event count expans univers u specifi zero one multipl instanc case zero instanc explor transact depend event count expans definit composit state composit state repres state protocol machin system arbitrari number base machin construct state class form nq bm number state base machin q q bm r u q mm q memori machin state repetit constructor order possibl state specifi name order lead definit state contain order relat among repetit constructor enhanc set q n definit contain say composit state contain composit state q consequ contain that famili state repres superset famili state repres therefor discard verif process provid prove expans process base expans rule section monoton oper set composit state s is memori event appli rule expans process set oper applic composit state state gener process defin follow stand or show state transit aggreg q q r coincid transit q r r u observ transit onestep transit a q q b q q machin state q denot q tupl transit appli base machin state q q q caus base machin q move state q transit machin q may affect shown chang q q nstep transit rule specifi repetit applic transit n time n arbitrari posit integ a q q q mm b q q c q q progress transit provid q q q mm q r q mm state bracket form invalidationset base machin invalida tionset denot q tupl aggreg rule group base machin state one exampl coincid transit memori control send invalid signal everi cach valid copi onestep transit occur exampl memori receiv request exclus copi base machin class q base machin chang state q the request messag remov send channel memori normal process one request exclus copi time case machin q q may stay state may chang state new invalid messag sent receiv channel rule b c nstep transit correspond two chain transit transit q q appli unlimit number time long base machin state q transit effect machin denot q tupl typic exampl are processor replac copi state share processor receiv type messag processor issu memori access independ two addit rule similar interpret nstep transit requir progress expans process progress transit deal protocol transact involv event count explain section correspond two chain transit q mm q mm protocol model process request exclus copi memori transit recept invalid acknowledg such iack tabl invset set cach presenc bit set memori must invalid memori grant exclus copi rule a appli invalid process wherea rule b appli success invalid copi state expans process cach transact possibl current state explor state expans step two phase first new composit state produc appli one transit rule current state second aggreg rule appli lump base machin state see exampl figur monoton state expans gener system verifi compos finit state machin one machin commun machin directli composit state ssm form possibl state machin r repetit constructor partial order exist among repetit constructor one figur state expans rule includ aggreg rule onestep transit rule compound transit rule correspond multipl applic onestep transit rule aggreg rule rule use repres symbol state compactli possibl base partial order repetit constructor abstract state represent contain composit state base partial order among constructor context prove expans rule ssm monoton oper name intuit ssm state contain expans step done correctli next state state includ must also contain expans contain abstract state ssm independ properti verifi properti data consist see definit formul user check reduc state space lemma aggreg process monoton is q possibl state state machin r repetit constructor proof proof follow order relat among repetit constructor check possibl combin r r r r subject constraint lemma aggreg rule q lemma immedi successor origin state contain state origin state expans rule taken memori event q n q r q n q n appli proof need consid effect appli machin state q simplifi notat class q j j i lump q provid q q k follow two state gener onestep transit rule appli q mean transit may caus state chang machin sinc includ case singl base machin must contain case zero base machin clear contain relat also true compound rule involv multipl onestep transit nstep rule progress rule appli q lemma claim hold proof aggreg process monoton lemma lemma simpli extend result lemma q theorem monoton everi reachabl exist reachabl proof immedi result lemma q algorithm state expans process shown figur two list keep track nonexpand visit state step new state produc state contain state prune final output set essenti state definit essenti state composit state essenti exist composit state s reader awar fact gener essenti state success verifi system correct system incorrect expand error state lead unpredict state practic meaningless assum state expans process termin whenev error detect illustr figur state space report end errorfre expans process partit sever famili state which may r r overlap repres essenti composit state algorithm gener essenti state theorem essenti composit state gener algorithm figur complet symbol repres state produc basic state enumer method state abstract proof consid state s state enumer method composit ssm state r r r r symbol form r cover s result next state r also cover t gener composit state transit function appli inform accumul expans t q uniqu set essenti state set essenti state uniqu provid state graph connect essenti state strongli connect name exist least one path everi essenti state essenti state algorithm essenti state gener w list work composit state h list visit composit statesoutputessenti state w empti begin get current state w state class v applic oper v state p w q h discard a els begin remov p w p a remov q h q a add a w discard termin loop start new run insert h fulli expand contain end theorem success run verif start legal initi state gener set essenti state es state transit graph form essenti state es strongli connect set es uniqu sens state expans process alway produc set essenti state es start legal reachabl state s proof set essenti state defin fixpoint state expans process termin theorem state es repres possibl configur system reach therefor must contain least one e es symbol state expans monoton state deriv contain state deriv e state transit graph es strongli connect must exist least one path e essenti state imposs reach essenti state e es s q represent state space essenti state theorem hold state graph strongli connect consid simpl case state graph consist two subgraph g g g g individu strongli connect path exist g g vice versa state expans process start state contain state g state g subgraph g produc order gener entir state graph state expans must start state g howev livelock error g transit g may report case accord condit section overcom problem isol subgraph analyz them protocol design cannot determin whether state graph strongli connect advanc is howev normal safe start state expans process initi state cach invalid usual state system turn on accumul state inform accumul compact state inform composit state major strength ssm method approach consid simpl state transit caus read miss assumpt atom memori access essenti state initi processor copi block read miss cach receiv share data copi cach remain invalid state order reach state share share invalid cover share tradit state enumer method would need model least three cach gener difficult predict number cach need model reach possibl state protocol ssm method elimin uncertainti sinc verifi protocol model independ number processor correspond state enumer ssm model shown ssm expans monoton still need prove abstract ssm state transit system r s r a r s r equival explicit state transit system ms a s s d respect properti section correspond relat j ssm follow definit correspond relat state correspond state ie r js one state abstractli repres r state local automaton number local automata state must case cover repetit constructor r j name alway find abstract initi state r correspond initi state explicit model instanc normal start verif initi state cach copi exist case cach invalid invalid invalidinvalid theorem consid state transit system ms a s s d explicit model an arbitrari number of local automata abstract state transit model r ssm consid two state state local automaton given r js find r jtthen state violat properti section iff r error state r proof regard data consist complet specif proof direct cons r q n rn s im q jn im q j im q j s r q n rn im q jn quenc theorem one state repres r ie r js monoton oper ssm guarante state character r furthermor data consist complet specif properti check current state independ state for instanc data inconsist found processor allow read stale data definit thu r must error state error state vice versa show absenc simpl deadlock livelock defin definit need show processor never trap abl complet read write eventu sec tion consid explicit model trap subset state s sn s abstract ssm model r must correspond set state s r r r sn r r si r jsi theorem theorem suppos circular loop s r r r sn r r broken enabl transit si r r correspond exit si must exist ti r jt r constitu finit state machin q protocol error detect sinc unexpect messag recept error easi detect describ model procedur detect inconsist also present subtl livelock error found cours verif final compar perform ssm method murj term time complex memori usag verif result report here expans process start initi state cach copi empti messag channel state ssm method initi state free data inconsist detect mechan data inconsist base model describ section statu variabl ad cach channel messag carri data possibl valu nodata n fresh f obsolet o statu memori copi fresh f obsolet o movement data copi model assign statu one variabl anoth variabl figur state class augment parenthes statu associ everi data valu figur illustr state transit trigger read miss request reqsc transit end owner copi cach accord definit owner fresh copi wherea copi includ memori copi becom obsolet data inconsist detect whenev processor read obsolet data livelock expans step lead livelock origin protocol describ ini tialli consid system state owner request progress directori entri free state form free data transfer detect data inconsist ssm consid follow scenario owner replac copi write block back memori state indic writeback messag output channel n data f f reqsc wmp n fresh copi cach state fresh copi propag cach copi directori free accept new request memori copi fresh n data f data f f reqsc wmp n state transit memori respond reqsc request n data f f reqsc wmp n load data memori aggreg state transit n data f f reqsc wmp n mani intermedi state shown writemiss request load data memori success invalid cach copi n f reqsc wmp n state transit receiv data execut pend write new owner fresh data memori copi becom obsolet next cach experi write miss send request exclus copi new state free race exist writeback ownership messag case nonfifo network livelock detect ssm memori receiv ownership messag writeback messag case memori state chang xownc invalid invo sent cach memori still record cach owner result state xownc cach receiv invo messag chang state txoi system state becom xownc wmp f doxmr reqoc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo f synch nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif f synch nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpf doxmr reqoc initi state loop forev sink state memori receiv reqoc read miss miss miss read miss read miss read miss miss miss cach receiv nack memori receiv abort reqsc cach receiv nack cach receiv nack cach receiv nack memori receiv abort reqsc memori receiv abort reqsc memori receiv abort reqsc memori receiv abort request memori receiv abort request memori receiv abort request memori receiv abort request cach receiv nack cach receiv nack cach receiv nack cach receiv nack memori receiv doxmr cach receiv invo memori receiv doxmr wmp invo doxmr txoi final memori receiv writeback messag enter synchron state synch expect synchron messag sack cach figur system state synch howev synchron messag never sent cach lock directori entri forev ssm method error success detect report cycl exist four global state without exit state outsid loop shown figur the global state transit diagram strongli connect error detect present murj system check connect global state diagram overwhelmingli complex size global state diagram larg livelock condit origin fact memori check presenc bit receiv ownership request livelock remov follow correct protocol memori receiv reqoc messag check whether processor identifi messag correspond current owner doe memori state chang synchron state synch directli follow state diagram figur later writeback messag arriv memori updat copi block suppli cach copi block unlock directori entri comparison murj system murj system develop dill et al base state enumer two version murj nonsymmetr murj system murjn symmetr murj system murj murjn two system state equival ident wherea murj exploit symmetri system use characterist state repres state permut exampl two system state compos three local cach state share share invalid invalid share share deem equival order cach state global state represent irrelev correct protocol time complex memori usag verif close relat size system state space gener exhaust search algorithm perform three fundament oper gener new state left otherwis termin report final set global state compar new state set previous visit state keep new state futur expans new state visit befor timeconsum step compar new state previous visit state time complex grow proport size search space the set state gener analyz procedur memori usag increas size global txoi state space the set state save report end sinc search space direct expans global state space reduc size global state space particularli import murj incorpor state encod reduc memori usag hash tabl speed search comparison oper optim implement ssm tabl show perform comparison murjn murj ssm run model mbyte memori verif protocol make follow observ first smallscal system less five processor time complex memori usag murjn murj toler second size global state space search space murj significantli less murjn littl differ time taken method case four processor system observ murj take longer murjn the extra overhead due state permut map murj may explain thi processor ad model verif time memori usag increas drastic case compar murj ssm effici verif base ssm run second mbyte memori state space global state compar small fact perform classic enumer techniqu accept small system size rais question whether elabor approach ssm realli need sinc final set essenti state report ssm cover possibl state system reach essenti state maximum number base machin differ state repres complex state system verif use ssm complex essenti state consist base machin differ state mean system model least processor requir obtain error coverag state enumer method case murjn observ roughli time increas size search space time one process ad model trend continu proce sor search space could reach size state model processor time comparison ssm murjn murj method number processor size global state space size search space verif time memori usag mbyte murjn excess memori usag over mbyte murj ssm n memori space need verif complex would prohibit exist machin protocol verifi paper number messag float one messag channel time bound spite fact number processor model arbitrari howev ssm method preclud possibl protocol may allow processor send multipl even arbitrari number messag type result model messag channel may need adapt use finit variabl repres infinit system behavior case repetit constructor might use keep track abstractli number messag type ssm method detect protocolintrins livelock section number global state report rel small state case time complex check connect global state transit diagram manag murj conclus cach coher protocol design system assum nonfifo network requir system adapt rout faulttoler interconnect network paper verifi directorybas cach coher protocol nonfifo network verif protocol done murj system ssm method gener speak ing studi found murj system effect verifi smallscal system manag complex howev shown that protocol verifi paper system model least processor requir order reach error cover age mani processor complex state space search would prohibit murj system wherea perform ssm show could deal much complex protocol one use paper overal ssm method offer three advantag classic state enumer method state abstract first overcom state explos problem second sinc entir global state space symbol repres small number essenti state time complex check connect global state transit diagram need livelock detect manag third verifi protocol system size recent ip dill integr variat ssm method murj tool expand explicit state infer abstract state base gener explicit state wherea tool work directli abstract state therefor new murj tool may requir multipl run ad one processor model consecut run reach complet verif result obtain method experi confirm classic state enumer approach suffici verifi protocol system small number processor wherea method base symbol state represent ssm critic futur design complex protocol largescal multiprocessor architectur model figur memori access made sever consecut event thu atom constrain way sequenc access gener processor moreov hardwar distinguish synchron instruct regular loadstor instruct so paper latenc toler mechan processor cach model assum mechan correct enforc proper sequenc order memori access howev methodolog ssm preclud verif consist presenc latenc toler hard ware order includ latenc toler hardwar synchron access must model sequenc access gener processor constrain memori consist model approach appli delay consist protocol specifi wherea state enumer approach appropri verifi coher properti seem applic verif memori access order reason one found way far formul verif properti memori order state enumer graph thu verif memori access order must still reli test procedur manual proof acknowledg research support nation scienc foundat grant no ccr also want acknowledg contribut david l dill c norri ip provid invalu inform murj system r a lazi cach algorithm the cach coher problem sharedmemori multiprocessor cach coher protocol evalu use multiprocessor simul model a new solut coher problem multicach sy tem directorybas cach coher larg scale multiprocessor reason parallel architectur protocol represent finitest model protocol verif hardwar design aid memori access buffer multiprocessor delay consist effect miss rate parallel program mem ori consist event order sharedmemori multiprocessor prove sequenti consist high perform share memori verif distribut cach memori use abstract commun sequenti process algorithm autom protocol verif better verif symmetri verifi system replic compon murj the stanford flash multiprocessor design the directorybas cach coher protocol dash multiprocessor formal verif gigamax cach consist protocol the smp scalabl share memori multiprocessor the verif cach coher protocol a new approach verif cach coher proto col a survey techniqu verifi cach coher proto col verifi distribut directorybas cach coher protocol smp case studi symbol state model new approach verif cach coher protocol formal verif delay consist protocol tempest typhoon userlevel share memori a survey cach coher scheme multiprocessor data coher problem multicach system toward analyz synthes protocol tr cach coher protocol evalu use multiprocessor simul model memori access buffer multiprocessor cach coher problem sharedmemori multiprocessor lazi cach algorithm survey cach coher scheme multiprocessor directorybas cach coher largescal multiprocessor prove sequenti consist highperform share memori extend abstract delay consist effect miss rate parallel program reason parallel architectur verif cach coher protocol stanford flash multiprocessor tempest typhoon symbol state model verif techniqu cach coher protocol commun sequenti process new approach verif cach coher protocol protocol verif hardwar design aid formal verif delay consist protocol verifi distribut directorybas cahc coher protocol verif distribut cach memori use abstract verifi system replic compon murphi better verif symmetri