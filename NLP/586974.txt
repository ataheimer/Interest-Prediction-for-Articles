t simpl confluent persist caten list a consid problem maintain persist list subject concaten insert delet end updat persist data structur nondestructiveeach oper produc new list incorpor chang keep intact list list appli although gener techniqu exist make data structur persist techniqu fail structur subject oper caten combin two version paper develop simpl implement persist doubleend queue dequ caten support dequ oper constant amort time implement function allow memoiz b introduct last fteen year consider develop persist data structur current version also older one avail access partial persist updat full per sistenc particular driscol sarnak sleator tarjan develop ecient gener method make pointerbas data structur partial fulli persist dietz develop ecient gener method make arraybas structur fulli persist gener method support updat appli singl version structur time accommod oper combin two dierent version structur set union list caten driscol sleator tarjan coin term con uentli persist fulli persist structur support combin oper altern way obtain persist use pure function program take extrem strict view pure function disallow lazi evalu memoiz techniqu listbas data structur design pure function program amount use lisp function con car cdr pure function data structur automat persist inde con uentli persist simpl import problem data structur design make issu con uent persist concret implement persist doubleend queue dequ caten seri paper culmin work kaplan tarjan develop con uentli persist implement dequ caten worstcas constant time space bound dequ oper includ caten kaplantarjan data structur precursor obtain con uent persist pure function depart comput scienc tel aviv univers tel aviv israel haimkmathtauacil depart comput scienc columbia univers new york ny research carnegi mellon univers support advanc research project agenc csto titl the fox project advanc languag system softwar arpa order no c issu escen contract no fc cokasakicscolumbiaedu z depart comput scienc princeton univers princeton nj intertrust technolog corpor sunnyval ca research princeton univers partial support nsf grant no ccr retcsprincetonedu one care persist pure function program unnecessarili restrict particular okasaki observ use lazi evalu combin memoiz lead ecient function but pure function sens data structur con uentli persist order analyz structur okasaki develop novel kind debitbas amort use techniqu weaken time bound worstcas amort abl consider simplifi kaplantarjan data structur particular elimin complic skeleton encod tree extens redund digit number system paper explor problem simplifi kaplantarjan result obtain con uentli persist implement dequ caten constant amort time bound per oper structur substanti simpler origin kaplantarjan structur even simpler okasaki caten dequ wherea okasaki requir ecient persist dequ without caten build block structur entir selfcontain furthermor analysi use standard creditbas approach give two altern close relat implement method rst use memoiz second save small constant factor time space use extens memoiz express replac equival express remaind paper consist section section introduc terminolog concept section illustr approach develop persist implement dequ without caten section extend approach handl stack caten section develop solut dequ caten conclud section remark open problem extend abstract work appear preliminari object studi list allow follow oper list return new list contain singl element x return new list form ad element x front list l popl return pair whose rst compon rst element list l whose second compon list contain second last element l return new list form ad element x back list l return pair whose rst compon list contain last element l whose second compon last element l catenatel r return new list form caten l r l rst seek implement oper or specic subset them persist list oper allow previous construct list list time discuss variou form persist see stack list push pop allow queue list inject pop allow stequ stackend queue list push pop inject allow final dequ doubleend queue list four oper push pop inject eject allow four structur may may allow caten caten allow push inject becom redund sinc special case caten sometim conveni treat separ oper easier implement gener caten say data structur pure function built manipul use lisp function car con cdr is structur consist set immut node either atom node contain two pointer node cycl pointer node use build structur actual contain xed number eld reduc structur two eld per node ad addit node straightforward variou node structur repres list obtain result extend pure function allow memoiz function evalu node second time function evalu node valu simpli retriev previou comput construct constant number memoiz function one two implement memoiz node point result appli memoiz function it initi pointer unden rst function evalu ll appropri pointer indic result subsequ evalu mere follow pointer result take time also consid use substanti extens pure function allow oper replac node structur anoth node repres list replac perform imper set replac eld node instanc lisp use replaca replacd replac view gener memoiz structur node replac twice mean structur implement writeonc memori it easi convert algorithm overwrit eld xed constant number time writeonc algorithm constantfactor loss ecienc use overwrit instead memoiz save small constant factor run time storag space slightli simpli amort analysi perform amort analysi use standard potentialbas framework assign congur data structur the total node current exist potenti dene amort cost oper actual cost plu net increas potenti caus perform oper applic potenti empti structur zero potenti alway nonneg follow that sequenc oper start empti structur total actual cost oper bound sum amort cost see survey paper complet discuss amort analysi noncaten dequ section describ implement persist noncaten dequ constant amort time bound per oper structur base analog kaplantarjan structur much simpler result present illustr techniqu amort analysi persist data structur end section comment relat structur propos previous exist solut represent subsequ section say data structur set store element a represent recurs built boundeds dequ call buer contain three ele h kaplan c okasaki r e tarjen ment buer two kind prex sux nonempti dequ repres order tripl consist prex a denot prd possibl empti child dequ order pair a denot cd sux a denot sfd pair consist two element a child dequ cd nonempti repres way dene set descend dequ standard waynam c exist order element dequ dene recurs one consist order tripl buer pair child dequ thu order element dequ rst element prd element pair cd nalli element sfd gener represent dequ uniqueth sequenc element may repres tripl dier size prex sux well content represent descend dequ whenev refer dequ actual mean particular represent d one clear context pointer represent represent obviou one node repres dequ contain pointer prd cd sfd note pointer structur essenti link list descend sinc c d contain pointer c i d i oper implement dequ oper straightforward except maintain size bound buer specic push dequ easi unless prex size three pop dequ easi unless prex empti symmetr statement hold inject eject deal buer ow ow proactiv fashion rst xing buer oper perform cannot violat size bound actual oper detail follow dene buer green contain one two element red contain zero three dene two memoiz function dequ gp construct represent list green prex gs construct represent list green sux appli gp gs respect list whose prex sux red made green specic gp prex empti child dequ must nonempti symmetr gs give implement push pop gp implement inject eject gs symmetr denot dequ prex p child dequ c sux p c s mention section implement memoiz gp gs node point node result appli gp gs it initi pointer unden prd empti cd not let nonempti let x return pair x p ce sfe otherwis ce must empti let x return pair x s y z three element prd let p prex contain x let c prd empti cd not let x prex contain x follow y return p analysi amort analysi method reli memoiz gp gs call node repres dequ secondari return call gp gs primari otherwis secondari node construct call gpx gsx respect way access later via anoth call gpx gsx respect secondari node return result push pop inject eject oper mean gp gs call primari node devid node repres dequ three state node rr buer red gr exactli one buer red gg buer green subdivid rr gr state rr node rr neither gp gs appli it rr exactli one gp gs appli it rr gp gs appli it gr node gr neither gp gs appli it gr otherwis discuss everi secondari node gr gg dene rr rr gr number primari node state rr rr gr respect dene potenti collect node repres dequ rr call push either termin result call gp turn call push similarli call pop either termin result call gp turn call pop charg o time spent call gp exclus inner call push pop push pop call gp call push result sequenc recurs call push via call gp bottommost termin rest nontermin nontermin push one follow eect convert primari rr node rr creat new primari gr node the result push new secondari gr node the result call gp convert primari rr node rr creat new primari gr node new secondari gr node or convert primari gr node gr creat new primari gg node new secondari gg node case total potenti drop one pay time need push exclud recurs call termin push take o time creat o new node increas potenti o conclud push take o amort time analog argument appli pop inject eject give us follow theorem theorem oper push pop inject eject dene take o amort time implement use overwrit memoiz implement describ abov primari rr node give rise two secondari gr node repres list primari gr node give rise secondari gg node repres list redund represent exist simultan gr represent howev domin rr represent perform dequ op erat gg represent domin gr represent allow us improv ecienc implement use overwrit place memo izat gp call node overwrit content node result gp comput similarli gs one represent list exist time evolv rr gr gg via one two altern path depend whether gp gs call rst node need three eld for prex child dequ sux instead two extra gp gs use overwrit save constant factor run time storag space also simpli amort analysi follow dene rr gr number node state rr gr respect there secondari node dene potenti collect node rr gr nontermin push one follow eect convert rr h kaplan c okasaki r e tarjen node gr creat new gr node convert gr node gg creat new gg node either case reduc potenti one pay o time requir push exclud recurs call termin push take o time increas potenti o conclud push take o amort time similar argument appli pop inject eject relat work structur describ base kaplantarjan structur section simpli three way first skeleton structur the sequenc descend stack kaplantarjan structur skeleton must partit stack stack order support worstcas constanttim oper via redund binari count mechan second recurs chang structur make node green onesid instead twosid origin structur stackofstack mechan requir coordin keep side structur relat state third maximum buer size reduc three special case stequ maximum size sux reduc two special case queue prex sux reduc maximum size two altern much older approach use increment recopi obtain persist dequ worstcas constanttim oper see discuss approach increment recopi approach yield arguabl simpler structur one present here structur gener allow caten one know implement ecient use increment recopi also structur extend support access insert delet posit away end list olog d amort time appli idea caten stequ section show extend idea support caten specic describ data structur caten stequ achiev o amort time bound push pop inject caten data structur base recurs decomposit list section pointer structur need much simpler analysi amort follow framework outlin section use section represent structur similar structur section slightli dierent denit compon part section use buer two kind prex sux prex contain two six element sux contain one three element nonempti stequ repres either sux sfd onli order tripl consist prex prd a child stequ cd pair a sux sfd a contrast section pair dene order pair contain prex possibl empti stequ pair a observ denit add addit kind recurs pair store stequ structur section extra kind recurs allow ecient caten order element stequ one consist order tripl buer pair stequ within pair child stequ section mani dierent represent stequ contain given list element speak stequ mean particular represent it pointer structur represent straightforward tripl repres node contain three pointer prex child stequ sux pair repres node contain two pointer prex stequ oper implement stequ oper much like implement noncaten dequ oper present section call prex red contain either two six element green otherwis call sux red contain three element green otherwis prex suxonli stequ consid color sux dene two memoiz function gp gs produc greenprex greensux represent stequ respect call correspond buer red made green dene push pop inject call gp gs necessari obtain green buer denit below repres stequ prex child stequ c sux p c s case stequ repres tripl case stequ repres sux onli creat prex p contain x rst two element sfd creat sux contain last element sfd return p s otherwis creat sux push x onto sfd return s case stequ repres tripl case stequ repres sux onli creat sux contain x return sfd s otherwis creat sux inject x sfd return s case repres tripl first caten buer sfd prd obtain p now calcul c follow jpj let c creat two new prex p contain rst four element p p contain remain element let c either case return case repres sux onli push inject element suxonli stequ onebyon stequ note push caten produc valid stequ even second argument stequ prex length one although stequ normal allow may exist transient pop everi stequ immedi pass push caten discard howev order dene pop gp gs oper dene n aivepop oper simpli pop stequ argument without make sure result valid stequ repres tripl let x return consist sux onli let x pair x case stequ repres sux jprdj return n aivepopd case stequ repres tripl x rst element prd second jsfdj push onto sfd form h kaplan c okasaki r e tarjen return x s otherwis jsfdj form p rst two element sfd form last element sfd return x p s case stequ repres tripl creat two new prex p p split prd equal two let c cd proceed follow inspect rst pair p cd jpj empti let p inspect p case p contain least four element pop rst two element p form inject two element prd obtain p let c return case p contain three element push two element prd onto p obtain p let c nonempti c return stequ repres tripl contain rst two element sfd last element sfd let c return analysi analysi method similar analysi section dene primari secondari node node state potenti function exactli section potenti function there rr rr rr gr number primari node state rr rr gr respect section charg o cost call gp gs exclud cost recurs call push pop inject push pop inject call gp gs amort cost push inject o argument ident use analyz push section oper caten call push inject constant number time creat singl new node amort cost also o analyz pop assum call pop recur depth k via interven call gp argument analog push rst k call pay decreas potenti one termin call pop result call either push caten o amort cost follow overal amort cost pop o give us follow theorem theorem oper push pop inject caten dene take o amort time improv time space ecienc stequ data structur constant factor use overwrit place memoiz exactli describ section thi also simplifi amort analysi exactli describ section relat work structur present section analog kaplantarjan structur section structur section simpli follow first buer constantbound size wherea structur section use noncaten stequ buer structur section use noncaten stack buer buer turn must repres section paper use one method mention there contrast structur present section entir self contain second skeleton present structur stack instead stack stack third chang use make buer green appli onesid needdriven way repair must made simultan side structur care chosen locat okasaki devis dierent somewhat simpler implement con uentli persist caten stequ also achiev o amort bound per oper solut obtain ecienc implicitli use form path revers addit lazi evalu memoiz structur extend doubleend case shall see next section whether okasaki structur extend case open problem caten dequ section show extend idea support list oper specic describ data structur caten dequ achiev o amort time bound push pop inject eject caten structur base upon analog structur okasaki simpli use constants buer represent use three kind buer prex middl sux nonempti dequ repres either sux sfd tupl consist prex prd left dequ tripl ldd middl mdd right dequ tripl rdd sux sfd tripl consist rst middl buer dequ tripl last middl buer one two middl buer tripl must nonempti tripl contain nonempti dequ middl must nonempti buer tripl a prex sux tupl contain three six element sux suxonli represent contain one eight element middl tupl contain exactli two element nonempti middl buer tripl contain two three element order element dequ one consist order tupl buer tripl recurs dequ pointer structur straightforward node repres tupl tripl contain one pointer eld oper call prex sux tupl red contain either three six element green otherwis call sux suxonli represent red contain eight element green otherwis prex suxonli dequ consid color sux introduc two memoiz function function gp gs section produc greenprex greensux represent dequ respect call correspond buer red made green give implement push pop gp caten implement inject eject gs symmetr push pop gp respect denot dequ prex p left dequ l middl m right dequ r sux p l m case dequ repres tupl otherwis let case dequ repres sux onli sfd return suxonli dequ sux pushx sfd otherwis push x onto sfd form s nine element creat new prex p rst four middl next two sux last three return p m s section implement pop use n aivepop case dequ repres sux jprdj return n aivepopd case case x rst element prd creat new sux contain element prd mdd sfd except x return pair consist x dequ repres onli otherwis form p prd pop x inject rst element mdd mdd pop rst element inject rst element sfd form sfd pop rst element return x creat two new prex p p p contain rst four element jprdj p last two return p pushp proceed follow case ldd inspect rst tripl ldd either rst nonempti middl buer contain element contain nonempti dequ let t assum x nonempti consist one nonempti middl buer appli appropri one folow two subcas case form x x p prd pop rst element x inject prd return case inject element x prd form p empti return p l mdd rdd sfd otherwis d nonempti let l case inspect rst tripl rdd either rst nonempti middl buer contain element contain nonempti dequ let assum x nonempti consist one nonempti middl buer appli appropri one follow two subcas case x prd m x pop element inject prd form p pop element inject rst element x form pop rst element x form x return case inject two element mdd prd form p let empti r return case repres tupl let rst element prd let x last element sfd creat new middl contain x follow y partit element sfd fxg two buer contain two three element order possibl empti let ld ld otherwis let ld ld similarli partit element prd fyg two prex contain two three element order possibl empti let rd return prd ld case repres sux onli push inject element suxonli dequ onebyon dequ analysi analyz structur use denit potenti function section amort cost push inject caten pop o argument analog section amort cost eject o argument symmetr pop thu obtain follow theorem theorem oper push pop inject eject caten dene take o amort time section improv time space constant factor simplifi analysi use overwrit place memoiz overwrit prefer implement unless one use function program languag support memoiz easili allow overwrit relat work structur present section analog structur chapter section simpli follow first buer constant size wherea noncaten dequ second skeleton present structur binari tree instead tree extens redund digit number system also amort analysi use standard potenti function method rather complic debit mechan use anoth relat structur section repres pure function realtim dequ pair tripl rather tupl otherwis similar but simpler than structur section straightforward modifi structur present use pair tripl rather tupl result open question univers element dequ construct total order extend structur describ support addit heap order base order a specic support addit oper nding minimum element dequ but delet it preserv constant amort time bound everi oper includ nding minimum mere store buer dequ pair tripl minimum element it relat work see also support ip oper dequ ip oper revers linear order element dequ ith front becom ith back viceversa noncaten dequ section implement ip maintain revers bit ip ip oper revers bit set push becom inject pop becom eject inject becom push eject becom pop support caten well ip use revers bit level must also symmetr denit section allow dequ repres prex onli extend variou oper handl possibl interpret revers bit cumul is dequ x dequ insid d x regard revers odd number revers bit set along path actual pointer structur node node x perform caten revers bit either two dequ push bit ip bit dequ x ip bit dequ x point swap appropri buer dequ the prex sux exchang role left dequ right dequ order element prex sux revers well pushdown revers bit assembl new dequ overwrit old one devis altern implement caten dequ size prex sux instead memoiz pop eject oper avoid creat new structur green prex sux respect repres origin dequ perform pop eject respect use complic potenti function one use earlier section show implement run o amort time per oper one direct futur research nd way simplifi structur fur ther specic consid follow altern represent caten de que use singl recurs subdequ rather two subdequ nonempti dequ repres tripl consist prex prd possibl empti child dequ tripl cd sux sfd tripl consist nonempti prex dequ tripl nonempti sux nonempti prex sux buer tripl a oper push pop inject eject implement similar implement section major dierenc implement caten structur requir call pop specic let two dequ caten caten pop cd obtain tripl p new dequ c inject s c sfd obtain push p prd nal result prex prd child dequ c sux sfd open question whether algorithm run constant amort time per oper constant upper lower bound buer size anoth research direct design con uentli persist represent sort list access updat posit either end take olog d time caten take o time best structur far develop problem doubli logarithm caten time pure function time bound worstcas acknowledg thank michael goldwass detail read paper jason hartlin discuss led implement use memoiz r data structur bootstrap con uentli persist dequ via data structur boot strap fulli persist array fulli persist list caten make data structur persist dequ heap order list phd thesi simpl con uentli persist caten list ex tend abstract optim ram implement caten min doubleend queue amort comput complex worst case analysi set union algorithm tr ctr amo fiat haim kaplan make data structur confluent persist journal algorithm v n p august georg lagogianni yanni panagi spyro siouta athanasio tsakalidi survey persist data structur proceed th wsea intern confer comput p juli athen greec