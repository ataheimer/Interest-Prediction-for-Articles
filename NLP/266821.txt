t improv accuraci perform memori commun renam a processor continu exploit instructionlevel parallel greater demand place reduc effect memori access latenc paper introduc novel modif processor pipelin call memori renam memori renam appli regist access techniqu load instruct reduc effect delay caus need calcul effect address load preced store data fetch memori renam allow processor specul fetch valu produc data reliabl determin without need effect address work extend previou studi data valu depend specul memori renam ad processor pipelin renam appli memori refer translat overal improv execut time furthermor improv seen across memori segmentsinclud heap segment often difficult manag effici b introduct two trend design microprocessor combin place increas burden implement memori system aggress wider instruct issu higher clock speed instruct push pipelin per cycl proportion increas process memori oper account approxim instruct time gap processor dram clock speed dramat increas latenc memori oper cach univers adopt reduc averag memori access latenc aggress outoford pipelin execut along nonblock cach design employ allevi remain latenc bypass stall instruct unfortun instruct reorder complic necess calcul effect address memori oper wherea depend registerregist instruct identifi examin operand field memori depend cannot determin much later pipelin when effect address calcul result mechan specif load store eg mob pentium pro requir resolv memori depend later pipelin enforc memori access semant date effect solut deal ambigu memori depend requir stall load earlier unknown store address exist approach is howev overli conserv sinc mani load stall await address store depend on result increas load instruct latenc reduc program perform paper propos techniqu call memori renam effect predict memori depend store load instruct allow dynam instruct schedul accur determin load commenc execut addit reorder independ memori ref erenc flexibl develop improv dynam schedul achiev tech niqu memori renam enabl load instruct retriev data effect address calcul achiev identifi relationship load previou store instruct gener data new mechan employ use identifi associ storeload pair address valu bypass normal address mechan term memori renam come similar approach abstract operand specifi perform regist renam paper examin characterist memori refer stream propos novel architectur modif pipelin enabl specul execut load instruct earli pipelin befor address calcul thi true depend elimin particular true depend support complex address calcul use access program data shown signific impact overal perform as much speedup experi present remaind paper organ follow section examin previou approach specul load instruct section introduc memori reorder approach specul load execut evalu regular memori activ order identifi success strategi execut load specul section show one possibl integr memori renam outoford pipelin implement section provid perform analysi cycl level simul tech niqu section state conclus identifi futur research direct work background number studi target reduct memori latenc austin sohi employ sim ple fast address calcul earli pipelin effect hide memori latenc achiev target simpl baseoffset address mode use refer global stack data dahl okeef incorpor address bit associ regist provid hardwar mechan disambigu memori refer dynam allow compil aggress place frequent referenc data regist file even alias may present dramat reduc number memori oper must execut lipasti shen describ mechan valu load instruct predict base previou valu load instruct work use load valu predict unit hold predict valu along load classif tabl decid whether valu like correct base past perform predictor observ larg number load instruct bring valu time time specul use data valu last load instruct depend resolv abl remov depend critic path when specul accur use approach abl achiev speedup execut for simpl implement with infinit resourc perfect predict sazeid vassiliadi smith use address specul load instruct remov depend caus calcul effect address enabl load instruct proceed specul without address operand effect address comput particular load instruct remain constant as global variabl refer final moshovo breach vijaykumar sohi use memori reorder buffer incorpor data depend specul data depend specul allow load instruct bypass preced store ambigu depend resolv greatli increas flexibl dynam instruct schedul find memori instruct readi exe cute howev specul bypass violat true depend load store instruct flight state machin must restor point load instruct misspecul instruct load must abort reduc number time misspecul occur predict confid circuit includ control bypass allow confid mechan differ use valu predict locat depend pair store load instruct instead base confid histori load instruct onli refer predict ad multiscalar architectur execut perform improv averag approach specul extend valu predict depend predict perform target specul load instruct earli architectur pipelin renam memori oper memori renam extens processor pipelin design initi load instruct earli possibl combin depend predict valu predict achiev greater perform possibl either techniqu alon basic idea behind memori renam make load instruct look like regist refer therebi process load similar manner difficult achiev memori refer instruct unlik simpl operand specifi use access regist requir effect address calcul depend analysi perform elimin need gener effect address critic path access load data perform load specul use program counter pc load instruct index retriev specul valu similar approach use lipasti shen valu predict except memori renam perform indirectli load instruct en counter pc address associ load ldpc use index depend tabl call storeload cach determin like produc data gener store instruct recog valu file storeload cach specul load data figur support memori renam nize data referenc load instruct like produc singl store instruct data last execut store retriev valu file access valu file entri perform specul without need know effect address load store instruct instead valu file index uniqu identifi associ storeload pair thi mechan describ next section store instruct also use storeload cach locat entri valu file like referenc futur load store load instruct pair determin refer locat map valu file index figur show overview memori renam mechan approach advantag pro ducerconsum relationship exist load proceed earli pipelin effect address calcul proceed usual memori oper retriev valu dcach done valid specul valu brought valu file data load dcach match valu file specul success process continu unfett valu differ state processor must correct order memori renam improv processor perform may prudent includ predict confid mechan capabl identifi specul warrant valu predict depend predict use histori base scheme identifi specul like succeed unlik valu renam chose identifi stabl storeload pair instead reli static valu refer see advantag use producerconsum relationship confid mechan analysi shown spec benchmark program compil gnu gcc ver sion gnu ga version gnu gld version maximum optim o loop unrol enabl funrollloop fortran code first convert c use att fc version experi perform extend version simplescalar tool set tool set employ simplescalar instruct set virtual mipslik architectur tabl benchmark applic descript bench instr load valu addr prod mark mil mil local loc loc go gcc compress li tomcatv sucor hydrod mgrid sever approach improv process memori oper exploit regular refer stream regular found stream valu load memori effect address calcul perform depend chain creat store load instruct tabl show regular found differ characterist memori traffic first three column show benchmark name total number instruct execut total number load forth column show percentag load execut con stant near constant valu percentag shown often load instruct fetch data valu two success execut thi measur valu local shown tabl surpris number load instruct execut bring valu last time averag spec integ benchmark specfp benchmark surpris much regular exist valu reus percentag cover third load column show percentag load execut refer effect address last time show regular effect address reus final column show percentag time produc valu remain unchang success instanc load instruct mean store instruct gener data load see relationship far stabl even valu transfer chang differ memori locat use transfer relationship sourc store load remain stabl statist led us use depend pair store load instruct identifi specul would profit experiment pipelin design support memori renam pipelin must extend identifi storeload commun pair promot commun regist commun infrastructur verifi specul forward valu recov pipelin specul storeload forward unsuccess follow text detail enhanc made baselin outoford issu processor pipelin overview extens processor pipelin loadstor queue entri shown figur promot memori commun regist memori depend predictor integr front end processor pipelin de code storeload cach probe for store load index valu file entri assign depend edg access hit storeload cach valu file index return propag renam stage otherwis entri alloc storeload cach instruct addit valu file entri alloc index entri store storeload cach may seem odd alloc entri load valu file howev found simul benefici optim promot constant rare store variabl valu file permit access also benefit faster accur commun synchron addit decod stage hold confid counter renam load counter increment load sourc store predict correctli decrement or reset predict incorrectli renam stage pipelin load use valu file index pass decod stage access entri valu file valu file return either valu last store predict depend edg valu process comput ie flight loadstor queue reserv station index return reserv station index return load stall sourc store data written store reserv station renam load complet broadcast result depend instruct regist memori schedul oper specul load result without modif load specul otherwis access memori system renam load valu return memori system compar predict valu valu match load data misspecul occur pipelin recoveri initi unlik load store instruct access valu file retir time store deposit store data valu file memori sy tem later renam load refer valu abl access directli valu file attempt made maintain coher valu file main memori content diverg due to exampl extern dma pipelin continu oper correctli incoher detect renam load valu compar actual memori content initi bind store load creat load renam refer data produc renam store explor two approach detect new depend edg simplest approach look renam store forward load loadstor queue forward network ie commun instruct flight edg detect storeload cach entri load updat accordingli slightli capabl approach attach valu file indic renam store data propag indic memori hierarchi approach perform better detect longerliv depend edg howev extra storag valu file indic make approach expens recov misspecul renam load inject incorrect valu program comput correct program execut requir that minim instruct use incorrect valu depend instruct reexecut end explor two approach recov pipelin data misspecul squash reexecut recoveri two approach exhibit vari cost complex later see lower cost misspecul recoveri mechan enabl higher level perform sinc permit pipelin promot memori commun regist infrastructur squash recoveri expens perform penalti simplest approach implement approach work throw away instruct misspecul load instruct sinc depend instruct follow load instruct restrict depend instruct reexecut inde met unfortun approach decod renam schedul writeback loadstor queue entri storeload cach valu id conf renam writeback valu file lsq entri lru opt valu id schedul lru logic resv station load store inst specul forward resv station loadstor queue ld pred ldd st std loadstor data stdldd fault loadstor address valu file index loadstor queue ld pred ldd st std specul std forward result nonspecul ldd from lsq mem pred nonspec recov loadstor addr commit loadstor queue ld pred ldd st std memori system valu file figur pipelin support memori renam shown addit made baselin pipelin support memori renam solid edg writeback stage repres forward reserv station dash line repres forward loadstor queue also shown field ad shown gray instruct reorder buffer entri throw away mani instruct independ mi specul load result requir mani unnecessari re execut advantag approach requir littl support implement today misspecul load may treat misspecul branch reexecut recoveri complex significantli lower cost squash recoveri approach leverag depend inform store reserv station notyet retir instruct permit reexecut instruct depend specul load valu cost approach ad pipelin complex implement reexecut inject correct result misspecul load onto result bu depend instruct receiv correct load result reexecut rebroadcast result forc depend instruct reexecut on sinc nontrivi instruct know mani operand regener re execut instruct may possibl reexecut multipl time everi regener operand arriv addit depend memori may requir load instruct reexecut accommod depend loadstor queue also recheck memori depend store reexecut reissu depend load instruct addit load may forc reexecut receiv new address via instruct reexecut retir reexecut instruct oldest instruct machin thu cannot receiv regener valu instruct may safe retir section demonstr simul reexecut much less expens approach implement load misspecul recoveri experiment evalu evalu merit memori renam design extend detail time simul support propos design examin perform program run extend sim ulat vari confid mechan misspecul recoveri mechan key system paramet see affect paramet perform methodolog baselin simul detail tabl simplescalar simul suit simul simoutord simul execut userlevel instruct perform detail time simul way superscalar microprocessor two level instruct data cach memori simul implement outoford issu execut model simul executiondriven includ execut specul path detect fault tlb miss mispredict model employ entri reorder buffer implement renam regist storag hold result pend in struction load store place entri loadstor queue baselin simul store execut operand readi valu spec ul place loadstor queue load may execut prior store address comput valu come match earlier store store queue ie store forward data cach specul load may initi cach miss address hit tlb load subsequ squash cach miss still com plete howev specul tlb miss per mit is specul cach access miss tlb instruct dispatch stall instruct detect tlb miss squash commit cycl reorder buffer issu readi instruct commit result inord architect regist file store commit store valu written data cach data cach model fourport k twoway setassoci nonblock cach found earli instruct fetch bandwidth critic perform bottleneck mitig problem implement limit variant collaps buffer describ implement support two predict per cycl within instruct cach block provid significantli instruct fetch bandwidth better pipelin resourc util select benchmark look program vari memori system perform ie program larg small data set well high low refer local analyz program spec benchmark suit integ code float point suit memori renam experi perform entri way set associ storeload cach entri valu file lru replac detect initi depend edg bind propag valu file indic renam store data toplevel data cach load that renam access renam store data valu file index store data cach use updat load storeload cach entri predictor perform figur show perform memori depend predictor graph show hit rate due space restrict omit experi explor predictor perform sensit structur size structur size select elimin capac problem predictor allow us concentr effect leverag predict improv program perform cc comp go hydrod mgrid sucor tomcatv hit rate hit rate figur memori depend predictor perform memori depend predictor benchmark hit rate comput number load whose sourc store valu correctli identifi probe valu file predictor work quit well predict correctli mani pro gram memori depend averag program unlik mani valu predictor mechan depend predictor work well even better float point program better understand depend predictor find depend local broke correct predict segment refer data resid figur show breakdown correct predict data resid global stack heap segment larg fraction correct depend predict much mgrid overal averag came stack refer result surpris consid frequenc stack segment refer semistat na ture ie load store stack often refer variabl mani time later leverag properti improv perform confid mechan global access also account mani correct predict much tomcatv overal averag final signific number correct predict come heap seg ment much go overal averag better understand aspect program result correct predict profil top load examin sourc store found number common case heap access exhibit depend local exampl typic program construct challeng even sophist regist alloc result signific advanc compil technolog elimin memori access assert hold global ac fetch interfac fetch instruct two cach block per cycl separ two branch instruct cach k way setassoci latenc branch predictor bit global histori index entri pattern histori tabl gap bit satur counter cycl mispredict penalti outoford issu outoford issu oper per cycl entri reorder buffer entri mechan loadstor queue load may execut prior store address known architect regist float point function unit integ alu loadstor unit fp adder integ multdiv fp multdiv function unit latenc integ alu loadstor integ mult integ div fp adder data cach k way setassoci writeback writealloc latenc fourport nonblock interfac support one outstand miss per physic regist way setassoci unifi l cach byte block virtual memori k byte page fix tlb miss latenc earlierissu instruct complet tabl baselin simul model cc comp go hydrod mgrid sucor tomcatv breakdown segment global stack heap figur predictor hit memori segment repeat access alias data cannot alloc regist ffl access loop data loop depend distanc one ffl access singleinst dynam storag eg variabl alloc begin program point few immut global pointer discuss section pipelin implement also benefit confid mechan figur show result experi explor efficaci attach confid counter load instruc cess compil must assum alias stack access hand effect regist alloc therebi elimin memori access given processor enough regist note sinc alway predict sourc store last previou one predictor work loop depend distanc greater one even regular access support case current investig tion graph show confid coverag number predictor confid success rate highconfid load coverag fraction correctli predict load without confid cover highconfid predict particular predictor confid coverag shown pre dictor notat use follow xyz x count must reach predictor consid load highconfid load default count increment one predictor correctli predict sourc store valu reset zero predictor fail count increment use opcod load indic access stack pointer z count increment use opcod load indic access global pointer analys show stack global access well behav thu increas coverag without sacrif much confid increment confid counter valu greater one shown figur confid high configur examin much hydrod least experi use confid mechan experi tri increas increment stack global access half confid counter perform best configur usual degrad confid baselin case an increment one access coverag improv enough improv program perform coverag vari significantli number program eg compress hydro d high coverag other cc perl gain higher coverag signific amount confid sacrif anoth interest featur confid measur rel insensit coverag counter threshold confid threshold level rise rein coverag load cc comp go perl hydrod confid load cc comp go perl hydrod figur confid coverag predictor confid counter cc comp go hydrod mgrid sucor tomcatv sq sq re re figur perform vari predic torrecoveri configur forc earlier observ memori depend program rel static occur time often occur fashion much program execut pipelin perform predictor hit rate insuffici tool evalu use memori depend predictor order fulli evalu it must integr modern processor pipelin leverag predict produc correctli handl case predictor fail figur detail perform memori depend predictor integr baselin outoford issu perform simul experi figur show speedup in percent measur cycl execut entir program respect baselin simul four experi shown benchmark figur first experi label sq show speedup found depend predictor util confid configur squash recoveri load misspecul experi sq experi except confid mecha nism re configur employ confid configur util reexecut mechan describ section recov load mi specul final re configur also employ reexecut recoveri mechan util lowerconfid confid configur configur squash recoveri confid mechan ie sq show small speedup mani program fall short other cc saw slowdown littl investig slowdown quickli reveal highcost squash recoveri ie throw away instruct misspecul load often complet outweigh benefit memori renam mani program data misspecul branch mispredict one remedi highcost misspecul permit renam higher confid load experi label sq renam higherconfid load configur perform better suffer less misspecul howev exper iment eg cc show littl speedup still plagu mani highcost load mi specul better remedi high misspecul recoveri cost lower cost misspecul recoveri mech anism experi label re add reexecut support pipelin memori renam support confid mechan design lower misspecul cost allow show speedup experi run much mksim averag overal speedup confirm intuit lower cost reexecut measur directli cost squash recoveri reexecut run count number instruct thrown away due load misspecul found overal reexecut consum less execut bandwidth requir squash recoveri word less instruct flight load misspecul depend misspecul load averag addit reexecut benefit refetch decod issu instruct misspecul load given lower cost cost reexecut explor whether speedup would improv also renam lowerconfid load experi label re employ reexecut recoveri lowerconfid confid configur configur found better perform experi support benefit reexecut also explor use yet even lowerconfid noconfid config urat howev misspecul rate rise quickli configur perform suffer accordingli experi figur take bestperform configur ie re vari two key system paramet see effect efficaci memori renam first experi label fe cut peak instruct deliveri bandwidth fetch stage half configur deliv four instruct one basic block per cycl mani experi cut averag instruct deliveri bw nearli half shown result effect memori renam sever attenu half instruct deliveri bandwidth machin becom fetch bottleneck mani experi fetch bottleneck improv execut perform memori renam littl improv perform program especi true integ code fetch bandwidth limit due mani small basic block second experi figur label sf increas store forward latenc threefold three cy cle store forward latenc minimumlat cycl two oper commun valu memori baselin experi figur minimum store forward latenc one cycl shown graph perform improv due renam rise sharpli much mksim overal sharp rise due increas latenc communicationthrough memori latenc must cc comp go hydrod mgrid sucor tomcatv figur program perform vari system configur toler consum preciou parallel renam memori access howev may commun regist file potenti zero cycl via bypass result significantli lower commun latenc given complex loadstor queue dataflow analysi requir perform one cycl onecycl store forward sinc address comput may arriv previou cycl design may soon resort larger loadstor queue longer latenc store forward trend make memori renam attract fit conclus evalu grade goal set forth begin paper build renam mechan map memori commun regist commun synchron infrastructur hoist memori commun regist permit accur faster memori commun see success goal measur breakdown commun handl loadstor queue data cach memori commun handl loadstor queue handl in flight thu commun benefit renam do figur show benchmark fraction refer servic loadstor queue base configu ration label base fraction refer servic loadstor queue pipelin renam support label re shown figur signific amount commun handl regist commun in frastructur clearli much shortterm commun abl benefit renam support howev number benchmark eg cc xlisp tomcatv still nontrivi amount cc comp go hydrod mgrid sucor tomcatv load base re figur percent memori depend servic loadstor queue shortterm commun identifi depend predictor program execut benefit loadstor queue abil quickli comput loadstor depend address avail one goal work improv perform depend predictor virtual shortterm commun captur highconfid predict continu improv perform memori commun goal attain perform loadstor queue becom less import overal program perform re sult less resourc devot loadstor queue design implement conclus paper describ new mechan design improv memori perform accomplish restructur processor pipelin incorpor specul valu depend predictor enabl load instruct proceed much earlier pipelin introduc predict confid mechan base storeload depend histori control specul valu file contain load store data effici access without perform complex address calcul simul result valid approach improv memori perform show averag applic speedup intend extend studi number way obviou extens work identifi new mechan improv confid mechan increas applic scheme load instruct explor integr control flow inform confid mecha nism anoth architectur modif improv effici squash instruct effect mispredict start becom import branch predict becom import valu predict lower confid mechan also number instruct directli effect mispredict load valu less branch predict allow greater benefit improv identifi instruct need squash acknowledg final would like acknowledg help haitham akkari offer numer suggest greatli improv qualiti work also grate intel corpor support research intel technolog educ grant r intel boost pentium pro mhz evalu futur microprocessor simplescalar tool set optim instruct fetch mechan high issu rate reduc memori traffic creg mip risc architectur valu local load valu predict dynam specul synchron data depend perform potenti data depend specul collaps tr mip risc architectur twolevel adapt train branch predict reduc memori traffic creg optim instruct fetch mechan high issu rate zerocycl load valu local load valu predict perform potenti data depend specul myampersandamp collaps dynam specul synchron data depend lookahead processor ctr adi yoaz mattan erez ronni ronen stephan jourdan specul techniqu improv load relat instruct schedul acm sigarch comput architectur new v n p may daniel ortega eduard ayguad mateo valero dynam memori instruct bypass proceed th annual intern confer supercomput june san francisco ca usa benchung cheng daniel a connor wenmei w hwu compilerdirect earli loadaddress gener proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state georg z chryso joel s emer memori depend predict use store set acm sigarch comput architectur new v n p june andrea moshovo gurindar s sohi specul memori cloak bypass intern journal parallel program v n p daniel ortega mateo valero eduard ayguad dynam memori instruct bypass intern journal parallel program v n p june gokhan memik mahmut t kandemir arindam mallik load elimin lowpow embed processor proceed th acm great lake symposium vlsi april chicago illinoi usa jinsuo zhang predict load address acm sigarch comput architectur new v n septemb matt t yourst kanad ghose increment commit group nonatom trace process proceed th annual ieeeacm intern symposium microarchitectur p novemb barcelona spain anasta misev marjan gusev visual simul ilp dynam ooo processor proceed workshop comput architectur educ held conjunct st intern symposium comput architectur june munich germani sanjay jeram patel mariu ever yale n patt improv trace cach effect branch promot trace pack acm sigarch comput architectur new v n p june vlad petric ann braci amir roth three extens regist integr proceed th annual acmiee intern symposium microarchitectur novemb istanbul turkey dean m tullsen john s seng storageless valu predict use prior regist valu acm sigarch comput architectur new v n p may enric morancho jo mara llabera ngel oliv comparison two polici issu instruct specul journal system architectur euromicro journal v n p april jian huang david j lilja extend valu reus basic block compil support ieee transact comput v n p april andrea moshovo gurindar s sohi readafterread memori depend predict proceed nd annual acmiee intern symposium microarchitectur p novemb haifa israel glenn reinman brad calder dean tullsen gari tyson todd austin classifi load store instruct memori renam proceed th intern confer supercomput p june rhode greec daniel ortega mateo valero eduard ayguad novel renam mechan boost softwar prefetch proceed th intern confer supercomput p june sorrento itali jo gonzlez antonio gonzlez potenti data valu specul boost ilp proceed th intern confer supercomput p juli melbourn australia tingt sha milo m k martin amir roth scalabl storeload forward via store queue index predict proceed th annual ieeeacm intern symposium microarchitectur p novemb barcelona spain stephen jourdan ronni ronen michael bekerman bishara shomar adi yoaz novel renam scheme exploit valu tempor local physic regist reus unif proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state amir roth andrea moshovo gurindar s sohi depend base prefetch link data structur acm sigop oper system review v n p dec gabriel loh timestamp algorithm effici perform estim superscalar processor acm sigmetr perform evalu review v n p june s stone kevin m woley matthew i frank addressindex memori disambigu storetoload forward proceed th annual ieeeacm intern symposium microarchitectur p novemb barcelona spain peng jihkwon peir qianrong konrad lai addressfre memori access base program syntax correl load store ieee transact larg scale integr vlsi system v n p june tingt sha milo m k martin amir roth nosq storeload commun without store queue proceed th annual ieeeacm intern symposium microarchitectur p decemb glenn reinman brad calder predict techniqu aggress load specul proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state craig b zill gurindar s sohi understand backward slice perform degrad instruct acm sigarch comput architectur new v n p may pedro marcuello antonio gonzlez jordi tubella specul multithread processor proceed th intern confer supercomput p juli melbourn australia sangyeun cho penchung yew gyungho lee access region local highbandwidth processor memori system design proceed nd annual acmiee intern symposium microarchitectur p novemb haifa israel v krishna nandivada jen palsberg effici spill code sdram proceed intern confer compil architectur synthesi embed system octob novemb san jose california usa andrea moshovo gurindar s sohi reduc memori latenc via readafterread memori depend predict ieee transact comput v n p march sangyeun cho penchung yew gyungho lee decoupl local variabl access wideissu superscalar processor acm sigarch comput architectur new v n p may j gonzlez a gonzlez controlflow specul valu predict ieee transact comput v n p decemb sangyeun cho penchung yew gyungho lee highbandwidth memori pipelin wide issu processor ieee transact comput v n p juli lieven eeckhout koen de bosscher quantifi behavior differ multimedia generalpurpos workload journal system architectur euromicro journal v n p januari