t bound cacherel preemption delay realtim system a abstractcach memori use almost comput system today bridg ever increas speed gap processor main memori howev use multitask comput system introduc addit preemption delay due reload memori block replac preemption cacherel preemption delay pose seriou problem realtim comput system predict utmost import paper propos enhanc techniqu analyz thu bound cacherel preemption delay fixedprior preemptiv schedul focus instruct cach propos techniqu improv upon previou techniqu two import way first techniqu take account relationship preempt task set task execut preemption calcul cacherel preemption delay second techniqu consid phase task elimin mani infeas task interact two featur express constraint linear program problem whose solut give guarante upper bound cacherel preemption delay paper also compar propos techniqu previou techniqu use randomli gener task set result show improv worstcas respons time predict propos techniqu previou techniqu rang percent percent depend cach refil time task set util result also show cach refil time increas improv increas indic accur predict cacherel preemption delay propos techniqu becom increasingli import current trend widen speed gap processor main memori continu b introduct realtim comput system task time constraint term deadlin must met correct oper guarante time constraint extens research perform schedul analysi studi variou assumpt usual made simplifi analysi one simplifi assumpt cost task preemption zero assumpt howev hold gener actual system invalid result schedul analysi exampl task preemption incur cost process interrupt manipul task queue actual perform context switch mani direct cost address number recent studi schedul analysi focu practic aspect task schedul addit direct cost task preemption introduc form indirect cost due cach memori use almost comput system today comput system cach memori task preempt larg number memori block belong task displac cach memori time task preempt time task resum execut task resum execut spend substanti amount execut time reload cach memori block displac preemption cach reload greatli increas preemption delay may invalid result schedul analysi overlook indirect cost two way address unpredict result cacherel preemption delay first way use cach partit cach memori divid disjoint partit one partit dedic realtim task cach partit techniqu task allow access partit thu cacherel preemption delay avoid howev cach partit block minimum unit inform either present present cachemain memori hierarchi assum without loss gener memori refer made block unit number drawback one drawback requir modif exist hardwar softwar both anoth drawback limit amount cach memori use individu task second way address unpredict result cacherel preemption delay take account effect schedul analysi basumallick nilsen propos one techniqu techniqu use follow schedul condit set n task extend wellknown liu layland schedul condit condit u total util task set c worst case execut time wcet period respect addit term fl upper bound cacherel preemption cost impos preempt task one drawback techniqu suffer pessimist util bound approach larg n mani task set total util higher bound success schedul rectifi problem busquetsmataix et al propos techniqu base respons time approach techniqu incorpor respons time equat follow e theta c j r worst case respons time hpi set task whose prioriti higher recurs equat solv iter result worst case respons time r task compar deadlin determin schedul notat use throughout paper along denot deadlin assum without loss gener higher prioriti main memori cach memori preempt preempt preempt preempt a cach map b worst case preemption scenario s respons time preempt fig overestim cacherel preemption delay use techniqu comput multipli number cach block use task time need refil cach block estim base pessimist assumpt cach block use replac cach memori block need preempt task pessimist assumpt lead overestim cacherel preemption delay sinc possibl replac memori block one longer need one replac without rereferenc even preemption overestim address lee et al use concept use cach block comput cacherel preemption delay use cach block defin cach block contain memori block may rereferenc replac anoth memori block techniqu consist two step first step analyz task estim maximum number use cach block task base result first step second step comput upper bound cacherel preemption delay use linear program techniqu busquet mataix et al techniqu upper bound incorpor respons time equat comput worst case respons time although lee et al techniqu accur techniqu consid use cach block still subject number overestim sourc explain sourc use exampl fig exampl three task assum without loss gener higher prioriti highest prioriti task lowest prioriti suppos main memori region use three task map cach fig a also suppos maximum number use cach block respect time need refil cach block singl cycl set linear program method use lee et al techniqu would give solut preempt three time preempt twice s respons time r result preemption delay theta solut howev suffer two type overestim first task preempt use cach block replac cach exampl preempt small portion s use cach block replac cach correspond conflict cach block use ie cach block frame thick border fig a second worst case preemption scenario given solut may feasibl actual execut exampl cannot preempt three time sinc wcet thu first invoc certainli complet second invoc rectifi problem paper propos novel techniqu incorpor follow two import featur first propos techniqu take account relationship preempt task set task execut preemption calcul maximum number use cach block reload preemption second techniqu consid phase task elimin mani infeas task interact two featur express constraint linear program problem whose solut bound cacherel preemption delay paper focu cacherel preemption delay result instruct cach analysi data cacherel preemption delay equal import research issu handl method explain paper also compar propos techniqu previou techniqu result show propos techniqu give tighter predict worst case respons time previou techniqu result also show cach refil time increas gap worst case respons time predict made propos techniqu previou techniqu increas final result show cach refil time increas cacherel preemption delay take proport larg percentag worst case respons time indic accur predict cacherel preemption delay becom increasingli import current trend widen speed gap processor main memori continu rest paper organ follow next section describ detail lee et al techniqu serv basi propos techniqu section iii describ overal approach propos techniqu along constraint need incorpor scenariosensit preemption cost advanc constraint take account task phase discuss section iv section v discuss optim aim reduc amount comput need propos techniqu section vi present result experi assess effect propos techniqu final conclud paper section vii ii linear programmingbas analysi cacherel preemption delay section describ detail lee et al linear programmingbas techniqu analyz cacherel preemption delay techniqu respons time equat given follow pc r term guarante upper bound cacherel preemption delay given respons time r term includ delay due preemption also delay due preemption higher prioriti task respons time equat solv iter follow r r k r k iter procedur termin r converg r valu compar s deadlin determin schedul comput pc r k iter techniqu use two step approach first step task analyz estim maximum number use cach block task may execut estim use data flow analysi techniqu gener follow two type inform execut point p cach block c set memori block may resid cach block c execut point p set memori block may first refer cach block c execut point p cach block c defin use point p two set common element mean may execut memori block cach block c p rereferenc total number use cach block p determin addit cach reload time incur task preempt p obvious worst case preemption occur task preempt execut point maximum total number use cach block case give worst case cacherel preemption cost task final result first step tabl call preemption cost tabl give task worst case preemption cost f second step use preemption cost tabl linear program techniqu deriv upper bound pc r requir iter respons time calcul step first defin g j number preemption j r g j valu give worst case preemption scenario among task known worst case cacherel preemption delay interv r ie pc r calcul follow total cacherel preemption delay includ delay due preemption higher prioriti task note highest prioriti task includ summat sinc never preempt gener howev exact g j valu give worst case preemption delay cannot determin thu analysi safe scenario guarante wors actual preemption scenario assum conserv scenario deriv follow two constraint valid g j combin satisfi techniqu defin gener preemption cost f ij cost task pay worst case jth preemption j gamma th preemption howev sinc case execut point maximum total number use cach block contain within loop nest gener preemption cost littl effect f product iter bound contain loop first total number preemption r cannot larger total number invoc second total number preemption j r cannot larger number invoc j r multipli maximum number time singl invoc preempt higher prioriti task e theta note sinc techniqu comput worst case respons time highest prioriti task lowest prioriti task worst case respons time is r avail r comput summar lee et al techniqu problem comput safe upper bound formul linear program problem object function valu maxim satisfi two constraint side note linear program increasingli use realtim research area strong theoret ground exampl use bound worst case execut time task bound interfer program execut dma oper bound number retri lockfre realtim system iii overal approach one problem lee et al techniqu preemption cost task fix regardless task execut task preemption may result sever overestim cacherel preemption delay cach block share among task exampl cach block use preempt task use task execut preemption disjoint preemption cost particular preemption would zero nevertheless lee et al techniqu assum preemption cost still time need reload use cach block preempt task address problem techniqu propos paper take account relationship preempt task set task execut preemption comput preemption cost purpos propos techniqu categor preemption task number disjoint group accord task execut preemption number disjoint group k higher prioriti task exampl three higher prioriti task lower prioriti task number possibl preemption scenario correspond f g f g f g f accord set task execut s preemption task j denot p j gamma set possibl preemption scenario higher prioriti task set p j gamma equal power set set f exclud empti set sinc task j preempt least one higher prioriti task must involv addit denot p j h preemption task j task set h execut exampl denot preemption task preemption cost task differ preemption scenario given follow augment preemption cost tabl exampl block u u u u u u u u u u c c execut point cach block u fig calcul scenariosensit preemption cost comput f j h preemption cost scenario p j h follow three step taken base inform set use cach block obtain analysi explain first execut point task j comput intersect set use cach block j execut point set cach block use task h second determin execut point j largest element ie use cach block intersect final comput worst case preemption cost preemption scenario multipli number use cach block intersect cach refil time exampl consid fig show set use cach block denot us figur execut point lower prioriti task set cach block use higher prioriti task exampl worst case preemption cost case task execut preemption ie f f multipli cach refil time preemption cost determin execut point shade figur largest number use cach block conflict cach block use sinc preemption scenario k higher prioriti task need comput number preemption cost worst case may requir enorm amount comput k larg comput requir reduc substanti note need consid higher prioriti task whose cach block conflict cach block use task preemption cost comput exampl fig sinc none cach block use conflict use need consid preemption scenario includ comput preemption cost instead preemption cost scenario includ deriv includ note a problem formul formul problem comput safe upper bound pc r linear program problem base augment preemption cost f j hs defin new variabl j h denot number preemption j task set h is number preemption scenario p j h correspond object function object function state cacherel preemption delay r sum delay due preemption higher prioriti task r delay due preemption task defin sum count mutual disjoint preemption scenario task multipli correspond preemption cost lee et al techniqu cannot determin exact g j h valu give worst case preemption delay thu use variou constraint g j hs bound object function valu next subsect give two constraint extens lee et al origin constraint then section c discuss advanc constraint relat invoc higher prioriti task preemption lower prioriti task higher prioriti task involv section iv give advanc constraint consid phase task elimin mani infeas task preemption scenario final section v discuss optim reduc comput requir propos techniqu b extens lee et al constraint subsect describ extens base scenariosensit preemption cost two constraint use lee et al techniqu extend constraint given term g j hs and see later subsum lee et al origin two constraint first constraint lee et al techniqu state total number preemption r cannot larger total number invoc r straightforwardli extend use g j hs follow g k h note sinc k h equal g k constraint equival first constraint lee et al techniqu similarli second constraint origin state total number preemption j r cannot larger number invoc j r multipli maximum number time singl j invoc preempt higher prioriti task extend follow e theta r j constraint state number preemption j higher prioriti execut bound number invoc j multipli maximum number time singl j invoc preempt k show constraint subsum second constraint lee et al techniqu sum side constraint e theta j h j h e theta show new constraint subsum second constraint lee et al techniqu addit sinc number preemption j higher prioriti task k execut bound number k invoc combin constraint e theta sinc new constraint describ subsect either equival stringent origin two constraint lee et al techniqu f j h alway less equal f j h result object function valu alway smaller equal object function valu lee et al tech a cach map b preemption cost tabl c task invoc task r fig exampl task set niqu yield tighter predict cacherel preemption delay exampl consid task set fig consist four task highest prioriti task lowest one assum task map cach memori shown fig a use cach block task denot number respect cach map distribut use cach block task give preemption cost tabl fig b assum cach refil time singl cycl assum interest comput cacherel preemption delay respons time task denot r fig c also assum r exampl simplifi explan assum set use cach block task shown fig a includ set use cach block execut point task assumpt hold gener exampl fig illustr four invoc three invoc two invoc whose respons time denot figur r r r respect note respons time avail comput r sinc calcul respons time highest prioriti task lowest prioriti task first constraint ie constraint follow three inequalitiesx r similarli second constraint ie constraint follow inequ e theta r g e theta r g e theta r g mind r e theta r g mind r e theta r g mind r e theta r maximum object function valu satisfi two set constraint valu g j hs give maximum follow comparison purpos lee et al techniqu use instead maximum object function valu would significantli larger given propos techniqu maximum object function valu deriv preemption cost f determin number use cach block task shown fig a note solut correspond case nine invoc task preempt task largest preemption cost constraint use arex r r e theta r e theta d r e theta d r c advanc constraint relationship task invoc preemption although new constraint stringent lee et al techniqu cannot elimin infeas preemption scenario fact even combin g j h valu give maximum object function valu previou exampl infeas sinc requir least eight invoc wherea four invoc exampl cf fig c among eight requir invoc four invoc g f mean four preemption execut four requir invoc g f four preemption execut reason earlier constraint cannot elimin infeas preemption scenario cannot relat invoc higher prioriti task preemption lower prioriti task higher prioriti task involv exampl fig trivial shown sum number preemption execut bound number invoc give follow constraint elimin infeas preemption scenario first sight appear problem solv bound number preemption lower prioriti task higher prioriti task execut number invoc higher prioriti task j express follow constraint g k h r constraint cast exampl fig translat follow constraint higher prioriti task involv particular constraint constraint gener howev safe mean valid preemption scenario may satisfi singl invoc higher prioriti task involv one preemption lower prioriti task thu count multipl time summat lefthand side constraint exampl preempt is turn preempt invoc doubli count first g f g second g f gener invoc k doubli count g j h g captur observ symmetr relat call dc stand doubli count relat denot dc relat associ two preemption scenario g exampl four task possibl pair preemption scenario relat dc follow use relat safe constraint deriv follow consid combin preemption scenario higher prioriti task involv pair preemption scenario combin relat dc sum number preemption combin bound number invoc higher prioriti task exampl follow constraint elimin infeas preemption scenario safe sinc pair preemption scenario appear lefthand side relat dc hand follow constraint safe p f relat dc e set possibl safe constraint deriv rule follow higher prioriti task involv r r e a maximum number preemption preemption b minimum number r r fig exampl infeas task phase constraint case higher prioriti task involv deriv similarli iv advanc constraint task phase among two problem lee et al techniqu explain introduct first problem address previou section introduc scenariosensit preemption cost section address second problem name problem techniqu consid phase among task thu may allow mani infeas preemption scenario exampl techniqu assum number preemption lower prioriti task higher prioriti task involv potenti rang zero number invoc higher prioriti task howev fig a illustr invoc higher prioriti task denot j figur cannot involv preemption lower prioriti task denot k figur even assum worst case respons time denot r k figur lower prioriti task similarli fig b illustr invoc higher prioriti task inevit involv preemption lower prioriti task even assum best case respons time b k lower prioriti task section incorpor constraint other task phase framework develop previou section first defin follow four number two task j k j prioriti higher worst case respons time r jk n jk let set interv length r hyperperiod form j k is lcmt least common multipl number jk maximum number preemption lower prioriti higher prioriti task j execut interv i similarli n jk minimum number preemption lower prioriti task k higher prioriti task j execut set interv hand jk maximum number time instanc lower prioriti task k overlap instanc higher prioriti task j technic maximum number levelk busi period j k interv i final n jk minimum number time instanc lower prioriti task k overlap instanc higher prioriti task j ie minimum number levelk busi period j k interv i assum worst case respons time j k r j r k respect avail comput r likewis assum best case respons time j k b j b k respect best case execut time use then four number given follow min x min x deriv lengthi present here interest reader refer extend version paper first two number jk n jk use bound number preemption two number jk n jk use bound number preemption certain type first jk use bound number preemption execut of cours without multipli count use techniqu explain previou section hand n jk use bound number preemption either j k execut exampl number preemption j execut k bound r jk likewis number preemption k execut j bound jk follow give exampl constraint use jk n jk assum four task correspond j k constraint respect exampl ten possibl preemption scenario among them three preemption scenario execut relat dc thu subject multipli count one particip summat number preemption restrict lead follow two inequ similarli three preemption scenario execut not relat dc follow two inequ final three preemption scenario execut not relat dc follow two inequ v optim base task set decomposit one potenti problem propos techniqu requir larg amount comput larg number task sinc number variabl use o n n number task task set section discuss simpl optim base task set decomposit drastic reduc amount fig exampl task decomposit comput requir consid exampl fig show cach block use four task figur notic although cach block share also overlap cach block use use mean neither affect cacherel preemption delay either vice versa base observ decompos given task set collect subset way two task two differ subset share cach block them task subset analyz independ task subset use constraint given previou two section exampl fig given task set decompos two subset g calcul worst case respons time lowest prioriti task use iter procedur explain section ii task one subset analyz independ task subset two result combin follow r k r k r k r k cacherel preemption delay due interact share cach block comput maximizex constraint involv similarli pc r k cacherel preemption delay due interact comput maximizex constraint involv maxim benefit optim explain abov number subset analyz independ larg interest topic futur research devis scheme alloc main memori task result cach map give larg number subset vi experiment result section compar worst case respons time predict propos techniqu previou techniqu use sampl task set target machin idtr board mhz r risc cpu r fpa float point acceler instruct cach data cach kbyte each cach direct map block size byte sram static ram use target machin main memori cach refil time cycl task set specif task period wcet unit cycl experi use sampl task set whose specif given tabl i tabl first column list task task set four task use experi fft lud lm fir fft task perform fft invers fft oper array float point number use cooleytukey algorithm simultan linear equat doolittl method lu decomposit fir implement point finit impuls respons fir filter gener signal final lm point adapt fir filter filter coeffici updat input signal tabl also give period wcet task second third column respect sinc target machin use sram main memori cach refil time cycl much smaller current comput system rang cycl cycl dram use main memori obtain wcet task realist cach refil time divid wcet two compon first compon execut time task memori refer cach hit independ cach refil time measur target machin execut task code data preload cach second compon time need servic cach miss occur task execut depend cach refil time compon comput multipli total number cach miss cach refil time ref ill experi total number cach miss obtain follow procedur two differ execut time measur task one code data preload cach without preload denot divid differ cycl cach refil time target machin comput total number cach miss task execut use three differ cach map code use four task shown lud lm fft cach map cach map cach map fig three differ cach map task fig first map code use task map cach region hand second map cach region use task overlap final third map code use task map disjoint region cach specul three map repres reason well spectrum possibl overlap among cach region use task ii give preemption cost tabl three map note preemption cost task decreas overlap cach region decreas less use cach block displac preemption eventu cach region disjoint preemption cost zero use publicdomain linear program tool call lp solv michel berkelaar url ftpftpeseletuenlpublp solv solv linear program problem pose propos techniqu total number constraint task set took less minut user cpu time minut system cpu time comput data point present section propos techniqu axil ii preemption cost tabl three cach map preemption cost tabl cach map unit cycl preemption cost tabl cach map unit cycl preemption cost tabl cach map unit cycl workstat run suno mhz supersparc cpu ti tmsz mbyte main memori experi also implement simpl fixedprior schedul base tick schedul explain implement schedul invok everi cycl take account overhead associ schedul use analysi techniqu explain techniqu schedul overhead respons time r given number schedul invoc r number time schedul move task delay queue where task wait next invoc run queue r ffl c int time need servic timer interrupt it measur cycl target machin ffl c ql time need move first task delay queue run queue it measur cycl target machin ffl c qs time need move addit task delay queue run queue it measur cycl target machin detail explan equat beyond scope paper interest reader refer fig a b show predict worst case respons time lowest prioriti task percentag cacherel preemption delay worst case respons time respect cach refil time increas cycl cycl three differ techniqu use predict worst case respons time first techniqu propos paper predict three differ cach map explain earlier second c techniqu explain assum cach block use preempt task replac cach memori block need preempt task final p lee et al techniqu present preemption cost assum time need reload use cach block note unlik propos techniqu worst case respons time predict c p insensit cach map sinc preemption cost assum independ cach map cach refil timeworst case respons time a cach refil timecacherel preemption worst case respons b fig worst case respons time cacherel preemption delayworst case respons time vs cach refil time result fig a show propos techniqu give significantli tighter predict worst case respons time previou techniqu exampl cach refil time cycl second cach map use propos techniqu give worst case respons time predict tighter best previou approach cycl vs cycl p superior perform propos techniqu becom evid cach region use task becom less overlap is move fig a jump worst case respons time predict three techniqu jump occur increas worst case respons time due increas cach refil time caus addit invoc higher prioriti task result number bump fig b result fig a also show cach refil time increas gap increas worst case respons time predict two tech cach map cach map cach map worst case respons time cach refil a cach map cach map cach map worst case respons time cach refil b fig impact differ constraint group accuraci worst case respons time predict niqu eventu task set deem unschedul c p cach refil time cycl respect hand task set schedul even cach refil time cycl cach map use final result fig b show cach refil time increas cacherel preemption delay take proport larg percentag worst case respons time result even method cacherel preemption delay take worst case respons time cach refil time cycl cach map use indic accur predict cacherel preemption delay becom increasingli import cach refil time increas is current trend widen speed gap processor main memori continu assess impact variou constraint use propos techniqu accuraci result worst case respons time predict classifi constraint two group calcul reduct worst case respons time predict group constraint set classifi follow three constraint section iii deal scenariosensit preemption cost classifi group wherea section iv elimin infeas task phase classifi group fig a b show reduct worst case respons time predict two constraint group appli cach refil time cycl cycl respect comparison purpos also give worst case respons time predict techniqu result show cach refil time cach region use task complet overlap ie cach map reduct come constraint group sinc case scenariosensit preemption cost degener preemption cost use techniqu p howev cach region use task becom less overlap impact constraint group becom signific eventu cach region disjoint reduct come constraint group alon sinc case scenariosensit preemption cost zero perform experi use number task set result similar given section interest reader refer result task set present vii conclus paper propos enhanc schedul analysi techniqu analyz cacherel preemption delay requir cach memori use multitask realtim system propos techniqu use linear program follow two novel featur express term constraint linear program first techniqu take account relationship preempt task set task execut preemption calcul number memori block reload cach preempt task resum execut second techniqu consid phase task elimin mani infeas task interact experiment result show incorpor two featur yield accur predict worst case respons time compar predict made previou techniqu result also show cach refil time increas gap increas worst case respons time predict propos techniqu previou techniqu final result show cach refil time increas cacherel preemption delay take proport larg percentag worst case respons time indic accur predict cacherel preemption delay becom increasingli import current trend widen speed gap processor main memori continu acknowledg author grate sam h noh help suggest comment earlier version paper r some result earliest deadlin schedul al gorithm find respons time realtim system the rate monoton schedul algorithm exact character averag case behavior schedul algorithm multiprogram hard realtim environ dynam schedul hard realtim task realtim thread an extend approach analyz fix prioriti hard realtim task effect analysi engin realtim fix prioriti schedul the impact ada runtim system perform characterist schedul model account interrupt handl cost dynam prioriti task system engin analysi fix prioriti schedul comput architectur quantit approach smart strateg memori alloc realtim cach design oscontrol cach predict realtim system compil support softwarebas cach partit softwarebas cach partit realtim applic cach issu realtim system ad instruct cach effect schedul analysi preemptiv realtim system analysi cacherel preemption delay fixedprior preemptiv schedul effici microarchitectur model path analysi realtim softwar a method bound effect dma io interfer program execut time a framework implement object schedul task lockfre realtim system scienc research associ fix prioriti schedul period task set arbitrari dead line bound cacherel preemption delay realtim system dftfft convolut algorithm theori elementari numer analysi c algorithm realtim dsp tr compil principl techniqu tool result earliest deadlin schedul algorithm dynam schedul hard realtim task realtim thread extend approach analyz fix prioriti hard realtim task c languag algorithm realtim dsp compil support softwarebas cach partit analysi cacherel preemption delay fixedprior preemptiv schedul comput architectur nd ed schedul algorithm multiprogram hardrealtim environ elementari numer analysi engin analysi fix prioriti schedul effect analysi engin realtim fix prioriti schedul impact ada runtim system perform characterist schedul model ad instruct cach effect schedul analysi preemptiv realtim system oscontrol cach predict realtim system effici microarchitectur model path analysi realtim softwar analysi cacherel preemption delay fixedprior preemptiv schedul method bound effect dma io interfer program execut time framework implement object schedul task lockfre realtim system ctr jaudelic c de oliveira caterina scoglio ian f akyildiz georg uhl new preemption polici diffservawar traffic engin minim rerout mpl network ieeeacm transact network ton v n p august account cacherel preemption delay dynam prioriti schedul analysi proceed confer design autom test europ april nice franc hemendra singh negi tulika mitra abhik roychoudhuri accur estim cacherel preemption delay proceed st ieeeacmifip intern confer hardwaresoftwar codesign system synthesi octob newport beach ca usa jan staschulat rolf ernst scalabl precis cach analysi preemptiv schedul acm sigplan notic v n juli chanik park jaeyu seo sunghwan bae hyojun kim shinhan kim bumsoo kim lowcost memori architectur nand xip mobil embed system proceed st ieeeacmifip intern confer hardwaresoftwar codesign system synthesi octob newport beach ca usa jan staschulat rolf ernst multipl process execut cach relat preemption delay analysi proceed th acm intern confer embed softwar septemb pisa itali