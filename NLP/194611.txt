t tight bound oblivi chain a chain problem defin follow given valu chain problem appear subproblem mani context known algorithm solv chain problem crcw pram oalphan time alphan invers ackerman function slowli grow function author studi class algorithm call oblivi algorithm problem simpl oblivi chain algorithm run oalphan time present importantli optim algorithm demonstr show match lower bound oblivi algorithm use n processor first step toward lower bound chain algorithm also provid show chain algorithm run two step must use superlinear number processor proof use prefix graph weak superconcentr interest connect two demonstr idea use obtain improv bound size prefix graph b introduct consid follow problem call chain given valu ig defin output view pointer chain s link list chain problem natur problem consid context databas retreiv oper record satisfi particular predic correspond input bit valu chain s correspond make link list record futur process apart appear subproblem mani context studi parallel integ sort parallel merg integ drawn restrict domain parallel subset compact circuit comput threshold function exampl easi solv problem on time use one processor use processor fast parallel algorithm exist run time close constant reason simplic open question theoret interest whether constant time parallel algorithm exist berkman vishkin independ ragd given parallel algorithm solv chain problem offn time use n processor ffn invers ackerman function slowli grow function use algorithm similar chain algorithm berkman vishkin give algorithm achiev bound problem lowestcommonancestor problem parenthesi match problem studi oblivi algorithm chain problem inform oblivi algorithm one pattern memori access depend n the size problem specif input class algorithm interest algorithm berkman vishkin ragd modifi oblivi present simpl oblivi algorithm chain run offn time perform bound previous known algorithm algorithm simpl make use previous known graph structur importantli show class oblivi algorithm optim prove oblivi chain algorithm use n processor time sinc known algorithm chain made oblivi give evid superconst lower bound chain algorithm chandra fortun lipton show circuit bound depth prefixcarri problem requir superlinear size impli superconst lower bound depth circuit linear size essenti show circuit must structur special type graph call prefix graph prove upper lower bound size prefix graph bound depth demonstr connect prefix graph anoth famili graph call superconcentr use idea present simpl proof improv lower bound show construct optim dolevdwork pippeng wigderson show lower bound weak superconcentr bound depth lower bound oblivi chain algorithm obtain interpret algorithm graph use techniqu analyz properti worth note chain algorithm whose graph weak superconcentr henc lower bound cannot use directli provid first step toward prove lower bound algorithm show chain algorithm termin step requir superlinear number processor time submiss paper conjectur techniqu develop paper would use prove lower bound algorithm inde case techniqu use recent extend prove lower bound chain algorithm model comput use paper concurrentread concurrentwrit parallel random access machin crcw pram common model crcw pram processor simultan write memori cell must write valu power prioriti model processor associ prioriti sever processor simultan write memori cell highest prioriti processor succe shown prioriti model strictli stronger common model show consid oblivi algorithm model equival common machin extra memori thu throughout paper algorithm describ run common model lower bound prove prioriti model oblivi comput pram input algorithm chain consist valu n the size problem n bit call input vector repres problem step processor comput base action far memori address access content write if write step oblivi algorithm mean one address access fix input vector ie depend valu n howev whether processor perform action may depend input vector exampl fifth write step p write alway write c may may write depend input vector our definit oblivi algorithm coincid call semioblivi conveni model comput oblivi algorithm graph given algorithm input size n direct graph g an defin follow vertic g an group level suppos algorithm solv chain problem k step graph g an consist k vertic number k even level vertex cell memori access algorithm vertic form c j j k call cell vertic or cell odd level vertex processor vertic form p j call processor vertic or processor thu k level processor vertic cell vertic edg g an defin follow input vector step j input vector step j initi bit input vector assum cell final output valu correspond bit assum cell i shall refer vertic i x vertic i k let p number processor use a number cell access comput kp two kind edg graph adjac processor vertex other sinc processor vertex degre former kp number cell access comput k cell vertic graph one even level thu total number cell vertic graph k p sinc cell vertex adjac two latter type edg k p edg henc number edg graph certainli upperbound k p given input vector d length n shall associ cell vertex content processor vertex state content associ c j content cell c step j just j st readwrit step comput input d state associ state processor p read step j th readwrit step comput time comput action processor depend sole state processor start fix initi state partial input one b f lambdag input vector denot set input consist b partial input b cell vertex c j defin content x xb g similarli processor vertex state e x xb g say cell processor vertex x j fix partial input b j sb x j j oblivi common simul oblivi prioriti consid follow problem call leftmoston problem given input g fich ragd wigderson show leftmoston problem solv o time common use n processor n memori cell algorithm made oblivi shall use fact prove follow lemma consid oblivi algorithm run prioriti pram p processor memori cell k step oblivi algorithm solv problem common pram p processor memori cell ok step proof suffic show one write step oblivi prioriti algorithm simul oblivi common machin o step suppos prioriti machin write r cell denot set processor may write c fix set note processor may choos write suffici common machin find i highest prioriti processor choos write done solv leftmoston problem size j j use j j cell processor o time space bound follow fact henceforth shall refer prioriti algorithm lemma algorithm run common time bound note gener true one step prioriti algorithm simul common algorithm o step boppana give exampl problem solv o time prioriti logn loglog n time common upper bound ackerman function defin follow function f let f ne k function k invers kth level ackerman function ie k ng behav like log n like log n defin jg berkman vishkin independ ragd given algorithm solv chain problem prioriti ck step use ni k n processor c constant algorithm one construct algorithm use on processor take offn time give simpl oblivi algorithm solv problem k step prioriti use ni k n processor though perform bound same feel algorithm easier understand prefix graph size n direct acycl graph n vertic call input vertic n vertic y yn outdegre call output vertic depth prefix graph length longest path input output prefix graph follow properti direct path x j say prefix graph level vertic partit level number everi edg level vertex level vertex call edg level edg prefix graph contigu vertex v input v reachabl form x possibl construct level contigu prefix graph size n depth k i k number level edg ni k n restricteddomain prefixmaxima problem defin follow given input ig show solv problem use prefix graph initi set valu vertex propag valu tail head vertic level select largest valu propag them easi see valu vertex reachabl x j g thu valu theorem k oblivi prioriti pram algorithm use ni k n processor solv chain problem k step show oblivi prioriti pram algorithm simul comput level contigu prefix graph g label edg g follow let fx r j r i jg set input vertic reach vertex tail edg e label e j design memori cell mv correspond vertex v g step i alloc processor pe level edg g two edg f label labelf pf higher prioriti pe alloc easi do e edg v w pe read valu mv valu pe noth otherwis write valu mw easi show valu mw maxfa r j w reachabl x r g my solv chain problem input first n simpli solv restricteddomain prefixmaxima problem valu mx input state bound follow bound prefix graph weak superconcentr prefix graph prove prefix graph depth k edg improv lower bound show construct optim weak superconcentr direct acycl graph n vertic vertic outdegre properti k exist vertex disjoint path fx fy j jk g depth weak superconcentr length longest direct path it prove weak superconcentr depth edg theorem prefix graph depth k requir omegagamma ni k n edg show everi prefix graph weak superconcentr let x input output vertic prefix graph g k exist path x vertex disjoint p q path jp x q jq common vertex path x q contradict use function properti follow defin tree k l l k l leav depth k edg label power outdegre root l outdegre everi vertex label edg come vertex parent describ construct k l start root edg vertic k l creat certain order think vertic given depth arrang left right order creation rule govern label edg is depth label first edg creat label jth edg creat twice maximum product label path start j gamma th edg creat end leaf initi root vertex v depth less k number children v creat far less label edg v parent or less l v root creat new child v label connect edg per rule move new child number children creat far equal label edg v parent move parent v v root alreadi l children construct complet vertex depth k ie leaf simpli move back parent recal definit ackerman function previou section appendix shown maximum product label path k l root leaf suffici larg let h set leav label edg path root h order follow inequ hold similar inequ prove includ proof appendix shall prove other here fact let v non leaf node tree t k l let w next node right level let c label edg v w parent respect let e label edg v rightmost child v easili seen e c e c lemma let c c k label path root leaf then jhj leav tree left right lemma clearli hold path h all label assum lemma hold path hm shall show hold path hm path hm hm diverg level call level r c c r common level let c r c k r k remain label path hm hm respect note c r c k label rightmost children fact c j c j induct hypothesi j j sinc r c r c r c r c r j complet proof lemma function k follow hold let l posit integ let consid set path root leaf properti set vertic pass level j k respect vertic j left right consid path leftmost leaf among set consid path path pass v let label path c j log y label edg vertex right v least y done assum c j log y then lemma log sinc c c k y c j c k log label edg vertex right v fact log log corollari inequ k k proof v vertex level j k l let c v c j v label path root v order lemma hand sinc label success edg level increas least factor two log edg level label exce y lower bound consid follow fact theorem show obtain oblivi chain algorithm whose graph as defin section prefix graph theorem everi prefix graph weak super concentr lower bound weak superconcentr known given fact tempt conjectur graph everi oblivi chain algorithm prefix graph therebi directli obtain lower bound howev chain algorithm whose graph weak su perconcentr exampl consid algorithm which first two step processor p read x x without write anywher next two step p write valu x x cell z z respect chain problem solv input z processor ever read cell x x again graph comput path x must pass vertex henc never vertex disjoint thu graph weak superconcentr simpl exampl gener necessari therefor care analyz structur graph chain algorithm prove prioriti algorithm solv chain problem n processor suffic prove follow theorem n suffici larg oblivi prioriti algorithm solv chain problem size n k step processor an graph algorithm a termin k readwrit step let input output vertic g an let h set leav k l defin previou section pick u random subset n pick element n independ probabl ph consid partial input fix valu input vertic g an indic b vertex v g an let f v denot indegre v let v j denot set vertic level j j k call vertex consid high degre vertex c j fix b let p highest prioriti processor write c j input consist b ie set variabl p write c step j state p affect input vertic reach p j gamma modifi b input vertex set input consist new b p fix valu c j c j fix b sinc p overrid processor write processor write c j modifi b set variabl reach c c j call oper fix vertex carri follow two step procedur g an a j start go k gamma fix highdegre vertic v j start go n set input vertic with valu reach lowdegre vertic valu except x claim end procedur undefin input vertic fix except possibl one see thi suppos one input vertex undefin set except leftmost undefin input vertex x let partial input c let x j first input vertex right x valu clearli x j exist set step b x reach lowdegre vertic howev two input consist c vertic reachabl x low degre vertic differ valu sinc high degre vertic fix henc state j remain fix input error write eab expect number input bit set process argument eab ej u obtain upper bound e ab note fix highdegre vertic v thu variabl affect content v undefin variabl reach v lowdegre vertic henc v enumb input set fix enumb undefin input reach v low degre vertic actual fix fix state highest prioriti processor p write v or processor write fix v vertex repres memori cell v previou time step number input fix number input reach either two lowdegre vertic ie c j highdegre vertex v minimum two quantiti ie v expect number bit set a sum expect number bit set fix high degre vertex ie ea enumb bit set a g thu ea upper bound eb expect number input set step b let j output vertex let reach j lowdegre vertic u jg befor j j process j step b pi u j u sinc event u j u independ pi u j u henc e number input set process j step b befor eb sum output vertic expect eb clearli multipli side c k h sum h h interchang order summat get g let zv g notic v j disjoint union zv j w v j use observ rewrit get simplifi further observ sum indegre cell vertic bound number edg number cell vertic bound k p ie separ bound term lh call i ii iii respect i written sum two term separ vertic degre greater k n other thu use inequ b d bound first term a c bound second find use c simplifi ii get term iii estim use c yield rh equat estim use give rh n k ngamma n thu rewrit equat simplifi yield nonoblivi lower bound techniqu use lower bound oblivi algorithm may extend nonoblivi algorithm conjectur similar lower bound algorithm abl prove case although follow theorem may prove use comput similar use oblivi case use simpler comput hope illumin associ graph gab nonoblivi algorithm partial input b befor g ab level vertic edg defin by vector consist b step j vector consist b step j cell c note case edg cell vertic cell vertic v vertex gab defin sb v befor theorem prioriti pram algorithm solv chain problem step requir nlog n processor number processor use a suppos termin step gab consist level number vertic let e set edg level level gab easili seen partial input b j e b j p j e b j p level vertex indegre ig j j z consid highest prioriti processor p edg v state processor depend one input bit set input bit p write v let b partial input defin clearli j sb v fix manner fix vertic let c partial input obtain procedur number bit set c sinc fix vertex involv set one bit level vertic g ac fix written less processor state differ thing written vertex at most two valu processor may write and case processor write at most two valu initi contain henc v j sc v processor read vertex differ valu written number state processor bound product twoie output vertic g ac suppos bit set c defin l bit c l j c undefin may have final valu one l l j ml j sinc minim show r l j ml j e e c edg p c let ge number differ valu p write c input consist c output vertex y let e set edg y number differ valu written y bound number valu differ processor write via edg e plu number valu in case processor write henc sc y eey processor p total number difer valu write edg lead bound c p sum quantiti processor give upper bound number difer valu written via edg e c thu equat get j sc y r l j ml j final equat get sinc r n ilog n yield conclus open problem shown oblivi chain n processor thetaffn time leav open question whether o time nonoblivi algorithm exist recent chaudhuri radhakrishnan settl question show omegagamma ffn lower bound chain algorithm use on processor use random better perform may achiev situat raman gave random algorithm run o time number s input larg conjectur arbitrari input constanttim chain possibl even use random acknowledg grate ravi boppana introduc work mani help discuss indebt jaikumar radhakrishnan simpl proof upper bound innumer insight comment r optim separ concurr write parallel machin improv determinist parallel integ sort some triplylogarithm parallel algorithm recurs startre parallel data structur recurs startre parallel data structur unbound fanin circuit associ function lower bound constant depth circuit prefix problem tight bound chain problem complex parallel prefix problem small domain upper lower time bound parallel random access machin without simultan write superconcentr gener gener connector limit depth simul among concurrentwrit model parallel comput count pack parallel on integ sort parallel hash perfect hash graph entropi circuit complex the parallel simplic compact chain the power collis random parallel algorithm chain integ sort subset select parallel tr