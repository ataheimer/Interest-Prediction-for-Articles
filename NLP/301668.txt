t new tile techniqu improv cach tempor local a tile wellknown loop transform improv tempor local nest loop current compil algorithm tile limit loop perfectli nest transform trivial way perfect nest paper present number program transform enabl tile class nontrivi imperfectlynest loop cach local improv defin program model loop develop compil algorithm tile propos adopt oddeven variabl duplic break anti output depend without unduli increas workingset size adopt specul execut enabl tile loop may termin prematur due to eg converg test iter algorithm implement techniqu research compil panorama initi experi sever benchmark program perform sgi workstat base mip rk rk processor overal transform program run faster b introduct due widen gap processor memori speed import effici use cach wide recogn loop tile combin stripmin loop interchang wellknown loop transform use increas work sponsor part nation scienc foundat grant ccr mip purdu research foundat appear acm sigplan pldi copyright c fl associ comput machineri inc permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page intial screen document copyright compon work own other acm must honor abstract credit permit copi otherwis republish post server redistribut list requir prior specif permiss andor fee request permiss public dept acm inc fax permissionsacmorg reus cach data varieti loop transform revers skew also propos enabl loop tile current tile techniqu gener limit perfectlynest loop loop except innermost one perfect nest contain exactli one inner loop next level loop nest contain simpl statement two loop header shown figur transform perfect nest simpli move statement guard appropri insert condit insid inner loop assum inner loop iter least onc unfortun mani imperfectlynest loop numer program trivial one figur loop may contain sever inner loop level exampl jacobi program kernel shown figur a two separ loop nest within outmost loop certain case techniqu peelandfus transform nontrivi imperfectlynest loop perfectli nest one may becom amen tile unfortun techniqu exploit tempor local within iter outer loop eg loop jacobi code in paper tloop call timestep loop rel littl tempor reus exploit cach data reus across differ time step current tile techniqu also difficulti prematur loop exit caus converg test iter numer algorithm paper present number program transform overcom aforement difficulti tile make two main contribut ffl defin class nontrivi imperfectlynest loop present algorithm legal profit tile separ loop perfectlynest timestep loop case jacobi tempor reus thu exploit across differ time step ffl present scheme permit tile loop prematur exit specul execut iter timestep loop exit condit test iter rollback statement insert insur correct program result case exit condit turn true techniqu introduc paper particularli suitabl iter stencil comput matrix element updat base valu neighbor element comput often perform solv partial differenti equat geometr model imag process ing data depend inform requir autom propos techniqu gather exist compil analys implement propos techniqu within panorama compil order evalu effect appli techniqu one wellknown numer comput kernel jacobi two applic program tomcatv swim industri spec benchmark overal program transform improv execut speed sgi sequenti workstat statement statement end statement end statement end end a transform b transform figur trivial imperfect loop nest transform perfect loop nest paper consid uniprocessor comput memori hierarchi includ cach memori one level assum one cach larg enough store small number column consid array whole array secondari cach typic modern workstat satisfi assumpt techniqu introduc paper aim improv data reus cach rest paper organ follow section defin class imperfectlynest loop present tile scheme legal tile loop also present criteria determin whether tile scheme profit discuss techniqu improv profit tile scheme loop preprocess section present scheme specul execut allow tile timestep loop contain prematur exit section present experiment result discuss relat work section conclud section tile imperfectlynest loop section first use jacobi exampl give basic idea tile scheme imperfectli nest loop defin class loop handl scheme that present scheme legal tile imperfectlynest loop criteria determin whether tile end end end end end a jocobi kernel code b stencil illustr jacobi code j j j j j j flow depend backward direct along j j flow depend straight forward direct along j j antidepend backward direct along j j antidepend straight forward direct along j j output depend backward direct along j j output depend straight forward direct along j j c iter subspac depend figur code comput stencil depend iter subspac jacobi kernel profit discuss techniqu improv profit tile scheme addit loop transform analyz complex compil algorithm briefli discuss extens basic idea iter numer algorithm array element usual access repeatedli differ time step number array element larg cach overflow requir array element fetch repeatedli cach everi time step use loop tile work time step finish execut move next time step oper array element recent refer enc avoid cach overflow unfinish time step continu later moment consid jacobi kernel shown figur a converg test remov simplifi illustr plot iter subspac j j loop shown figur c within iter complet execut j j loop requir access nearli theta n gamma distinct array element suffici larg n cach overflow result cach miss next itera tion avoid overflow partit iter subspac tile mark staircas line figur c execut order topleft bottomright properli chosen tile size make number memori locat access tile fit cach reorder execut sequenc legal satisfi origin data depend figur b show jacobi comput stencil figur c show subset data depend edg iter point indic flow anti output depend adopt valuebas definit flow depend flow depend exist statement statement latter may use valu written former adopt tradit definit anti output depend antidepend exist former read memori locat overwritten latter output depend exist may overwrit memori written one similarli defin depend two variabl refer two loop iter two program segment key scheme tile imperfectlynest loop find uniform tile slope flow depend carri satisfi find offset tile inner loop flow depend within also satisfi tile shape result guarante flow depend exist laterexecut tile earlierexecut tile anti output depend exist laterexecut tile earlierexecut one elimin techniqu call oddeven duplic array unlik full array expan sion oddeven duplic unduli increas workingset size defeat local figur c edg node n n drawn solid j loop index valu n greater drawn dot otherwis j stand either j j solid edg affect legal tile shape one see solid flow depend edg within tile solid antidepend edg may cross two neighbor tile howev shown section latter remov oddeven duplic exist solid output depend edg jacobi class imperfectlynest loop gener program model present figur a loop bodi contain jloop j loop may contain arbitrari program construct without loss gener loop assum step requir loop j take form lower upper bound respect l u invari b nonneg known constant make present clean itmax assum even number requir read refer get valu either alway iter end end end modt eq end end end end end end a program model b oddeven array duplic modt eq end end end end end end end c tile figur step tile imperfect loop nest alway previou iter henc flow depend distanc either loop level commonli true applic focu use iter algorithm exist compil techniqu array privat determin whether condit flow depend satisfi see list refer jacobi code figur read refer alway get valu previou iter except give distanc read refer l alway get valu iter make distanc figur a assum b alway get valu previou iter simplic exposit paper consid tile j loop onli m even though may contain inner loop techniqu propos here howev extend includ loop within j loop briefli discuss section tth iter potenti reus slope tth iter loop ji loop ji figur portion tile illustr reus algorithm tile imperfect loop nest given loop nest program model goal transform form shown figur c where term jj call tile control loop j tile loop conv nienc call loop timestep loop j loop tile size nstep term figur c nstep number grid point tile jj direct slope number grid point tile shift left tindex increas figur illustr two instanc loop j show shape portion tile potenti tempor reus across iter proport valu nstep gamma slope figur show main step tile tech niqu rest subsect present compil algorithm implement step construct subgraph minimum legal slope constrain data depend distanc exist extens studi problem comput data depend distanc pair array refer respect common enclos loop distanc constant symbol analysi perform deriv bound distanc valu current literatur depend distanc usual defin respect loop contain depend refer program model would appli loop onli slightli extend definit also includ j loop program model suppos exist depend iter t j iter k say depend distanc vector specif say distanc respect j loop j neg say exist backward depend wrt j exist work distancecomput cite readili use comput lower bound upper bound distanc defin refer differ j loop construct depend subgraph loop nest node repres statement within one j loop edg repres flow anti output depend multipl edg may exist one node anoth edg mark ffl construct depend subgraph ffl calcul minimum slope ffl select maximum legal tile size test profit ffl perform array duplic ffl gener tile code figur main step tile loop nest distanc vector dt dj dt distanc wrt dj lower bound estim possibl neg distanc wrt j loop dt valu group three class valu greater differenti differ dt valu greater denot g equal recal that program model flow depend distanc respect loop henc possibl anti output depend onli distanc wrt j cannot neg let dj jacobi exampl figur depend subgraph shown figur a statement comput l one comput a easi illustr figur a draw one edg repres type data depend flow anti output one vertex anoth mark possibl depend distanc vector sinc loop iter must execut lexicograph order flow depend edg depend subgraph whose vertic must distanc vector dj anti output depend edg must distanc vector dj g dj group anti output depend edg sourc target dj valu delet one edg minimum dt valu tile shape determin remain depend edg also satisfi delet one furthermor condens node in depend subgraph belong j loop singl node result new graph defin below simplifi graph filter depend inform unimport tile scheme thu improv effici graph travers techniqu definit jloop distanc subgraph g l graph deriv depend subgraph gd given loop nest conform program model node j g l repres j loop given loop nest flow depend edg gd distanc vector dt dj n loop j n loop j j j differ node g l add edg g l j j distanc vector dt dj otherwis j j dt j b a antidepend flow depend depend figur depend jloop distanc subgraph jacobi equal add edg j j distanc vector dt dj everi two node n gd exist anti depend n n loop j n loop j consid antidepend edg n a group antidepend edg edg belong group dj valu b group take minimum dt valu denot mindt add edg j j distanc vector mindt process output depend gd way step note step b g l instead mindt dj although treatment potenti produc overconserv tile shape expect case jacobi depend distanc subgraph figur a jloop distanc subgraph deriv shown figur b calcul minimum slope follow algorithm perform loop tile base jloop distanc subgraph first algorithm comput minimum legal tile slope slope offset j loop bound within tile algorithm comput minimum legal tile slope offset input loop nest conform program model jloop distanc subgraph g l output slope minimum legal slope tile offset node g l procedur ffl step a comput offset everi node g l temporarili remov anti output depend edg edg node g l without successor node g l assign offset valu go otherwis continu find node u g l whose successor assign offset valu edg annot go back put edg remov step a back g l offsetuju v node g l flow depend edg gfor jacobi code figur a step a exist one edg j j distanc vector initi offsetj offsetj mean need adjust loop bound either j j within iter step b sinc exist two flow depend edg from j j select tile size definit defin wsetx maximum work set size singl iter transform code figur c singl iter transform code loop bound j depend combin jj wsetx take maximum work set produc jjt combin sinc code yet transform compil stage estim wsetx memcount repres number differ memori locat access x iter loop j estim give upperbound wsetx memcount estim array data flow analysi merg array region access j loop bodi next determin size tile object maxim tile size order maxim data reus within tile prevent anti output depend cross backward one tile boundari tile wide work set size exce effect cach size algorithm profit test tile size deter minat input loop nest conform program model jloop distanc subgraph g l slope valu comput algorithm given cach size cs ff effectivecach factor output tile size nstep tile profit logic valu profit procedur hold m go step otherwis return procedur comput goto step nstep slope return procedur otherwis goto step let ju v node g l u v anti output depend edg node g l u v anti output depend edg g nstep otherwis guarante overlap iter point least one j loop adjac iter ie hold least one j loop step guarante work set fit effect cach accord figur make nstep larg enough allow potenti tempor reus across iter step prevent anti output depend cross backward one tile boundari jacobi jloop distanc subgraph figur b exist two anti depend edg respect recal offsetj exist antidepend edg two output depend edg array duplic next algorithm determin whether particular anti output depend need remov duplic algorithm oddeven duplic input loop nest conform program model jloop distanc subgraph g l data flow upwardexposur inform output loop nest oddeven array duplic insert as shown figur b procedur theta cs call effect cach size determin variou system factor recommend comput vendor base empir local measur chose experi ffl step a everi anti output depend distanc vector check see whether a need oddeven array dupli cation procedur return otherwis continu step b ffl step b duplic loop bodi insert ifstat one copi loop bodi becom branch copi els branch branch execut odd iter els branch even iter respect ffl step c anti output depend distanc vector condit a b step hold identifi array say a contribut depend declar copi a ffl step d assum origin array c new copi write refer branch chang referenc array name c read refer a valu odd iter chang c ffl step e insert proper initi statement new copi array region initi newli declar array upwardlyexpos entri second iterationin worst case array could duplic jacobi jloop distanc subgraph figur b antidepend j j make necessari duplic a array region upwardli expos entri second iter initi valu copi duplic tile code gener base calcul slope nstep offset loop transform perform algorithm follow algorithm calcul loop bound tile j loop modifi loop new jj loop figur c also form loop bodi tile j loop algorithm tile code gener input jloop distanc subgraph g l slope calcul algorithm nstep calcul algorithm loop nest updat algorithm form shown figur b output tile loop nest procedur end a end end end figur tile j loop ffl everi j loop whose current loop bound respect replac whole loop bodi code segment shown figur b offsetj repres origin j loop bodi except loop index variabl j replac k bodyk offsetj loop bodi replac code segment shown figur a ffl lower bound jj loop tile loop nest mg upper bound jj loop mg lower bound new loop maxmin fd upper bound new loop c itmaxth proof correct algorithm sketch appendix a figur show jacobi code transform algorithm note sinc offsetj loop bodi figur a appli loop im prove shown figur loop fusion forward substitut assum array l dead exit whole loop nest improv known techniqu discuss detail paper techniqu improv profit number compil techniqu appli given loop nest shorten backward depend distanc wrt j loop henc increas profit present two algorithm paper first one deal problem incompat j loop take exampl figur a exist flow depend j j henc say loop j j incompat indic appear differ dimens array a hand say loop j compat end end modt eq end end end end end end end end end end end figur jacobi kernel transform tile oddeven duplic modt eq end end end end end end figur tile jacobi kernel improv simpl loop fusion forward substitut indic appear array dimens loop j permut shown figur b flow depend j distanc vector make loop nest profit tile similarli loop said compat loop j loop loop j permut shown figur c howev cachelin spatial local suffer due columnmajor memori alloc array need transpos order restor spatial local formal definit compat given below definit program model figur a suppos j loop contain inner loop i i perfectli nest within j outmost one innermost one denot j i compat set m tupl c nonneg integ c m appear dimens ardo end end end end end end end end end end end end end end end a b c figur exampl illustr compat set ray type equal row or column indic appear first or second dimens call compat set rowcompat or column compat set respect dimension array rowassoci or columnassoci row compat or columncompat set least one loop index variabl ic set appear first or second dimens refer a follow algorithm check see combin array transpos loop permut produc loop nest profit tile although exist exponenti number possibl combin permut j loop array transpos small number need consid practic algorithm loop permut array transpos improv profit input loop nest lp conform program model comset compat set lp boolean array outmost allow array perm mg outmost allow uv indic whether loop iuv becom outmost loop within loop legal permut outmost allow legal permut vector output transform loop nest algorithm succe restor origin loop nest algorithm abort procedur profit permut unlik exist each element cs c array transpos array rowassoci cs outmost allow ic perform permut specifi permic appli algorithm return transform loop nest undo permut array transpos perform abov end abort jacobi code figur a two compat set column row figur a compat set column call permut loop loop j outmost allow true compat set row call transpos array permut j outmost allow true next show known loop transform call circular loop skew use enhanc profit tile techniqu exampl suppos code skeleton figur a wrap around comput stencil typic pde circular boundari condit iter subspac shown figur b assum that within time step jth iter loop j flowdepend j gamma th jth j iter j first iter loop j flowdepend first second last iter j last iter loop j flowdepend n gamma th nth first iter j assum flow depend j j distanc vector j loop free loopcarri depend reduc slope follow chang j s iter order also chang j s iter order on transform elimin backward depend result follow algorithm formal circular loop skew cl techniqu profit enhanc circularli skew bound everi j loop shorten backward distanc call procedur find cl paramet elimin backward depend whose distanc less given loop nest lp find cl paramet return ffi skew amount everi j loop adjac iter also mark fi m node j jloop distanc subgraph g l fi initi skew amount j algorithm circular loop skew shorten backward depend input loop nest lp conform program model except j loop index form l u invari jloop distanc subgraph g l real cach size cs effect cach size factor ff further everi loop assum free loopcarri depend output transform loop nest success procedur calcul csg end end end j j end end end j j a b c d figur sampl exampl transform algorithm origin loop nest skeleton b simplifi iter space graph transform c transform loop nest skeleton d simplifi iter space graph transform the code procedur find cl paramet present appendix b each j loop assum lower upper loop bound j l u respect chang loop bound assign j begin j loop bodi end appli algorithm transform loop nest return transform loop nest els abort figur c show transform code figur a appli algorithm figur d show correspond iter subspac suppos procedur find cl paramet perform follow initi remov edg l j sinc predecessor noth j increment fi backward depend distanc restor edg back g l process edg complex analysi construct jloop distanc subgraph requir inform array dataflow depend distanc which worst case requir exponenti time comput howev practic inform obtain effici implement scheme see list refer algorithm domin workingset comput requir array region union oper oper simpler construct jloop distanc subgraph given jloop distanc subgraph g l v e algorithm take ojv algorithm find array duplic need ojv time renam refer take time proport loop bodi size algorithm take time multipli loop bodi size algorithm theoret take o loop bodi size m small practic algorithm procedur find cl paramet worstcas time ojv jjej discuss techniqu extend tile inner loop within j loop take one loop level j exampl extens j loop perfectli nest inner loop lower bound upper bound u invari j invari c known nonneg constant follow chang made previou definit algorithm need extend distanc vector tripl dt dj di instead pair dt dj definit extend edg g l mark new distanc vector algorithm comput slopej slopei j loop loop respect also need annot g l offset j offset j loop respect algorithm comput nstepj nstepi j loop respect definit extend defin wsetxi x nstepj nstepi new algorithm check see whether wsetnstepj fnstep g true increas nstepj max fx j wsetx nstepi ff csg ffl algorithm duplic condit a b true either j algorithm need gener correct loop bound ii addit jj j tile specul execut numer program use iter method often exist converg test may caus maximum iter count reach enabl tile algorithm present abov present algorithm partit maximum iter count end end goto next end end next a extend program model chunk plu exit condit iter end end next b code iter chunk initi b a execut tile chunk econdeqtru go rollback copi aor odd copi c backup copi b accumeqitmax goto next end end go next roolback restor backup copi b execut origin loop nest figur a next c tile specul code figur tile specul execut chunk exit condit test execut chunk iter instead one iter tile individu chunk case overshoot iter execut roll back specul code statement must insert guard potenti except overflow dividedbyzero possibl except detect execut roll back latest checkpoint model defin section henc extend includ loop exit test shown figur a exit condit refer variabl defin either within iter outsid loop sourc carri flow depend follow algorithm implement idea algorithm tile specul execut input loop nest conform program model shown figur a output tile loop nest procedur ffl step a estim chunk size lmax ffl step b block loop figur a chunk size lmax shown figur b ffl step c tile chunk use algorithm ffl step d transform loop nest one shown figur c array referenc exit condit renam which similar renam algorithm in transform code everi array sourc carri flow depend creat backup copi b ident copi initi variabl accum accumul total iter execut far everi iter outmost loop execut tile program lmax step condit rollback check execut must rollback valu store b restor comput resum begin accumth iter latest checkpoint otherwis or odd copi c copi backup copi b execut reach itmaxth iter outmost loop termin tradeoff overshoot cost checkpoint overhead perform gain tile reason follow let origin execut time per time step let flmax speedup per time step due tile account checkpoint overhead amort lmax time step assum origin take step converg sinc incur penalti lmax iter rollback occur tile specul gain perform is total current use formula e equal estim time step per tile given tile size nstep in futur work one certainli experi formula instanc lmax may vari distinct comput stage section see gain cach tempor reus outweigh loss due checkpoint overshoot experiment evalu implement techniqu panorama compil appli algorithm one wellknown numer kernel jacobi converg test two spec benchmark tomcatv swim run two sgi uniprocessor workstat one base mip rk processor base mip rk rk processor kb way data cach kb way unifi l cach rk processor also kb way l data cach mb way unifi l cach moreov mip rk perform outoford instruct ex ecut provid data prefetch instruct permit multipl pend cach miss nativ compil mipspro f compil experi origin code peelandfus code turn o switch enabl number loop transform includ interchang fusion fission tile code gener techniqu o o deliv nearli perform we show o result here origin tomcatv swim program fail profit test appli algorithm two program take gener step shown figur algorithm find tomcatv made profit tile loop permut array transpos algorithm find swim made profit circular loop skew algorithm appli jacobi tomcatv the swim program exit condit timestep loop jacobi code also optim forward substitut figur jacobi program fix itmax vari input matrix size arbitrarili base algorithm nstep deriv respect rkbase workstat matrix size rkbase workstat nstep deriv respect tabl show perform result origin program peelandfus program tile algorithm mark tile w array dup although base tile techniqu array dupli cate shown figur array l elimin forward substitut figur give increas memori usag peelandfus scheme manual appli method present lrw tss choos tile size real cach size effect cach size best four scheme give shortest execut time chosen evalu peelandfus tabl tile oddeven duplic alway perform better peel andfus improv perform rk rk origin code tomcatv program among nbyn array tomcatv two array duplic increas memori usag nstep equal rk rkbase workstat respect refer input data tomcatv alway run maximum time step ie order measur potenti overhead rollback alter converg test trigger rollback comparison differ converg test result differ number iter execut untransform transform program execut time differ version tomcatv rk shown tabl iter orig mean number tabl execut time in second tomcatv rk variou converg test iter orig itertran exec time orig time speedup tabl execut timein second swim test exec time speedup exec time speedup orig prog tran prog iter execut untransform code iter tran mean number iter execut transform code roll back chunk size lmax base heurist rollback happen alway incur penalti lmax iter howev except case converg fast still get steadi speedup rollback the loop bound reach speedup rk origin program execut second transform program take second speedup converg test alter perform comparison similar rk also run tomcatv peelandfus transform code take second rk rk achiev speedup respect origin program swim program duplic swim nstep equal rk rk respect perform result shown tabl orig prog stand origin program tran prog repres transform program rk smaller l cach therefor smaller result less overlap iter point adjac iter within tile thu yield lower speedup peelandfus appli directli swim due long backward depend distanc rk addit execut time also measur secondari cach miss use perfex librari base rk perform counter tabl show result ls stand number dynam loadstor instruct sm number miss secondari cach mr secondari cach miss ratio jacobi even checkpoint number dynam loadstor instruct reduc due forward substitut tabl execut time in second differ version jacobi differ scheme matrix size rk matrix size rk origin time peelandfus time tile w array dup time believ differ number loadstor instruct origin code peelandfus code due slightli memori optim opportun nativ compil peelandfus tomcatv number loadstor instruct increas techniqu due period checkpoint swim ad number loadstor instruct expans array make program conform program model five case secondari cach miss rate dramat reduc gain tempor local across iter overcom loss memori instruct thu improv overal perform experi appli intervari pad similar scheme tile swim pad reduc cach set conflict henc improv speedup also appli intervari pad three origin program without notic perform gain cach overflow origin program domin perform relat work kodukula et al propos data shackl block array base data flow analysi form new loop nest comput block block although tackl certain imperfectlynest loop method appli stencil comput handl work updat one block destroy boundari data necessari adjac block manjikian et al present peelandfus method partial fuse adjac loop within loop tile fuse loop exploit local within loop iter algorithm bear similar peelfactor comput consid depend within iter onli consid depend across iter kodukula pingali propos matrixbas framework repres transform imperfectlynest loop includ permut revers skew scale align distribut jam work appli tile strout et al discuss minimum storag requir allow flexibl loop schedul tile method deal imperfectli nest loop handl work collard propos method specul execut whileloop parallel machin object increas parallel process util tile loop better memori perform uniprocessor use quit differ algorithm pugh et al present method handl exit condit iter applic parallel environ work collard pugh et al present interest idea handl loop exit condi tion may incorpor futur work mccalpin wonnacott develop scheme call time skew adopt valuebas flow analysi optim memori local method first perform full array expans forward sub stitut recompress expand array preserv data depend method handl subset imperfectlynest loop repres program model conclus futur work paper present new techniqu tile nontrivi imperfectlynest loop handl class imperfectlynest loop seem quit gener scientif comput develop two algorithm shorten backward depend distanc improv profit also extend program model handl exit condit common iter algorithm implement techniqu fortran sourcetosourc compil panorama preliminari experiment result show transform program run faster optim nativ compil work open sever interest subject futur work import one includ applic idea specul execut localityenhanc techniqu studi effect aggress localityenhanc algorithm effect cach size acknowledg thank chauwen tseng care review paper final r data comput transform multiprocessor compil transform highperform comput ing symbol rang propa gation experi effici array data flow analysi array privat tile size select use cach organ data layout symbol depend analysi high perform parallel compil matrixbas approach global local optim problem transform imperfectli nest loop structur comput comput cach perform optim block algorithm fusion loop parallel local improv data local loop transform time skew valuebas approach optim memori local iti practic algorithm exact array depend analysi exploit monoton converg function parallel program elimin conflict miss high perform architectur standard perform evalu corpor combin loop transform consid cach schedul improv local parallel nest loop data local optim algorithm high perform compil parallel comput tr cach perform optim block algorithm data local optim algorithm practic algorithm exact array depend analysi improv local parallel nest loop instructionlevel parallel process compil transform highperform comput tile size select use cach organ data layout improv data local loop transform exploit monoton converg function parallel program combin loop transform consid cach schedul fusion loop parallel local multilevel block experi effici array data flow analysi array privat elimin conflict miss high perform architectur scheduleindepend storag map loop transform imperfectli nest loop structur comput comput symbol rang propag matrixbas approach global local optim problem ctr claudia leopold optim tempor local stencil code proceed acm symposium appli comput march madrid spain nawaaz ahm nikolay mateev keshav pingali synthes transform local enhanc imperfectlynest loop nest intern journal parallel program v n p octob shoaib kamil kaushik datta samuel william leonid olik john shalf katherin yelick implicit explicit optim stencil comput proceed workshop memori system perform correct octob san jose california david wonnacott achiev scalabl local time skew intern journal parallel program v n p june roger espasa federico ardanaz joel emer stephen felix julio gago roger gramunt isaac hernandez toni juan geoff lowney matthew mattina andr seznec tarantula vector extens alpha architectur acm sigarch comput architectur new v n may guohua jin john mellorcrummey experi tune smg semicoarsen multigrid benchmark base hypr librari proceed th intern confer supercomput june new york new york usa jingl xue wentong cai timeminim tile rise larger zero parallel comput v n p june j hu m kandemir n vijaykrishnan m j irwin analyz data reus cach reconfigur acm transact embed comput system tec v n p novemb guohua jin john mellorcrummey robert fowler increas tempor local skew recurs block proceed acmiee confer supercomput cdrom p novemb denver colorado steve carr soner nder case workingsetbas memori hierarchi proceed nd confer comput frontier may ischia itali nawaaz ahm nikolay mateev keshav pingali synthes transform local enhanc imperfectlynest loop nest proceed th intern confer supercomput p may santa fe new mexico unit state indupraka kodukula keshav pingali datacentr transform local enhanc intern journal parallel program v n p june nawaaz ahm nikolay mateev keshav pingali tile imperfectlynest loop nest proceed acmiee confer supercomput cdrom pe novemb dalla texa unit state gabriel rivera chauwen tseng local optim multilevel cach proceed acmiee confer supercomput cdrom pe novemb portland oregon unit state qing yi vikram adv ken kennedi transform loop recurs multilevel memori hierarchi acm sigplan notic v n p may naraig manjikian tarek s abdelrahman exploit wavefront parallel largescal sharedmemori multiprocessor ieee transact parallel distribut system v n p march yonghong song rong xu cheng wang zhiyuan li data local enhanc memori reduct proceed th intern confer supercomput p june sorrento itali kristof beyl erik h dholland intermedi execut code key find refactor improv tempor data local proceed rd confer comput frontier may ischia itali a ya kalinov a l lastovetski i n ledovskikh m a posypkin compil vector statement c languag architectur multilevel memori hierarchi program comput softwar v n p mayjun sriram krishnamoorthi muthu baskaran uday bondhugula j ramanujam atana rountev p sadayappan effect automat parallel stencil comput acm sigplan notic v n june jonathan weinberg michael o mccracken erich strohmaier allan snave quantifi local memori access pattern hpc applic proceed acmiee confer supercomput p novemb gabriel rivera chauwen tseng tile optim scientif comput proceed acmiee confer supercomput cdrom pe novemb dalla texa unit state y charli hu alan cox willi zwaenepoel improv finegrain irregular sharedmemori benchmark data reorder proceed acmiee confer supercomput cdrom pe novemb dalla texa unit state michel mill strout larri carter jeann ferrant barbara kreaseck spars tile stationari iter method intern journal high perform comput applic v n p februari chunghs hsu ulrich kremer quantit analysi tile size select algorithm journal supercomput v n p march martha mercaldi steven swanson andrew petersen andrew putnam andrew schwerin mark oskin susan j egger instruct schedul tile dataflow architectur acm sigop oper system review v n decemb karin hgstedt larri carter jeann ferrant parallel execut time tile loop ieee transact parallel distribut system v n p march venkata k pingali salli a mckee wilson c hseih john b carter comput regroup restructur program tempor data cach local proceed th intern confer supercomput june new york new york usa chen ding maksim orlovich potenti comput regroup improv local proceed acmiee confer supercomput p novemb swarup kumar sahoo sriram krishnamoorthi rajkiran panuganti p sadayappan integr loop optim data local enhanc tensor contract express proceed acmiee confer supercomput p novemb venkata k pingali salli a mckee wilson c hsieh john b carter restructur comput tempor data cach local intern journal parallel program v n p august abdelhame a badawi aneesh aggarw donald yeung chauwen tseng evalu impact memori system perform softwar prefetch local optim proceed th intern confer supercomput p june sorrento itali d cociorva j w wilkin c lam g baumgartn j ramanujam p sadayappan loop optim class memoryconstrain comput proceed th intern confer supercomput p june sorrento itali jingl xue xavier vera effici accur analyt model wholeprogram data cach behavior ieee transact comput v n p may sandhya krishnan sriram krishnamoorthi gerald baumgartn chichung lam j ramanujam p sadayappan venkatesh choppella effici synthesi outofcor algorithm use nonlinear optim solver journal parallel distribut comput v n p may zhiyuan li yonghong song automat tile iter stencil loop acm transact program languag system topla v n p novemb chen ding ken kennedi improv effect bandwidth compil enhanc global cach reus journal parallel distribut comput v n p januari