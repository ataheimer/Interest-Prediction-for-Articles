t obtain knuth morri pratt string matcher partial evalu a present first formal proof partial evalu quadrat string matcher yield precis behaviour knuth morri pratt linear string matcherobtain kmplike string matcher canon exampl partial evalu start naiv quadrat program check whether pattern occur text one ensur backtrack perform partialevalu time a bindingtim shift yield stage string matcher special result stage program yield residu program back text la kmp awar howev formal proof partial evalu stage string matcher precis yield kmp string matcher fact specif string matcherin articl present stage string matcher formal prove perform sequenc comparison pattern text kmp string matcher end oper specifi program languag matcher written formal sequenc comparison trace semant also state mild condit special stage string matcher respect pattern string provabl yield special string matcher whose size proport length pattern string whose time complex proport length text string final show tabul one function stage string matcher give rise next tabl origin kmp algorithmth method scale obtain linear string matcher known new b introduct obtain knuth morri pratt linear string matcher naiv quadrat string matcher tradit exercis partial evalu run match pat re run pe match pat run match pat re given static pattern partial evalu perform backtrack static produc special matcher travers text linear time initi exercis propos futamura illustr gener partial comput form partial evalu memoiz result dynam test process condit branch subsequ consel danvi point bindingtim improv ie stage quadrat string matcher could also special linear string matcher use standard mixstyl partial evalu number public follow show either rang bindingtim improv string matcher present rang partial evalu integr bindingtim improv year howev observ kmp test call appear littl impact ani develop algorithm outsid field partial evalu except grobauer lawal recent work issu precis character time space special string matcher address goal work address second item hope contribut remedi first one long run work relat origin kmp algorithm stage quadrat string matcher keep one charact neg inform essenti consel danvi origin solut mani way stage string matcher show one appendix a approach semant rather algorithm intuit exampl dynam test comparison static ie known charact pattern dynam ie unknown charact text one condit branch charact match static know dynam charact is branch charact mismatch static know dynam charact not former piec posit inform latter piec neg inform formal imper languag similar one kmp algorithm tradit specifi formal subset scheme stage matcher specifi present two trace semant account sequenc indic correspond success comparison charact pattern text show kmp algorithm stage matcher share trace analyz bind time stage matcher use otheshelf bindingtim analysi that similix observ dynam comparison one static pattern dynam text therefor special stage string matcher preserv trace given oin program special such similix comput static oper special time gener residu program dynam oper disappear duplic execut order sourc program also assess size residu program proport size correspond static pattern correspond preserv trace show stage matcher keep one charact neg inform correspond special the second half of kmp algorithm precis also two corollari stage matcher keep track neg inform srensen gluck joness work posit supercompil give rise kmp algorithm instead observ stage matcher give rise morri pratt algorithm chapter also linear slightli less ecient stage string matcher keep track charact neg inform accumul consecut charact mismatch futamura gener partial comput gluck klimov supercompil jone gomard sestoft textbook figur give rise kmp algorithm either correspond residu program slightli ecient kmp algorithm size linearli proport length pattern inde grobauer lawal shown size residu program bound pat pat denot pattern denot alphabet said a linear string match kmp exampl handbook exact string match charra lecroq list dierent algorithm follow tradit count size integ unit exampl tabl integ size log n integ lie interv n consid size m b mani naiv string matcher exist stage yield varieti linear string matcher eg boyer moor observ half algorithm list charra lecroq obtain special version stage string matcher prove observ done manner present articl kmp furthermor obtain new linear string matcher explor varieti stage string matcher overview rest articl organ follow section specifi oper semant imper languag use knuth morri pratt section specifi oper semant subset scheme section specifi abstract syntax languag express valu evalu rule string matcher semant string matcher abstract semant string matcher point abstract semant account sequenc comparison pattern text knuth morri pratt algorithm the imper matcher stage string matcher the function matcher lemma show abstract semant faith account comparison pattern text string matcher theorem establish correspond abstract imper matcher section theorem section abstract function matcher section concret imper matcher section section concret function matcher section section section show imper matcher function matcher give rise sequenc comparison section investig result special function matcher respect pattern string use program special use simpl form data special section conclud kmp imper section describ imper languag imper string matcher specifi languag canon constant mutabl identifi immut array present imper string matcher mean final specifi trace semant imper matcher abstract syntax program consist statement stm express e exp numer mutabl identifi x mid array identifi aid oper opr opr xe ss e els fi e od return e e num x c ae e opr e e e express valu valu integ boolean charact alphabet rule follow rule e exp v auxiliari construct languag includ numer oper comparison oper charact store store total function constant constant defin total function array array defin partial function n denot set natur number includ zero index array start zero index bound undefin relat bigstep evalu relat express read smallstep evalu relat statement read r stm comput progress r unit comput complet normal r z comput abort return choos bigstep evalu relat express interest intermedi evalu step choos smallstep evalu relat statement want monitor progress imper comput express var array statement assign while e od unit while e od swhile e od a c return e n string matcher kmp algorithm consist two part initi next tabl actual string match initi next tabl first part build next tabl pattern satisfi follow definit tabl next tabl array indic length pattern next j largest less j pat j exist next j initi next tabl describ pseudocod figur assum pat txt lpat ltxt given initi store pat denot pattern lpat length txt denot text ltxt length j lpat patj patt nextj nextt els nextj od figur initi next tabl string match second part travers text use next tabl describ program figur written imper languag specifi section second part lpat ltxt constant identifi j k mutabl identifi pat txt next array identifi pat denot pattern lpat length txt denot text ltxt length write pseudocod instead code languag section array immut could easili extend languag support mutabl array would clutter rest develop side condit express next tabl updat second part kmp algorithm therefor chosen simplifi languag jlpat kltxt j patj txtk figur imper string matcher rest articl consid second part kmp algorithm refer imper matcher semant imper matcher consid mean imper matcher state without proof imper matcher termin access pattern text next tabl within bound sequenc indic correspond success comparison charact pattern text imper languag determinist kmp algorithm correct string matcher sequenc exist uniqu imper comparison string matcher section deriv tree form deriv tree definit index follow function map imper comparison correspond pair indic pattern text index definit comput imper comput deriv imper matcher premis sn deriv tree contain pattern text next tabl c contain length pattern text imper matcher initi state map identifi zero comput said complet r n imper comput premis might contain imper com parison want build sequenc indic correspond success comparison charact pattern text appli index function imper comparison premis give indic collect sequenc nonempti set pair indic follow premis imper comput let c set imper comparison n imper trace sequenc neutral element concaten section lemma show premis definit contain one imper comparison therefor i p either empti singleton set imper trace thu sequenc singleton set correspond success comparison charact pat txt choos three program point one check whether end pattern end text one compar charact pattern charact text one reiniti index pattern ie shift pattern page base next tabl definit program point imper program point match compar shift defin follow set configur match compar shift jlpat kltxt j patj txtk set imper program point defin sum compar abstract semant definit abstract state set abstract imper state sum set abstract imper final state set abstract imper intermedi state state state int state fin state int match compar shift inject tag definit program point abstract state defin correspond abstract imper state union imper program point final result follow relat state int pp match j match compar j compar shift j definit abstract matcher let pat txt let next next tabl pat abstract imper matcher follow total function state int state match j compar j compar j shift j compar nextj match function last yield last element nonempti sequenc abstract state last state last definit abstract comput let pat txt let correspond abstract imper matcher set abstract imper comput abscomp state least set close match last s p p abscomp said complet i last s state fin comput faith abstract imper comput repres imper comput faith word imper comput start initi deriv either contain program point contain program point apart final configur contain comparison final configur program point p match match p whenev last configur imper comput imper program point p relat abstract state s exist imper program point final result p abstract state follow hold deriv p p contain program point p deriv contain comparison c index proof part straightforward verifi part must divid case dictat abstract matcher show singl case p match k case similar deriv while jlpat kltxt od unit jlpat kltxt od els return if j lpat return kj els return a c if j lpat return kj els return return kj var sinc match j kj also kj n furthermor observ deriv contain program point comparison sinc one comparison exist step deriv imper trace definit sequenc singleton set moreov sinc imper matcher termin abstract matcher well definit abstract trace abstract imper trace map sequenc abstract state anoth sequenc abstract state trace state trace follow corollari lemma show abstract imper trace repres imper trace corollari imper trace faith let pat txt given imper trace complet imper comput let compar j abstract imper trace correspond complet abstract imper comput word abstract trace faith repres imper trace summari formal specifi imper string matcher implement kmp algorithm given trace semant account indic success compar charact pattern text next section turn function string matcher treat similarli kmp function section describ function languag function string matcher specifi languag firstord subset scheme tail recurs equat present function string matcher mean final specifi trace semant function matcher abstract syntax program consist seriou express e exp trivial express triv oper opr opr numer num num valu identifi x vid function identifi f fid sequenc valu identifi x vid express valu valu integ boolean charact string rule auxiliari construct languag includ numer oper comparison oper charact stringindex oper c ith charact s index string start zero index bound undefin environ express evalu valu environ venv function environ relat bigstep evalu relat trivial express read smallstep evalu relat seriou express read e f r choos bigstep evalu relat trivial express interest intermedi evalu step choos smallstep evalu relat seriou express want monitor progress comput program top level program evalu initi function environ hold predefin function initi valu environ hold predefin valu initi configur program thu e function environ trivial express var seriou express string matcher consid string matcher figur motiv appendix a written subset scheme specifi section initi environ bind pat lpat pattern length txt ltxt text length none pat txt lpat ltxt bound program therefor denot initi valu throughout rest articl refer string matcher function matcher semant function matcher consid mean function matcher sequenc indic correspond success comparison charact pattern text function comparison string matcher section deriv tree form denot anoth deriv tree letrec match lambda j if k ltxt compar j k compar lambda j if eq stringref pat match if match rematch rematch lambda j k jp kp if kp if eq stringref pat jp if jp match rematch compar jp k if eq stringref pat jp rematch rematch match figur function matcher definit index follow function map function comparison correspond pair indic pattern text index f definit comput function comput deriv function matcher premis deriv tree initi function environ e function matcher valu environ map pat txt lpat ltxt pattern text length respect valu identifi zero comput said complet r n function comput premis might contain function compar ison want build sequenc indic correspond success comparison charact pattern text appli index function function comparison premis give indic collect sequenc nonempti set pair indic follow definit premis function comput let c set function comparison e n function trace sequenc otherwis section lemma show premis definit contain one function comparison therefor i p either empti singleton set function trace thu sequenc singleton set correspond success comparison charact pat txt choos three program point one check whether end pattern end text one compar charact pattern charact text one match pattern prefix sux pattern program point correspond bodi match compar rematch function definit program point function program point match f compar f rematch f defin follow set configur match compar f rematch bodi match function c bodi compar function r bodi rematch function set function program point defin sum compar f rematch f abstract semant definit abstract state set abstract function state sum set abstract function final state set abstract function intermedi state f state int f state fin f state int f rematch n n n n match compar rematch inject tag definit program point abstract state defin correspond abstract function state union function program point final result follow relat f state int match j compar j rematch j k jp kp f e rematch f definit abstract matcher let pat txt abstract function matcher follow total function f state int match j compar j compar j match rematch j k otherwis rematch j k jp kp f match compar jp rematch j k jp definit last function last f yield last element nonempti sequenc abstract state last last definit abstract comput let pat txt let f correspond abstract function matcher set abstract function comput abscomp f state f least set close match last f s f p p abscomp f said complet i last f s state fin f comput faith abstract function comput repres function comput faith word function comput start initi deriv either contain program point contain program point apart final configur contain comparison final configur program point p match f match whenev last configur function comput function program point p relat abstract state s f exist function program point final result p abstract state follow hold deriv p p contain program point f f p deriv contain comparison c indexf proof part straightforward verifi part must divid case dictat abstract matcher show singl case p match f txt case similar deriv var var compar app c denot bodi compar function definit sinc match j k also compar j k correspond final configur deriv furthermor observ deriv contain program point comparison sinc one comparison exist step deriv function trace definit sequenc singleton set moreov one matcher termin well definit abstract trace abstract function trace map sequenc abstract state anoth sequenc abstract state trace trace follow corollari lemma show abstract function trace trace corollari function trace faith let pat txt given function trace complet function comput let compar j abstract trace correspond complet abstract function compu tation word abstract trace faith repres function trace lemma invari let pat txt abscomp f correspond set abstract function comput s follow condit whose conclus call invari satisfi proof let pat txt given let abscomp f proof structur induct s base case show invari hold initi induct case show invari preserv match compar rematch initi definit abscomp f initi abstract function state comput match length string pat txt nonneg insert obtain m thu hold trivial initi abstract function state preserv match let us assum invari m m hold abstract function state match j k consid three possibl case j next abstract state abstract function comput therefor kj invari preserv next abstract state therefor invari preserv next abstract state therefor compar k case assumpt invari c c invari thu preserv match preserv compar let us assum invari c c hold abstract function state compar j k consid three possibl case next abstract state abstract function comput match sinc j k pat txt integ j pat hold sinc premis true invari c c invari m m hold txtk patj definit compar j next abstract state match argument ident obtain invari m insert valu invari m done init case also obtain invari m txtk patjj definit compar j next abstract state rematch due c j r hold c ident r thu r hold convent denot empti string similarli patkp jp denot empti string invari r hold final r hold trivial interv kp jp denot empti set convent invari thu preserv compar preserv rematch let us assum invari r r r r r hold abstract function state rematch j k jp kp consid five possibl case definit rematch j k jp kp f match next abstract state abstract function comput match invari r obtain shown abov definit rematch j k jp kp f next abstract state rematch invari r r hold j k trivial updat immedi give invari r r kp sinc j invari r satisfi first look pat patjp empti string sinc empti string therefor invari r hold invari know bodi r hold everi k interv kp jp sinc j need show pat patj k specif easili seen sinc case assumpt give patj invari r hold k next abstract state therefor compar r r case assumpt hold sinc k kp next abstract state therefor rematch give us r pat patjp need show patjp true case assumpt thu r hold sinc interv k unchang hold assumpt kp j patjp patkp definit rematch j k jp kp f rematch j k kp jp next abstract state therefor rematch trivial updat j k r r shown abov still hold clearli jp assumpt kp jp give us kp final sinc kp j kp j kp thu invari r hold again shown second case string empti condit thu invari r hold similarli second case need show pat patj specif hold consid jpth k jpth entri charact patjp patkp respect sinc k kp case assumpt entri distinct conclud show first string contain jpth entri case assumpt us that jp thu invari r hold key connect abstract function matcher abstract imper matcher state follow remark remark show interpret invari r term next tabl remark notic j b k a bpat patj definit next j cannot occur interv j b j a inde k j pat patj k patj k patj j k candid nextj therefor negat condit give us j k candid nextj summari formal specifi function string matcher given trace semant account indic success compar charact pattern text next section show given pattern text trace imper matcher function matcher coincid extension correspond imper function matcher definit correspond defin correspond imper function state relat state state f match j compar j shift j defin state state f sequenc f hold empti sequenc synchron relat sync state state f defin trace s trace f s last s last f s theorem abstract equival given pattern text uniqu complet abstract imper comput uniqu complet abstract function comput two abstract comput synchron ie sync hold proof let pat txt given let abscomp proof structur induct abstract comput base case prove abstract comput start abstract state therefor initi synchron induct case prove synchron alway preserv initi definit abscomp abscomp f abstract comput start abstract state match sinc syncmatch match hold abstract comput initi synchron preserv match assumpt initi subsequ synchron ie synci hold last last f match j k three case occur exhaust invari lemma j similarli definit match j j assumpt synci hold therefor thu complet abstract comput synchron similarli definit match j abov synchron preserv sinc comput end integ j pat k txt definit match j larli definit match j assumpt synci compar j k compar j k also hold synchron thu preserv case preserv compar assumpt initi subsequ synchron ie synci hold last last f compar j k three case occur exhaust invari lemma txtk patj definit compar j similarli definit compar j sinc definit sinc synci assumpt shift state includ abstract trace synci shift j match txtk patjj definit compar j similarli definit compar j hold assumpt shift j similarli definit compar j synci hold assumpt synci match j k match again synchron preserv case preserv rematch shift assumpt initi subsequ synchron ie synci hold last last f rematch j k jp kp sinc definit shift j jp kp consid case abstract function comput goe abstract state form dierent rematch j k jp kp sound recurs call rematch function never diverg the lexicograph order m kp jp jp termin relat rematch call match compar two case occur definit rematch j k jp kp f match know invari r hold k interv remark impli next j case assumpt know next j j next therefor definit abstract imper matcher shift j synci hold assumpt synci match k match k also hold due invari r r jp pat definit rematch j k jp kp f compar jp k know bodi invari r hold k interv jjp remark give us next j jp j r know case assumpt patjp patj therefor jp candid next j sinc next j sinc next j largest valu less j satisfi requir next invari r know jp definit abstract imper matcher shift j compar jp k sinc synci hold assumpt synci compar jp k compar jp k also hold sinc kmp algorithm termin sinc abstract matcher total function complet abstract comput exist uniqu posit state main result captur diagram section abstract imper matcher section theorem section abstract function matcher section concret imper matcher section section concret function matcher section section corollari equival let pat txt given correspond complet imper comput c final configur n number n correspond complet function computa tion c final configur n number n trace c c equal proof theorem abstract function matcher termin corollari function matcher complet function comput therefor exist lemma lemma corollari abstract comput repres comput trace result repres faith final theorem abstract comput synchron mean abstract trace result equal summar shown given pattern text trace imper matcher function matcher coincid sens two matcher do same albeit dierent time complex next section show elimin extra complex function matcher use partial evalu intension correspond imper function matcher turn special function string matcher respect given pattern first use partial evalu ie program special next consid simpl form data special first show size special program linear size pattern special program run time linear size text next show special data coincid next tabl kmp section inform make somewhat liber use partial evalu terminolog defin main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j k compar j k compar lambda j k match if match rematch rematch lambda j k jp kp if kp if eq stringref pat jp if jp match rematch compar jp k if eq stringref pat jp rematch rematch match figur bindingtim annot function matcher program special figur display bindingtim annot version complet function matcher deriv appendix a formal paramet tag s for static d for dynam depend whether denot valu depend data avail partialevalu time whether denot valu may depend data avail run time addit dynam condit express dynam test dynam addit subtract box part sourc program static evalu partialevalu time dynam part reconstruct give rise residu program partial evalu similix design preserv dynam comput order present case dynam test among dynam comput guarante occur special program order sourc program therefor construct similix gener program travers text order function matcher thu kmp algorithm exampl special function matcher respect pattern abac without postunfold result residu program display figur lambdadrop renam the charact follow subscript next charact pattern match textan intuit notat suggest grobauer lawal special string matcher travers text linearli compar charact text liter charact pattern articl page knuth morri pratt display similar program next tabl compil control flow come back point end section revisit partial evalu pattern match string grobauer lawal analyz size complex residu code produc similix measur term number residu test show size residu program linear length pattern time complex linear length text manner show similix yield residu program linear length pattern whose time complex linear length text similix polyvari programpoint special build mutual recurs special version sourc program point by default condit express dynam test sourc program point special respect set static valu correspond residu program point index set sourc program point met set static valu residu call correspond residu program point gener proposit special function matcher figur respect pattern yield residu program whose size linear length pattern proof inform function residu code gener main match compar first one main goal function contain memoiz point one residu main function gener exactli one memoiz pointa dynam condit express function match compar static data avail two memoiz point bound j pat lpat piec static data vari valu j ie j sinc j pat memoiz point becaus invari lemma section fact memoiz point match reach j pat pat variant two memoiz point gener number defin mainabac txt let ltxt stringlength txt defin match abac defin compar abac if eq a stringref txt k match abac k match abac k defin match abac defin compar abac if eq b stringref txt k match abac k compar abac k defin match abac defin compar abac if eq a stringref txt k match abac k match abac k defin match abac defin compar abac if eq c stringref txt k compar abac k match abac txt evalu mainabac txt yield result evalu main abac txt k evalu match abac k scope ltxt yield result evalu match k scope lpat ltxt lpat denot length pat ltxt denot length txt k evalu match abac k scope ltxt yield result evalu match scope lpat ltxt k evalu match abac k scope ltxt yield result evalu match k scope lpat ltxt k evalu match abac k scope ltxt yield result evalu match k scope lpat ltxt figur result special function matcher wrt abac residu function therefor linear size pattern addit size function bound small constant seen one write bnf residu program proposit special function matcher figur respect pattern yield residu program whose time complex linear length text proof inform proven knuth morri pratt kmp algorithm perform number comparison charact pattern text linear length text corollari show function matcher perform exact sequenc comparison charact pattern text kmp algorithm comparison perform compar function exactli one comparison perform call compar number call compar therefor linear length text sinc match function either termin call compar number call match bound number call compar proposit residu code gener function main compar match time complex function main compar match easili seen bound small constant sinc main call number call compar match linear length text time complex residu program linear length text data special section remark connect rematch function function matcher next tabl kmp algorithm section revisit connect show actual deriv kmp algorithm next tabl function matcher use simpl form data special end first restat function matcher function matcher function tail recurs ie iter call other particular rematch complet either call match call compar two actual paramet match liter increment k avail scope match two actual paramet compar jp comput cours rematch k avail scope compar make possibl tabul rematch function modifi function matcher longer tail recurs instead rematch call match compar tail recurs make return valu call match compar set valu jp a natur number correspondingli instead compar call rematch tail recurs make dispatch result rematch call match compar tail recurs result display figur proof theorem show rematch termin call compar jp equal next j kmp algorithm also show defin main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j if k ltxt compar j k compar lambda j if eq stringref pat match if match let next rematch j if next match compar next k rematch lambda j jp kp if kp if eq stringref pat jp if jp rematch if eq stringref pat jp rematch rematch match figur variat function matcher match call rematch valu next j kmp algorithm call rematch compar therefor call new rematch function equival lookup next tabl kmp algorithm particular tabul pat input valu rematch correspond j pat yield next tabl use kmp algorithm simpl data special yield string matcher travers text linearli match pattern look next index pattern next tabl case mismatch word data special function matcher yield kmp algorithm particular special string matcher figur or tabul version respect pattern would compil correspond next tabl control flow residu program result would coincid compil code knuth morri pratt articl page conclus issu present first formal proof partial evalu precis yield kmp extension trace semant synchron intension size special program relat next tabl actual deriv kmp algorithm shown key obtain kmp naiv quadrat string matcher keep backtrack static control also maintain exactli one charact neg in format consel danvi origin solut togeth grobauer lawal complex proof size time complex residu program buildup corollari pave way relat eect stage string matcher independ known string matcher eg boyer moor work led us consid famili kmp algorithm relat follow famili stage string matcher stage string matcher keep track neg inform give rise knuth morri pratt next tabl f function page ie morri pratt algorithm chapter tabul function yield array size pattern stage string matcher keep track one charact neg inform correspond knuth morri pratt algorithm next tabl stage string matcher keep track limit number charact neg inform give rise kmplike algorithm correspond residu program ecient also bigger stage string matcher keep track charact neg inform also give rise kmplike algorithm correspond residu program even ecient also even bigger grobauer lawal shown size residu program bound pat size alphabet howev conjectur string matcher keep track two charact neg inform tighter upper bound size twice length pattern ie pat conjectur hold short pattern let us conclud two point obtain ecient string matcher partial evalu naiv string matcher obtain ecient essenc obtain ecient string matcher partial evalu naiv string matcher ensur backtrack naiv matcher static one either stage naiv matcher use simpl partial evalu keep naiv matcher unstag use sophist partial evalu matter backtrack carri special time dynam comput preserv special program size residu program provid lower bound time complex special exampl look kmp size residu program proport size pattern posit inform kept best generalpurpos partial evalu could thu proceed time linear pat ie opat first pass kmp algorithm how ever evalu static part sourc program special time driven static control flow sourc program seem like optim strategi even discount complex bindingtim analysi exampl data special section work time quadrat pat ie opat construct next tabl hand ecient treatment could one bullet partial evalu gun section ie treatment gener applic dramat eect occasion exampl prove conjectur could lead bullet acknowledg grate torben amtoft julia lawal karolin malmkjr jan midtgaard mikkel nygaard anonym review varieti comment special thank andrzej filinski comment led us reshap articl work support esprit work group appsem http wwwmdchalmerssecsresearchsemanticsappsem stage quadrat string matcher figur display naiv quadrat string matcher success check whether pattern pat prefix one success sux text txt main function initi indic j k access pat txt match function check whether match finish either success failur whether one comparison need compar function carri comparison either continu match rest pat rest current sux txt start match pat next sux txt figur display stage version quadrat string matcher instead match pat next sux txt version use rematch function recompar function first match pat prefix sux pat know equal correspond segment txt eventu rematch function resum match rest pattern rest txt result stage string matcher backtrack txt partialevalu jargon string matcher figur use posit inform text see footnot page piec neg inform also avail name latest charact provok mismatch figur display stage version quadrat string matcher exploit neg inform rather blindli resum compar function rematch function first check whether charact caus latest mismatch could caus new mismatch therebi avoid one access text simplifi formal develop inlin recompar rematch lambdalift rematch lexic level match compar result string matcher display figur section cours mani way stage string matcher one chosen easi deriv easi reason about r abstract instanti stringmatch program mix comput translat linearis decomposit compil similix manual automat autoproject recurs equat global variabl abstract data type exact string match algorithm sandrin chiroko partial evalu pattern match string transform recurs equat program block structur program transform system base gener partial comput gener partial comput essenc gener partial comput occam razor metacomput notion perfect process tree partial evalu pattern match string lambda lift transform program recurs equat partial evalu automat program gener revis report algorithm languag scheme data special fast pattern match string program data special principl abstract interpret partialevalu algo rithm transformationbas optimis haskel christian queinnec jeanmari geroy partial evalu pattern match constraint logic program languag posit su percompil tr lambda lift transform program recurs equat partial evalu pattern match string partial evalu pattern match constraint logic program languag automat autoproject recurs equat global variabl abstract data type essenc gener partial comput partial evalu automat program gener abstract interpret partial evalu algorithm data special transformationbas optimis haskel lambdadrop glossari partial evalu relat topic program transform system base gener partial comput revis report algorithm languag scheme combin program data special occam razor metacompu partial evalu pattern match string revisit ctr mad sig ager olivi danvi hen korsholm rohd fast partial evalu pattern match string acm sigplan notic v n p octob yoshihiko futamura zenjiro konishi robert glck automat gener effici string match algorithm gener partial comput proceed asian symposium partial evalu semanticsbas program manipul p septemb aizu japan olivi danvi hen korsholm rohd obtain boyermoor stringmatch algorithm partial evalu inform process letter v n p august mad sig ager olivi danvi hen korsholm rohd fast partial evalu pattern match string acm transact program languag system topla v n p juli germn vidal costaug partial evalu function logic program higherord symbol comput v n p marchjun