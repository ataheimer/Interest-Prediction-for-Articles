t cach sensit modulo schedul a paper focus interact softwar prefetch both bind nonbind softwar pipelin vliw machin first shown evalu softwar pipelin schedul without consid memori effect rather inaccur due stall caus depend memori instruct even lockupfre cach consid also shown penalti stall gener higher effect spill code second show gener bind scheme power nonbind one softwar pipelin schedul final main contribut paper heurist scheme schedul memori oper accord local estim compil time attribut depend graph propos scheme shown outperform heurist approach sinc achiev better tradeoff comput stall time other b introduct softwar pipelin wellknown loop schedul techniqu tri exploit instruct level parallel overlap sever consecut iter loop execut parallel differ algorithm found literatur gener softwar pipelin sched ule popular scheme call modulo schedul main idea scheme find fix pattern oper call kernel steadi state consist oper distinct iter find optim schedul resourc constrain scenario npcomplet problem practic propos base differ heurist strategi key goal scheme achiev high throughput eg minim regist pressur eg eg none evalu effect memori scheme assum fix latenc memori oper usual correspond cachehit latenc lockupfre cach allow processor stall cach miss howev vliw architectur processor often stall afterward due true depend previou memori oper altern schedul load use cachemiss latenc requir consider instruct level parallel increas regist pressur softwar prefetch effect techniqu toler memori latenc softwar prefetch perform two altern scheme bind nonbind prefetch ing first altern also known earli schedul memori oper move memori instruct away instruct depend them second altern introduc code special instruct call prefetch instruct nonfault instruct perform cach lookup modifi regist altern prefetch scheme differ drawback bind scheme increas regist pressur lifetim valu produc memori oper stretch may also increas initi interv due memori oper belong recurr nonbind scheme increas memori pressur sinc increas number memori request may produc increas initi interv besid may produc increas regist pressur sinc lifetim valu use comput effect address stretch higher regist pressur may requir addit spill code result addit memori pressur paper investig interact softwar prefetch softwar pipelin vliw machin first show previou scheme consid effect memori penalti produc schedul far optim evalu take account realist cach memori evalu sever heurist schedul memori oper insert prefetch instruct softwar pipelin schedul contribut stall spill code quantifi case show stall penalti much higher impact perform spill code propos heurist tri trade initi interv stall time order minim execut time softwar pipelin loop final show scheme base bind prefetch effect base nonbind prefetch softwar pipelin schedul use bind nonbind prefetch previous studi respect among other howev knowledg previou work analyz interact prefetch scheme softwar pipelin techniqu select schedul schedul oper cachehit latenc other cachemiss latenc like scheme propos paper howev select schedul base profil inform wherea method base static analysi perform compiletim addit select schedul consid interact softwar pipelin rest paper organ follow section motiv impact memori latenc may softwar pipelin loop section evalu perform simpl scheme schedul load store instruct section describ new algorithm propos paper section explain experiment methodolog present perform result final main conclus summar section motiv softwar pipelin loop via modulo schedul character basic two term initi stage counter former indic number cycl initi success iter latter show mani iter over lap way execut time loop calcul as given architectur given schedul first term sum call comput time rest paper fix determin compil time stall time mainli due depend previou memori instruct depend runtim behavior program eg miss ratio outstand miss etc order minim execut time classic method tri minim initi interv goal reduc fix part exec minimum initi interv bound resourc recurr lower bound due resourc constraint architectur assum function unit pipelin calcul as indic number oper type loop bodi indic number function unit type architectur lower bound due recurr graph comput as repres sum node latenc recurr repres sum edg distanc recurr particular data flow depend graph given architectur result ii depend latenc schedul assign oper latenc oper usual known compil except memori oper variabl latenc ii also depend affect spill code introduc schedul paramet fix convent modulo schedul propos use fix latenc usual cachehit time schedul memori instruct schedul instruct minimum latenc minim regist pressur thu reduc spill code hand minimum latenc schedul increas stall time data depend particular oper need data load previou instruct memori access finish yet processor stall data avail figur show sampl schedul data depend graph given architectur case memori instruct schedul cachehit latenc stall time ignor ii sc re ii rec ii re ii re max op arch nop op nfu op ii rec ii rec max rec graph lat rec dist rec usual studi deal softwar pipelin techniqu expect optimist execut time suppos huge obvious optimist estim actual execut time rather inaccur instanc suppos miss ratio n load oper eg stride element per cach line everi cach miss processor stall cycl call penalti penalti particular memori instruct depend hit latenc miss latenc distanc schedul memori oper first instruct use data produc memori instruct depend n n penalti cycl stall time assum remain depend produc penalti is therefor case actual execut time near twice optimist execut time assum miss ratio instead discrep optimist actual execut time even higher case stall time is therefor load mult load add storen alu mem b data flow depend graph b code schedul c kernel instruct latenc loadstor a origin code enddo figur sampl schedul memori refer consid effect stall time could greater discrep optimist estim usual util evalu perform softwar pipelin schedul actual perform could much higher also conclud schedul scheme tri minim stall time may provid signific advantag paper propos schedul evalu compar other use exec metric requir consid runtim behavior individu memori refer requir simul memori system basic scheme schedul memori oper section evalu perform basic scheme schedul memori oper point drawback them motiv new approach propos next section alreadi mention previou section modulo schedul scheme usual schedul memori oper use cachehit latenc scheme call cachehit latenc chl scheme expect produc signific amount processor stall suggest previou section approach reduc processor stall insert prefetch instruct everi memori oper instruct schedul distanc equal cachemiss latenc actual memori refer scheme call insert prefetch alway ipa howev scheme may result increas number oper due prefetch instruct also addit spill code therefor may requir ii higher previou approach final altern approach schedul memori oper use cachemiss latenc scheme call earli schedul alway esa scheme prefetch data without requir addit instruct may result increas ii memori instruct recurr besid may also requir addit spill code figur compar perform three scheme specfp benchmark two differ architectur detail evalu methodolog architectur given section column split comput stall time figur also shown lower bound execut time opt lower bound correspond execut program memori oper schedul use cachehit latenc which minim spill code assum alway hit cach which result null stall time lower bound defin optimist execut time section main conclus drawn figur perform three realist scheme far away lower bound gener chl scheme result signific percentag stall time for aggress architectur stall time repres execut time program ipa scheme reduc significantli stall time complet due fact program especi tomcatv swim cach interf instruct short distanc therefor prefetch alway effect may collid replac data use besid ipa scheme result signific increas comput time program eg hydrod turbd among other esa scheme practic elimin stall time remain stall time basic due lack entri outstand miss tabl use implement lockupfre cach howev scheme increas significantli comput time program like turbd by factor aggress architectur mgrid hydrod due memori refer recurr limit ii csm algorithm section propos new algorithm call cach sensit modulo schedul csm tri minim comput time stall time term independ reduc one may result increas other shown previou section propos algorithm tri find best tradeoff two term csm algorithm base earli schedul select chosen memori oper schedul memori oper use cachemiss latenc hide almost memori latenc shown previou section without increas much number instruct as oppos use prefetch instruct howev increas execut time three way may increas regist pressur therefor may increas due spill code perform loop bound memori oper may increas latenc memori oper augment may increas length individu loop iter may increas augment cost prolog epilog figur basic scheme perform chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt normal loop execut time tomcatv swim sucor hydrod mgrid turbd specfpchl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt normal loop execut time tomcatv swim sucor hydrod mgrid turbd a simpl architectur b aggress architectur ii ii rec two main issu csm algorithm reduct impact recurr ii minim stall time problem cost prolog epilog handl comput two altern schedul focu minim stall time ii howev one reduc impact prolog epilog expens increas stall time wherea care prolog epilog cost then depend number iter loop effect one chosen core csm algorithm shown figur algorithm make use static local analysi addit issu order determin latenc consid schedul individu instruct local analysi base analysi present divid three step reus analysi comput intrins reus properti memori instruct propos goal determin kind reus exploit refer loop five type reus determin none selftempor selfspati group tempor groupspati interfer analysi use initi address refer previou reus analysi determin whether two static instruct alway conflict cach besid selfinterfer also taken account consid stride exhibit static instruct refer interfer refer figur csm algorithm function csmsinnerloop il return schedul recurrencesingraph els endif niter upperbound return sch els return sch endif endfunct function computeschedminreceffectgraph g return schedul re foreach recurr r g ii rec r ii endif endforeach return computeschedulingg endfunct function minimizerecurrenceeffectrec r int ii return integ orderinstructionsbylocalityr ii rec r ii endwhil return endfunct figur schedul loop recurr enc consid type local even exhibit type reus volum analysi determin refer cannot exploit reus displac cach base comput amount data use refer loop analysi conclud refer expect exhibit local reus interfer includ itself volum data consecut reus lower cach size initi two data depend graph node edg gener differ latenc assign node grph memori node tag accord local analysi tag cachehit latenc exhibit type local cachemiss latenc otherwis grph memori node tag cachemiss latenc then schedul minim impact recurr ii comput graph use function computeschedminreceffect shown figur first step function chang latenc memori oper insid recurr limit ii cachemiss cachehit ii limit resourc constrain recurr node modifi chosen accord local prioriti order start one exhibit local then second step comput actual schedul use modifi graph step perform softwar pipelin schedul propos literatur final minimum number iter upperbound ensur sch better sch comput main differ two schedul cost prolog epilog part lower sch bound depend comput schedul result local analysi calcul estim execut time schedul sch chosen execut time given schedul estim stall time estim penalti calcul explain section missratio estim local analysi way sch prefer sch if use schedul accord local chl which achiev minimum sc order take account possibl poor local loop perform evalu csm section present perform evalu csm algorithm compar perform basic scheme evalu section also compar alter est est stall est niter penalti op op mem penalti latmiss cycleus cycleprod op mem nativ bind earli schedul nonbind insert prefetch instruct prefetch scheme architectur model vliw machin consid evalu perform differ schedul algorithm model two architectur order evalu differ aspect produc schedul execut time stall time spill code etc first architectur call simpl compos four function unit integ float point branch memori cachemiss latenc first level cach cycl second architectur call aggress two function unit type cachemiss latenc cycl function unit fulli pipelin except divid squar root oper model first memori level correspond kb lockupfre directmap cach line byte outstand miss featur model architectur depict tabl model architectur two reason processor stall a instruct requir operand avail yet eg read second level cach b memori instruct produc cach miss alreadi outstand miss experiment framework local analysi schedul task perform use ictineo toolset ictineo sourc sourc translat produc code sentenc semant similar current machin instruct translat code lowlevel represent appli classic optim depend graph innermost loop construct accord particular prefetch approach then instruct schedul instruct latenc machin model simpl aggress integ branch fu float point memori cach size kb div sqrt pow line size outstand miss control memori latenc branch number regist call return tabl model architectur use softwar pipelin algorithm particular softwar pipelin algorithm use experi report hrm shown effect minim ii regist pressur result code instrument gener trace feed simul architec ture program run first million memori refer perform figur shown section refer innermost loop contain part program measur memori refer insid innermost loop repres memori instruct consid benchmark statist innermost loop quit repres whole section program differ prefetch algorithm evalu follow specfp benchmark tomcatv swim sucor hydrod mgrid turbd restrict evalu fortran program sinc current ictineo tool process fortran code earli schedul section compar csm algorithm scheme base earli schedul memori oper scheme are i use alway cachehit latenc chl ii use alway cachemiss latenc esa iii schedul instruct type local use cachehit latenc schedul remain one use cachemiss latenc later scheme call earli schedul accord local esl differ algorithm evalu term execut time split comput stall time stall time due depend lack entri outstand miss tabl figur see result simpl aggress architectur benchmark column normal chl execut time seen csm algorithm achiev comput time close chl scheme wherea chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm normal loop execut time tomcatv swim sucor hydrod mgrid turbd chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm normal loop execut time tomcatv swim sucor hydrod mgrid turbd a simpl architectur b aggress architectur figur csm algorithm compar earli schedul stall time close esa scheme is result best tradeoff comput stall time program recurr limit initi interv therefor esa scheme increas comput time for instanc hydrod turbd benchmark csm method minim effect expens slight increas stall time tabl show rel speedup differ schedul respect chl scheme averag altern schedul outperform chl scheme which usual one use softwar pipelin schedul howev program mainli turbd esa esl schedul perform wors chl due increas ii caus recurr csm algorithm achiev best perform benchmark simpl architectur averag speedup aggress architectur tabl compar csm algorithm optimist execut time opt defin section use lower bound execut time also show percentag execut time processor stall seen simpl architectur csm algorithm close optimist bound caus almost stall aggress architectur perform csm wors opt stall time repres total execut time notic howev optimist bound could quit actual minimum execut time tabl compar differ scheme use chl algorithm refer point scheme show increas comput time decreas stall time seen befor schedul memori oper use cachemiss latenc affect initi interv stage counter result increas comput time column denot dcomput repres increment comput time compar chl schedul scheme s calcul as stall time due depend elimin schedul memori instruct use cachemiss latenc default spill code schedul use cachehit latenc therefor may caus stall although unlik spill code usual store follow load address sinc usual close otherwis spill code hardli reduc regist pressur load caus stall interfer memori esa esl csm esa esl csm tomcatv sucor hydrod mgrid turbd geometr mean tabl rel speedup dcomput stall refer store itself column denot stall repres percentag stall time caus chl algorithm avoid scheme s calcul as see tabl csm algorithm achiev best tradeoff comput time stall time reason outperform other esa scheme best one reduc stall time expens larg increment comput time insert prefetch instruct order reduc penalti caus memori oper altern earli schedul memori instruct insert prefetch instruct provid mani current instruct set architectur eg touch instruct powerpc new scheme introduc addit spill code sinc increas regist pressur particular lifetim valu use comput effect address increas sinc use optcsm stall optcsm stall sucor hydrod mgrid turbd geometr tabl csm compar opt schedul esa esl csm esa esl csm dcomput stall dcomput stall dcomput stall dcomput stall dcomput stall dcomput stall sucor hydrod mgrid turbd geometr tabl increment comput time decrement stall time relat chl stall chl stall prefetch ordinari memori instruct also increas initi interv due addit memori instruct evalu three altern scheme introduc prefetch instruct i insert prefetch alway ipa ii insert prefetch refer without tempor local even exhibit spatial local accord static local analysi ipt iii insert prefetch instruct without type local ipl first scheme expect result stall requir mani addit instruct may increas ii ipt scheme select ad prefetch instruct howev add unnecessari prefetch instruct refer spatial local instruct spatial local caus cach miss new cach line access cach ipl scheme conserv sens add less number prefetch instruct figur compar total execut time csm schedul abovement prefetch scheme figur normal chl schedul csm scheme alway perform better scheme base insert prefetch instruct except mgrid benchmark aggress architectur latter case ipa scheme best one perform csm close it among scheme insert prefetch instruct none outperform other gener depend particular program architectur best one among differ one prefetch scheme outperform chl scheme gener ie perform figur figur gener lower case may even wors chl gener wors scheme base earli schedul compar bind figur nonbind figur scheme observ bind prefetch alway better three first benchmark scheme similar per a simpl architectur b aggress architectur figur csm algorithm compar insert prefetch instruct ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm normal loop execut time tomcatv swim sucor hydrod mgrid turbd ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm normal loop execut time tomcatv swim sucor hydrod mgrid turbd formanc next two benchmark last one nonbind prefetch outperform bind scheme understand reason behavior prefetch scheme present addit statist aggress architectur tabl show percentag addit memori instruct execut csm algorithm scheme base insert prefetch instruct csm algorithm addit instruct due spill code wherea scheme due spill code prefetch instruct see tabl that except ipl scheme mgrid benchmark prefetch scheme requir much higher number addit memori instruct expect increas number memori instruct ipa scheme highest follow ipt ipl final csm tabl show increas comput time decreas stall time scheme base insert prefetch instruct relat chl scheme neg number indic stall time increas instead decreas see tabl comput time increas prefetch scheme sinc larg number addit instruct may impli signific increas ii loop memori bound stall time gener reduc reduct less csm scheme see tabl program mgrid one prefetch base scheme ipa outperform csm algorithm howev differ slight remain program perform csm scheme overwhelmingli better ipa scheme tabl show miss ratio differ prefetch scheme compar miss ratio nonprefetch scheme chl see gener scheme insert memori prefetch produc highest reduct miss ratio howev insert prefetch instruct remov cach miss even scheme insert prefetch everi memori instruct ipa due cach interfer prefetch instruct there spill code simul part program csm insert prefetch instr ipa ipt ipl sucor hydrod mgrid tabl percentag addit memori refer prefetch data use quit common program tomcatv swim instanc two memori refer interfer cach close code like two prefetch correspond schedul memori refer case least one two memori refer miss spite prefetch besid prefetch memori instruct schedul revers order ie instruct schedul b prefetch b schedul prefetch a memori instruct miss summar two main reason bad perform scheme base insert prefetch instruct compar csm scheme increas comput time due addit prefetch instruct spill code alway effect remov stall caus cach miss due interfer prefetch instruct ipa ipt ipl dcomput stall dcomput stall dcomput stall tomcatv sucor hydrod mgrid turbd geometr tabl increment comput time decrement stall time scheme base insert prefetch instruct chl ipa ipt ipl sucor hydrod mgrid turbd geometr tabl miss ratio chl differ prefetch scheme conclus interact softwar prefetch softwar pipelin techniqu vliw architectur studi shown modulo schedul scheme use cachehit latenc produc mani stall due depend memori instruct simpl architectur stall time repres execut time aggress architec ture thu ignor memori effect evalu softwar pipelin schedul may rather inaccur compar perform differ prefetch approach base either earli schedul memori instruct bind prefetch insert prefetch instruct nonbind prefetch seen provid signific improv gener howev method base earli schedul outperform base insert prefetch main reason wors perform latter method increas memori pressur due prefetch instruct addit spill code limit remov shortdist conflict miss propos heurist schedul algorithm csm base earli schedul tri minim comput stall time algorithm make use static local analysi schedul instruct recurr shown outperform rest strategi instanc compar approach base schedul memori instruct use cachehit latenc produc code time faster simpl architectur time faster aggress architectur former case also shown execut time close optimist lower bound r tr softwar pipelin effect schedul techniqu vliw machin softwar prefetch data local optim algorithm circular schedul architectur softwarecontrol data prefetch design evalu compil algorithm prefetch lifetimesensit modulo schedul balanc schedul evolut powerpc architectur iter modulo schedul minim regist requir resourceconstrain rateoptim softwar pipelin optimum modulo schedul minimum regist requir compil techniqu data prefetch powerpc stage schedul hypernod reduct modulo schedul predict loadstor instruct latenc decompos softwar pipelin static local analysi cach manag swing modulo schedul ctr jess snchez antonio gonzlez instruct schedul cluster vliw architectur proceed th intern symposium system synthesi septemb madrid spain enric gibert jess snchez antonio gonzlez effect instruct schedul techniqu interleav cach cluster vliw processor proceed th annual acmiee intern symposium microarchitectur novemb istanbul turkey jess snchez antonio gonzlez modulo schedul fullydistribut cluster vliw architectur proceed rd annual acmiee intern symposium microarchitectur p decemb monterey california unit state enric gibert jess snchez antonio gonzlez local schedul techniqu memori coher cluster vliw processor distribut data cach proceed intern symposium code gener optim feedbackdirect runtim optim march san francisco california javier zalamea josep llosa eduard ayguad mateo valero twolevel hierarch regist file organ vliw processor proceed rd annual acmiee intern symposium microarchitectur p decemb monterey california unit state enric gibert jess snchez antonio gonzlez interleav cach cluster vliw processor proceed th intern confer supercomput june new york new york usa javier zalamea josep llosa eduard ayguad mateo valero modulo schedul integr regist spill cluster vliw architectur proceed th annual acmiee intern symposium microarchitectur decemb austin texa alex alet josep m codina jess snchez antonio gonzlez graphpartit base instruct schedul cluster processor proceed th annual acmiee intern symposium microarchitectur decemb austin texa enric gibert jesu sanchez antonio gonzalez distribut data cach design cluster vliw processor ieee transact comput v n p octob javier zalamea josep llosa eduard ayguad mateo valero softwar hardwar techniqu optim regist file util vliw architectur intern journal parallel program v n p decemb