t modulo schedul reduc regist pressur a abstractsoftwar pipelin schedul techniqu use product compil order expos instruct level parallel innermost loop modulo schedul refer class algorithm softwar pipelin previou research modulo schedul focus reduc number cycl initi consecut iter which term ii consid effect regist pressur produc schedul regist pressur increas instruct level parallel increas regist requir schedul higher avail number regist loop must reschedul perhap higher ii therefor regist pressur import impact perform schedul paper present novel heurist modulo schedul strategi tri gener schedul lowest ii and possibl schedul ii tri select lowest regist requir propos method implement experiment compil test perfect club benchmark result show propos method achiev optim ii least percent loop compil time compar convent topdown approach wherea regist requir lower addit propos method compar exist method result indic propos method perform better heurist method almost well linear program method obtain optim solut impract product compil comput cost grow exponenti number oper loop bodi b introduct increas instruct level parallel observ trend design current microprocessor requir combin effort hardwar softwar order effect sinc execut time common program spent loop mani effort improv perform target loop nest softwar pipelin instruct schedul techniqu exploit instruct level parallel loop overlap execut success iter loop differ approach gener softwar pipelin schedul loop modulo schedul class softwar pipelin algorithm propos begin last decad incorpor product compil eg besid mani research paper recent appear topic modulo schedul framework reli gener schedul iter loop schedul repeat regular interv depend violat resourc usag conflict aris interv succes iter term initi interv ii constant initi interv impli resourc may use time modulo ii modulo schedul approach consist two step first comput schedul tri minim ii without care regist alloc then variabl alloc regist execut time softwar pipelin loop depend ii maximum number live valu schedul term maxliv length schedul one iter ii determin issu rate loop iter regard second factor maxliv higher number avail regist comput schedul feasibl influenc execut time otherwis action must taken order reduc regist pressur possibl solut outlin evalu are ffl reschedul loop increas ii gener increas ii reduc maxliv decreas issu rate neg effect execut time ffl add spill code neg effect sinc increas requir memori bandwidth result addit memori penalti eg cach miss besid memori may becom satur resourc therefor ad spill code may requir increas ii final length schedul one iter determin cost epilogu execut main loop order finish last iterarion initi main loop complet see section cost may neglig iter count loop high previou work focus reduc ii sometim also length schelud one iter consid regist requir propos schedul may sever impact perform outlin abov current trend design new processor increas amount instruct level parallel exploit exploit instruct level parallel result signific increas regist pressur exacerb problem ignor effect perform given schedul order obtain effect schedul recent propos modulo schedul approach tri minim ii regist requir produc schedul approach base formul problem term optim problem solv use integ linear program approach may produc optim schedul unfortun approach comput cost grow exponenti number basic oper loop bodi therefor impract big loop case time consum part program thu may one benefit softwar pipelin practic modulo schedul approach use product compil use heurist guid schedul process two relev heurist approach propos literatur tri minim ii regist pressur are slack schedul stage schedul slack schedul iter algorithm limit backtrack iter schedul choos oper base previouli comput dynam prioriti prioriti function slack oper ie measur schedul freedom oper also depend much critic resourc use oper are select oper place partial schedul either earli possibl late possibl choic two altern made basic determin mani oper input output stretchabl choos one minim involv valu lifetim schedul cannot place select oper due lack conflictfre issu slot forc particular slot conflict oper eject partial schedul order limit type backtrack oper eject mani time ii increment schedul start again stage schedul whole modulo schedul set heurist techniqu reduc regist requir given modulo schedul object achiev shift oper multipl ii cycl result schedul ii lower regist requir paper present hypernod reduct modulo schedul hrm heurist modulo schedul approach tri gener schedul lowest ii possibl schedul ii tri select lowest regist requir main part hrm order strategi order phase order node schedul them predecessor successor node schedul schedul except recurr schedul step node schedul earlyl possibl predecessorssuccessor preliminari version work appear previous schedul perform hrm evalu compar convent approach a topdown schedul care regist pressur evalu use thousand loop perfect club benchmark suit account execut time result show hrm achiev optim ii least loop compil time compar topdown approach wherea regist requir lower addit hrm test set loop taken compar two heurist strategi two strategi previous mention slack schedul frlc heurist strategi take account regist requir addit hrm compar spilp linear program formul problem comput requir latter approach small loop use comparison result indic hrm obtain better schedul two heurist approach result close one produc optim schedul compil time hrm similar heurist method much lower linear program approach rest paper organ follow section exampl use illustr motiv work is reduc regist pressur modulo schedul loop achiev near optim ii section describ propos modulo schedul algorithm call hrm section evalu perform propos approach final section state main conclus work overview modulo schedul motiv ex ampl section includ overview modulo schedul motiv work present paper detail discuss modulo schedul refer overview modulo schedul softwar pipelin loop schedul iter divid stage execut consecut iter distinct stage overlap number stage one iter term stage countsc number cycl per stage ii figur show depend graph run exampl use along section graph node repres basic oper loop edg repres valu gener consum oper graph figur show execut six iter softwar pipelin loop ii sc oper schedul assum fourwid issu machin generalpurpos function unit fulli pipelin latenc two cycl schedul iter obtain use topdown strategi give prioriti oper g f figur sampl depend graph critic path addit constraint resourc use cycl modulo ii figur also show correspond lifetim valu gener iter execut loop divid three phase ramp phase fill softwar pipelin steadi state phase softwar pipelin achiev maximum overlap iter ramp phase drain softwar pipelin code implement ramp phase term prologu steadi state phase execut pattern oper execut stage achiev iter piec code term kernel correspod one stage steadi state phase third piec code call epilogu requir drain softwar pipelin execut steadi state phase initi interv ii two success iter bound either loopcarri depend graph recmii resourc constraint architectur resmii lower bound ii term minimum initi interv reader refer extens dissert calcul resmii recmii sinc graph figur recurr circuit initi interv constrain avail resourc number oper divid number resourc notic schedul figur depend violat everi function unit use even cycl cycl modulo odd cycl cycl modulo code correspond kernel softwar pipelin loop obtain ovelap differ stage constitut schedul one iter shown figur b subscript code indic rel iter distanc origin loop oper instanc exampl iter kernel execut instanc oper instanc oper b previou iter initi loop valu use loop correspond either loopinvari variabl loopvari variabl loopinvari repeatedli use never defin loop execut loopinvari singl valu iter loop therefor iter iter iter iter iter prologu steadi epilogu ii kernel code iter a g f g f g f g f g f g f figur a softwar pipelin loop execut b kernel c regist requir requir one regist regardless schedul machin configur loopvari valu gener iter loop and therefor differ valu correspond iter natur softwar pipelin lifetim valu defin iter overlap lifetim valu defin subsequ iter figur show lifetim loopvari correspond everi iter loop overlap lifetim differ iter pattern length ii cycl indefinet repeat obtain pattern shown figur c pattern indic number valu live given cycl shown maximum number simultan live valu maxliv accur approxim number regist requir schedul section regist requir given schedul approxim maxliv howev experi section measur actual regist requir regist alloc valu lifetim greater ii pose addit difficulti sinc new valu gener previou one use one approach fix problem provid form regist renam success definit valu use distinct regist renam perform compil time use modulo variabl expans ie extens discuss problem alloc regist softwarepipelin loop refer strategi present paper almost alway achiev maxliv lower bound particular wandsonli strategi use endfit adjac order never requir maxliv regist unrol kernel renam compil time multipl definit variabl exist unrol kernel rotat regist file use solv problem without replic code renam differ instanti loopvari execut time motiv exampl mani modulo schedul approach lifetim valu unnecessarili larg exampl figur show topdown schedul figur bottomup schedul exampl graph figur machin four generalpurpos function unit twocycl latenc topdown strategi oper schedul predecessor alreadi schedul node place earli possibl order delay possibl successor similari bottomup strategi oper readi schedul successor alreadi schedul case node place late possibl order delay possibl predecessor strategi sever candid schedul algorithm choos one critic schedul topdown schedul node e schedul node f sinc e predecessor place cycl order delay possibl successor place earli possibl figur show lifetim loop variant topdown schedul assum valu aliv begin produc oper begin last consum notic loop variant unnecessari larg lifetim due earli placement e schedul bottomup approach e schedul f therefor place late possibl reduc lifetim figur b unfortun c schedul b and order delay possibl predecessor schedul late possibl notic vb unnecessari larg lifetim due late placement c hrm oper readi schedul even predecessor successor schedul condit to guarante preorder step oper schedul partial schedul contain predecessor successor none them in absenc recurr order done aim oper previous schedul refer oper except first oper schedul instanc consid node graph figur schedul order fa b c d f gg notic node f schedul node fe gg predecessor successor respect partial schedul contain predecessor d f schedul order c e the two conflict oper topdown bottomup strategi refer oper alreadi schedul place partial schedul figur show hrm schedul one iter oper schedul cycl oper b depend a schedul cycl c later d schedul cycl point oper f schedul earli possibl g c cycl c d figur bottomup schedul a schedul one iter b lifetim variabl c kernel d regist requir ie cycl becaus depend d avail resourc cycl delay cycl schedul place oper e late possibl schedul successor e previous place partial schedul thu oper e place cycl final sinc oper g predecessor previous schedul place earli possibl schedul ie cycl figur b show lifetim loop variant notic neither c e place late earli schedul alway take previous schedul oper refer point sinc f schedul e schedul refer oper decid late start e figur show number live valu kernel figur c steadi state phase execut loop live valu first row second contrast topdown schedul simultaneosli live valu bottomup schedul follow section describ algorithm order node schedul schedul step hypernod reduct modulo schedul depend innermost loop repres depend graph set vertic graph g vertex oper loop e depend edg set edg u v e repres depend two oper u v edg may correspond follow type depend regist depend memori depend control depend depend distanc ffi uv nonneg integ associ edg depend distanc ffi uv two node u v execut oper v depend execut oper u ffi uv iter befor latenc u nonzero posit integ associ node u v defin cycl c d figur hrm schedul a schedul one iter b lifetim variabl c kernel d regist requir number cycl taken correspond oper produc result hrm tri minim regist requir loop schedul oper u close possibl rel ie predecessor u p redu successor u succu schedul oper way shorten operand lifetim therefor reduc regist requir loop softwar pipelin loop schedul must handl cyclic depend caus recurr circuit schedul oper recurr circuit must stretch beyondomega theta ii whereomega sum distanc edg constitut recurr circuit hrm solv problem split schedul two step preorder step order node and actual schedul schedul node onc time order given preorder step preorder step order node depend graph goal schedul loop ii close possibl mii use minimum number reg ister give prioriti recurr circuit order stretch recurr circuit also ensur that node schedul current partial schedul contain predecessor successor node never unless node last node recurr circuit schedul order step assum depend graph connect compon g connect compon decompos set connect compon fg g g order separ final list node g concaten give higher prioriti g restrict recurr circuitin term recmii next preorder step present first assum depend graph function pre orderingg l h freturn list node g orderedg fit take input g fthe depend graph g g fa list node partial order l g fan initi node ie hypernod h g list return list figur function preorder node depend graph without recurr circuit recurr circuit section section introduc modif order deal recurr circuit final section present schedul step preorder graph without recurr circuit order node graph initi node call hypernod select iter process node depend graph reduc hypernod reduct set node hypernod consist of delet set edg among node set hypernod replac edg rest node reduc set node edg rest node hypernod final delet set node reduc preorder step figur requir initi hypernod partial list order node current implement select first node graph ie node correspond first oper program order node graph taken initi hypernod node insert partial list order preliminari experi show select differ initi node produc differ schedul function hypernod reductionv gh f creat subgraph g f reduc g node h graph g g els return g figur function hypernod reduct node preorder algorithm sort rest node step predecessor successor hypernod determin node appear path among predecessor successor obtain function search path predecessor successor path connect obtain node reduc see function hypernod reduct figur hypernod subgraph contain topolog sort topolog sort determin partial order predecessor successor append order list node predecessor topolog sort use pala algorithm pala algorithm like alap as late possibl algorithm list order node invert successor topolog sort use asap as soon possibl algorithm exampl consid depend graph figur a next illustr order node graph step step initi list order node empti list fg start design node graph hypernod h figur assum first node graph result graph shown figur b append approxim regist requir there minor differ caus resourc constraint execut time search path okv k list order node list fag next step predecessor h select sinc predecessor successor select ie node c node c reduc h result graph figur c c ad list order node list fa cg process repeat select node g h case select multipl node may path connect node algorithm look possibl path topolog sort node involv sinc path connect g h ad list list fa c g hg reduc hypernod result graph figur d h predecessor thu reduc produc graph figur e append list list fa c g hdg j successor h order list fa c g hdjg reduc produc graph figur f point h two predecessor b i path b contain node e therefor b e reduc h produc graph figur g then subgraph contain b e topolog sort partial order list fi e bg append list order circuit then order depend graph shown subsect present order algorithm recurr circuit let us put forward consider recurr recurr circuit classifi as ffl singl recurr circuit figur a g f g f g f f f f a b c d e f g h figur exampl reorder without recurr a b c d figur type recurr recurr circuit share set backward edg figur b call recurr subgraph set recurr circuit share set backward edg way figur b recurr subgraph ffl sever recurr circuit share node figur c d distinct set backward edg case consid recurr circuit differ recurr subgraph recurr circuit identifi calcul recmii instanc recurr circuit graph figur b fa d eg fa b c eg recurr circuit group recurr subgraph in worst case may recurr subgraph backward edg instanc recurr circuit figur b group recurr subgraph fa b c d eg recurr subgraph order base highest recmii valu recurr circuit contain subgraph decreas order node appear one subgraph remov except restrict subgraph term recmii instanc procedur order recurrencesg l list h fthi procedur take depend graph gg fand simplifi list recurr subgraph lg fit return partial list order node listg fand result hypernod hg list pre orderingg list h l function gener subgraphv g fthi function take depend graph g subset node v g fand return graph consist node v edgesg famong themg figur procedur order node recurr circuit list recurr subgraph associ figur c ffa c dg fb c egg simplifi list ffa c dg fb egg algorithm order node grah recurr circuit see figur take input list l recurr subgraph order decreas valu recmii entri list list node travers associ recurr subgraph trivial recurr circuit ie depend oper itself affect preorder step sinc impos schedul constraint schedul previous ensur ii recmii algorithm start gener correspond subgraph first recurr circuit without one backward edg caus recurr we remov backward edg higher ffi uv therefor result subgraph recurr order use algorithm without recurr present section whole subgraph reduc hypernod then node path hypernod next recurr subgraph identifi in order properli use algorithm search path requir backward edg caus recurr remov graph that graph contain hypernod next recurr circuit node path connect order appli algorithm without recurr circuit reduc hypernod path hypernod next recurr circuit node recurr circuit reduc hypernod recurr circuit connect hypernod f g ih ka f g kh g a b c d e figur exampl order recurr procedur process repeat recurr subgraph list point node recurr circuit path connect order reduc hypernod therefor graph contain hypernod remain node graph without recurr circuit order use algorithm present previou subsect instanc consid depend graph figur a graph two recurr subgraph fa c d fg fg j mg next illustr reduct recurr subgraph subgraph fa c d fg one highest recmii therefor algorithm start order it isol subgraph remov backward edg obtain graph figur b order graph list order node list fa c dfg graph figur b reduc hypernod h origin graph figur a obtain depend graph figur c next step reduc follow recurr subgraph fg j mg purpos algorithm search node possibl path h recurr subgraph then graph contain node construct see figur d sinc backward edg remov graph recurr circuit order use algorithm present previou section graph order list node append previou one result partial list list fa c df i g j mg then subgraph reduc hypernod graph figur c produc graph figur e point partial order node belong recurr initi graph reduc graph without recurr circuit figur e graph without recurr circuit order present subsect final list order node list fa c df i g j mheb l kg schedul step schedul step place oper order given order step schedul tri schedul oper close possibl neighbor alreadi schedul oper schedul schedul differ way depend neighbor oper partial schedul ffl oper u predecessor partial schedul u schedul earli possibl case schedul comput earli start u as earli start v cycl v schedul v latenc v ffi vu depend distanc v u psp u set predecessor u previous schedul schedul scan partial schedul free slot node u start cycl earli start u cycl earli start u notic that due modulo constraint make sens scan ii cycl ffl oper u successor partial schedul u schedul late possibl case schedul comput late start u as late start pssu set successor u previous schedul schedul scan partial schedul free slot node u start cycl late start u cycl late start ffl oper u predecessor successor schedul scan partial schedul start cycl earli start u cycl minlat start ffl final oper u neither predecessor successor schedul comput earli start u as earli start scan partial schedul free slot node u cycl earli start u cycl earli start u found node ii increas schedul step repeat increas ii result opportun find slot advantag hrm node order onc even schedul step sever trial evalu hrm section present result experiment studi first complex perform hrm evalu benchmark suit compos larg number number regist of loop l hrm l topdown l topdown figur cumul distribut regist requir loop variant innermost loop perfect club select loop includ singl basic block loop condit bodi previous convert singl basic block loop use ifconvers includ loop subroutin call condit exit depend graph obtain use experiment ictineo compil total loop account total execut time perfect club schedul loop perform hrm compar perform topdown schedul second compar hrm schedul method propos literatur use small set depend graph previous publish result perform evalu hrm use two machin configur evalu perform hrm configur loadstor unit adder multipli divsqrt unit assum unit latenc store instruct latenc load latenc con figur l configur l addit multipl latenc divis latenc root unit fulli pipelin except divsqrt unit pipelin all order evalu perform execut time in cycl schedul loop estim ii loop time number iter loop perform ie number time bodi loop execut purpos program perfect club instrument obtain number iter select loop hrm achiev loop mean optim term ii least loop averag schedul achiev execut hp workstat hrm topdown hrm topdown memori ideal reg reg figur memori traffic infinit regist regist regist hrm topdown hrm topdown l lcycl reg reg figur cycl requir execut loop infinit regist regist regist consid dynam execut time schedul loop would execut maximum perform regist alloc perform use wandsonli strategi use endfit adjac order extens discuss problem alloc regist softwarepipelin loop refer figur compar regist requir loopvari two schedul techniqu topdown care regist requir hrm two configur mention abov figur plot percentag loop schedul given number regist without spill code averag hrm requir regist requir topdown schedul sinc machin limit number regist also interest evalu effect regist requir perform memori traffic loop requir avail number regist spill code ad loop reschedul differ altern heurist propos speedup gener spill code among them use heurist spill variabl maxim quotient lifetim number addit load store requir spill variabl heurist one produc best result figur show memori traffic execut time respect loop schedul schedul infinit regist avail notic gener hrm requir less memori traffic topdown number regist limit differ memori traffic requir schedul increas number avail regist decreas instanc configur l hrm requir traffic requir topdown schedul regist avail regist avail requir traffic requir topdown schedul addit assum ideal memori system loop schedul hrm execut faster one schedul topdown hrm give prioriti recurr circuit loop recurr usual produc better result top down addit factor increas perform hrm topdown reduc regist requir instanc configur l schedul loop hrm produc speedup topdown ideal assumpt infinit regist file avail speedup regist file regist regist notic schedul agress configur l requir regist l configur degre pipelin function unit import effect regist pressur high regist requir aggress configur produc signific degrad perform memori traffic limit number regist avail instanc loop schedul hrm requir cycl execut configur l l infinit number regist assum regist avail l requir cycl l complex hrm schedul testbench consum second sparc workstat time compar second consum topdown schedul breakdown schedul execut time differ step shown figur notic hrm comput recurr circuit consum preorder step consum schedul step consum even though time spent preorder step overal time extrem short extra time lost preorder node allow simpl and fast schedul step topdown schedul preorder step consum small percentag time schedul step requir lot time schedul fail find schedul given ii loop reschedul increas initi interv topdown reschedul loop much often hrm time second hrm topdown schedul prioriti function find recurr comput mii figur time schedul loop hrm topdown schedul comparison schedul method section compar hrm three schedul heurist method take account regist requir frlc lifetim sensit heurist method slack linear program approach spilp schedul depend graph machin fp adder fp mul tiplier fp divid loadstor unit assum unit latenc add subtract store instruct latenc multipli load latenc divid tabl compar initi interv ii number buffer buf total execut time schedul sparc workstat four schedul method result three method obtain depend graph perform comparison suppli author number buffer requir schedul defin sum buffer requir valu loop valu requir mani buffer number time produc instruct issu issu last consum addit store requir one buffer shown buffer requir provid tight upper bound total regist requir tabl summar main conclus comparison entri tabl repres number loop schedul obtain hrm better ii equal ii wors ii schedul obtain method term applic hrm spilp slack frlc program ii buf sec ii buf sec ii buf sec ii buf sec liver loop linpack whet cycl tabl comparison hrm schedul schedul method initi interv initi interv same also show number loop hrm requir less buffer buf equal number buffer buf buffer buf notic hrm achiev perform spilp method term ii buffer requir compar method hrm obtain lower ii loop remain loop ii mani case hrm requir less buffer special compar frlc final tabl compar total compil time second four method notic hrm slightli faster two heurist method addit method perform notic wors find good schedul hand linear program method spilp requir much higher time construct schedul turn perform schedul produc hrm fact time spent spilp due livermor loop even without take account loop hrm time faster slack tabl comparison hrm perform versu method hrm spilp slack frlc compil time tabl comparison hrm compil time method conclus paper present hypernod reduct modulo schedul hrm novel effect heurist techniqu resourceconstrain softwar pipelin hrm attempt optim initi interv reduc regist requir schedul hrm work three main step comput mii preorder node depend graph use prioriti function schedul node follow order order function ensur node schedul partial schedul contain least refer node a predecessor successor except particular case recurr tend reduc lifetim loop variant thu reduc regist requir addit order function give prioriti recurr circuit order penal initi interv provid exhaust evalu hrm use loop perfect club benchmark suit seen hrm gener schedul optim term ii least loop although preorder step consum high percentag total compil time total schedul time smaller time requir conventi topdown schedul addit hrm provid signific perform advantag topdown schedul limit number regist better perform come reduct execut time memori traffic due spill code softwar pipelin execut also compar propos three method spilp integ program formul slack schedul frlc schedul schedul exhibit signific improv perform term initi interv buffer requir compar frlc signific improv initi interv compar slack lifetim sensit heurist obtain similar result spilp integ linear program approach obtain optim solut prohibit compil time real loop r softwar pipelin convers control depend data depend uniform represent highlevel instructionlevel transform perfect club benchmark effect perform evalu supercomput approach scientif array process architectur design apbfp famili overlap loop support cydra compil cydra stage schedul techniqu reduc regist requir modulo schedul optimum modulo schedul minimum regist requir minim regist requir resourceconstrain softwar pipelin highli concurr scalar process circular schedul new techniqu perform softwar pipelin softwar pipelin effect schedul techniqu vliw machin systol array optim compil reduc impact regist pressur softwar pipelin loop hypernod reduct modulo schedul regist requir pipelin loop effect perform regist requir pipelin processor novel framework regist alloc softwar pipelin ing softwar pipelin parisc compil iter modulo schedul algorithm softwar pipelin loop schedul techniqu easili schedul horizont architectur high perform scientif comput regist alloc softwar pipelin loop parallelis loop exit pipelin architectur decompos softwar pipelin new perspect new approach enhanc modulo schedul loop condit branch modulo schedul multipl initi interv tr ctr spyridon triantafylli manish vachharajani neil vachharajani david i august compil optimizationspac explor proceed intern symposium code gener optim feedbackdirect runtim optim march san francisco california david lpez josep llosa mateo valero eduard ayguad widen resourc costeffect techniqu aggress ilp architectur proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state david lpez josep llosa mateo valero eduard ayguad costconsci strategi increas perform numer program aggress vliw architectur ieee transact comput v n p octob josep llosa eduard ayguad antonio gonzalez mateo valero jason eckhardt lifetimesensit modulo schedul product environ ieee transact comput v n p march