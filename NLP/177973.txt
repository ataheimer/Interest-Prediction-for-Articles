t reduc indirect function call overhead c program a modern comput architectur increasingli depend mechan estim futur control flow decis increas perform mechan specul execut prefetch becom standard architectur mechan reli control flow predict prefetch specul execut futur instruct time comput programm increasingli turn objectori languag increas product languag commonli use run time dispatch implement object polymorph dispatch usual implement use indirect function call present challeng exist control flow predict techniqu measur occurr indirect function call collect c program show that although import predict branch accur indirect call predict also import factor program grow import growth objectori program examin improv offer compiletim optim static dynam predict techniqu demonstr compil use exist branch predict mechan improv perform c program use method program examin number instruct mispredict break control doubl exist comput b introduct design comput architectur languag tightli en twine exampl advent regist displac address enabl effici implement algol increas use cobol emphas use bcd arithmet likewis c paper appear acm principl practic program lan guag portland oregon fortran languag becom ubiquit strongli influenc risc processor design objectori program recent gain popular illustr widespread popular c objectori languag exercis differ aspect comput architectur support objectori program style paper examin indirect function call use support object polymorph influenc perform effici object orient languag modern architectur use deep instruct pipelin specul execut reli predict control flow chang indirect function call caus unpredict chang program control flow exampl dec alpha axp processor one first widelyavail deepli pipelin superscalar microprocessor stall instruct processor mispredict flow control increas mispredict target instruct cach must fetch system increasingli reli specul execut import control flow predict increas program condit branch introduc main uncertainti program flow architectur use varieti branch predict techniqu reduc instruct cach miss insur instruct avail processor pipelin function call specifi explicit call target thu function call trivial predict control flow predict import objectori program languag tend use indirect function call address call target load memori fisher et al said indirect function call unavoid break control compil hardwar trick could allow instructionlevel parallel advanc past them accur predict call address processor reduc instruct stall prefetch instruct result show accur predict behavior indirect function call larg elimin controlflow mispredict penalti use statictyp objectori languag c figur show normal execut time varieti c program measur number instruct execut program collect inform concern condit branch indirect function call execut program although measur program decstat simul branch mispredict characterist deepli pipelin superscalar architectur similar dec alpha axp program bar indic number machin cycl spent execut instruct suffer delay impos mispredict control flow differ assumpt valu indic program spend addit time due delay valu indic program would execut twice slowli leftmost bar indic delay would incur everi control flow chang incorrectli predict predict next bar indic increas execut condit branch predict use static profil base predict next three bar indic decreas execut time branch indirect function call correctli predict use three differ techniqu describ paper program measur found could improv perform use simpl techniqu final improv depend number indirect function call program librari use underli architectur architectur deeper pipelin issu instruct per cycl would evinc greater improv interest reduc cost indirect function call ical modern architectur compil determin uniqu like call target indirect function call convert direct call uniqu call target likewis compil may choos inlin like uniqu call target inlin ical reduc number function call expos opportun optim better regist alloc constant fold code schedul like howev type inferenc c program nphard problem difficult integr exist compil becauseaccur type infer requir inform entir type hierarchi inform typic avail program link impli typedetermin algorithm requir linktim optim interest subtl optim mod est albeit respect perform improv mani optim code transform reli modifi exist program execut possibl assist compil profilebas optim began studi ask follow question ffl could predict frequent compilerbas method could elimin indirect function call ffl accur profilebas predict dynam predict method accur ffl use exist branch predict hardwar predict indirect function call ffl effect combin predict techniqu type compil optim appli toward indirect function call order improv perform date experiment hasdemonstr although objectori librari support object polymorph target indirect function call accur predict either prior run program program execut furthermor mani exist c program optim nave linker use inform c type system optim examin involv convert indirect function call call uniqu function name direct function call sophist compil linktim code gener signific optim opportun exist lastli compil optim term ical convers use increas perform indirect function call inform use simpl profilebas binari modif improv execut exist c program modern architectur measur behavior varieti publicli avail c program collect inform instruct count function call inform also part larger studi quantifi differ c convent c program studi show call predict import mani c program show extent static dynam compil direct method reduc indirect function call overhead also demonstr opportun profilebas optim c program measur theseoptim profit appli exist architectur incur signific controlflow mispredict penalti result present divid two portion first consid appli hardwar branch predict mechan exist c program second consid addit profil base optim appli c program x discuss relev prior work x describ experiment methodolog use describ program instrument measur x compar variou ical predict mechan studi summar improv perform exist c program consider amount research conduct reduc overhead method call dynam type objectori languag mani solut relev domain appli optim compiledlanguagesus ical c discuss shortli furthermor numer research examin similar issu reduc branch overhead sinc function call branch alter control flow consider overlap work yet substanti differ well one differ condit branch two possibl target indirect function call larg number potenti target measur program differ subroutin call singl indirect function call make branch easier predict dynam branch predict mechan achiev gamma predict accuraci level accuraci need superscalar processor issu sever instruct per cycl relev prior work predict destin indirect function call hardwar conduct david wall examin limit instruct level parallel state littl work done predict destin indirect jump might pay instructionlevel parallel simul static profil base predict infinit finit dynam last call predict find accur predict ical destin howev benefit ical predict minim examin c fortran program go beyond research show ical predict import program compiletim optim combin static profil base predict increas program congress doc idl idraw groff morpher rtshnormal number instruct branch branch ical branch ical uniqu branch ical uniqu conv figur normal execut time variou c program includ expect instruct stall due mispredict control flow comput similar dec alpha axp perform simpl techniqu yield accur ical predict rate and indepth comparisonbetween differ static dynamicmechan ical predict compil optim two class compilerori optim relev research larg bodi research exist dataflow analysi determin set possibl call target given call site ryder present method comput callgraph set function may call call site use dataflow equat recent work burk hall refin techniqu work character program procedur valu may pass function paramet other includ hall also examin function program re centli pand ryder shown infer set call target call site languag c type system nphard problem paper seek minim pipelin stall use inform concern frequenc call specif call site unless previou algorithm determin uniqu call target inform need ical predict howev result studi indic singl call target occur frequent techniqu eg ryder may success prac tice knowledg littl work specifi probabl specif call target call use dataflow techniqu comparison consider work adapt runtim system reduc cost polymorph dynam type languag recent foremost effort work self project custom method dispatch extens optim method lookup self dynamiclytyp languag provid rich set capabl present staticallytyp languag c howev staticallytyp languag c effici use constanttim method dispatch mechan staticallytyp objectori languag popular less compil effort need achiev reason perform objectori program style encourag softwar resourc structur softwar librari custom optim produc consider perform improv self implement mani way extend optim explor self project c languag howev must reli hardwar custom eg predict hardwar rather softwar becausemost c implement alreadi effici exampl indirect function call c take seven instruct decstat reduc cost greatli improv perform applic difficult also feel result research benefit prototyp languag self smalltalk languag optim modern architectur also secondari effect optim certain case code transform allow function inlin facilit optim self use inlin cacheto speed indirect function call inlin cach record last target address call site method call jump target recov softwar cach holzl et al found could improv perform convert inlin cach access polymorph inlin cach pic lookup pic encod datadepend type check stub procedur dynam modifi program reduc search appropri method given data type use similar techniqu term ifconvers describ later paper convert indirect call type check direct method call tri optim indirect call site main differ two method compil staticlytyp object orient languagec holzl et al compil dynamicli type languag self use static profil gather data use instruct cost model decid whether call site could benifit if convers method also benifit indirect jump hardwar predicit self system build pic stub tabl runtim ad method type call site stub function indirect jump hardwar predict littl benifit self dynam method lookup implement indirect jump instruct branch predict number mechanismsto amelior effect uncertain control flow chang includ static dynam branch pre diction branch target buffer delay branch prefetch target earli branch resolut branch bypass prepareto branch mechan convent branch predict studi typic assum two possibl branch target given branch point multitarget branch occur infrequ program rather present comprehens overview field focu method relat techniqu consid paper architectur employ static predict hint use either profilederiv inform inform deriv compil time analysi inform branch direct branch opcod wall found profiledriven static predict reason accur indirect function call fisher freudenberg found profilederiv static predict effect condit branch hypothes interrun variat occur prior input cover suffici execut path result provid support hypothesi gener profil base predict techniqu outperform compiletim predict techniqu techniqu use huerist base branch predict instruct opcod architectur use dynam predict either use tabl explicit branch regist branch target buffer btb small cach hold address branch site address branch target myriad variat gener idea typic cach contain entri may way associ address branch site use tag btb match data use predict branch design includ decod instruct well branch target design elimin branch target address observ branch go one two way takennot taken still design elimin tag branch site address tabl design use branch site address index tabl predict bit inform actual predict inform anoth branch howev there least chanc predict inform correct improv somewhat common variant tablebas design bit techniqu indic direct recent branch map given predict bit bit techniqu yield much better perform program loop advantag bittabl techniqu keep track littl inform per branch site effect practic lastli somecomputersuseexplicit branch target addressregi ter btar specifi branch target numer advantag branch instruct compact easili decod btar appli condit branch function call instruct load branch target move loop optim way furthermor address specifi explicit branch target regist provid addit hint instruct cach instruct prefetch decod earli howev propos implement provid btar content regist probabl save across function call thu instruct manipul btar must occur earli instruct stream effect use btar first glanc techniqu bittabl tech niqu appear applic ical predict indirect function call jump number call target later show profilebas ical convers use mechan experiment design comparison use tracebas simul instrument number c program list tabl use modifi version qpt program trace tool emphasizedprogram use exist c class librari structur applic modular extens fashion normal associ objectori design extens comparison characterist c c program found empir comput scienc labourintens undertak program compil process decstat s three c compil gnu g dec c att c v requir successfullycompil program much occur c languag standard collect program instrument consum gb disk space despit good perform qpt trace tool convent pro gram offer littl trace compress program use indirect call construct simul analyz program trace typic simul run collect inform call branch target anda second time use predict inform prior run one program groff compar predict use input differ run better assess robust result modifi qpt indic caus basicblock transit a direct branch indirect branch fallthrough record whether function call caus direct indirect call program also abl indic function method classifi unpredict break control three class br condit branch br branch multipl destin usual aris switch case statement ical indirect function call tabl list number occurr type unpredict break control differ program show three entri groff use three execut coverag analysi later entri column site trace list number branch call site type encount program execut exampl doc actual indirect function call encount call program ex ecut head occurr execut list number time break type appear program execu tion thu indirect function call trace doc approxim indirect call c method except groff method perform comparison mani metric use compar ical predict combin ical branch predict techniqu tabl show number instruct break nibb without branch ical predict track break control flow caus long pipelin delay break condit branch indirect call return also caus long pipelin stall return accur predict use return stack track these assum uncondit branch procedur call assign goto accur predict controltransf instruct condit branch ical also caus instruct misfetch penalti must decod instruct stream know instruct type thu instruct fetch unit may incorrectli fetch next instruct rather target destin anoth paper show misfetch penalti avoid use extra instruct type bit andor simpl instruct type predict tabl coupl techniqu discuss paper consid condit branch indirect call would expect paramet tabl similar c c program contrari found sampl c program higher number instruct break indic c program tend either predict c program or use differ linguist construct condit logic exampl consid balancedtre implement c c c programm might implement singl procedur balanc tree pass sever flag control actual bal anc c programm hand would tend use inherit object model provid similar function thu surpris c program tend procedur call fewer condit oper remain tabl show mean nibb program use harmon mean nibb summari also use percent break predict bp understand well variou techniqu predict break metric common mispredict rate commonli use compar branch predict mechan howev note bp metric could extract inform idl compil dec c name descript congress interpret prologlik languag input one exampl distribut congress configur manag doc interact text formatt base interview librari input briefli edit page document groff groff version version ditroff text formatt one input collect manual page anoth input page paper idl sampl backend interfac definit languag system distribut object manag group input sampl idl specif fresco graphic librari idraw interact structur graphic editor base interview librari exampl draw edit figur morpher structur graphic morph demonstr base interview librari exampl morph run man exampl distribut program rtsh ray trace shell interact ray trace environ tcltk user interfac c graphic librari exampl small ray trace imag distribut program tabl c program instrument account densiti break program exampl may singl condit branch instruct program branch may alway mispredict number instruct break remain high there fore use look nibb bp compar predict techniqu across differ program bound compiletim ical predict interest determin well interprocedur dataflow analysi could predict indirect method call compar result profilebas static predict method method name c encod uniqu type signatur linker knew intend type signatur call site singl function signatur function could appropri call site indirect call could replac direct call call uniqu name measureand feel repres lower bound could accomplish dataflow optim algorithm practic dataflow method accur symbol tabl unix system typic includ method class never invok extrem record number singl target ical site ical site record singl call target trace compil direct ical predict use singl target select number trace record singl target measur repres upper bound target predict could expect dataflowbas predict algorithm uniqu name singl target valu measur number dynam occurr gener result indic signific promis static analysi c program particular effect simpl implement feel uniqu name measur integr exist compil linker current compil provid inform call site inform easi captur static vs dynam predict although compil techniqu appear promis found profilebas dynam predict techniqu clearli better implement simpl major profilebas techniqu ran program record like target call site use predict call target futur run result shown column label static tabl simpl techniqu accur predict surprisingli larg number ical run use program input gener predict trace measur shown determin accur predict rate differ input ran groff two input tabl show percentag ical predict use combin differ input file found small number predict set appear suffici provid accur predict case profilebas method poor perform experi usual occur input use establish profil use predict branch ical provid adequ coverag branch indirect function call problem mention other studi detail tabl also show effect ideal dynam predict techniqu simul two infinit larg branch target buffer first btb bit simpli use previou ical target predict futur ical much like method cach use self recent method save second bit use bit strategi avoid chang predict inform previou predict incorrect twice row ical consid unpredict first encoun tere surprisingli bit mechan wors perform static predict howev requir profil run improv shown bit techniqu illustr bit techniqu chang predict rapidli exampl call site call sequenc method ax bx ax bit method would miss three time bit method would miss onc inform import design wideissu processor exampl recent design propos consid use kb memori btb anoth paper show elimin need site trace occur execut program br ical br br ical br instruct congress doc morpher tabl detail statist number instruct break control program measur metric congress doc groff idl idraw morpher rtsh mean median stddev tabl number instruct break absenc control flow predict program uniqu name singl target static inf bit btb inf bit btb congress doc groff idl idraw morpher rtsh mean tabl percentag indirect function call predict use compiletim profilebas dynam predict y could comput use use use use program groff groff groff combin groff groff tabl percentag ical predict groff use static predict differ input file metric congress doc groff idl idraw morpher rtsh break call tabl mean number instruct ical instruct stream hit break anoth function call includ start procedur break point bit br uniqu name singl target static ical program nibb bp nibb bp nibb bp nibb bp congress doc groff idl idraw morpher rtsh tabl measur break predict use compiletim static ical predict bit branch predict resourc like predict architectur would benefit small bit predict mechan indirect function call last predict mechan consid branch target address regist btar assum architectur would implement small number btar would like save across procedur call thu two limit use btar indic intend branch target assum btar could load anywher previou basic block provid lower bound interv btar load branch taken likewis assum clever compil might abl load btar immedi follow previou procedur call return becausew assumedbtar save across function call tabl show two valu instruct sinc begin basic block instruct sinc last callreturn gener instruct schedul prepar jump inform first target instruct need simpl predict target indirect function call ffl dynam method use bit branch target buffer effect techniqu consid howev style predict may expens implement ffl combin simpler branch predict techniqu btb indirect function call resourc demand becom realist ffl static profiledriven predict wasveri accur use remaind paper use profil elimin indirect function call prior measur shown percentag ical predict use differ techniqu comparison tabl show percent total break predict use static predict prior profil ical accur predict half remain break control doubl number instruct break assum break evenli distribut recal figur figur condit branch indirect function call predict use static profilebas techniqu de scribe second bar program indic addit delay incur break indirect function call mispredict condit branch third bar elimin delay static predict indirect function call architectur provid btb delay would slightli smaller clearli predict branch foremost prioriti predict indirect call remov substanti number break success profilebas static predict also indic mani method could success compil inlin even without compiletim type analysi convert indirect function call egobject foo condit procedur call runtim type check typeofobject object afoo els object foo transform use three reason first code transform perform function call afoo inlin secondli high likelyhood call afoo code sequenc less expens risc architectur use instruct rather lastli architectur provid branch predict support predict indirect function call transform code avoid mani mispredict penalti exist branch predict hardwar may abl improv strictli profilebas predict accommod burst call secondari call target although inlin function use alway reduc program execut time howev mani indirect function call c tend short programm like employ proper data encapsul techniqu believ automat inlin use c c further architectur convert indirectfunct call effici high likelyhood call common function afoo abov construct follow cost model handl ical use optim ical detail assum cost direct method call c dmc instruct come extra instruct need comput object pointer pass call instruct cost indirect method call c imc instruct extra instruct need comput pointer address futur branch target cost if c shown previou exampl instruct includ indirect load object pointer load constant comparison penalti mispredict condit branch indirect function call c miss instruct time assum mispredict break caus cycl pipelin delay get cost indirect method call predict sinc indirect call predict consid mi predict comparison static profilebas predict mechan discuss previou section cost becom cpredict p probabl accur predict call target call site cost convert indirect method call if done abov would howev use exist profil inform comput q percentag second like call target select note q less equal minpp els would like target select interest note q might high percentag remain ical exampl may next like branch occur time mean remain ical correctli predict thu cost convert indirect function call if construct actual cusegammaif figur show cost cnopredict the horizont line cpredict the lower line boundari cusegammaif pq best case worst case worst case if convers cusegammaif p hypothet case mani second like target q approxim equal zero percent graph best case convers cusegammaif p q achiev ical site target canonli happenwhenp whenp best q equal p remain gammap q ical target cannot predict reason line graph best case convers chang slope graph one see alway benefit static ical predict given valu c c dmc c miss c imc use depend accur one predict second like target q better convers ical rather predict like target graph one see that cusegammaif p eventu intersect cpredict p alway benefici convers architectur provid static predict architectur assumpt occur line cnopredict cusegammaif p worst case also eventu intersect alway benefici convers architectur provid static predict architectur assumpt occur convers architectur provid static predict give user sens benefit static predict mention architectur weve consid similar digit axp architectur includ intel pentium also issu two instruct per clock newli announc architectur ibm riosii issu eight instruct per cycl architectur advantag ifconvers occur much lower probabl p gener predict inform greatli reduc penalti indirect function call notic graph alway benefici predict destin ical accur profilebas measur expos optim accuraci predict frequent call function exce tabl show occur mani program measur transform also provid opportun inlin bodi function allow compil custom paramet function avoid regist spill like rightmost bar program shown figur show effect appli transform appropri base model call site program comparison second bar right show benefit use predict uniquenam elimin without use convers although advantag small similar costbenefit analysi use determin advantag addit function inlin note greater advantag use convers architectur support static predict conclus futur work objectori program becom common increas need optim indirect function call becom even import processor pipelin depth increas superscalar instruct issu specul execut becom common exist branch predict mechan accur predict gamma condit branch branch predict success accur predict remain break number cycl percentag ical site probabl target p optim ical site static profil static predict use worst case use best case figur cost instruct addit delay differ indirect function call method controlflow becom increasingli import processor begin issu instruct concurr elimin mispredict penalti indirect function call c program remov remain break control c program found static profilebas predict mechan work well collect exist c program ex amin saw addit improv combin compil optim techniqu uniqu name elimin if conver sion static indirect call predict inform profilebas predict also use code transforma tion inlin better regist schedul result show get averag improv number instruct execut program use ical predic tionoptim techniqu recommend compil highli pipelin specul execut architectur use profilebas static predict method optim c program use linktim inform remov indirect function call custom callsit use if convers base profil inform furthermor hope architectur benchmark commun expand benchmark suit includ modern program languag c modula like languag exercis differ architectur featur c fortran program acknowledg would like thank ben zorn john feehrer review comment paper wed also like thank jame laru develop qpt help us solv variou problem encount appli larg program work fund part nsf grant no asc part continu effort make languag c suitabl scientif comput r tera comput system branch predict free optim profil trace pro gram intervalbas approach exhcaust increment interprocedur analysi branch align exploit behavior differ c c custom optim compil technolog self iter type analysi extend messag split optim dynamicallytyp objectori program subprogram inlin ing studi effect program execut time reduc cost branchesbi use regist predict condit branch direct previou run program effici call graph analysi optimiz dynamicallytyp objectorientr languag polymorph inlin cach branch histori tabl prdiction move target branch due subroutin return limit control flow paral lelism branch predict strategi branch target buffer design reduc branch penalti pipelin pro cessor reduc cost branch improv accuraci dynam type determin c branch target buffer design optim construct call graph program a studi limit instructionlevel parallel altern implement twolevel adapt branch predict comprehens instruct fetch mechan processor support specul execu tion comparison dynam branch predictor use two level branch histori tr reduc cost branch reduc branch penalti pipelin processor custom optim compil technolog self dynamicallytyp objectori program languag intervalbas approach exhaust increment interprocedur dataflow analysi interact type analysi extend messag split optim dynamicallytyp objectori program limit instructionlevel parallel branch histori tabl predict move target branch due subroutin return subprogram inlin limit control flow parallel altern implement twolevel adapt branch predict optim profil trace program improv accuraci dynam branch predict use branch correl predict condit branch direct previou run program effici superscalar perform boost comprehens instruct fetch mechan processor support specul execut effici call graph analysi branch predict free comparison dynam branch predictor use two level branch histori tera comput system branch target buffer design optim optim dynamicallytyp objectori languag polymorph inlin cach studi branch predict strategi ctr stevan vlaovic edward s davidson gari s tyson improv btb perform presenc dll proceed rd annual acmiee intern symposium microarchitectur p decemb monterey california unit state kazuaki ishizaki motohiro kawahito toshiaki yasu hideaki komatsu toshio nakatani studi devirtu techniqu java justintim compil acm sigplan notic v n p oct jare stark mariu ever yale n patt variabl length path branch predict acm sigplan notic v n p nov poyung chang eric hao yale n patt target predict indirect jump acm sigarch comput architectur new v n p may john kalamatiano david r kaeli predict indirect branch via data compress proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state david grove jeffrey dean charl garrett craig chamber profileguid receiv class predict acm sigplan notic v n p oct hyesoon kim jo a joao onur mutlu chang joo lee yale n patt robert cohn vpc predict reduc cost indirect branch via hardwarebas dynam devirtu acm sigarch comput architectur new v n may tao li ravi bhargava lizi kurian john adapt branchtarget buffer improv target predict java code acm transact architectur code optim taco v n p june karel driesen ur hlzle accur indirect branch predict acm sigarch comput architectur new v n p june derek raysid kosta kontogianni syllogist structur objectori program proceed rd intern confer softwar engin p may toronto ontario canada bradley m kuhn david w binkley enabl optim c virtual function proceed acm symposium appli comput p februari philadelphia pennsylvania unit state hemant d pand barbara g ryder static type determin c proceed th confer usenix sixth c technic confer p april cambridg sara porat bilha mendelson irina shapira sharpen global static analysi cope java proceed confer centr advanc studi collabor research p novemb decemb toronto ontario canada karel driesen ur hlzle direct cost virtual function call c acm sigplan notic v n p oct ur hlzle david ungar optim dynamicallydispatch call runtim type feedback acm sigplan notic v n p june b calder d grunwald fast accur instruct fetch branch predict acm sigarch comput architectur new v n p april karel driesen ur hlzle minim row displac dispatch tabl acm sigplan notic v n p oct barbara ryder futur program analysi acm comput survey csur v ne dec amer diwan j eliot b moss kathryn s mckinley simpl effect analysi staticallytyp objectori program acm sigplan notic v n p oct frank tip peter f sweeney class hierarchi special acm sigplan notic v n p oct kevin skadron pritpal s ahuja margaret martonosi dougla w clark improv predict procedur return returnaddressstack repair mechan proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state david f bacon peter f sweeney fast static analysi c virtual function call acm sigplan notic v n p oct peter f sweeney frank tip extract librarybas objectori applic acm sigsoft softwar engin note v n p nov kevin skadron pritpal s ahuja margaret martonosi dougla w clark branch predict instructionwindow size cach size perform tradeoff simul techniqu ieee transact comput v n p novemb mari f fernndez simpl effect linktim optim modula program acm sigplan notic v n p june peter f sweeney frank tip studi dead data member c applic acm sigplan notic v n p may hazelwood david grove adapt onlin contextsensit inlin proceed intern symposium code gener optim feedbackdirect runtim optim march san francisco california loren larsen mari jean harrold slice objectori softwar proceed th intern confer softwar engin p march berlin germani frank tip jen palsberg scalabl propagationbas call graph construct algorithm acm sigplan notic v n p oct sara porat david bernstein yaroslav fedorov joseph rodrigu eran yahav compil optim c virtual function call proceed nd confer usenix confer objectori technolog coot p june toronto ontario canada amer diwan kathryn s mckinley j eliot b moss use type analyz optim objectori program acm transact program languag system topla v n p jan vijay sundaresan lauri hendren chrislain razafimahefa raja vallerai patrick lam etienn gagnon charl godin practic virtual method call resolut java acm sigplan notic v n p oct phung hua nguyen jingl xue strength reduct loopinvari type proceed th australasian confer comput scienc p januari dunedin new zealand frank tip peter f sweeney chri laffra aldo eisma david streeter practic extract techniqu java acm transact program languag system topla v n p novemb ayal zak vitali feldman nava aizikowitz seal call java packag acm sigplan notic v n p oct olivi zendra dominiqu colnet suzann collin effici dynam dispatch without virtual function tabl smalleiffel compil acm sigplan notic v n p oct jeffrey dean greg defouw david grove vassili litvinov craig chamber vortex optim compil objectori languag acm sigplan notic v n p oct frank tip jongdeok choi john field g ramalingam slice class hierarchi c acm sigplan notic v n p oct takeshi ogasawara hideaki komatsu toshio nakatani studi except handl dynam optim java acm sigplan notic v n p peter f sweeney michael burk quantifi evalu space overhead altern c memori layout softwarepractic experi v n p june takeshi ogasawara hideaki komatsu toshio nakatani edo exceptiondirect optim java acm transact program languag system topla v n p januari peng zhao jo nelson amar ablego function outlin partial inlin framework research articl softwarepractic experi v n p april lorenzo bettini sara capecchi betti venneri doubl dispatch c softwarepractic experi v n p may