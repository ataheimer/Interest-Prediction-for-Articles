t elus atom regist a present construct singlewrit multipleread atom regist singlewrit singleread atom regist complex construct asymptot optim om share singlewrit singleread safe bit requir construct singlewrit mreader nbit atom regist b introduct current accept theori concurr comput deepli root concept atom regist atom regist data object read written one process accord follow assumpt sever read write oper regist enabl simultan differ process oper execut sequenc one other concurr assumpt strongli suggest wellknown interleav semant concurr comput valid assumpt thu cornerston justifi present theori concurr comput one way check valid assumpt show atom regist construct use set realist regist read written concurr differ process construct process read write construct atom regist invok program within program regist realist kind read written differ program invok differ process concurr requir howev net effect resembl serial invoc program restrict waitfre ie synchron primit p v await unbound busywait loop allow restrict guarante process read write construct atom regist finit amount time regardless activ process thi also mean read write process immun failur process also access regist waitfreedom restrict distinguish problem construct atom regist classic readerswrit problem peterson first suggest problem construct atom regist safe regist safe regist data object read written concurr differ process read oper overlap write oper may return valu valu domain regist read oper overlap oper obtain recent written valu leap safe regist atom regist quit larg fortun divid number smaller step figur depict two chain regist construct lead singlewrit singleread singlebit safe regist kwriter mreader n bit atom regist notat kmn denot regist written k process read process store n bit valu step figur label refer paper given construct present henceforth concern singlewrit atom regist problem construct multipleread atom regist singleread atom regist mention open problem lamport vitanyi awerbuch first solut problem present us tworead construct given gener construct mreader regist m gamma reader regist solut though easi explain understand use exponenti number singl safe atom atom atom kmn atom figur two chain regist construct reader atom regist subsequ sever solut polynomi complex present includ one given us latter construct gener tworead construct paper present construct multipleread atom regist base upon solut present construct differ two respect first solut present optim complex wherea one given not actual optim solut attain combin solut construct lamport peterson see detail second correct proof present paper rigor formal and hope easier understand proof present rest paper organ follow section formal defin problem construct mreader atom regist singleread atom regist section present construct inform descript construct present section formal correct proof present section proof make use sever lemma state prove appendix conclud remark appear section regist construct regist construct defin number differ way choic definit base simplic conveni order avoid confus henceforth capit term read write appli construct regist leav uncapit appli variabl use construct view writer and reader construct program invok process order write read valu from regist program writer one input paramet indic valu written similarli program reader one output paramet indic valu read exampl see construct depict figur variabl construct singleread singlewrit atom regist restrict aris sinc aim construct multipleread regist singleread regist also requir variabl bound size there simpl solut variabl unbound mention introduct program construct waitfre ie synchron primit busywait loop allow for formal definit waitfreedom refer next defin sever concept need state correct condit multipleread construct definit appli given construct state assign valu variabl construct note program program counter consid variabl construct one state design initi state event execut statement program u two state construct state u result execut statement state t e event correspond statement execut say e enabl state write e u histori construct sequenc initi state preced anoth event f histori iff e occur f historydefinit set event histori correspond complet program execut call oper oper p preced anoth oper q histori iff event p preced event q observ preced relat irreflex total order event irreflex partial order oper proof correct construct suffici consid histori initi write oper preced oper incomplet program execut ie oper on deal histori note assum initi write oper valu read read oper match written write oper equival defin initi state equal result initi write oper note also histori incomplet oper extend one complet oper possibl sinc program requir wait free deal complet oper valu read from written to construct regist oper welldefin notat denot ith oper writer denot initi write follow lamport defin correct condit construct follow let h histori construct h said atom iff exist function oe map everi read oper h natur number i w write oper h follow three condit hold ffl integr read oper r h valu read r valu written w oer ffl proxim read oper r h r preced write oper write oper w oer preced r ffl preced two read oper r h r preced oer oesdefinit regist construct correct iff histori atom multiread construct propos construct depict figur consist writer program program reader i share variabl construct singleread kind interfac writer reader consist variabl wri written writer read reader variabl rw i written reader read writer interfac across reader consist set variabl rri j j variabl rri j written reader read reader j explan field name appear type definit follow alt bit altern valu oper writer done bit distinguish two valu written write oper variabl wri new current valu construct regist valtyp type construct regist old previou valu construct regist possibl elimin variabl rri i construct howev includ variabl simplifi proof correct rrtype rang initi new valtyp initi begin old new alt new val alt k read qk rw k od k seqk qk phi od k write wrk old new seqm alt fals od k write wrk old new seqm alt true od return valtyp var defin lag initi begin read x wri write rw i xseqi k read vk rrk i od read wri f lag k write rri k f lag yseqi yalt od lag returnynew els returnyold fi figur multipleread construct f lag bit indic whether read oper return old new valu seq modulo integ sequenc number phi denot modulo addit variabl local program declar either var block variabl declar block assum retain valu across invoc correspond program variabl declar var block assum retain valu across invoc initi assert follow variabl declar serv defin appropri initi valu variabl construct state satisfi assert suitabl initi state howev recal that assumpt initi write oper preced read oper program construct use special syntax order distinguish read write share variabl read write local variabl program read given share variabl z execut statement form read u z u local variabl type z program write share variabl z execut statement form write z u variabl z consist field u mtupl ith compon u local variabl whose valu store ith field z use similar name sometim ident compon u field z correspond obviou sequenc number share writer reader form basi construct includ everi valu written writer set sequenc number one per reader write oper writer read variabl rw k obtain recent sequenc number reader k new sequenc number reader k obtain increment read rw k use modulo addit writer write reader two pass first pass writer write reader order second pass order revers done bit distinguish two pass valu writer write reader includ previou current valu construct regist aforement set sequenc number alt done bit reader read two valu writer x y read sequenc number obtain first read written back writer valu read reader k k i valu read writer reader use comput f lag bit indic whether old new valu return note f lag assign valu base upon express express introduc shorthand defin defin section return valu reader write valu reader k k i valu includ reader is f lag bit also sequenc number reader alt bit writer obtain reader is second read wri calcul space complex construct determin number share singlewrit singleread safe bit requir size share variabl construct follow consist consist bit consist bit use construct singlewrit singleread bbit atom regist construct use share singlewrit singleread safe bit construct yield space complex mn m m m well known lower bound space problem construct asymptot optim given correct proof section construct establish follow theorem theorem possibl construct singlewrit mreader n bit atom regist use share singlewrit singleread safe bit inform explan section explain intuit behind algorithm discuss proof oblig establish next section appendix so howev introduc notat use ensu discuss oper program p label statement p loop denot event correspond execut statement oper p otherwis loop denot event correspond iter loop loop counter equal j exampl write oper w construct figur w i denot event w read rw i w i denot event w write wri second time next defin three type control predic oper program p histori let event p then p true state histori iff event true state iff state occur event true state iff state occur event n label loop program p use p n shorthand i p ni use p n shorthand i p ni use p n shorthand i p ni observ loop p impli p i particular p strengthen p also requir p enabl hand loop possibl p p i assert hold event loop first enabl follow assert consequ preced definit let p given definit ffl p exampl control predic observ write oper w construct figur ffl w i denot w read sequenc number reader i ffl w denot w begun second pass write ffl w i denot w complet write reader second pass ffl w denot w complet second pass write let b two state assert assert unless b hold iff everi pair consecut state histori ab hold first state ab hold second state notion unless borrow uniti logic chandi misra inform unless b mean becom true remain true unless b becom true particular falsifi event b either true state prior occurr event true state follow occurr event requir b eventu becom true howev case remain true forev oper z local variabl p then pz denot final valu variabl z assign oper p now readi explain intuit idea algorithm let us examin write oper w writer assum w chang valu regist old new possibl identifi two point b within execut w reader return new reader return old b let us call interv b uncertainti interv w establish correct construct main difficulti ensur preced condit in definit atom histori given section violat uncertainti interv write oper w amount prove newthenold conflict aris interv avoid newthen old conflict difficult fact singleread regist use construct result limit w must inform reader new valu written one time thu uncertainti interv w exist certain point some all reader inform w valu new current written difficulti encount construct multipleread atom regist singleread one solut uncertainti interv begin writer write wr second pass end writer write wrm second pass word uncertainti interv exist predic w w true solut therefor guarante follow three properti read begin interv return new valu read end interv return old valu read interv result newthenold conflict state properti precis defin predic cue relat valu written particular write oper exist valu variabl rri j inform predic cuew i j thought cue reader reader j reader return new valu w predic defin follow cuew lag rri accord reader program valu read wrj reader j written write oper w valu read rri j satisfi predic reader j find predic p true subsequ return valu new return discuss uncertainti interv properti a ensur cuew i j fals begin interv word control predic w i ad conjunct ensur valu wseqi use definit cuew i j avail reader i prove properti lemma appendix base lemma reader return new valu begin uncertainti interv properti a hold now consid oper r reader assum valu read wri r written w r begin uncertainti interv w r find p true consequ r return valu new thu reader return old valu end interv henc properti a hold final ensur properti a hold ie newthenold conflict avoid within uncertainti interv consid success read oper reader reader j two case consid either j j i former case difficult oper reader return valu new uncertainti interv w then upon complet establish cuew i j show predic remain stabl uncertainti interv reader j also return valu new newthenold conflict aris stabil cuew i j captur follow properti w cuew prove lemma appendix latter case interest direct commun reader reader j j i order avoid newthenold conflict case reli upon either writer complet write reader j reader k j set cuew k j true word show w cuew l i let us examin assert detail state that uncertainti interv w reader cu reader l and henc return new valu smaller j to reader write valu either w written final valu reader j in case reader j return new valu reader j turn cu reader k in case stabil cuew k j reader j return new valu properti prove lemma appendix complet last remain oblig a proof newthenold conflict occur formal proof next section mirror intuit explan present here proof correct prove construct correct defin function oe given histori show defin oe meet three condit integr proxim preced defin section follow notat convent definit use proof notat order avoid use mani parenthes defin bind order symbol use follow list symbol group bind power group order highest bind power lowest gamma phi oe let e f two event histori then e oe f j e preced f e event correspond execut statement read z oper p z local variabl share variabl valu p read written oper q say oper q determin pz let r two oper reader reader j respect ry determin write oper sy determin write oper preced proof fdefinit determinesg preced sg determin sy definit determinesg ftransit oeg oper occur sequenti historyg ng let r read oper suppos write oper ry then oer defin follow lag otherwiseobserv oer nonneg see thi recal initi write oper assumpt preced read oper thu ry determin w rydon hold impli rf lag hold henc proof integr let r read oper suppos write oper determin ry lag true definit oe r return valu rynew ie valu written w m lag fals definit oe r return valu ryold ie valu written w proof proxim let r oper reader i suppos write oper ry preced preced r thu proxim satisfi case sinc r preced w m clearli r next show preced r definit impli rf lag fals henc rp also fals definit p impli rydon fals rxseqi ryseqi rydon fals i thu either case preced r proof preced proof preced quit complic consist somewhat lengthi case analysi releg appendix here make use lemma prove there three lemma base lemma discuss inform descript previou section let r oper reader i oper reader j r preced s proof oblig show oer oe assum write oper determin ry sy respect observ follow ng fbi definit oe ffrom observ prove earlier r preced fbi definit oe appendixg fbi definit oe fbi definit oe fbi definit oe oe ng fbi definit oe f lag flemma appendixg true discuss shown singlewrit mreader n bit atom regist construct waitfre manner use singlewrit singleread atom regist construct requir om mn share singlewrit singleread safe bit asymptot optim definit atom equival given misra axiom atom essenc requir read write oper shrunk point shrink oper possibl iff function oe meet three condit definit exist recent herlihi wing extend idea atom arbitrari abstract data type defin concept lineariz though akin serializ usual correct criterion concurr execut transact subtl differ two concept one import distinct lineariz local correct condit wherea serializ not refer reader detail order prove correct multipleread atom regist construct function oe meet three condit integr proxim preced defin everi possibl histori lead long somewhat tediou proof mainli proof must take account possibl way read write overlap keep result case analysi proof minimum chose function oe simpl depend boolean variabl f lag proof appear formid spite simplif formal reason leav doubt valid proof howev given length proof seem reason inquir whether exist approach construct mreader regist facilit simpler correct argument briefli describ approach next main idea behind approach develop construct mreader m regist collect m gamma reader regist mreader regist implement singleread regist recurs appli construct first replac m gamma reader regist m gamma reader one replac regist m gamma reader one on simpl implement mreader regist m gammaread regist depict figur construct writer reader denot w r respect remain reader denot sm reader execut program call s construct use two singleread share variabl wr rw two share variabl ws rs variabl name indic program read write it respect exampl ws written writer w read reader sm gamma observ reader share variabl fact crucial exploit recurs applic construct local variabl use construct similar use construct figur primari advantag recurs construct proof correct simplifi assum two reader name r s specif ignor possibl interleav may aris among reader sm gamma consid proof integr proxim preced follow quit easili proof integr proxim condit relat individu read oper oper writer proof preced note preced condit restrict valu return read oper strict preced relationship one anoth reader sm gamma initi lag program new valtyp begin old new alt new val alt read q rw program r return valtyp program return valtyp var begin begin read x wr read x ws read wr read ws f lag lag returnxnew returnynew els returnyold figur recurs construct execut ident program write share variabl preced relationship interest follow read oper r preced read oper read oper r preced anoth read oper r read oper j preced read oper r read oper j preced read oper k case precis aris special case thu proof correct mreader regist reduc much simpler task prove correct tworead construct consist reader r s formal proof correct construct figur appear construct first present remaind section inform describ construct work two reader compar gener construct given earlier figur in gener construct consid here assum variabl remov see footnot begin section henc reader program loop index statement loop index statement begin comparison consid variant tworead version gener construct figur variant shown figur a variant statement combin larger atom statement denot enclos within angl bracket h i note also renam program variabl coincid name given figur also move assign seq occur immedi read rw chang origin construct clearli affect construct correct thu origin construct correct construct shown figur a also correct now consid code w figur a fifth atom statement w alway assign valu true wrdone henc done field wr remov without affect construct correct chang w s fifth atom statement replac singl write wr next consid reader s first atom statement assign valu local variabl x y thu reader ss calcul f lag depend p p defin figur tautolog remov chang seq field construct serv use purpos henc remov final condit reader ss comput f lag also tautolog instead remov it choos replac anoth tautolog y chang clearli affect construct correct yield code given figur b figur shown reader r code chang note that construct figur b statement read write multipl share variabl first statement reader statement elimin turn slight chang code reader r first statement reader broken three separ statement requir program begin old new alt new val alt read q rw hread q sw hwrite wr old new seq seq alt fals program r return valtyp program return valtyp begin begin read x wr hread x ws read wr read v rs f lag p read ws lag p p f lag returnynew f lag returnynew els returnyold fi els returnyold fi a program return valtyp begin begin read q rw read v rs lag ydone lag lag returnynew els returnyold fi b figur two intermedi construct chang reader r follow reader r comput f lag f lag f lag ydone assign f lag xseq xalt rs rather f lag yseq yalt reader r alway return xnew last chang turn writer longer need write old valu reader r result construct given figur complet comparison two construct although construct figur simpler correct proof figur simplic come price particular shown construct multipleread regist requir number bit exponenti number reader acknowledg would like thank ted herman ut distribut system discuss group comment paper would also like thank nanci lynch anonym refere help comment appendix remaind correct proof prove lemma use proof given section outlin inform discuss algorithm section lemma relat uncertainti interv write oper valu variabl rri j use commun reader lemma state elementari result use prove subsequ lemma lemma use prove result use proof lemma lemma consid valu return two success read oper use proof preced present section word concern structur proof order junctur proof reason base upon sequenc state event in word assum total order read write intern variabl construct wherev possibl proof simplifi introduct invari establish invari usual proceed case analysi order event may affect one anoth exampl consid write oper w read oper r reader i oper w read sequenc number reader oper r write sequenc number writer so possibl case analysi whether ws read sequenc number occur rs write sequenc number whole proof difficult but due numer interleav event may potenti occur rather lengthi follow definit use proof first repeat section let w write oper let cuew lag rri consid histori say state prior event e i state follow e similarli e event prior state i e i event follow state i lemma let r oper reader rp k hold k i let w write oper determin ry then hold state prior event r k proof program writer therefor transit w i oe r impli wqi determin either r predecessor r show r determin wqi rp k hold w determin ry therefor transit r determin wqi w assign seqi qi phi impli contrari therefor r determin wqi thu conclud wqi determin predecessor r ie w i oe r second part proof assum k let state prior event k rp k true k follow assert hold state t rrk if lag rrk k have definit p k w determin ry impli walt thu transit follow assert hold state t rrk if lag rrk therefor definit cue cuew k i hold state t follow lemma relat sequenc number read two consecut oper reader i state valu differ one intuit follow order reader is sequenc number increment must first written reader rw i read writer increment writer written wri final read reader i two read wri two consecut read oper complet sequenc event happen onc lemma let r consecut oper reader i then proof prove lemma first show follow assert invari prove b invari consid assert b b defin show b invari assert refer local variabl qi seqi writer xseqi reader i see b invari observ follow ffl b initi true statement possibl falsifi read writer rw i but execut statement b true establish b ffl statement possibl falsifi b assign seqi writer but execut statement b true establish b ffl statement possibl falsifi b first write writer wri but execut statement b true establish b ffl statement possibl falsifi b read reader wri but execut statement b true establish b ffl statement possibl falsifi b write reader rw i but execut statement b true establish b thu conclud b delta delta delta b invari also impli b invari sinc use invari b show lemma hold proof oblig follow let denot state prior event r consecut valu rw i state equal rxseqi valu wriseqi state equal sxseqi sinc b invari either i state t case state t case follow lemma relat valu written rri j oper r reader valu written overlap succeed write oper w proof lemma make use lemma lemma let r oper reader i let w write oper state w i hold valu appear rri j i j state written r cuew i j fals t proof let state w i hold j indic j assum valu appear rri j state written r proof oblig show cuew i j fals t first show rxseqi wseqi let e event prior state t w i hold t w therefor wqi determin either r successor r former case rxseqi w assign seqi qi phi impli wseqi rxseqi latter r write valu appear rri j state state follow event e r consecut oper reader i henc lemma wqi equal rxseqi rxseqi phi therefor wseqi equal rxseqi phi rxseqi phi phi modulo addit impli wseqi rxseqi thu case wseqi rxseqi r write valu appear rri j state t hold state t consid two valu ryseqi wseqi equal wseqi rxseqi rxseqi ryseqi consequ rf lag fals therefor rri jf lag fals henc cuew i j fals t hand ryseqi wseqi rri jseq wseqi therefor fals t follow lemma ensur new valu return write oper uncertainti interv state reader cue reader j return new valu unless writer begun second pass write reader proof make use lemma lemma let w write oper j then proof prove lemma induct i assum result indic less prove i consid state interv w i w hold need show cuew i j fals interv j i consid state interv question assum cuew i j fals state interv occur t note could first state interv show cuew i j also fals j i rri jf lag fals t cuew i j clearli fals t so remaind proof assum rri jf lag true t sinc rri jf lag fals initi exist oper r of reader i write valu appear rri j t consid event fals t requir so remaind proof assum w i oe r let e event prior state t program reader r write valu appear rri j state t r j e w hold t e oe therefor ry determin w write oper immedi preced w latter case ryalt walt therefor cuew i j fals t remaind proof consid case ry determin w therefor rydon fals henc definit p rp fals show l fals well r write valu appear rri j t impli rri jf lag fals henc cuew fals t consid l rang program writer w assumpt w i oe r program reader thu consid state prior event r l preced assert w l w hold state l cuew l i fals state follow assumpt cuew i j fals j state occur interv w i w hold fals state induct hypothesi thu either case cuew l i fals state sinc w determin ry contraposit lemma rp l fals establish remain proof oblig follow lemma assert stabil cuew uncertainti interv state cuew true interv remain true interv end proof make use lemma lemma let w write oper let j then w cuew proof state safeti properti preserv trivial event writer reader differ reader i show also preserv event reader i let oper reader i consid event j event may falsifi predic cuew state prior event let u state follow event assum w cuew hold t then proof oblig show cuew i j hold u w hold u trivial program reader i follow assert hold u thu prove cuew i j hold u suffic prove follow lag cuew i j fals initi rri jf lag initi fals valu appear rri j state written oper r of reader i immedi preced s consid event w i r contraposit lemma w i hold w i oe r but assumpt w hold t therefor now show w determin ry program reader sinc r preced w hold ie state prior j r j oe therefor ry determin either w write oper immedi preced w latter case ryalt walt therefor rri jalt walt t consequ fals t contrari assumpt therefor w determin ry program writer therefor appli therefor w determin sx sy latter impli walt meet two three proof oblig left proof oblig sf lag hold prove next cuew hold t r write valu appear rri j state t rf lag hold sinc w determin ry impli cuew i i hold state follow event r i consequ sinc r consecut oper reader also hold state prior event i definit cue impli follow assert hold state lag rri program reader i rri also hold state therefor lag w determin sx sy shown earlier consequ therefor use definit p sp true consequ sf lag hold final proof oblig follow lemma consid case oper reader preced oper reader j j lemma formal follow properti variabl read determin write oper impli assign variabl uncertainti interv write oper first read return new valu second read also return new valu lemma base lemma turn use proof preced lemma r oper reader oper reader j preced s assum ry sy determin write oper then proof assum write oper w determin ry sy rp k hold k i proof oblig show sp l hold l j first establish w determin sx sy j program reader therefor w determin sy w determin sx sy now consid event first dispos former case show sp true w determin sx sy sydon true therefor definit p sp true remaind proof assum have assumpt rp k hold k i thu lemma program reader therefor next show cuew i true state prior event i let state follow event r j rp k hold rf lag true therefor follow assert hold state t lag rri w determin ry walt thu follow assert hold state t lag rri henc cuew i true state t thu contraposit lemma w i w hold state t program reader i r preced s r j oe thu therefor w i hold state t consequ w hold t ie w w hold t but preced assert w hold t thu w hold t ie w oe r j therefor observ w hold state r j thu lemma hold state interv particular hold state prior now program reader j rri hold state prior event impli follow assert hold lag account fact sx sy determin walt therefor lag henc definit p sp true proof oblig writer write higher number reader first lemma need ensur newthenold conflict aris histori oper higher number reader follow oper lower number one requir properti given later lemma lemma given next take care subcas aris proof lemma lemma state reader cu reader j new valu uncertainti interv write oper w either account read final valu writer ie w i hold account cu turn reader ie hold proof lemma make use lemma lemma let w write oper j then w cuew proof consid reader state interv w hold need show properti hold state interv consid state interv question assum properti hold state interv occur t note could first state interv show properti also hold state t assum cuew i hold state j i proof oblig show cuew k i hold state k i sinc rri jf lag fals initi state cuew i j initi fals therefor assum valu appear rri j state written oper r of reader i consid event w i r contraposit lemma w i hold w i oe r but assumpt w hold t therefor program reader r write valu appear rri j state t r j e e event prior state t w i hold t e oe w i therefor therefor ry determin either w immedi predecessor w but immedi predecessor w determin ry account true state t so w determin ry cuew hold state t rri jf lag also hold t henc r write valu appear rri j t rf lag hold program reader i impli rp k true k k i show k observ assert impli r oe e oe w i thu w determin ry rydon fals impli rp fals thu k k i i program reader j thu let u denot state prior event r k rp k hold k lemma cuew k i hold state u thu contraposit lemma w k w hold u but assert w k hold u consequ w hold u ie w w hold u but w hold u thu w hold u impli w oe r k thu assert have observ w hold state r k w i sinc cuew k i hold state u lemma cuew k i hold state interv particular hold state the state follow event e establish proof oblig k i case hold state u u lie within interv w hold u occur t consequ assumpt properti hold state prior interv w i hold state u hold state u k i howev w i hold state u therefor cuew k i hold state u k i consequ appli lemma previou paragraph cuew k i also hold state t desir accord next lemma reader cu reader j uncertainti interv write oper w also cu reader indic j proof follow essenti fact reader write reader order increas indic lemma make use lemma turn use proof lemma lemma let w write oper j then w cuew proof assum w cuew hold state t let k j show cuew hold state t rri jf lag fals initi state cuew i j initi fals therefor assum valu appear rri j state written oper r of reader i let u state follow event r k sinc cuew hold sinc r write ident valu rri j rri k cuew hold u now consid event w i r contraposit lemma w i hold w i oe r but assumpt w hold t therefor program reader r write valu appear rri j state t r j e e denot event prior state t sinc w hold t e oe w m therefor sinc w i cuew hold state u lemma w hold u word w w hold u but w hold state u thu w hold u consequ lemma cuew hold state interv r k w m particular state t establish proof oblig lemma relat valu rrl i rrk j state reader l cu reader uncertainti interv write oper w reader indic lower either inform new valu writer ie w j hold turn cu reader ie hold proof lemma make use lemma lemma let w write oper l i then w cuew l i proof assum w cuew l i hold state t breviti let p j shorthand show w j p j hold state t proof induct induct step given follow assert which shown later hold state t w cuew given assumpt w cuew l i hold t induct step impli one disjunct consequ hold t second disjunct hold induct step appli again time use w cuew l anteced number reader finit reader indic l appear second disjunct consequ smaller indic l i induct step appli way finit number time thu finit number applic eventu obtain consequ first disjunct hold sinc assert p j accumul second disjunct applic induct step impli follow assert hold induct termin j assert follow state t combin rang two univers quantif get state t impli hold state t requir proof oblig proof induct step follow all state predic refer state t w cuew l i w l assumpt w g w l w l fdefinit p jg w l assumpt w cuew l ig w l w l fdefinit p jg w l w l fpredic calculu l ig w l fdefinit p i g w l assumpt w g w l follow lemma consid two success read oper r r though preced s read recent write oper s order writer write reader situat aris index r greater s lemma ensur r comput f lag fals comput f lag true lemma base lemma turn use proof preced lemma let r oper reader oper reader j preced s assum ry sy determin write oper lag fals sf lag true program reader w determin sy w preced w therefor henc rydon fals sydon true thu definit p rp fals sp true sp true program reader j sf lag true meet half proof oblig remaind proof show rp k fals k rang impli remain proof oblig name rf lag fals consid two event former case contraposit lemma rp k fals k desir so assum remaind proof k i program reader thu use note w k w hold state prior r k henc lemma hold state therefor contraposit lemma rp k fals requir proof oblig final lemma proof construct consid case oper reader preced oper reader j j lemma counterpart lemma consid case j lemma base lemma turn use proof preced lemma let r oper reader oper reader j preced s assum ry sy determin write oper then proof assum write oper w determin ry sy rp k hold k i proof oblig show sp l l j consid two event first dispos former case r preced s program reader therefor thu sinc w determin sy sydon true therefor definit p sp true establish proof oblig remaind proof assum r ry determin impli rydon fals definit p impli rp fals program reader therefor let denot state prior event r k show w hold t rp k true k lemma cuew k i hold state t henc contraposit lemma w k w hold t becaus thu previou preced assert follow therefor w k hold state t consequ w hold t ie w w hold t but preced assert w hold t thu w hold t sinc w cuew k i hold state j i lemma w j hold cuew m j hold j former case r preced s impli repeat reason follow impli sp hold requir remaind proof assum cuew m j hold t sinc w hold state t k program reader therefor consid two event first dispos former case r preced s r henc sydon true moreov sinc therefor definit p sp true establish proof oblig remaind proof assum r preced s r oe thu follow assert hold therefor assert w hold state interv r k recal cuew m j hold state t ie state prior event r k therefor lemma cuew m hold state interv particular hold state follow event m program reader j rrm state therefor lag w determin sy sy syalt therefor lag consequ definit pm sp true proof oblig r virtu patienc concurr program without wait elus atom regist construct twowrit atom regist construct multiread atom valu nonatom valu parallel program design foundat concurr control reader writer counterexampl one writer multiread atom variabl construct burn peterson lineariz correct condit concurr object atom multiread regist hoar logic part ii construct waitfre variabl axiom memori access asynchron hardwar system protocol waitfre concurr read write concurr read write ii multiwrit case correct atom multiwrit regist elus atom regist revisit construct atom variabl convert lamport regular regist atom regist concurr read write revisit atom share regist access asynchron hardwar tr axiom memori access asynchron hardwar system elus atom regist revisit construct multiread atom valu nonatom valu protocol waitfre atom multiread share variabl convert lamport regular regist atom regist construct twowrit atom regist parallel program design foundat lineariz correct condit concurr object concurr read write concurr control myampersandldquoreadersmyampersandrdquo myampersandldquowritersmyampersandrdquo atom multiread regist construct atom variabl extend abstract share concurr asynchron waitfre varaibl preliminari version virtu patienc concurr program without wait elus atom regist ctr s haldar k vidyasankar construct writer multiread multivalu atom variabl regular variabl journal acm jacm v n p jan cynthia dwork orli waart simpl effici bound concurr timestamp traceabl use abstract journal acm jacm v n p sept alessandro panconesi marina papatriantafil philippa tsiga paul vitnyi random name use waitfre share variabl distribut comput v n p august jame h anderson yongjik kim nonatom mutual exclus local spin proceed twentyfirst annual symposium principl distribut comput juli monterey california rida a bazzi gil neiger gari l peterson use regist achiev waitfre consensu distribut comput v n p april ming li john tromp paul m b vitnyi share concurr waitfre variabl journal acm jacm v n p juli paul c atti e allen emerson synthesi concurr program atom readwrit model comput acm transact program languag system topla v n p march john tromp paul vitnyi random twoprocess waitfre testandset distribut comput v n p juli yehuda afek david s greenberg michael merritt gadi taubenfeld comput faulti share object journal acm jacm v n p nov jame h anderson lamport mutual exclus year plant seed proceed twentieth annual acm symposium principl distribut comput p august newport rhode island unit state