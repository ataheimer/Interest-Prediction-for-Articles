t concurr thread optim parallel minimum span tree algorithm a paper resolv longstand open problem whether concurr write capabl parallel random access machin pram essenti solv fundament graph problem like connect compon minimum span tree ologn time specif present new algorithm solv problem ologn time use linear number processor exclusiveread exclusivewrit pram logarithm time bound actual optim sinc well known even comput nbit requir ohgrlog n time exclusivewrit pram effici achiev new algorithm base new schedul exploit high degre parallel b introduct given weight undirect graph g n vertic edg minimum span tree mst problem nd span tree or span forest g smallest possibl sum edg weight problem rich histori preliminari version paper appear proceed tenth annual acmsiam symposium discret algorithm baltimor maryland acm new york siam philadel phia pp work support part hong kong rgc grant hkue address ka wong chong takwah lam depart comput scienc inform system univers hong kong hong kong email fkwchongtwlamgcsishkuhk yiji han comput scienc telecommun program univers missouri kansa citi rockhil road kansa mo usa email hancstpumkcedu permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut prot direct commerci advantag copi show notic rst page initi screen display along full citat copyright compon work own other acm must honor abstract credit permit copi otherwis republish post server redistribut list use compon work work requir prior specic permiss andor fee permiss may request public dept acm inc broadway new york ny usa fax permissionsacmorg han tw lam sequenti mst algorithm run om log n time known decad ago see tarjan survey subsequ number ecient mst algorithm publish particular fredman tarjan gave algorithm run ommn time m n minfi j log i n mng time complex improv om log m n gabow galil spencer tarjan chazel present even faster mst algorithm time complex ommn log m n m n invers ackerman function recent chazel improv algorithm run ommn time later petti independ devis similar algorithm time complex recent petti ramachandran obtain algorithm run optim time simpl random algorithm run linear expect time also found karger et al parallel context mst problem close relat connect compon cc problem nd connect compon undirect graph cc problem actual admit faster algorithm sequenti con text yet two problem solv similar techniqu variou model parallel random access machin see survey jaja karp ramachandran respect model concurr write capabl ie processor write share memori locat simultan problem solv olog n time use nm processor awerbuch shiloach cole vishkin use random gazit algorithm solv cc problem olog n expect time use n processor work algorithm dene timeprocessor product on m thu optim later cole et al obtain result mst problem exclus write model includ concurrentread exclusivewrit exclusiveread exclusivewrit pram olog n time algorithm cc mst problem develop two decad ago chin et al hirschberg et al while believ exclus write model could overcom olog n time bound rst breakthrough due johnson metaxa devis olog n time algorithm cc problem mst problem result improv chong lam chong olog n loglog n time random allow time work improv particular karger et al show cc problem solv olog n expect time later halperin zwick improv work linear mst problem karger obtain random algorithm use olog n expect time and superlinear work poon ramachandran gave random algorithm use linear expect work olog n log log n log n expect time anoth approach stem fact determinist space bound stconnect problem immedi impli ident time bound erew algorithm cc problem nisan et al shown stconnect problem solv determinist use olog n space armoni et al improv bound olog n result impli erew algorithm solv cc problem olog n time olog n time respect optim parallel mst algorithm prior work open whether cc mst problem could solv determinist olog n time exclus write model notic log n optim sinc graph problem least hard comput n bit cook et al proven latter requir qui n time crew erew pram matter mani processor use exist mst algorithm and cc algorithm dicult improv lock among processor processor work dierent part graph dierent densiti progress processor uniform yet processor coordin close order take advantag result comput other result mani processor often wait rather use comput paper present new parallel paradigm solv mst problem requir minim coordin among processor fulli util parallel base new insight structur minimum span tree show paradigm implement erew solv mst problem olog n time use n m processor algorithm determinist natur requir special oper edg weight other comparison find connect compon minimum span tree often key step parallel algorithm graph problem see eg miller ramachandran maon et al tarjan vishkin vishkin new mst algorithm parallel algorithm immedi improv run optim ie olog n time without use concurr write eg biconnect tarjan vishkin ear decomposit miller ramachandran theoret point view result illustr concurr write capabl essenti solv number fundament graph problem ef cientli notic erew algorithm actual practic sens adapt realist parallel model like queu share memori qsm gibbon et al bulk synchron parallel bsp model valaint latter distribut memori model parallel comput gibbon et al show erew pram algorithm simul qsm model slow factor g g bandwidth paramet qsm model simul is howev known crcw pram thu result impli mst problem solv ecient qsm model og log n time use linear number processor furthermor gibbon et al deriv random workpreserv simul qsm algorithm logarithm slow bsp model rest paper organ follow section review sever basic concept introduc notion call concurr thread nding minimum span tree parallel section describ schedul use thread illustr limit form pipelin which avor similar pipelin mergesort algorithm cole section lay detail requir thread section show detail algorithm simplifi discuss rst focu crew pram show solv mst problem olog n time use n m log n processor section adapt algorithm run erew pram reduc processor bound linear kw chong y han tw lam remark recent petti ramachandran made use result paper improv exist random mst algorithm precis algorithm rst one run high probabl olog n time linear work erew pram basic parallel mst algorithm past present section review classic approach nding mst base approach easili contrast new mst algorithm exist one assum input graph g given form adjac list consid edg g note e appear adjac list u v call copi e mate other need distinguish them use notat hu vi hv ui signifi edg origin respect weight e real number denot we wu v without loss gener assum edg weight distinct thu g uniqu minimum span tree denot g throughout paper also assum g connect otherwis algorithm nd minimum span forest g let b subset edg g contain cycl b induc set tree natur sensetwo vertic g tree connect edg b b contain edg incid vertex v v form tree denit consid edg g tree f u v belong e call intern edg one u v belong e call extern edg note edg also intern edg convers may true denit b said forest tree f least vertic exampl b empti set b forest g span tree g nforest consid set b edg chosen g assum b forest augment b give forest use greedi arbitrari subset f f includ tree f fewer vertic may contain tree vertic everi tree f pick minimum extern edg denot b set edg lemma jaja lemma b consist edg g onli lemma forest proof everi tree f f alreadi contain least vertic consid tree f let hu vi minimum extern edg v belong anoth tree f respect vertic connect togeth among tree induc one includ contain least vertic therefor forest g base lemma nd g blog nc stage follow notat let bp q denot q empti set otherwis optim parallel mst algorithm procedur blog nc stage a let f set tree induc b g let f arbitrari subset f f includ tree f fewer vertic e minimum extern edg f g return b blog nc stage i dierent strategi choos set f step a may lead dierent b s nevertheless b i alway subset g induc forest particular b blog nc induc blog nc forest tree denit contain least blog nc n vertic word b blog nc induc exactli one tree equal g use standard parallel algorithm techniqu stage implement olog n time erew pram use linear number processor see eg jaja therefor g found olog n time fact parallel algorithm nding mst includ crcw pram algorithm base similar approach see eg awerbuch shiloach chin et al citencv johnson metaxa chong lam chong karger et al parallel algorithm sequenti sens comput b start b avail see figur a innov idea exploit mst algorithm use concurr thread comput b s thread group processor work dierent task comput thread independ other algorithm blog nc concurr thread nding particular b thread character fact thread comput b start long thread comput b complet actual output b o time figur b result g found olog n time algorithm take advantag interest properti set properti actual hold respect determinist algorithm nding mst though mention explicitli literatur lemma let one tree induc b k k blog nc e minimum extern edg subtre ie connect sub minimum extern edg either e edg proof see appendix overview schedul algorithm consist blog nc thread run concurr blog nc thread aim nd set b one possibl set comput stage procedur iterativemst precis let f set tree induc arbitrari subset f includ tree fewer contain minimum extern edg tree f thread kw chong y han tw lam phase phase phase phase phase phase phase phase b thread phase blog ic phase blogi c fig a iter approach b concurrentthread approach receiv output thread ie increment never look comput o time exampl show detail schedul thread i give two exampl illustr thread speed comput b exampl thread comput b time ci respect thread i c xed constant simplifi discuss exampl assum adjac list set vertic merg singl list time end section explain infeas implement highlight novel observ techniqu evad problem thread start set q adjac list list contain smallest edg incid vertex g edg kept q alreadi sucient comput b reason follow consid tree induc assum minimum extern edg e incid vertex v contain fewer vertic edg incid v intern edg thu smallest edg incid v must includ e exampl straightforward implement lemma thread start avail let f set tree induc b suppos merg adjac list vertic tree form singl combin adjac list notic hat tree f fewer vertic combin adjac list contain edg optim parallel mst algorithm combin list edg determin minimum extern edg time ci c suitabl constant collect minimum extern edg report b observ combin adjac list edg repres tree contain least vertic denit b necessari report minimum extern edg tree exampl exampl slightli complex illustr thread work increment manner thread start soon b i comput point avail thread readi comput b nevertheless perform preprocess call phase below b becom avail comput b speed run time ci phase ii phase i let f set tree induc b i again suppos merg adjac list q everi tree f form anoth set q adjac list denit b i tree f contain least i vertic tree f fewer vertic combin adjac list contain edg extract list i smallest edg connect distinct tree f edg sucient nding b the argument extens argument exampl comput take time ci onli phase ii b avail comput b base q follow edg bi connect tree f form set f bigger tree suppos merg list q everi tree f notic tree f contain fewer vertic compos i tree f combin adjac list contain i edg case nd minimum extern edg time b set minimum extern edg found conclus comput b found time remark set b found exampl may dierent yet either case subset g forest schedul mst algorithm base gener idea comput thread divid blog ic phase thread comput enter last phase take o report b see figur b global speak mst algorithm run blog nc superstep last o time particular thread deliv b end ith superstep let us rst consid power two phase thread start avail comput take i superstep end i start i avail use i superstep subsequ phase use half mani superstep preced phase last phase phase log i start end within ith superstep see figur gener i thread run blog ic phase mark start time kw chong y han tw lam i i ii i iphas log phase phase thread fig schedul thread i power phase dene sequenc that is phase j thread i j blog ic start a th superstep use j superstep phase j handl edg set b j made avail thread execut phase j merg exampl assum everi tree f merg adjac list vertic or subtre phase ii exampl singl list ecient time depend total length done via techniqu introduc tarjan vishkin let us look exampl suppos tree contain edg e two vertic u v assum adjac list u v contain e mate respect two list combin e mate exchang successor see figur everi edg mate exchang successor adjac list get combin adjac list o time howev merg fail edg mate includ correspond adjac list algorithm keep track edg vertex or subtre ecienc exampl adjac list q involv edg incid vertex respect tree edg mate may present correspond adjac list therefor appli otim merg techniqu may abl megr adjac list one singl list repres fail form singl combin adjac list also complic extract essenti edg in particular minimum extern edg comput set b particular cannot easili determin vertic belong identifi redund edg ie intern extra multipl extern edg adjac list e e e e fig merg pair adjac list lu lv respect common edg e optim parallel mst algorithm actual mst algorithm insist merg adjac list singl list key idea algorithm maintain essenti edg includ one particular combin adjac list base structur properti minimum span tree lter redund adjac list obtain uniqu adjac list see lemma section adjac list repres intern edg remov use techniqu base threshold chong intrigu part concern extra multipl extern edg nd necessari remov them specic show extra multipl extern edg cannot remov easili must bigger weight presenc aect correct comput next section elabor idea formul requir phase achiev schedul requir phase section specifi formal thread expect achiev phase initi in phase thread construct set q adjac list vertex v g q contain circular link list l includ smallest edg incid v addit l assign threshold denot hl l contain edg v smallest edg truncat l blog ic phase adjac list merg base newli arriv edg set truncat accord length requir combin adjac list new threshold comput intuit threshold record smallest edg truncat far consid phase j j blog ic inherit set q j adjac list phase j receiv edg set ba recal denot set tree induc b j phase j aim produc set q j adjac list captur extern edg tree f j essenti comput b basic tri merg adjac list q j respect ba mention befor merg process may produc one combin adjac list tree nevertheless strive ensur one combin list retain rest ltere out view time constraint impos schedul thread i also need tight bound length remain adjac list let l list q j r uniqu correspond tree f j store extern edg case said repres l q j tree f j may repres list q fewer vertic repres r length l contain bi j c edg dene edg tree f j essenti must includ l consid extern edg e connect anoth tree f j han tw lam say e primari if among edg connect e smallest weight otherwis e said secondari note minimum span tree g contain edg extern edg must primari one ideal primari extern edg retain list yet infeas sinc thread start truncat adjac list cannot identifi remov secondari extern edg phase remov intern edg though nontrivi feasibl import observ necessari remov secondari extern edg base structur classic light heavi edg dene below nd light secondari extern edg remov easili af terward list contain light primari extern edg possibl heavi secondari extern edg set light primari extern edg may cover primari extern edg size much smaller bi j c yet show set light primari extern edg suce comput presenc heavi secondari extern edg aect correct give denit light heavi edg base notion base denit let tree f j let real number tree f j said access anoth tree f j access connect edg weight smaller let e extern or intern edg dene set weaccess tg size basef total number vertic tree involv let e extern or intern edg say e light kbasef follow denit light edg tree smaller weight heavi edg also heavi edg remain heavi edg subsequ phase specic phase k k j subtre tree x f k extern or intern edg e therefor e heavi respect also heavi respect x follow lemma give upper bound number light primari extern edg tree f j compli length requir list q j lemma tree f j bi j c light primari extern edg proof let x number light primari extern edg among light primari extern edg let e one biggest weight set includ least x tree adjac b j j forest everi tree f j contain least j vertic denit light edg thu x j x optim parallel mst algorithm follow requir speci essenti edg kept list character secondari extern edg ani list r base let tree f j repres list l q j light primari extern edg includ l secondari extern edg includ l must heavi retain light primari extern edg list q j alreadi sufcient comput b particular let us consid scenario end phase blog ic tree f blog ic fewer vertic minimum extern edg e ts must report b note basef blog ic contain ts light primari extern edg previou phase k f k contain subtre denot w e ts extern edg note e ts also light primari extern edg w as heavi edg remain heavi edg subsequ hand end phase blog ic tree x f blog ic contain vertic extern edg heavi r cannot enforc minimum extern edg e tx x kept list x fortun necessari thread report minimum extern edg tree follow requir threshold help us detect whether minimum extern edg x remov so report anyth x essenti requir e tx primari extern edg e x remov list l x repres x threshold kept l x bigger we respect we smallest edg l x e tx weight fewer threshold let tree f j repres list l q j threshold l satis follow properti r lower bound threshold hl hl equal weight heavi intern extern edg r upper bound threshold let e extern edg includ l e primari hl we our algorithm actual satis stronger requir hl we e primari e secondari mate e still includ anoth list l q j summari r r guarante end phase blog ic tree fewer vertic minimum extern edg e edg kept uniqu adjac list repres otherwis may may repres list repres list e alreadi remov threshold kept we everi extern edg current kept list must weight greater equal threshold thu simpli ignor list easi check q satis requir phase next section give algorithm satisfi requir everi phase consequ thread report b base edg list kw chong y han tw lam algorithm section present algorithm detail thread i show merg extract adjac list phase discuss induct naturefor j assum phase j produc set adjac list satisfi requir rr show phase j comput new set adjac list satisfi requir oi j use linear number processor phase j inherit set adjac list q j phase j receiv edg ba eas discuss refer ba input notic list q repres one tree f j recal denot set tree induc b phase j merg adjac list q accord tree f j connect edg input consid edg input denot w w tree f j contain u v respect ideal e mate appear adjac list w w respect adjac list w w merg easili o time howev w w might alreadi larg represent q j even repres length requir adjac list may allow e includ result e may appear two separ list q one even none call e full half lost edg respect accordingli partit input three set name fullinput halfinput lostinput phase j start merg list q respect edg fullinput let tree f j let w tree f j that togeth edg input constitut note w may repres list q j sinc merg done respect fullinput adjac list w present may merg sever list instead singl one let merg list l repres bigger subtre z call cluster see figur cluster may contain one w distinguish one cluster call core cluster minimum extern edg e extern edg cluster note minimum extern edg core cluster may may e noncor cluster z minimum extern edg e z z must tree edg by lemma thu e z input moreov e z full edg otherwis merg oper e z becom intern edg bigger cluster merg list obvious need satisfi requir q j follow section present addit process use fulll requir ment summari process given section discuss process merg list divid accord size tree sketch follow tree f j contain fewer vertic simpl way ensur exactli one merg list retain q j edg list optim parallel mst algorithm fig wx repres tree f j dot solid line repres half full edg input respect tree form connect tree f j edg input zy call cluster subtre form connect wx s full edg onli adjac list wx s within zy merg singl list easili ltere contain light primari extern edg secondari extern edg includ must heavi tree f j contain least vertic process may retain one merg list put extra step ensur that except possibl one merg list remov threshold remain list updat retain bi j c smallest edg show requir threshold satis matter whether tree concern contain fewer vertic not tree f j fewer vertic section focu tree f j contain fewer vertic denot merg list repres cluster observ list contain bi edg below deriv ecient way nd uniqu adjac list repres contain light primari extern edg first all realiz everi light primari extern edg also light primari extern edg tree w f j must present adjac list repres w q j by r thu light primari extern edg includ minimum extern edg present merg list uniqu represent let l cc list fl l cc contain minimum extern edg e is l cc repres core cluster z concern remov list fl repres uniqu l cc ecient distinguish l cc list make use properti kw chong y han tw lam state follow lemma let l nc list fl g let z denot cluster repres l nc lemma i l cc contain edg halfinput ii l nc contain least one edg halfinput particular minimum extern edg z halfinput proof lemma i assum contrari l cc includ edg halfinput precis ha bi l cc hb ai includ list tree f j connect e w edg e primari extern edg w well w w w subtre w also subtre z show contain least vertic latter contradict assumpt thu lemma i follow w subtre contain less vertic r q contain list lw repres w r lw contain light primari extern edg w edg hb ai includ lw must heavi therefor next want show tree basef subtre dene b subtre construct remov e see figur assum contain vertex b vertex b w well z fig partit two subtre ta b connect e subtre w subtre b lemma minimum extern edg b either e e former case imposs e includ l cc must extern edg z thu e minimum extern edg b denit base basef cannot includ tree f j outsid b word b includ subtre basef must least vertic must contradict occur proof lemma ii let e z minimum extern edg z e z tree edg input full edg case show e z actual half edg includ l nc thu complet proof let w tree f j w compon z e z extern edg w note e z primari extern edg w let lw denot adjac list q repres w sinc e z minimum extern edg optim parallel mst algorithm includ tree f j outsid z thu size less r light primari extern edg w includ e z present lw therefor e z halfinput l nc must inherit e z lw use lemma easili retain l cc remov merg list l nc one might worri l nc might inde contain light primari extern edg remov l nc incorrect actual imposs view follow fact lemma extern edg e includ l nc proof let e z minimum extern edg z extern edg e includ l nc e also extern edg z we we z let w w tree f j connect e z w compon z shown previou lemma e z halfinput moreov e z tree edg present adjac list w is w compon adjac list w q contain e z note e z primari extern edg w r r conclud e z heavi extern edg w henc kbasef therefor lemma l nc contain light primari extern edg word light primari extern edg must l cc list retain exclud light intern secondari extern edg l cc contain light primari extern edg also edg length requir ie r retain bi j c edg l cc note light primari extern edg may smallest edg l cc base follow two lemma remov light edg l cc includ light intern secondari extern edg light primari extern edg smallest edg left list retain bi j c smallest edg alway includ light primari extern edg lemma suppos l cc contain light intern edg hu vi mate hv ui also appear l cc proof recal l cc form merg adjac list tree f j r list contain intern edg tree repres l cc contain light intern edg hu vi edg u v must two tree w w f j compon z assum light extern edg w w respect let lw lw adjac list q j hu vi appear appear lw r light edg found lw includ hu vi must primari extern edg w symmetri hv ui primari extern edg w r again hv ui appear lw sinc l cc inherit edg lw lw conclud hu vi hv ui appear l cc han tw lam lemma suppos l cc contain light secondari extern edg e let e correspond primari extern edg e e appear l cc mate also appear anoth merg list l cc l cc repres core cluster anoth tree f j proof suppos l cc contain light secondari extern edg e assum e connect anoth tree f j e primari extern edg we we e fig e light secondari extern edg e correspond primari extern edg thu e also light primari extern edg must includ l cc hand sinc e secondari equal basef thu contain less vertic merg list q obtain merg list l cc includ light primari extern edg show l cc contain mate e e observ kbasef e e light extern edg e also primari extern edg e more precis mate must includ l cc let w w two tree f j connect e w subtre w e light extern edg also light extern edg w w note l cc inherit e adjac list repres w r lw includ light secondari extern edg w e primari extern edg w symmetri e also primari extern edg w thu r e adjac list lw repres w note l cc must includ edg lw well list q j contain light extern edg see lemma l cc contain e too lemma remov light intern edg simpli remov edg whose mate list lemma impli l cc contain light secondari extern edg correspond primari extern edg also appear optim parallel mst algorithm l cc mate exist anoth list l cc suggest simpl way identifi remov light secondari extern edg follow without loss gener assum everi edg l cc determin ident l cc ani distinct label given l cc edg e l cc mate anoth list say cc e announc ident l cc mate vice versa sort edg l cc respect ident receiv mate multipl light extern edg connect tree come togeth easili remov light secondari extern edg know l cc contain light primari extern edg edg contain must heavi let us summar step requir build uniqu adjac list repres procedur mc mc mean merg clean edg input full respect q j activ merg list q j let q set merg adjac list merg adjac list l q a l contain edg halfinput remov l q b detect remov intern secondari extern edg l accord lemma tree least vertic consid tree f j contain vertic let l l merg list repres cluster list may contain edg unlik case section minimum extern edg e heavi cannot guarante merg list contain e repres core cluster nevertheless thread ignor tree may remov merg list lemma show list fl l g repres noncor cluster remov easili inde merg list l cc repres core cluster thread may remov l cc sinc contain least vertic light primari extern edg noth enforc l cc regard light primari extern edg concern l cc requir threshold handl section contain least vertic merg list l nc repres noncor cluster may satisfi properti state lemma ii need way detect l nc first detect length l nc l nc contain edg remov l nc immedi next l nc contain less edg make use follow lemma identifi it denot hl threshold associ list l merg l nc g lemma list l repres noncor cluster satis least one follow condit l nc contain edg halfinput everi edg hu vi l nc either hv ui also l nc wu v han tw lam proof assum l nc contain edg halfinput l nc contain edg hu vi contain hv ui show wu v tmphl nc edg u v intern extern edg z case u v intern edg z l nc inherit hu vi list l tree repres l r hu vi extern edg w thu z includ anoth tree w f j hv ui extern edg l nc also inherit edg list lw repres w note hv ui appear lw r hlw case u v extern edg z obviou wu v we z e z minimum extern edg z show we z tmphl tree z e z extern edg let lw adjac list repres w mention befor e z input full edg e z lost edg l nc contain e z e z half edg l nc contain e z l nc contain edg halfinput conclus e z appear l nc henc cannot appear lw sinc e z primari extern edg w know that r hlw we z denit use lemma extend procedur mc remov everi merg list l nc repres noncor cluster tree f j see procedur ext mc precis fewer vertic l nc remov step a otherwis l nc remov step b step ac procedur ext mc a edg input full respect q j activ merg list q j let q set merg adjac list b list l q l contain remov l q merg adjac list l q a l contain edg halfinput remov l q b detect remov intern secondari extern edg l c if edg hu vi l wu v tmphl remov l q procedur ext mc execut remain merg list repres core cluster tree f j moreov tree f j fewer vertic procedur ext mc like procedur mc alway retain merg list l cc repres core cluster l cc remov step b l cc cannot contain edg addit l cc contain light primari extern edg lemma below show tmphl cc weight heavi intern extern edg thu l cc contain edg weight less tmphl cc cannot remov step c lemma tmphl cc equal weight heavi intern extern edg proof among list q j merg l cc let l one optim parallel mst algorithm smallest threshold is tmphl cc denot tree f j repres l r hl equal weight heavi intern extern edg e w thu e also heavi intern extern edg updat threshold retain extern edg procedur ext mc execut everi remain merg list repres coreclust tree f j let l cc list repres tree f j contain less vertic light primari extern edg appear among smallest edg l cc edg l cc heavi edg least vertic extern intern edg light edg l cc must heavi denit ext mc number edg l cc bi may exceed length requir phase j ie ensur l cc satis r retain bi j c smallest edg l cc threshold l cc denot hl cc updat minimum tmphl cc weight smallest edg truncat contain fewer vertic not everi edg truncat l cc heavi togeth lemma conclud hl cc equal weight heavi intern extern edg satisfi r next give observ l cc lemma show r satis denot z coreclust repres l cc lemma let e extern edg z e tree edg e includ l cc hl cc we proof suppos e includ l cc note e cannot full edg respect q full edg mate remov step b procedur ext mc e halfinput procedur ext mc remov l cc step a contradict l cc one remain list procedur ext mc execut therefor e includ l cc next show hl cc we let w subtre z e extern edg w sinc e tree edg e primari extern edg w e includ l cc l cc inherit adjac list lw repres w e also includ lw r hlw we recal lemma let e extern edg current found l cc i e primari ii e secondari mate e still includ list l q j hl cc we proof let vi extern edg current found l cc satisfi condit state lemma let w tree f j w subtre e extern edg w respect w either e primari e secondari mate e includ anoth list q consid whether w includ core cluster z case w subtre z denit z w must repres list end phase j e may may appear lw e kw chong y han tw lam z fig z z connect path p p contain edg a b extern edg z w appear lw then r hlw hl cc we suppos e lw e pass l cc procedur ext mc start o yet e current l cc e remov l cc within procedur ext mc take place step b e either intern edg secondari extern edg remov togeth mate contradict assumpt e thu e remov procedur ext mc ie due truncat case way hl cc updat guarante case w subtre noncor cluster z show z extern we observ contain path connect z z path must involv extern edg ha bi z lemma hl cc wa b next show wa b we let w tree f j w subtre z ha bi extern edg w see figur suppos remov edg a b partit two subtre b contain vertic b respect note b contain w e extern edg b hand z includ e extern edg b lemma minimum extern edg b hb ai therefor wa b we result hl cc wa b we lemma follow remov remain intern edg note l cc may still contain intern edg procedur ext mc remov intern edg whose mate also appear l cc follow lemma show everi remain intern edg l cc weight greater hl cc thu discard edg l cc weight greater hl cc ensur extern edg retain cours light primari extern edg remov step lemma intern edg e current includ l cc proof consid whether intern extern edg z optim parallel mst algorithm fig pair vertic u v e connect path p everi edg p weight smaller we case e intern edg z suppos l cc inherit e list repres tree w f j w subtre z r hu vi extern edg w z includ anoth tree w f j contain vertex v denot lw list q j repres w edg hv ui extern edg w hv ui appear lw otherwis would also inherit hv ui lw procedur ext mc remov hu vi hv ui l cc step b r hlw wu v case e extern edg z lemma e tree edg let p path connect u v see figur sinc subtre g everi edg p weight smaller wu v p nd extern edg ha bi z lemma again hl cc wa b henc hl cc wu v complet algorithm discuss thread previou three section summar follow procedur time processor requir analyz next section thread input g b k k avail end kth superstep construct q g blog ic phase j denot input ba a edg input full respect q list set merg adjac list b list l q l contain bi part lg otherwis remov l q list l q remov unwant edg list kw chong y han tw lam a l contain edg halfinput remov l q b detect remov intern secondari extern edg l c if edg hu vi l wu v tmphl remov l q truncat list necessari remov remain intern edg a list l q l contain bi j c edg retain smallest one updat hl minimum tmphl we smallest edg remov l b edg hu vi l wu v hl remov hu vi l appear list l q blog ic wu v hl g time processor complex first show new mst algorithm run olog n time use nm log n crew pram processor illustr modifi algorithm run erew pram reduc processor bound linear thread start run concurr need initi step first adjac list g sort ascend order respect edg weight set sort adjac list replic blog nc time copi move local memori thread part global share memori dedic processor perform local comput thread replic take olog n time use linear number processor thread construct q o time afterward thread run concurr mention section comput thread schedul run number phase phase start end predetermin superstep need show comput phase complet within alloc time interv particular phase j thread schedul start a j th superstep end j th superstep use superstep follow lemma show phase j thread implement ci j time c constant set length superstep constant c ci j c phase j complet comput superstep verifi lemma phase j thread implement oi use processor proof consid comput phase j thread i merg adjac list start thread read ba may also read mani thread local memori thread i merg adjac list step a take o time step b test length list bi done perform pointer jump time that adjac list left length bi subsequ step make use standard parallel algorithm techniqu includ list rank sort pointer jump optim parallel mst algorithm process remain list time use techniqu logarithm order length list see eg jaja therefor step phase j implement ci use linear number processor corollari minimum span tree weight undirect graph found olog n time use n m log n crew pram processor proof lemma comput phase j thread satis predetermin schedul therefor b found end ith superstep b blog nc readi end blog ncth superstep mean whole algorithm run olog n time thread use nm processor n m log n processor suce whole algorithm adapt erew pram illustr modifi algorithm run erew pram model consid phase j thread i discuss proof lemma concurr read use access edg ba may also read mani thread time ba alreadi resid local memori thread i step implement erew pram avoid use concurr read requir thread copi output subsequ thread modifi schedul thread perform copi process sequenti manner detail follow shown proof lemma phase j thread implement ci c constant length superstep set c phase j thread complet within superstep length superstep doubl ie superstep take c time instead c comput phase j defer last half superstep ie last superstep rst half superstep phase j ie th a j th superstep comput perform thread wait thread store output b j local memori complet schedul need show thread k k i perform copi time recal thread k complet comput kth superstep k four thread name thread replic take use linear number processor lemma consid thread i end a th super step copi ba resid local memori thread i proof k i thread receiv b k k phase j thread i b j last set edg receiv arriv a th superstep start second half phase j han tw lam linear processor section adapt mst algorithm run linear number processor rst show reduc processor requir m n log n then dens graph least n log n edg processor requir domin m final give simpl extra step handl spars graph reduc processor requir log n would like introduc preprocess thread thread work n instead m edg comput requir output use n processor yet preprocess thread still need handl edg requir processor sidestep diculti attempt share preprocess among thread precis comput divid dlog log ne stage stage k ne perform one singl preprocess allow k thread comput concurr edg set use processor preprocess run o k superstep use processor thu stage make use total number superstep stage still olog n lemma minimum span tree weight undirect graph found olog n time use m n log n processor erew pram proof linearprocessor algorithm run dloglog ne stage stage found thread k dloglog ne stage k given comput b specic let thread x preprocess thread x actual comput part requir ox superstep preprocess prepar initi adjac list thread let f set tree induc b x is denit x forest g invok thread x execut phase onli comput set q adjac list denit list q length x repres tree f contain primari extern edg base less x contain sucient edg nding b x also f contain n x tree q contain total n edg list q sort respect edg weight use ox superstep n processor q copi local memori thread x one one x superstep use n processor x thread replac initi set adjac list q new set q i construct truncat list q includ smallest edg thread x readi run concurr comput b respect x thread use q i initi set adjac list follow origin phasebyphas schedul execut algorithm state section note algorithm thread versatil state everi thread start q i input thread comput edg set b xi instead found thread x x superstep note q i n edg processor requir thread n onli short stage k take ox superstep use mx n mn log n processor optim parallel mst algorithm recal dlog log ne stage altogeth run olog n time use processor input graph spars ie n log n rst construct contract graph g c g follow execut thread loglog n concurr nd log n induc log nforest b g then contract tree forest obtain contract graph g c n log n vertic contract take olog n time use processor lemma minimum span tree g c denot gc comput olog n time use m n log n log processor note gc b includ exactli edg g conclud follow theorem theorem minimum span tree undirect graph found olog n time use linear number processor erew pram r new connect msf algorithm shu faster determinist algorithm minimum span tree minimum span tree algorithm inverseackermann type complex find minimum span tree erew pram find connect compon olog n loglog n time erew pram parallel merg sort find minimum span forest logarithm time linear work use random sampl approxim exact parallel schedul applic list upper lower time bound parallel random access machin without simultan write fibonacci heap use improv network optim algorithm optim random parallel algorithm find connect compon graph sharedmemori model serv bridg model parallel comput proceedingsin proceed th acm symposium parallel algorithm architecturesproceed fast ecient parallel connect compon algorithm comput connect compon parallel comput connect compon olg parallel algorithm comput minimum span tree random sampl graph optim problem random lineartim algorithm nd minimum span tree fast connect compon algorithm erew pram parallel algorithm sharedmemori ma chine parallel ear decomposit search undirect connect olog n space find minimum span tree on random timework optim parallel algorithm find minimum span forest optim minimum span tree algo rithm random linear work erew pram algorithm find minimum span forest structur network algorithm bridg model parallel comput tr data structur network algorithm upper lower time bound parallel random access machin without simultan write effici algorithm find minimum span tree undirect direct graph fibonacci heap use improv network optim algorithm new connect msf algorithm shuffleexchang network pram parallel ear decomposit search ed italicstnumb graph parallel merg sort bridg model parallel comput parallel algorithm sharedmemori machin connect compon italicoitaliclgsupscrptsupscrptitalicvital parallel time crew pram extend abstract introduct parallel algorithm parallel algorithm comput minimum span tree fast connect compon algorithm erew pram random lineartim algorithm find minimum span tree effici fast parallelconnect compon algorithm random sampl graph optim problem find minimum span forest logarithm time linear work use random sampl sharedmemori model serv bridg model parallel comput isli myampersandsubeilisupsup find connect compon italicoitaliclog italicnital loglog italicnital time erew pram optim random erew pram algorithm find span forest basic graph connect problem minimum span tree algorithm inverseackermann type complex effici parallel algorithm graph problem comput connect compon parallel comput optim minimum span tree algorithm random linear work erew pram algorithm find minimum span forest random timework optim parallel algorithm find minimum span forest faster determinist algorithm minimum span tree find minimum span tree om alphamn time ctr tsansheng hsu simpler faster biconnect augment journal algorithm v n p octob stavro d nikolopoulo leonida palio parallel algorithm p toshihiro fujito takashi doi approxim nc algorithm connect vertex cover tree cover inform process letter v n p vladimir trifonov olog n log log n space algorithm undirect stconnect proceed thirtyseventh annual acm symposium theori comput may baltimor md usa david a bader guoj cong fast sharedmemori algorithm comput minimum span forest spars graph journal parallel distribut comput v n p novemb aaron windsor nc algorithm find maxim acycl set graph proceed sixteenth annual acm symposium parallel algorithm architectur june barcelona spain seth petti vijaya ramachandran optim minimum span tree algorithm journal acm jacm v n p januari