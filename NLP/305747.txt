t product help bit decis tree a investig two problem concern complex evalu function f k distinct input k parallel decisiontre algorithmsin product problem fix depth bound d seek maxim fraction input ktupl k decis tree correct assum singl input f best depthd decis tree correct fraction p input prove maximum fraction ktupl k depthd algorithm correct pk trivial lower bound show replac restrict depth expect depth d result need holdin helpbit problem decisiontre comput begin k arbitrari binari question helpbit queri ask ktupl input second stage possibl ktupl answer helpbit queri ktupl decis tree ith tree suppos correctli comput valu function ith input input consist help bit complex maximum depth tree algorithm show k suffici larg complex equal degsf minimum degre multivari polynomi whose sign equal f b introduct pick favorit comput model complex measur eg boolean circuit size commun complex decis tree depth interact proof length tensor rank etc attempt understand model complex measur requir understand way unreason comput effici reason one cours reason chang understand model improv suppos given sever unrel instanc problem solv reason approach solv instanc separ intuit comput use solv one instanc irrelev other extent intuit valid given model follow question common way formal thi directsum problem suppos complex comput function f c true comput f twice two unrel input requir complex c comput f k unrel input question first studi context boolean circuit ulig paul gf subsequ work concern bilinear circuit j bsh boolean circuit fkn commun complex krw paper consid two relat problem similar flavor product problem let f function suppos complex c comput fraction input correctli comput f p suppos two independ comput take input order pair a b input f first comput tri comput f a second tri comput f b two comput complex c fraction input pair a b correct exceed analog question k independ comput k input first comput use input second use input b p upper bound trivial intuit suggest advantag comput access other input variant problem seek comput f two input singl comput studi recent irw helpbit problem suppos complex comput boolean function f c suppos one wish comput f two input b allow free one helpbit ie arbitrari function two input possibl choos helpbit function that given helpbit f a f b comput comput complex less c so much comput f k input helpbit problem introduc to knowl edg context constant depth circuit cai also studi context boolean circuit abg point k input k help bit use obtain valu f input comput necessari instanc obtain valu f still need complex c comput f last input effect use help bit paper consid problem context boolean decis tree complex perhap simplest comput model cost comput decis tree simpli number input variabl read the depth decis tree precis definit given section easi exercis see directsum hold decis tree depth two problem difficult answer product problem qualifi ye theorem let f nvariabl boolean function suppos depth decis tree comput f correctli fraction p input let decis tree access set nk variabl correspond ktupl k input f depth d fraction ktupl k correctli output f a p k theorem seem complet obviou howev reader might test intuit follow variat suppos that theorem chang complex measur depth av erag depth ie averag input depth leaf reach input modifi statement theorem seem similarli obvi ou but see fals recent work irw done independ our includ substanti differ proof weaker variant theorem name singl depth tree tri comput k function correct p k fraction input result show even use k parallel decis tree cant better thi help bit problem answer com plicat nathan linial lin shown complex comput f two input one help bit least degf degre uniqu multilinear real polynomi equal f sinc almost boolean function nvariabl degf say help bit help function result seem extend k fact suffici larg k result impli fals manag prove lower bound hold k alway tight k number instanc solv suffici larg need follow definit f nvariat boolean function say nvariat real polynomi p signrepres f input a here take boolean set fgamma g signdegre f deg f minimum degre polynomi sign repres f theorem let f nvariat boolean function suppos optim decis tree comput f depth d k solut help bit problem f k input help bit requir depth least deg f furthermor suffici larg k decis tree algorithm bit whose depth deg f case f equal product n variabl which correspond pariti function f gvalu variabl deg f so lower bound impli helpbit help case actual function neg function deg f ordinari decis tree complex boolean function n mean larg enough k complex k instanc given bit less ordinari decis tree complex func tion particular f major function deg f lower bound vacuou upper bound say k suffici larg possibl ask question that given answer valu function one k input comput probe one vari abl remark save typic recent shown rr almost function satisfi next section review decis tree model section give gener formul product problem decis tree prove gener theorem theorem section discuss help bit problem prove theorem proof appendic techniqu develop appli decis tree model may appli model well fact suffic obtain mani known result boolean circuit model sketch applic last section preliminari section present basic definit notat notion discuss familiar case notat nonstandard boolean function purpos paper conveni use boolean domain instead f g x set boolean assign x map ff x b set boolean assign x denot b x refer element x variabl consid probabl distribut set assign specifi distribut d random assign chosen accord denot place identifi eg ff boolean function variabl set x rang r xrfunction function b x r paper rang r alway equal b k integ k decis tree tree paper root order binari tree tree everi intern node v exactli two children two children distinguish child child v depth dt v node v is usual number edg along path v root depth dt maximum depth node formal decis tree variabl set x rang r xrdecis tree tripl t root binari tree p map associ intern node v variabl set x map associ leaf v element v r label p v call queri associ v node v said probe variabl gener say xrdecis tree keep map p implicit set x rdecis tree x denot x r simpli let xrdecis tree ff assign b x comput ff uniqu path root leaf start root v induct defin defin v ffp v child v output comput label l ff thu view boolean function x rang r trivial everi xrfunction f comput xrdecis tree usual cost function comput perform ff length number intern node comput path denot ct ff worst case complex ct maximum ff ct ff cf decis tree depth f minimum ct decis tree comput f distribut assign distribut complex cd t averag ct ff respect distribut d given x r function f complex bound b with respect complex measur interest well f approxim tree complex b close approxim defin respect probabl distribut boolean assign x thu xrdecis tree agreement probabl q f f rel d probabl respect random assign ff chosen accord d decis tree approxim problem f du f x rfunction distribut boolean assign x u set decis tree determin q f u defin maximum agreement probabl q f particular interest case u set x r decis tree depth d final decis forest f x rang order sequenc xr decis tree f comput boolean function b x r theta r k product problem disjoint set vari abl let respect distribut assign assign fi x view ktupl assign x let denot distribut assign x given probd product distribut theta k suppos k decis tree approxim problem optim agreement probabl u f rel conveni sometim view f function entir variabl set x ignor variabl except consid problem simultan approxim decis forest simultan agreement probabl q f denot prob abil ff chosen accord d t famili x r tree q f denot maximum q f choic tree now sinc f depend x choos assign ff k depend would seem q f product probabl q clearli case tree queri variabl x howev as shown exampl below allow queri variabl outsid x need case intuit would seem variabl outsid x could help approxim f inde trivial true tri approxim f seek approxim function simultan longer obviou crossqueri irrelev nevertheless one might expect reason abl class u decis tree optim simultan agreement probabl attain sequenc tree queri variabl x thu equal product individu optim agreement probabl main result section prove case i u set tree fix depth theorem abov let k nonneg integ note theorem special case abov give proof present two exampl show multipl fail natur altern choic class u exampl theorem fail replac class class tree restrict queri variabl x along path queri variabl outsid x free consid follow trivial exampl let g distribut assign x probabl assign x probabl function f f given mean allow look variabl x allow look variabl ever achiev simultan agreement probabl better let tree queri x output x tree queri x output x then probabl f agre f agre probabl assign valu somewhat subtl exampl given by exampl distribut b x let class tree whose expect depth respect d ie averag number variabl queri respect ff chosen d theorem fals replac see thi let x set four vari abl f pariti function x let u uniform distribut assign x first show maximum agreement probabl f attain decis tree expect depth equal agreement probabl attain tree queri particular variabl x return otherwis queri remain three variabl return pariti them see best possibl note decis tree al gorithm leaf l depth less agre f exactli half input reach l thu p probabl random input ff end leaf depth i agreement probabl q f bound suffic show p expect depth tree least p mean let copi f u disjoint variabl set show possibl choos decis tree expect depth whose agreement probabl exce describ let x denot variabl x probe first let follow tree first probe x in output one read four variabl x output pariti expect depth tree sinc half path depth one half path depth five let us consid probabl event condit probabl given x x must agre f must agre f thu probabl simultan agreement happen exampl variabl x act share random coin partial coordin two comput like simultan correct proof theorem fix sequenc decis tree depth denot event event tree index evalu respect function cor rectli seek prove probck bound proof induct k fix k induct ktupl result vacuou assum k consid first case may assum k th parti must guess valu f k ff k without look variabl k consist singl leaf label now condit valu vector ff k probabl p ck hold written let fl assign ff k maxim probabl last express defin tree u contract use ff fl may rewrit last term probu f tree u depth may bound first factor induct hypothesi equal desir result follow assum i defin direct graph f kg edg first variabl probe input f j sinc direct graph outdegre one direct cycl let j length cycl let us renam set indic cycl set way first probe variabl denot x i first probe j variabl denot intuit behind rest proof possibl replac tree tree depth first probe decreas probabl simultan agreement denot function obtain f fix x distribut set obtain condit x event ff write probabl comput correctli condit b follow seek upper bound express by show claim b b j condit probabl ck given ab most assum claim moment substitut express obtain follow bound probabl tree correct sum rewritten as equal to now th term product correspond probabl correctli comput f first probe x then depend outcom use optim depth tree evalu residu function thu upper bound term express upper bound express requir suffic prove claim defin f ab function f b f otherwis similarli distribut ab equal b otherwis observ mutual independ given ab product distribut ab k let ab tree obtain contract assumpt ab hold condit probabl ab equal probabl with respect product distribut ab depth ab j may appli induct say probabl respect product distribut ab i ab most f ab f ab equal express claim prove claim theorem remark proof theorem extend gener model decis tree comput model case singl function given function f arbitrari domain r want comput f s unknown input s given set q admiss queri queri q q partit set s q r respons queri q index q node decis tree label queri branch node correspond answer queri collect function f disjoint domain formul product problem gener model statement proof theorem go assum allow queri depend variabl one function distribut independ help bit help bit problem k boolean function disjoint variabl set given unknown assign ff variabl set evalu f ff i decis forest allow ask for free arbitrari set l binari question assign ff answer l question vector b l decis forest f t k requir f ff agre assign ff consist a thu algorithm specifi l arbitrari boolean function h the help bit variabl set x togeth l decis forest complex algorithm maximum depth l k decis tree forest gener decis tree comput f ff ff consist allow probe variabl outsid x conceiv use togeth help bit probe could impli inform variabl x instanc one help bit function f ff theta ff j x x variabl x j probe variabl x deduc probe variabl x say pure l k decis tree pure algorithm pure paper restrict attent case that variabl set x boolean function f x x copi x function f copi f help bit problem h kl f evalu k copi f given l help bit complex optim algorithm solv it also defin problem pure f h kl f except requir algorithm pure defin c kl pure f complex optim pure algorithm goal obtain bound c kl f c kl pure f main result section which slight refin theorem is theorem boolean function f n variabl posit integ k pure f k suffici larg pure f first reformul problem h kl f pure f given function f decis forest f say f cover assign ff x respect f d minimum number forest consist tree depth d need cover input respect f let k pure f d correspond minimum restrict forest pure proposit let f boolean function k l nonneg integ then c kl f k f d l c kl pure f k pure f d l word dlog k f de minimum l h kl solv tree depth d pure f de minimum l h kl pure solv tree depth d proof prove first assert proof second complet analog c kl f l forest given algorithm also cover k f d l suppos k f d l collect l forest cover assign x index forest f z z rang b l order forest lexicographi calli defin az set assign cover f z cover f z set partit set assign x defin help bit function h l ff uniqu index z ff az function togeth solv h kl concentr obtain bound d k pure f d need yet anoth definit random xrdecis tree algorithm probabl distribut q xr decis tree algorithm said approxim f probabl p assign ff random decis tree chosen accord q probabl fff least p defin pf d maximum p distribut q set decis tree depth approxim f probabl p easi see pf d ordinari decis tree complex f pf d follow result relat f d pf d lemma boolean function f n variabl k havepf d k f d pure f d nk d k e proof middl inequ trivial last inequ use standard probabilist argument show famili k pfd e pure forest depth cover assign ment let q distribut y rdecis tree depth approxim f probabl pf d correspond distribut set x tree consid distribut theta q k forest suppos select forest accord p given assign ff j t probabl cover ff least pf d k thu probabl none forest cover ff gamma pf d probabl exist assign ff cover none forest nk e express posit probabl forest cover assign must collect forest depth cover assign turn lower bound f d thi need follow relationship pf d agreement probabl q f d respect particular distribut assign lemma y rboolean function f integ exist distribut assign q variant fundament observ yao y follow minmax theorem two person zero sum game distribut lemma suppos famili forest cover assign ff x consid distribut p assign ff product theta copi x then theorem forest f probabl cover ff pf d k expect number assign cover tpf d k sinc f cover assign expect must least pf d k immedi corollari lemma proposit get follow bound complex help bit problem corollari boolean function f n variabl integ k l l pf d k c kl f d l nkpfd k c kl pure f next need connect quantiti pf d signdegre deg f proposit boolean function f pf d proof let deg f nvariat polynomi degre gff f ff shift polynomi small constant may assum gff never may assum without loss gener sum absolut valu coeffici g consid follow random decis tree algorithm choos monomi g random probabl given monomi chosen absolut valu coeffici probe variabl monomi output product valu easili seen assign ff probabl correctli evalu f ff minu probabl incorrectli evalu fff equal jgffj here use domain fgamma g thu ff algorithm correctli evalu f ff probabl exceed suppos pf d must exist random decis tree algorithm q depth tree evalu f ff correctli probabl exceed now well known easi see by induct d look two subtre root decis tree depth variabl fx xng polynomi degre gt assign ff defin polynomialgx sum qt g gamma sum tree depth qt probabl select distribut q choic q latter term posit theorem follow easili proof theorem corollari would follow hold suffici larg k sinc pf deg f also corollari show c pure deg f suffic show k follow immedi fact proposit pf deg f remark interest note that k larg enough possibl construct obtain optim algorithm decis tree particularli simpl form random algorithm proof proposit use decis tree correspond comput monomi g use random algorithm proof upper bound lemma decis tree use help bit algorithm form remark note introduct f major function deg f decis tree use optim algorithm h larg k depth case f major function three variabl manuel blum gave follow construct protocol solv h enumer subset k size least k number set ck c fix encod set ck bit given k separ input majorityof function imagin input arrang k theta array row least two three entri agre major valu column least k entri agre function valu col umn help bit ask lowest index column requir bit set row column give function valu requir ck bit arm inform valu function row r equal entri row design column r neg entri otherwis remark proof lower bound lemma use theorem order deduc forest f depth d probabl respect particular distribut p assign f correct k function pf d k special case relev case prove c theorem altern argument sketch argument benefit extend model besid decis tree seen next section note abov pf d thu ff select the distribut lemma decis tree depth agre f probabl exactli particular shown impli fix valu variabl either partial assign occur probabl d valu f condit assign unbias now defin random variabl c want show probabl c fact distribut uniform f g k xor lemma vaz see also cghfr distribut f g k uniform subset j k random variabl c j defin xor c j probabl c j event c event j equal f j combin decis tree ft ji jg get singl decis tree depth jj jd comput j claim decis tree must agre f j probabl exactli enough finish argument prove claim show leaf tree j reach nonzero probabl f j ff condit ff reach leaf unbias leaf tree variabl x appear path recal valu f unbias condit valu variabl condit valu f j valu variabl x f still unbias therefor f j remark one implic theorem larg enough k best algorithm h use pure tree reason specul case h kl f k l open case interest note case hard show pure tree algorithm better cf ordinari decis tree complex f see thi note help bit partit set assign two group hard see either set assign x induc b x set assign induc must b x first case given pure tree comput f hard problem without help bit second case given pure tree comput f x hard problem without help bit model idea use far also relev model comput get result model similar neither precis strong obtain decis tree conveni describ result follow gener framework fix comput model comput function f input ff x class fea feasibl algorithm result hold class certain closur properti class fea close kcount k algorithm fea algorithm run k algorithm input accept reject base number comput k accept also fea exampl class polynomi size circuit close polycount polylogbit commun complex protocol close polylogcount class defin multiinput algorithm feasibl algorithm comput function f pair input ff said rectangularlyfeas fea everi fix valu ff induc algorithm f fea everi fix valu ff induc algorithm f fea notic two exampl mention and essenti model one may think of fea ae fea thu exampl case polys circuit lower bound given twoinput algorithm appli polys circuit well product product theorem set may proven use yao xorlemma y observ appli gener set let distribut lemma yao assum fea close kcount one deduc approxim product theorem theorem assum fea close k count proof fix algorithm fea denot py probabl correct input pnn probabl incorrect both py n probabl correct first input pni probabl correct second input sinc everi fix valu ff probabl correct f averag ff similarli final yao xorlemma impli omegagamma inequ togeth fact p yy p n directli impli omegagamma prove lemma help bit use approxim product theorem get helpbit result random algorithm given class feasibl algorithm fea say function randomli feasibl comput rfc exist probabl distribut algorithm fea input algorithm chosen distribut correct f probabl least constant import usual amplif lemma work gener case lemma fea close kcount constant replac or gammak without chang class rfc case fea class polynomi size circuit known random increas power thu rfc exactli equal function comput determinist poli size circuit case fea polylog bit commun protocol rfc function comput random polylogbit protocol twosid error let us defin feasibl comput helpbit let fea given class algorithm helpbitfeas algorithm fea set two algorithm fea boolean function h whose valu input ff output hff function rfc fea algorithm comput two copi f everi pair input correct probabl least prove random help bit theorem theorem fea close o count rfc proof assum f rfc then amplifi similarli lemma exist distribut q f fea use approxim product theorem fea algorithm two copi f correct o fraction input under distribut theta d follow fea algorithm correct probabl twice that probabl smaller again probabl taken pair input chosen theta d turn impli f rfc case boolean circuit proven abg log k barrier approxim product theorem ran domiz helpbit theorem natur gener log k function famili fea close kcount that techniqu break down unknown exampl whether polynomi size circuit use n helpbit comput n copi function polynomi size circuit one show black box model altern rel particular oracl gener fals use log consid model polynomials circuit access blackbox theorem blackbox exist boolean function f cant comput polynomials circuit famili helpbit allow polynomials circuit alway comput answer n disjoint copi f n input size f proof well know random f cant comput polynomials circuit fix f success circuit would take input output vector v blackbox way circuit without helpbit cant find it circuit helpbit goe directli it let n size x choos n input tupl output v follow let random lnbit string place v locat index place sorri locat t standard count argument one show polynomi size circuit famili with access black box answer correctli ntupl input howev given l helpbit easi queri oracl locat reveal answer tupl interest note yao xor lemma fail rel blackbox sens xor ln variabl pariti stop get harder comput word xor lemma log n barrier abov acknowledg author mani convers sever peopl regard re search would especi like acknowledg contribut richard beigel nati linial russel impagliazzo avi wigderson r connect bound queri class nonuniform complex extend direct sum conjectur lower bound constant depth circuit presenc help bit bit extract problem tresili function amort commun complex complex output boolean network advanc comput complex theori fraction cover commun com plexiti prove superlogarithm depth lower bound via direct sum commun complex direct product theorem round commun complex revisit realiz boolean function disjoint set variabl synthesi selfcorrect scheme function element small number reliabl compon theori applic trapdoor function probabilist comput toward unifi measur complex tr ctr ronen shaltiel toward prove strong direct product theorem comput complex v n p juli paul beam toniann pitassi nathan segerlind avi wigderson strong direct product theorem corrupt multiparti commun complex disjoint comput complex v n p decemb anna gl peter bro miltersen cell probe complex succinct data structur theoret comput scienc v n p june