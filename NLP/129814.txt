t lingua franca concurr logic program a two import concurr logic program languag nonflat guard ghc parlog balanc requir clean semant provid good control facil rather differ respect merit compar contrast sinc concurr logic program would benefit both neither languag abl express program express languag lingua franca languag defin justifi method given translat ghc parlog it method preserv ariti execut condit claus enabl lingua franca implement support languag transpar provid simpl concurr logic program languag suitabl program right b introduct among concurr logic program clp languag like concurr prolog two promin ghc parlog ghc parlog similar execut model complementari virtu argu henc could desir find common denomin languag suffici express worth program right yet suffici close languag inter translat them implement languag would support program ghc parlog well common denomin style lingua franca simpler implement either ghc parlog benefit streamlin implement could realis well paper describ lingua franca ghc parlog ghc parlog program set relat r r n r made guard horn claus name ariti edinburgh prolog syntax h g g atom formula unitari prolog goal claus follow form h g g b b n claus head h give relat name ariti g b j guard bodi goal separ commit oper metasymbol signifi conjunct oper primit true alway succe fill empti guard bodi claus declar read h true g g b b n true place filler ghc parallel conjunct oper parlog either parallel sequenti conjunct oper one claus form order relat c n c guard horn claus metasymbol act place filler claus search oper symbol termin relat ghc stand parallel search oper wherea parlog stand either parallel sequenti claus search oper oper right associ bind tightli allow nest parlog parlog claus relat r ariti n preced singl mode declar mode rm n r claus head princip functor either input argument symbol output argument symbol head argument parlog claus relat classifi input output declar ghc claus head argument alway input argument oper semant ghc redescrib way correspond parlog come out point view execut ghc parlog program refut conjunct goal g g n resolv n input resolut ignor moment parlog sequenti oper claus search goal conjunct goal g solv parallel either primit satisfi remov resolv user defin goal follow goal match input argument claus head relat determin parallel whether relev goal argument unifi input argument head fresh copi claus without bind goal variabl share other algorithm explicit input match use primit given later claus may satisfi head match requir goal instanti further suspend upon relev goal variabl input head argument unifi correspond goal argument variabl upon suspend bound parallel head match guard goal claus solv parallel one claus head match requir guard goal relat satisfi one select nondeterminist parallel claus search termin goal reduc goal select claus bodi replac resolv guard goal head match fail claus goal relat goal fail resolut succe goal solv resolv empti fail goal resolv obtain origin goal fail parlog execut subject follow special condit output unif head argument ________________________________________________ author depart comput scienc heriotwatt univers edinburgh scotland ghc actual defin without assum finit failur effect implement make assum finit failur practic necess chapter especi section p sequenti claus search sequenti goal conjunct reduct output argument parlog claus head specifi mode declar unifi correspond goal argument parallel bodi goal evalu parlog claus sequenti search restrict claus goal initi guard goal satisfact head match claus next unencount sequenti claus search oper order left right guard goal head match fail claus head guard claus next unencount claus search oper evalu parlog goal conjoin sequenti oper goal conjunct left hand side oper satisfi satisfact attempt right hand side goal conjunct ghc execut subject follow special condit synchronis rule sequenc rule synchronis rule state tri bind call argument variabl passiv part head guard prior commit caus unif suspend guarante safeti guard evalu name guard whose claus figur reduct goal instanti goal sequenc rule state claus bodi may execut commit long attempt bind passiv part variabl prior commit caus unif suspend simpli satisfi delay execut bodi goal commit ghc parlog distinct among clp languag perform guard evalu singl bind environ avoid big runtim overhead face clp languag concurr prolog support multipl bind environ flatten clp languag ban user defin goal claus guard overcom problem sacrif signific express power lingua franca ghc parlog follow lingua franca ghc parlog characteris justifi main featur parlog ghc claus express lingua franca claus satisfact condit lingua franca common languag variat ghc parlog similar syntax semant like ghc parlog lingua franca program set relat r r n relat r compos guard horn claus h g g b b n metasymbol signifi parallel conjunct oper n like ghc lingua franca sequenti conjunct oper claus c form order relat c n relat c guard horn claus termin relat like parlog act metasymbol place filler either sequenti parallel claus search oper lingua franca relat modeless ghc fashion claus head argument occur input match role lingua franca goal execut andparallel input resolut common way describ earlier ghc parlog except sequenti claus search oper constrain orparallel execut parlog style full metainterpret lingua franca given later lingua franca oper semant differ ghc allow sequenti search parlog disallow sequenti conjunct differ sequenc head match guard evalu instead requir compil time analysi guard ensur guard safeti like parlog requir runtim safeti test like ghc lingua franca impos mandatori requir safeti howev suppli languag primit support runtim safeti test anywher safe guard evalu must guarante shall see standard ghc parlog primit support lingua franca well three new primit satisfi ward need translat ghc parlog lingua franca point develop lingua franca made review factor respons differ ghc parlog control emphasi parlog thematis control logic program full construct allow programm synchronis sequenc execut part logic program parlog support sequenti parallel oper claus search goal conjunct thu follow claus process recurs process list queryrespons messageq r element mode process process processmessage_ rb true second claus guard test whether queri part q valid goal is executeq r unifi r respons otherwis messag queri ignor repli given sequenti conjunct oper second third claus bodi ensur element execut process continu next element second claus sequenti search oper ensur failur valid_queri guard test allow third claus tri type sequenti oper enhanc control featur parlog use sequenc call inputoutput primit help control extent comput demand driven control granular parallel howev sequenti oper weaken complementar parlog oper declar semant need parlog statu logic program languag declar read parlog orsequenti oper signifi negat prior claus guard subsequ claus guard cannot soundli realis oper implement negat mere failur prior guard without impos extra restrict determin compil time analysi p restrict rais problem precis identifi unsaf guard discuss later furthermor sequenti parlog andsequenti oper affect termin properti parlog program contribut declar mean swap sequenti parallel conjunct oper deadlock parlog goal use succeed thu unbound goal valida truth succe relat mode valid validtruth wherea sequenti variant truth suspend ever although oper swap chang declar mean queri make queri longer satisfi lack emphasi clean semant properti parlog allow defin certain kind parlog program could written unsaf guard could validli execut unsaf guard sabotag success reduct goal relev claus enabl irrelev guard evalu whose claus figur reduct goal bind call argument mode choic choicea life waya true choiceb faith true mode way godless make call choicex y faith program abov make follow thing possibl x first top level goal share first argument first claus choic x first claus guard bound godless satisfact wayx second top level goal bound faith first top level goal head match first claus fail first top level goal match second claus head succe instanti b godless happen top level goal reduc bodi second claus choic fail thu examin subsequ reject claus result unsaf guard goal wayx bind x godless interf top level goal abl succeed second claus order tri rectifi kind difficulti gregori introduc compil time safeti check tri weed unsaf guard claus parlog program unfortun analys safeti parlog program compil time undecid matter gener p thu algorithm exist select claus parlog program whose guard unsaf control emphasi parlog also allow parlog use primit like var time call semant p thu conjunct goal call unbound succe fail depend upon whether first primit execut second like unsaf guard time call behaviour make harder prove correct properti program whether goal succe fail depend upon mean goal upon nondeterminist properti implement time call properti confin primit like var appli even key parlog primit like two argument metacal call primit alway succe initi attempt satisfi first argument unifi second argument constant express result howev satisfi goal transform new conjunct obtain whose success failur depend time execut conjunct preserv execut condit transform program claus replac occurr term guardbodi fresh variabl x conjoin goal parallel rest guardbodi call antisubstitut clearli parlog claus contain call lack properti thu parlog semant drawback sequenti affect goal termin declar mean unsaf guard cannot precis identifi prevent caus invalid execut realis declar mean negat failur also rais safeti identif problem primit time call semant make comput outcom nondeterminist drawback exist addit basic drawback clp languag preclud complet search embrac care nondetermin commit choic mechan howev extra semant defici bought signific price enhanc control parlog featur make apt system program argu semant emphasi ghc approach clp languag design opposit point view parlog thematis semant rather control issu clp languag program sequenti conjunct search oper exclud languag remov execut order constraint mar declar read guard claus termin properti program rule synchronis introduc ensur guard guarante safe primit like var metacal exclud eschew time call effect allow ghc claus possess antisubstitut lastli localis gener output bind unif primit becom simpler reason flow bind ghc execut measur produc simpl power languag open applic variou transform techniqu amen formal analysi howev emphasi ghc clariti simplic semant weaken abil use gener purpos program tool exclud primit like var ghc cannot use condit whether variabl current unbound decid whether commit claus not although delay commit variabl bound preclud ghc defin unif within itself also preclud abl defin wide rang relat unif function within itself abil program variat unif crucial logic program languag abil program metainterpret languag languag flavour differ itself experi prolog demonstr prolog abil support wide varieti metainterpret relat languag top major part reason success lose access metaprogram unif ghc hamstrung capac mirror prolog wide metaprogram capabl system program clp languag requir abil handl failur except runtim error subcomput modular fashion localis effect also requir abil control interact task suspend resum abort them metainterpret flavour extra control featur need thi either explicitli program implement control metacal oper system also need dynam programm control schedul resourc alloc subcomput sophist control metacal achiev howev ghc refus support parlog metacal refus support primit need program unif ghc limit abil support flavour metainterpret result impoverish system program capabl ghc eschew sequenti search oper make program ghc difficult exampl lack sequenti search oper make difficult control grain orparallel make harder control order claus examin furthermor claus choic userdefin condit test hold hold conveni express sequenti search goalin out testin processin out goalin out true transformin out use negat failur not p goalin out testin processin out goalin out nottestin transformin out avoid condit testin evalu twice hold wellknown clp languag like fcp parlog cp pprolog support sequenti search form ghc lack sequenti conjunct oper ghc program limit abl use short circuit techniqu test set goal satisfi use techniqu conjunct alphaa d betaa b gammac d transform give goal two extra argument chain alphaa d x x betaa b x x gammac d x x goal succe unifi last two argument test joint termin done bind one end x constant done wait chain end x bound done ghc goal execut andparallel ghc program cannot use parlog simpl expedi sequenc execut goal unif local chain end mode alpha ________________________________________________ design klb basic machin languag icot parallel infer machin alreadi influenc consider klb base upon flat ghc extend pragma metacal price loss ghc nice semant properti neither ghc gener use sequenc rule alphaa d x x alphaa d achiev effect first goal sequenc cannot violat safeti guard alpha second argument accept input tri instanti goal would suspend attempt bind use short circuit fulli gener way ghc program must extend test termin primit call liabl bind variabl relev program unif bodi ghc claus defin alpha mean replac goal unifya b x x defin follow p unifya b x x true local part short circuit close match detect unif done plainli overhead transform mark gulf express ghc parlog paper show choic made clp languag clean semant like ghc one good system program capabl like parlog possibl benefit respect virtu languag singl implement rewrit lingua franca emul languag directli common linguist denomin lingua franca ghc parlog must abstract differ yet enabl languag translat lingua franca back again express either neither ghc parlog express enough translat away languag claus parlog cannot support ghc runtim suspens test ghc disallow action mani parlog primit besid restrict primit ghc four main featur distinguish parlog mode declar pure parallel search conjunct oper claus bodi execut commit long tri instanti bodi variabl share head guard caus unif suspend commit attempt guard goal write upon call argument variabl commit suspend mode declar ghc input match head argument explicitli repres output bind unif bodi claus parlog easili transform obey rule p output mode parlog head argument remov replac fresh variabl extra unif goal origin head argument ad claus bodi chang parlog head argument treat input argument mode declar dispens with way lingua franca translat away mode declar parlog relat without support itself passiv part concurr ghc parlog allow head match proceed parallel guard evalu lingua franca would made simpler requir instead head match complet guard evalu begin would elimin implement overhead provid safe storag variabl share head argument user defin guard goal access execut guard goal relev bind variabl suppli goal head match would also enabl index test head match use sole mean determin earli whether claus suitabl reduc goal would avoid earli evalu guard claus whose head yet match goal detect whether guard fail claus guard empti signifi true transform need translat ghc parlog lingua franca compens lingua franca sequenc head match guard evalu furthermor guard goal fail head match succe transform necessari either howev case head match perform parallel guard evalu otherwis suspens head match could delay indefinit discoveri guard goal execut fail thu guard nonempti known guard fail head match succe head match decompos extra one way unif guard fashion translat parlog kernel parlog p variant gregori method use differ oneway unif primit tri unifi argument suspend relev left hand argument variabl success unif would bind one share two them whole head match realis form aggreg term head argument occur uniqu variabl head oneway unifi similar aggreg distinct variabl replac thu guard claus compareab cd testa c compareb d translat compare f e f ab cd testa c compareb d new claus head distinct fresh variabl argument approach give simpler represent head match separ goal creat match head argument repeat variabl gregori method howev multiprocess implement may want implement use sever simpl match goal gregori fashion avoid creat content exclus access variabl tie variabl togeth one primit process sequenti algorithm given figur specifi behaviour requir oneway unif oper algorithm return success failur suspend execut execut time process run return success failur return suspend process suspend least left hand side variabl detect bound unifi procedur earli detect failur requir suspend variabl well awoken made runnabl variabl get bound list repres two argument structur handl separ whole algorithm execut atom faster algorithm would circumv use full unif test nonunifi determin variabl suspend order avoid obtain exclus access left hand variabl execut sequenti oper unlik ghc parlog support andsequenti oper howev synchronis satisfact parlog goal achiev indirectli sequenti conjoin goal remov parlog claus use metacal synchronis flag link metacal p absenc andsequenti oper ghc possibl elimin sequenti conjunct oper parlog way establish anoth common featur ghc parlog copi lingua franca need support andparallel conjunct andsequenti oper elimin transform away parlog sourc would help lingua franca program extract andparallel applic ghclike program style make program less prone sequenti style prolog program dog mani parlog program rather use gregori method employ parlog three argument control metacal simpler two argument metacal satisfi introduc instead attempt satisfi first argument succe bind second argument simpl term succe itself attempt satisfact fail fail differ parlog metacal call never fail although metacal satisfi defin use call howev violat antisubstitut unlik call seen earlier introduc new primit ground suspend argument ground satisfi use defin auxiliari relat wait follow waitgoal control flag groundcontrol satisfygo flag wait suspend second argument ground execut first argument goal fail goal fail succe signal fact bind third argument constant wait provid simpl mean realis sequenti execut control execut order andparallel goal synchronis flag thu mix conjunct translat follow aa b waitonea d waittwob e waitthreeab d e _ control variabl e delay execut threeab onea twob satisfi gener form method translat away sequenti conjunct appli prolog syntax structur contain reserv predic wait pure prolog program given figur queri pgoal new_goal _ parallel goal conjunct parlog goal unifi new_goal lingua franca translat orsequenti search ghc support orparallel claus search although option allow sequenti search mean otherwis predic consid ghc design one stage hand parlog allow claus search parallel sequenc gregori shown possibl elimin orsequenti claus search use three argument parlog metacal p howev use gregori rather complex method would mean abandon principl repres parlog ghc claus lingua franca claus translat relat name ariti fortun unnecessari sequenti search easi support directli clp implement rule sequenc option execut bodi ghc claus commit subject ghc rule sequenc may seem appropri highli parallel dataflow architectur like result lot redund comput less parallel architectur expens could profit execut furthermor allow prematur comput almost ghc program guarante termin without import extra fair assumpt p avoid semant difficulti keep extant implement ghc special suspens mechan propos support ghc rule sequenc lingua franca rule obey parlog strict sequenc evalu obey lingua franca claus commit evalu bodi commenc rule synchronis ghc rule synchronis preserv guard safeti requir unif would bind share call argument variabl ancestor guard unif suspend thu claus ye call aska suspend unif ye suspend order instanti call argument variabl ancestor guard two main approach canvass implement guard suspens test ueda pointer colour scheme miyazaki guard number scheme scheme concentr upon suspend unif bodi ghc claus use evalu guard goal event unif attempt write upon call argument variabl either scheme threaten impos suspens test overhead upon everi explicit unif howev ghc claus either match input head argument primit input argument guard evalu remain case necessari test user defin primit guard goal output argument write upon call argument variabl demand driven scheme could separ suspens produc condit ghc claus order localis requir suspend evalu extra primit goal respons guard would impos gener overhead upon unif bodi allow unsaf userdefin guard goal evalu without suspens constraint output bind evalu made eager comput space effect recycl comput space use repres guard goal process process tree claim releas soon guard goal satisfi fail claim frozen unus pend commun input valu remov suspens goal process suspend unsaf bind deep guard evalu frozen space may includ space claim store ancestor process suspend upon suspend userdefin guard process well claim store process perform suspend unif localis central idea behind localis suspens effect due rule synchronis aris happen guard evalu restrict locu evalu follow variabl term unsaf occur head ghc claus either user defin guard goal argument posit primit guard goal liabl bind given valu unsaf variabl guard goal replac fresh variabl transform call guard goal allow proceed without subject safeti suspens condit safeti suspens condit achiev new primit relink unsaf guard variabl new replac way ghc program distil lingua franca claus interleav special primit achiev safe guard suspens mechan special primit job allow old variabl valu pass new replac ensur unifi new old guard variabl would bind call argument variabl commit special primit suspend exampl take ghc claus remov head match manner alreadi describ replac fresh variabl userdefin guard test special primit ward ad link two variabl way protect call environ bound suspend call instead result is ward need abl suspend sever variabl must handl complex term complex term get progress bound also need abl suspend awak pass valu mayb suspend again properti ward infer fact guard goal test might need argument bound valu succeed satisfact guard achiev ward goal pass bind second argument first howev ward goal allow user defin guard goal export valu satisfact ward simpli unifi a unidirect unif apt howev ward equat second goal guard succeed case not call argument b bound might get bound _ first input match unidirect unif succeed share _ sinc still unbound second guard safeti unidirect unif succeed share them shortli afterward parallel test call might bind variabl incorrect result could instanti call argument variabl _ incorrect claus commit behaviour cannot avoid insist second goal unidirect unif perform test goal succeed bind could never pass ward user defin guard goal better idea make ward predic reluct unidirect unif ward predic suspend if order unifi unidirect argument share variabl reluct unidirect unif unidirect unif bind made instanti side whenev nonvari bind detect noninstanti side unidirect unif possibl fail two side never unifi instanti side variabl need associ complex noninstanti side term contain variabl bound consist copi complex term avoid variabl share unidirect unif reluct variabl instanti side get bound nonvari other never get share variabl noninstanti side predic suspend instead problem test sever guard goal need partial bound unbound argument order succeed ward predic must suspend ever exampl guard goal defin follow true true result reluct unidirect unif would ward predic suspend two variabl argument even userdefin guard test succeed ward predic suspend two unbound argument long guard goal ward succeed implement thi variabl bind use signal success userdefin guard goal signal sent ward predic extra argument predic defin get signal abandon reluct oneway unif tri relink origin variabl replac nonreluctantli unidirect ensur bind gener evalu guard goal pass call environ caus primit suspend attempt put consider togeth give follow origin claus get transform into first guard goal implement head match next two implement origin guard goal set ghc suspens test userdefin guard goal succe call argument variabl replac link reluct unidirect unif allow share variabl ward first two argument guard goal succe c bound metacal satisfi signal ward unidirect unifi first two argument allow share variabl them algorithm ward first two argument unifi opposit order given gener localis suspens transfer translat scheme gener scheme requir take account multipl occurr unsaf variabl one guard goal simpl sound way place entir origin guard satisfi metacal part guard contain origin head argument variabl aggreg term unsaf variabl consist copi also form substitut fresh variabl unsaf variabl two term relat ward gener rule implement guard safeti suspens ghc appli guard goal contain userdefin predic primit liabl bind argument variabl head argument userdefin guard goal primit goal argument primit goal may bind form risk set distinct fresh substitut variabl set creat risk set empti noth done everi member risk set guard goal uniformli replac substitut whole ghc guard put first argument satisfi metacal fresh variabl call control variabl put second argument structur arbitrari functor argument consist member risk set variabl form copi structur made substitut variabl replac risk variabl ward predic goal ad guard structur structur copi control variabl satisfi first three argument head match decompos guard fashion describ earlier although ward use compil ghc lingua franca cannot use satisfi compil ghc flat ghc metacal violat antisubstitut unlik parlog metacal call primit ward doe unbound variabl goal wardcd aa ye suspend wherea antisubstitut may succeed henc ward cannot made ghc primit appli exampl translat exampl show result appli transform ghc follow ghc claus processab c ad checkab e testad e processb c d translat lingua franca claus processj c k j k ab ad e testfh e i processb c d first guard goal implement head match second implement safe guard suspens test three relev variabl third satisfi origin guard two extra primit goal metacal requir implement localis runtim suspens test head match differ exampl show transform parlog claus mode test e testb c d follow lingua franca claus waitchecka j waittestc j k waitanalysea l waitsynthesiseb f m waittransformb f l m n waitunfoldc e l m o waittestb c d l m n o p translat back lingua franca revers translat translat ghc simpl gener method presuppos occurr predic ward satisfi sole product origin correct translat satisfi predic replac first argument first two argument ward unifi goal remov two argument unifi goal remov guard left empti space fill primit true simplic revers translat method be done translat ghc lingua franca decompos unif way appropri suspens effect unif direction associ them clearli reunifi restor statu quo revers translat lingua franca parlog perform three step first head match restor unifi two argument remov goal sequenti conjunct put back final output head argument restor gener algorithm sequenti conjunct replac given execut queri qgoal new_goal _ _ _ pure prolog program given figur goal bound lingua franca conjunct goal new_goal unifi origin parlog conjunct output head argument restor unifi argument predic bodi creat origin translat remov them uniqu identifi give reserv name origin translat mode declar cannot alway correctli infer initi translat lingua franca preserv independ lingua franca semant metainterpret full lingua franca invok callgoal given figur call first claus handl conjunct second claus evalu primit recognis suspend primit primit third claus handl commit choic resolut frozen claus retriev second list argument claus defin first argument relat oper join adjac claus claus select test reduc first claus reduc examin whether lead claus reduc goal second claus search next claus parallel third claus examin last claus group claus search parallel sequenti search oper ensur fourth claus consid first three consid reject continu claus search previou reduc claus shown unabl reduc goal test ensur head match perform guard call match use primit melt obtain fresh melt copi frozen claus input match goal it instead impos inadequ select guard safeti criterion valid program like parlog requir mandatori runtim safeti test evalu everi claus guard like ghc lingua franca suppli precis mean support runtim safeti test anywher safe guard evalu must guarante test use augment compil time safeti analysi p thu unsaf guard reduc made safe replac test ward goal act valv prevent execut g metacal satisfi export bind g henc goal call environ lingua franca simplifi clp languag semant make safeti clp claus guard constraint must satisfi execut clp languag validli guarante guard safeti enabl provid mean let precis test safeti appli anywher need languag semant make option appli it test realis claus use method translat describ earlier exercis gener program unsaf guard use safe guard metainterpret describ abov lingua franca exce ghc parlog express power abl translat ghc parlog claus lingua franca claus oper semant ghc parlog unabl lingua franca claus furthermor abl translat clp languag lingua franca back lingua franca implement present transpar ghc parlog lingua franca implement program style lingua franca hybrid ghc parlog lingua franca follow ghc eschew provis andsequenti oper modeless steer programm away laps sequenti prologlik style reli mislead assur given mode declar lingua franca follow parlog provid rich set control construct disallow use time call primit thu provid clp vehicl right rather like parlog program system with uncoupl evalu user defin guard suspens mechan use ward localis suspens effect unsaf guard lingua franca make execut guard goal eager effect recycl comput space ghc comput space use repres user defin guard goal process claim releas soon guard goal satisfi fail claim frozen unus pend commun input valu remov suspens goal process suspend unsaf bind lingua franca requir head match concurr guard evalu incur less runtim overhead respect ghc parlog elimin need provid safe storag variabl share head argument user defin guard goal access guard goal execut relev variabl bind suppli head match also expedit use index claus select avoid earli evalu guard claus whose head yet match goal detect whether guard fail kernel parlog view intermedi languag compil parlog lingua franca play role similar kernel parlog p howev sever import differ unlik kernel parlog lingua franca made express enough use program vehicl first instanc like parlog ghc thu preserv full head match function rather translat away fashion kernel parlog furthermor kernel parlog support primit like ward would enabl translat away ghc runtim suspens test kernel parlog execut obey runtim suspens test implement independ support it ward complex action cannot perform kernel parlog simpl input match primit would requir ensur atom execut sever togeth howev kernel parlog lack mean thi part method describ translat away ghc runtim suspens test complex seri simpl match perform parallel context translat full ghc clp languag cp howev translat exploit multipl environ properti clp languag atom oper requir kind possibl kernel parlog cannot follow cp thi ward suitabl treat kernel parlog primit design philosophi underli choic kernel parlog primit aim ensur process intend andor tree implement model pp never requir suspend variabl onc howev ward abl thi conclus strategi absorb differ two promin clp languag assimil common languag variant propos meet differ demand clp languag support common medium strategi detail translat ghc parlog lingua franca back implement lingua franca transpar present user either execut ghc parlog directli support languag lingua franca provid user semant desir properti ghc control featur parlog simpl program style singl implement accord requir acknowledg would like thank steve gregori paper review mani detail help comment well colleagu heriotwatt univers member imperi colleg parlog group r implement commit choic languag share memori multiprocessor logic oper system design issu flat parlog basi comparison parlog system program languag partial evalu ghc program base upon urset constraint parallel logic program parlog languag implement abstract machin implement parlog uniprocessor a distribut implement flat ghc multipsi a preliminari note semant guard horn claus an abstract kl machin instruct set the dataflowbas parallel infer machin support two basic languag kl a ghc abstract machin instruct set translat safe ghc safe concurr prolog fcp ghc oper semant problem relationship cp a subset concurr prolog interpret the famili concurr logic program languag metainterpret expert system construct localis ghc suspens test on oper semant guard horn claus guard horn claus tr parallel logic program parlog languag implement metainterpret expert system construct abstract machin implement parlog uniprocessor famili concurr logic program languag ghc abstract machin instruct set implement commit choic logic languag share memori multiprocessor