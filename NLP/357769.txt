t optim hardwarealgorithm sort use fixeds parallel sort devic a abstractw present hardwarealgorithm sort n element use either psorter sort network fix io size p strictli enforc conflictfre memori access best knowledg first realist design achiev optim time perform run theta fracn log np log p time rang n result complet resolv problem design implement timeoptim algorithm sort n element use psorter importantli howev result show that order achiev optim time perform need sort network depth olog p as exampl batcher classic biton sort network b introduct recent advanc vlsi made possibl implement algorithmstructur chip build block highperform comput system sinc sort one fundament comput problem make sens endow generalpurpos comput system specialpurpos parallel sort devic invok whenev servic need articl address problem sort n element use sort devic io size p n arbitrari p fix sort devic use either psorter sort network fix io size p assum input well partial result resid sever constantport memori modul addit achiev timeoptim crucial sort without memori access conflict reallif applic number n element sort much larger fix size p sort devic accommod situat sort devic must use repeatedli order sort input follow natur question aris how one schedul memori access call sort devic order achiev best possibl sort perform clearli question find appropri answer power sort devic fulli util psorter sort devic capabl sort p element constant time comput model p sorter exist exampl known p element sort o time p theta p reconfigur work support onr grant n nsf grant ccr ec louisiana grant leqsfrda depart comput scienc old dominion univers norfolk va usa z istituto di elaborazion dellinformazion cnr pisa itali x depart comput scienc univers texa dalla richardson richardson mesh beigel gill show task sort n element n p n log n log p call psorter present algorithm achiev bound howev algorithm assum p input psorter fetch unit time irrespect locat memori sinc gener address pattern operand psorter oper irregular appear algorithm cannot realist achiev time complex theta n log n log p unless one solv constant time address problem inher access p input psorter scatter output back memori spite thi result pose interest open problem name design implement theta n log n log p time sort algorithm use psorter consid algorithm sort n element use psorter ofn p time clear algorithm also sort n element use sort network io size p ofn p time main reason task sort p element use network requir odt proport depth dt maximum number node path input output network thu psorter oper replac naiv individu applic time requir sort becom odt delta fn p elimin odt slowdown factor network must use pipelin fashion turn pipelin requir suffici parallel psorter oper identifi exploit recent olariu pinotti zheng introduc simpl restrict design row merg model show model n element sort theta log n time use either psorter sort network io size p achiev better sort perform new algorithmstructur architectur must design involv devis sort algorithm suitabl hardwar implement and time architectur algorithm execut directli algorithmarchitectur combin commonli refer hardwarealgorithm major contribut articl present first realist hardwarealgorithm design sort arbitrari number input element use fixeds sort devic optim time strictli enforc conflictfre memori access introduc parallel sort architectur special design implement care design algorithm compon architectur includ parallel sort devic set randomaccess memori modul set convent regist control unit architectur simpl feasibl vlsi realiz show architectur model n element sort theta n log n log p time use either psorter sort network fix io size p depth olog p conjunct theoret work result complet resolv problem design implement time optim algorithm sort n element use psorter importantli howev result show order achiev optim sort perform psorter realli necessari need sort network depth olog p as exampl batcher classic biton sort network see it exceedingli import sinc known implement psorter requir power process element wherea batcher biton sort network use simpl compar architectur assumpt section describ architectur framework within specifi optim sort algorithm use fixeds sort devic consid sequenti sort algorithm adequ case consequ on assum assumpt impli address purpos need least log p bit reader conveni figur depict design keep figur simpl control signal line shown basic architectur assumpt sort model includ r r r r r r r r r memori modul ar ar ar ar ar ar ar ar ar sort devic control unit figur propos architectur i data memori organ p independ constantport memori modul word assum length w bit w log p assum n input element distribut evenli arbitrarili among p memori modul word address memori modul refer memori row memori modul randomli address address regist ar associ adder regist ar load word read memori modul row address broadcast cu see below ii set data regist r p capabl store w refer word store regist r compos word sinc consist three field ffl element field w bit store element ffl long auxiliari field log p bit ffl short auxiliari field log p bit remaind articl logarithm assum base field arrang element field left long auxiliari field left short auxiliari field field regist r load independ memori modul ith output sort devic broadcast cu output regist r connect ith input sort devic cu memori modul assum that ffl constant time p element data regist load address regist store p modul address address regist ffl bit field regist r p setreset s constant time ffl field data regist r p compar particular valu individu field set special valu depend outcom comparison moreov parallel compareandset oper take constant time iii sort devic fix io size p form psorter sort network depth olog p assum sort devic provid data path width w log p bit input output sort devic use sort compos word combin element auxiliari field case sort network use sort devic assum sort network oper pipelin fashion iv control unit cu short consist control processor capabl perform simpl arithmet logic oper control memori use store control program well control data cu gener control signal sort devic regist memori access cu broadcast address element memori modul andor data regist read element data regist assum oper take constant time describ minimum hardwar requir architectur model case sort network use sort devic one use halfpipelin scheme input network provid group row next group suppli output previou group obtain depth sort network sort network oper full capac one may add addit set address resp data regist one set address resp data regist use read oper order set use write oper oper perform concurr let us estim vlsi area design use hardwar data memori sort devic cu word model ie assum word length w constant exclud area taken cu highperform comput system one processor assign task control parallel sort subsystem clearli extra area use address data regist amount op exceed vlsi area implement psorter sort network io size p includ vlsi area run data memori address bu width log n bit control signal line data memori sort devic sinc need architectur involv data memori sort devic point architectur p memori modul involv total n p word control circuitri requir least omegagamma flog p log n area sinc oper perform control processor simpl assum take constant area length control memori word least log n length data memori address becom appar algorithm requir o n data memori consequ control memori word length olog n control program simpl take constant memori howev o n use control inform store data memori extend columnsort algorithm section present extens well known columnsort algorithm extend column algorithm implement architectur model invok repeatedli sort larg number element two known version columnsort one involv eight step seven provid extens step columnsort step version map well architectur columnsort design sort columnmajor order matrix r row column classic columnsort contain step oddnumb step involv sort column matrix independ evennumb step permut element matrix variou way permut step pick element columnmajor order lay rowmajor order permut step revers step permut step amount b rc shift element column permut step revers permut step step columnsort work assumpt r leighton pose open problem extend rang applic columnsort without chang algorithm drastic provid extens show one addit sort step necessari suffici complet sort case r ss gamma extens seen trade one addit sort step larger rang applic algorithm figur step step applic extend columnsort algorithm first eight step correspond classic step columnsort figur show matrix r row column condit r satisfi first eight step exampl correspond step columnsort algorithm produc sort matrix ad one step step element column sort obtain extend columnsort algorithm assum matrix r row column number r gamma gamma respect argument reli part follow wellknown gem comput scienc mention knuth proposit let matrix whose row sort sort column row remain sort follow result prove lemma element x end posit i j end step x rank least follow result mention without proof lemma element x end posit i j end step rank si proof interest determin lower bound number element known larger equal x purpos note sinc end step element x posit known larger equal x among these known smaller equal gamma j element column end step remain must smaller equal element column end step consequ x known smaller equal least rs element follow rank x si sj claim later refer choos r lemma element x end column c end step correct posit x sort matrix one pair column proof consid again gener element x end posit i j end step permut specif step guarante x move step posit correspond sort matrix element rank si j gener correct posit x howev shall prove x close correct posit follow sens x column c end step sort matrix x must one pair column recal virtu lemma combin x rank smaller si larger si sj moreov simpl algebra manipul show consid element z rank si respect number n y z element matrix lie z sort order is so observ equat impli z must lie adjac column sort matrix saw end step x lie posit correspond element rank sort matrix confirm x lie somewher z assum x lie column c end step thu correct posit x one column c gamma c case z column x one column c c column x lemma row sort end step proof consid arbitrari column k k gamma end step permut specifi step guarante first r element column k appear posit k ks ks column next group r element appear posit k ks ks on sinc column sort end step follow row k ks sort end step sinc k arbitrari conclus follow lemma element x bottom half column c end step correct posit sort matrix one column c c proof lemma know correct posit x one pair column thu prove claim need show x cannot column c gamma purpos begin observ proposit lemma combin row column sort end step now suppos element x end row t b rc end step x belong column c gamma sort matrix element matrix column c belong row must belong column c gamma below lemma element alreadi column must belong column sort matrix thu least addit element must belong column c gamma below contradict perfectli similar way one prove follow result lemma element top half column c end step correct posit sort matrix one column c gamma c now suppos find end step step columnsort lemma everi item x column c end step must column c sort matrix proof begin show element column c column proceed induct c basi trivial element column lie column left assum true column less c word element end one column end step lie column left need prove statement also hold column c see must case consid first element u lie bottom half column c end step end step u must either bottom half column c top half column c u belong bottom half column c then lemma must belong column c c sort matrix u belong top half column c must belong column c c sort matrix therefor either case u cannot belong column c gamma next consid element v lie top half column c end step v belong element bottom half column c gamma well element occur v column c must belong column c gamma induct hypothesi element lie column end step lie column c gamma lemma combin element lie top half column c gamma belong column c now reach contradict column must contain r element thu must hold prove element column belong column left symmetr argument show element belong column immedi right complet proof lemma one sort step complet task thu obtain step columnsort trade addit sort step larger rang r versu s theorem extend step columnsort algorithm correctli sort r theta matrix r ss gamma basic algorithm section show sort rowmajor order m use architectur model enforc conflictfre memori access result algorithm refer basic algorithm turn first step stone design timeoptim sort algorithm basic algorithm implement extend columnsort discuss section present focu effici use gener sort devic io size p mind shall keep track follow two paramet becom key ingredi evalu run time algorithm ffl number call sort devic ffl amount time requir data movement task involv sort assum sort rowmajor order element memori row case perfectli similar assum without loss gener input place order memori row integ sort element place memori row b rang a overlap step sort row independ step consist follow loop read ith memori row sort nondecreas order use sort devic result sort sequenc parallel store x j ith word memori modul j endfor endfor call sort devic op data movement involv sort step permut row permut specif step columnsort prescrib pick element memori row lay column column illustr consid case initi element distribut featur follow matrix end step permut matrix read care examin permut matrix reveal consecut element memori row end memori modul eg element occur memori modul therefor order achiev desir permut without memoryaccess conflict one devis differ way pick element variou memori row purpos find conveni view element x store memori modul order tripl hx rowx modulexi rowx modulex stand ident memori row memori modul respect contain x further let rowxjmodulex denot binari number obtain concaten binari represent rowx modulex detail spell follow procedur procedur begin parallel read th word memori modul j endfor use sort devic sort p element nondecreas order rowxjmodulex result sort sequenc parallel store x j th word memori modul j endfor endfor clearli procedur involv p iter iter p word read one memori modul sort written back memori one word per modul read write memori access conflict would seem though memori modul requir arithmet unit comput address word access iter fact point out arithmet capabl requir specif use p memori row store offset use memori access oper exampl offset begin step address regist contain first iter entri first row offset matrix ad content address regist guarante correct word memori modul access illustr refer note offset first row indic word involv read oper found address memori modul address memori modul on key observ understand happen iter column offset matrix entri first row avail subsequ element column gener modulo arithmet architectur comput perform adder associ address regist turn observ impli that fact offset matrix need store all entri gener fli yet anoth import point note order tripl hx rowx modulexi compos word three field compos word sort use combin two field name rowx modulex clearli modulex log p bit seem order repres rowx need log n bit actual replac rowx address offset contain offset matrix discuss abov sinc entri matrix integ larger p logp bit suffici therefor concaten rowxjmodulex involv log p bit discuss clear step requir p call sort devic time spent data movement oper involv sort bound op step step step permut step perform revers permut set word store row step step step shift row shall permut element slightli differ way specifi columnsort howev easi verifi element suppos end given row inde end desir row sinc step sort row order element place row step immateri permut step best illustr consid particular exampl specif permut specifi step columnsort involv three row shown is permut bit differ assum p consecut input row store memori start memori row addit assum memori row avail us content immateri denot s motiv anchor observ step sort memori row element row sort step consequ row sort step row detail follow procedur row shift begin sigma pupsilon parallel read ith word memori modul j store i gamma th word memori modul j endfor endfor import note that implement step involv sort howev op time spent data movement oper involv sort step step step simpli revers data movement step step step summar prove follow result theorem set p element store p memori row sort rowmajor order without memoryaccess conflict p call sort devic io size p op data movement involv sort essenti way one prove follow companion result theorem theorem task sort rowmajor order set mp element store m memori row perform without memoryaccess conflict call sort devic io size p om time data movement oper involv sort remaind section present import applic basic algorithm suppos wish merg two sort sequenc algorithm merg b reli follow technic result lemma assum n e b b n c let sequenc obtain merg e n then element sequenc strictli larger element sequenc proof begin show ne strictli larger element e assumpt n e b b n c guarante claim fals element strictli larger element c k evalu posit element c k sort sequenc c observ b nc element c come known larger equal and therefor strictli larger c k consequ n even b nc element c larger c k impli k b nc contradict hand n odd ne b nc and assumpt b n e larger and therefor strictli larger c k case least ne element c strictli larger c k follow contradict c k belong e next claim c larger element e sinc c sort statement fals c b k k k b nc notic element c come b smaller equal b k and therefor strictli smaller c follow contradict c belong d complet proof lemma mirror argument prove follow companion result lemma lemma assum n sequenc obtain merg element sequenc c strictli larger element sequenc worth note lemma combin show given two sort sequenc size n task merg handl follow begin split two sequenc two sequenc size n each element first one strictli larger element second one separ avail remain done sort two sequenc independ noteworthi featur approach fit extrem well architectur consid sort sequenc store memori row store memori row goal merg two sequenc store result sort sequenc memori row r r detail follow procedur merg two group begin mp use basic algorithm sort b nonincreas order c mp c store result memori row r els use basic algorithm sort nonincreas order c mp c store result memori row r copi memori row r row r copi memori row r m gamma memori row r b endfor odd copi leftmost pe element row r leftmost pe posit row r copi rightmost b pc element row r rightmost b pc posit row r endif endif odd copi leftmost pe element memori row r c leftmost pe posit row r copi rightmost b pc element row r c rightmost b pc posit row r endif copi memori row r c copi memori row r c endfor use basic algorithm sort memori row r r nondecreas use basic algorithm sort memori row r nondecreas order obviou procedur merg two group implement directli architectur model one point worth discuss howev specif task sort sequenc nonincreas order perform architectur follow sign element sort flip result sequenc sort nondecreas order final sign flip back origin valu correct procedur follow lemma moreov procedur requir three call basic algorithm consid task sort collect mp memori row abov partit input two subgroup consecut memori row each use basic algorithm sort group done complet sort use procedur merg two group thu follow result theorem task sort mp element store memori row perform five call basic algorithm om time data movement oper involv sort effici multiway merg algorithm consid collect sequenc size p assum store topdown order consecut memori row multiway merg problem sort sequenc rowmajor order goal section propos effici algorithm multiway merg multiway merg problem show implement architectur procedur multiway mergeam i size p output result sort sequenc store rowmajor order mp igamma contigu memori row g step select sampl size mp igamma retain everi pth element sequenc j j m move dmp igamma discuss below step one call sort devic els one call basic algorithm els frecurs multiway merg sg endif igamma sort version step partit p igamma contain mp element discuss below move element bucket without memori access conflict step sort bucket individu use basic algorithm procedur merg two group step coalesc sort bucket desir sort sequenc notic sampl store one memori row remaind section devot detail implement procedur architectur implement step step conveni view matrix size mp igamma theta p tth element memori row j denot aj t element aj p term leader memori row j goal step extract sampl retain leader everi memori row a along ident k subsequ k leader belong context k refer sequenc index s two disjoint group dmp igamma consecut memori row set asid store sampl correspond set sequenc indic remaind subsect view memori row alloc two matric size dmp igamma p intent end step sx y ix y store yth leader sequenc index respect see step implement without memori access conflict notic memori row leader extract store memori modul p gener memori row j cu interchang temporarili element aj p aj dj p thi interchang undon end step next dmp igamma parallel read oper perform follow two parallel write oper jth parallel read oper pick kth word memori modul k k p p element store jth memori row alloc s second parallel write oper store sequenc indic p element jth memori row alloc i thu step implement omp igamma data movement call sort devic sampl process continu recurs level reach procedur multiway merg invok either case correspond sampl set store one memori row sort one call sort devic case sampl set store memori row sort one call basic algorithm sinc oper sort one row direct discuss way basic algorithm oper context conceptu process sort sampl benefit view one sort concaten sjk sampl element k sequenc index recal that describ section design assum sort devic provid data path size w log p input output impli step extend columnsort execut directli sort row r correspond row r i cu load two parallel read oper element field short auxiliari field data regist r j j p sr j ir j long auxiliari field let rj k rj element sequenc index store regist r j let rj jk rj denot concaten next content data regist suppli input sort devic let receiv r j sort rj k rj store respect element short auxiliari field r j two parallel write oper cu store element field short auxiliari field regist r j j p sr j ir j respect step basic algorithm perform permut implement step involv sort case data movement involv sampl element correspond sequenc indic perform two companion phase specif view sampl set correspond sequenc index set two matric permut perform i step basic algorithm involv data movement oper sort data movement oper step similar step detail further recal sort oper step basic algorithm perform concaten two auxiliari field store rel row number column number element henc perform two companion sort phase one permut sampl element permut sequenc indic clearli implement time complex easi confirm end step procedur multiway merg sampl set sort rowmajor order furthermor view matric ix y sequenc index sampl element sx y let sort version equat use step partit element bucket order so leader row need learn rank next goal associ everi memori row rank s task carri two stage first stage use sequenc index rank cu assign row number row a everi s row either exact row number extract step or case leader sever row equal row achiev possibl reassign leader row detail first stage spell procedur assign row number present below conveni use matrix represent i oper easili implement use address word correspond sx y initi contain sequenc indic sampl s procedur termin ix y contain row correspond procedur assign row number begin r k row number first memori row store sequenc k endfor e endfor endfor second stage cu assign rank memori row row contain ix y oper perform matrix represent easili implement use address word correspond sx y ix y sinc readwrit oper use procedur describ total time spent oper bound omp igamma implement step step rank leader known readi partit bucket first object construct collect bucket follow condit satisfi b everi element belong exactli one bucket b bucket contain mp element b everi j strictli larger element b j present bucket partit scheme need definit let mp igamma memori row leader b said regular respect bucket b j j notic equat guarante everi memori row regular respect exactli one bucket ident bucket determin cu constant time convers respect bucket exactli regular memori row memori row r leader b sequenc k k m term special respect bucket b if stand leader preced memori row k ani let memori row leader b regular respect bucket respect j import note equat impli memori row whose leader b special respect bucket conceptu bucket partit scheme consist two stage first stage associ regular special row respect gener bucket obtain set c j candid element second stage assign element bucket way actual element assign bucket b j form subset candid set c j specif element x memori row regular respect bucket b j assign b j one condit satisfi j gammam j gammam x jm whenev j element assign bucket virtu longer elig assign bucket remaind assign process consid further element x assign bucket respect memori row regular element x assign exactli one bucket respect memori row contain x special assum memori row contain x special respect bucket smallest index n lx one equat hold j n place j now x assign bucket b jn next result show bucket defin satisfi condit bb condit b b b proof clearli assign scheme guarante everi element get assign bucket element get assign one bucket thu condit b verifi further notic combin everi j candid set c j respect bucket b j contain memori row and therefor mp element a moreov indic element actual assign bucket b j subset c j prove b final equat guarante element x belong bucket b j cannot strictli larger element bucket b k k thu condit b hold well worth note preced definit bucket work perfectli well even input element ident fact element distinct one defin bucket simpler way moreov case distinct element step procedur multiway merg simplifi present implement detail assign element bucket write denot everi j order pair s j gammam jm jth bound pair notic equat amount test whether given element lie bound pair b bucket contain mp element a motiv us set asid memori row bucket b j these alloc first memori row element assign b j come regular memori row respect b j alloc last memori row element assign bucket b j resid special memori row respect b j addit find conveni initi content memori row alloc b j s import note regular memori row respect bucket b j natur order order correspond leader s clarifi last point recal leader belong bucket b j j gammam j accordingli memori row whose leader j gammam first regular row respect b j memori row whose leader j gammam second regular row respect b j on similarli fact sequenc k sort guarante may contain one special memori row respect bucket b j now case special row exist term kth special memori row respect b j distinguish other order move element bucket cu scan memori row one one suppos current memori row scan row r sequenc k assum leader row r b leader row r gamma use equat cu establish row r regular respect bucket b j similarli previou memori row regular respect bucket case row r first row k j set next element memori row r read element field data regist cu broadcast regist bound pair s j gammam jm use compareandset regist store short auxiliari field correspond element assign bucket b j virtu otherwis say element x data regist mark valu short auxiliari field otherwis x unmark clearli everi element x mark end first broadcast assign bucket parallel write oper cu copi mark element correspond word row alloc bucket b j done use compareandset mark element data regist set short auxiliari field clear further cu broadcast data regist increas order bound pair bucket us follow process specif bucket b j receiv bound pair data regist determin whether valu x store element field satisfi j place j mark x accordingli parallel write oper cu copi mark element correspond word next avail memori row alloc bucket b j next use compareandset mark element data regist set short auxiliari field clear process repeat remain bucket respect row r special reader fail note process row r complet element move bucket assign moreov are altogeth mp igamma regular row mp igamma special row total time involv assign element bucket bound omp igamma call sort devic summari step implement omp igamma data movement call sort devic step bucket sort independ bucket p memori row sort one call basic algorithm otherwis bucket partit two halv sort one call basic algorithm final two sort halv merg use procedur group theorem task sort bucket individu perform omp igamma call sort devic omp igamma data movement involv sort implement step motiv need process specif step note sort bucket individu step may number s bucket refer element empti memori row consist entir empti element term empti row memori row term impur partli empti clear bucket may one impur row memori row contain empti element refer pure task coalesc nonempti element bucket mp igamma consecut memori row refer compact easi discuss assum sort bucket store consecut row is nonempti row b follow nonempti row b nonempti row b follow nonempti row b on assum empti row remov compact process consist three phase phase let c row sequenc obtain concaten nonempti row b j s obtain step multiway merg increas order indic partit sequenc c subsequ x c j contain p consecut row c except last subsequ c x may contain fewer row clearli x mp igamma use basic algorithm sort subsequ independ let sort subsequ correspond c c empti row elimin futur consider let row sequenc obtain concaten row c s increas order indic partit sequenc subsequ j contain p consecut row d except last subsequ may contain fewer row use basic algorithm sort subsequ independ let sort subsequ correspond empti row elimin let e row sequenc obtain concaten row s increas order indic lemma preced row everi impur row except last row e pure row proof notic follow fact except last row d everi row either contain least p nonempti element contain fewer p nonempti element preced row must pure row row c contain least one nonempti element impur row gener one two condit a c j contain fewer p nonempti element contain one row impur row nonempti element come p impur row c j b c j contain p nonempti element c contain one impur row preced row pure row lemma directli follow fact phase phase comput set paramet use next phase let w total number nonempti row e assum row e locat row row w everi j stand number nonempti element impur memori row c j first subtask phase determin igamma consid gener impur row c j determin n j cu read entir row c j data regist r everi k k p c j th word memori modul k read regist r k long auxiliari field data regist r k set k use compareandset featur cu instruct regist r k reset auxiliari field gamma element hold ie empti next data regist load sort devic sort increas order long auxiliari field easi confirm that sort largest valu k j precis posit rightmost nonempti element memori row c j therefor cu set consequ task comput number call sort devic op igamma readwrit oper involv sort number avail cu comput prefix sum oe thi cours involv addit perform cu omp igamma call sort devic let e mod g defin phase construct row group g consecut row follow ff kgamma row start row e k els row kp start row e k end row e k row kp end row e g row w note e k e k may share two row lemma contain least ppelement last two row contain least p element g perform follow oper a sort use basic algorithm b replac fi smallest element s c sort use basic algorithm d ff k k g elimin last row e g perform a b c onli let k row group obtain e k let f row sequenc obtain concaten row s increas order indic f compact c set select element row s done o time compareandset oper exampl set leftmost element row s carri follow read row r s cu broadcast r s r compar set content s modifi row written back memori array base lemma easi verifi element f sort order step implement omp igamma call sort devic omp igamma data movement involv sort complex analysi correct multiway merg algorithm obviou turn complex specif interest assess total amount data movement involv sort requir procedur multiway merg specif let jmp stand time spent data movement task involv use sort devic take o time case take om time refer theorem final previou discuss show step step step step requir omp igamma recurs jmp igamma time thu obtain follow recurr system easi confirm that p solut recurr satisfi jmp similar analysi repeat show total number call sort devic io size perform procedur multiway merg merg m sequenc bound omp igamma summar discuss state follow import result theorem procedur multiway merg perform task merg m quenc size p architectur use omp igamma call sort devic io size p omp igamma data movement involv sort sort algorithm basic algorithm multiway merg dispos posit present detail sort algorithm use sort devic fix io size p input set sigma n item store evenli possibl p memori modul dummi element valu ad necessari ensur memori modul contain n e element dummi element remov sort goal show use architecturealgorithm combin input sort n log n log p time on data space assum p along impli log equat import analysi section discuss focu case sort network io size p depth olog p use sort devic natur candid network batcher classic biton sort network shall tacitli assum recal virtu have t turn equat guarante log n log p point note combin guarante log write observ reason becom clear later pad sigma appropri number element way that n stand length result sequenc sigma import note combin guarante suggest number memori row use sort algorithm bound o n show is inde case sort algorithm consist iter order guarante overal run time o n log n log p ensur iter perform o n see shortli sort network use follow three context i sort individu memori row turn out complex claim hold sort devic use is instead psorter ii sort individu group consist consecut memori row iii sort individu group consist consecut memori row effici implement i use simpl pipelin memori row sort input sort network one other initi overhead olog p time subsequ time unit produc sort memori row clearli total sort time bound olog effici implement ii use interleav pipelin let g gm group wish sort interleav pipelin begin run step basic algorithm pipelin fashion group g group g so word step basic algorithm perform group use simpl pipelin then perfectli similar fashion simpl pipelin use carri step basic algorithm group g strategi use remain step basic algorithm requir use sort devic consequ total amount time need sort group use interleav pipelin bound olog effici implement iii reli extend interleav pipelin let g gm group want sort recal theorem state sort group consecut memori row requir five call basic algorithm extend interleav pipelin consist five interleav pipelin step correspond one five call basic algorithm thu task sort group perform olog time discuss iter sort algorithm detail iter input partit n group involv p memori row use interleav pipelin group sort individu discuss abov run time iter bound olog iter input iter k collect n ksort sequenc size p store consecut memori row output iter k collect n sort sequenc size p store p consecut memori row partit sort sequenc n consecut sequenc each proceed sort group gk j call multiway merg k refer call multiway merg k call first level observ that sinc n altogeth n way merg call first one group step multiway merg call first level extract sampl k j k consist p sort sequenc size p store consecut memori row turn everi j j n sampl k j sort invok multiway merg k refer multiway merg call second level step multiway merg call second level extract sampl k j everi u c multiway merg call level u form multiway merg step call multiway merg u k multiway merg call level u form multiway merg u k let r ku denot total number row sampl u k j level u clearli r p u r ku qp r even recurs call multiway merg end level b k gammac last call form note depend whether k odd proceed demonstr take or k time show total time requir five step multiway merg call level u bound or ku consid particular level u step multiway merg call level u perform sampl u k j increas order j sampl u k extract one other clearli total time oper or ku perform step multiway merg call level u increas order j partit bucket sampl u k use correspond u k j lemma sampl bucket bucket contain p element discuss subsect task move element u k j bucket carri op use sort devic thu total time partit sampl u k multiway merg call level u bound o n step multiway merg call level u sort bucket involv element u k j obtain step perform step multiway merg call level u increas order j use extend interleav pipelin sort bucket u k j are altogeth n ubucket u k js thu total time sort bucket bound d total time sort bucket multiway merg call level u or ku step multiway merg call level u three phase discuss subsect oper phase phase involv sort devic carri use interleav pipelin oper phase involv sort devic carri use simpl pipelin clearli time complex step multiway merg call level u bound olog evalu time need perform step multiway merg call level u first consid call level b k gammac multiway merg b sampl extract step call p element odd use simpl pipelin sort sampl b k use interleav pipelin sort sampl b k either case time requir bound o n o n thu total time step multiway merg call level b k gammac or kb next time perform step multiway merg call level u induct deriv or ku use claim total time step multiway merg call level u or ku hypothesi step multiway merg call level thi turn prove total time requir multiway merg call level u bound or ku shown time requir multiway merg call level u iter k or ku conclud total time perform iter k or k o n iter n input element sort end iter assum algorithm termin iter input iter gamma collect sort sequenc sequenc size p store p tgamma consecut row complet sort need merg q sequenc desir sort sequenc task perform call multiway mergesigma t detail implement multiway mergesigma use sort network sort devic analysi involv almost iter iter differ paramet use interleav pipelin use step multiway merg iter gamma correspond step multiway merg iter use interleav pipelin similarli extend interleav pipelin use step multiway merg iter gamma correspond step multiway merg iter use extend interleav pipelin q multiway merg call level b tgammac multiway merg b odd recurs stop b tgammacth level sampl set b obtain step multiway merg call level b tgammac qp odd qp element even let r tgammau total number memori row simpl induct conclud multiway merg call level u take or tgammau time run time iter run time multiway merg call first level take or tgamma shown iter multiway merg implement time o n conclud run time sort algorithm n log n log p sinc psorter abstract sort network io size p depth o time complex stand sort devic use psorter work data memori iter on simpli sampl size multiway merg call level u p time sampl size multiway merg call level u sinc work data memori one iter reus anoth iter total data memori requir sort algorithm remain on summar previou discuss prove main result work theorem use simpl architectur set n item store n memori row sort rowmajor order without memori access conflict n log n log p time on data space use either psorter sort network io size p depth olog p sort devic r sort n object ksorter optim sort algorithm reconfigur mesh art comput program tight bound complex parallel sort introduct parallel algorithm architectur array sort o time reconfigur mesh size n sort n number n sort n item use sort network fix io size tr ctr classifi matric separ row column ieee transact parallel distribut system v n p juli giusepp campobello marco russo scalabl vlsi speedarea tunabl sort network journal system architectur euromicro journal v n p octob brian grattan greg stitt frank vahid codesignextend applic proceed tenth intern symposium hardwaresoftwar codesign may est park colorado