t viennafortranhpf extens spars irregular problem compil a abstractvienna fortran high perform fortran hpf data parallel languag introduc allow program massiv parallel distributedmemori machin dmmp rel high level abstract base spmd paradigm main featur includ direct express distribut data comput across processor machin paper use viennafortran gener framework deal spars data structur describ new method represent distribut data dmmp propos simpl languag featur permit user character matrix spars specifi associ represent togeth data distribut matrix enabl compil runtim system translat sequenti spars code explicitli parallel messagepass code develop new compil runtim techniqu focu achiev storag economi reduc commun overhead target program overal result power mechan deal effici spars matric data parallel languag compil dmmp b introduct past year signific effort undertaken academia govern laboratori industri defin highlevel extens standard program languag particular fortran facilit data parallel program wide rang parallel architectur without sacrif perform import result work vienna fortran fortran high perform fortran hpf intend becom defacto standard languag extend fortran fortran direct specifi align distribut program data among processor thu enabl programm influenc local comput whilst retain singl thread control global name space lowlevel task map comput target processor framework singleprogrammultipledata spmd model insert commun nonloc access left compil hpf origin version high perform fortran focuss attent regular com putat provid set basic distribut block cyclic replic although approv extens hpf includ facil express irregular distribut use indirect special support spars data structur propos paper consid specif requir spars comput aris varieti problem area molecular dynam matrix decomposit solut linear system imag reconstruct mani other order parallel sequenti spars code effect three fundament issu must address must distribut data structur typic use code necessari gener represent spars matric singl processor distributedmemori machin way save memori comput also achiev parallel code compil must abl adapt global comput local comput processor resolv addit complex spars method introduc paper present approach solv three problem first new data type introduc vienna fortran languag repres spars matric then data distribut explicitli design map data type onto processor way exploit local spars comput preserv compact represent matric vector therebi obtain effici workload balanc minim commun experi parallel spars code hand confirm suitabl distribut also excess amount time spent develop debug stage manual parallel encourag us build compil specifi algorithm highlevel dataparallel languag way new element introduc vienna fortran extend function express irregular problem subsequ compil runtim techniqu develop enabl specif optim handl typic featur spars code includ indirect array access appear array element loop bound result power mechan store manipul spars matric use dataparallel compil gener effici spmd program irregular code kind paper assum represent distribut spars data invari howev fact represent spars data comput runtim simplifi addit support handl complex featur dynam redistribut matrix fillin ie runtim insert addit nonzero element spars matrix rest paper organ follow section introduc basic formal background handl spars matric section present sever data distribut spars problem section describ new direct specif distribut vienna fortran languag section respect outlin runtim support compil technolog requir implement featur section present experiment result finish section discuss relat work conclus repres spars matric distributedmemori machin matrix call spars small number element nonzero rang method develop enabl spars comput perform consider save term memori comput solut scheme often optim take advantag structur within matrix consequ parallel firstli want retain much save possibl parallel code secondli order achiev good load balanc runtim necessari understand achiev term data structur occur spars problem formul section discuss method repres spars matric distributedmemori machin assum reader familiar basic distribut function vienna fortran hpf name block cyclick throughout paper denot set target processor proc assum data distribut twodimension mesh proc x processor number dimens specif assum vienna fortran hpf code includ follow declar note abstract processor declar impli specif topolog actual processor interconnect network basic notat terminolog array associ index domain denot replicationfre distribut total function map array element processor becom owner element and capac store element local memori further processor p proc denot p set element local p call local segment p follow assum twodimension real array repres spars matrix declar index domain notat introduc relat a without explicitli reflect depend begin defin set auxiliari function definit symbol matrix associ total predic ftrue falseg i ff j fiji ig j specifi number matrix element nonzero valu biject enumer a number element consecut order start assum enumer select total function tth index associ nonzero element a default use enumer follow number element row wise ie assum i spars matrix map distributedmemori machin approach requir two kind inform specifi user are represent spars matrix singl processor call spars format distribut matrix across processor machin context concept distribut use matrix dens combin spars format distribut call distribut spars represent matrix spars format discuss data distribut strategi spars data must understand data usual repres singl processor numer storag format propos sparsematrix literatur work use commonli use cr compress row storag format approach extend cc compress column storag swap row column text follow simplic consid spars matric real element immedi gener includ element type logic integ complex definit compress row storag cr spars format determin tripl function dacoro total data function defin dat at denot set real number co total column function defin cot t total row function defin follow a let denot arbitrari row number roi least one specifi properti exist otherwis roi roi three function repres obviou way vector ff real number the data vector ff column number the column vector number rang row vector respect see figur b data vector store nonzero valu matrix travers rowwis fashion column vector store column indic element data vector final row vector store indic data vector correspond first nonzero element row if element exist storag save achiev approach usual signific instead store n element need locat spars matrix algorithm design cr format typic use nest loop outer loop iter row matrix inner loop iter nonzero row see exampl section matrix element identifi use twodimension index set say ijj denot ith row matrix jj denot jjth nonzero row matrix element refer ijj one row number r column number coroijj nonzero valu store daroijj heavi use indirect access spars represent requir introduc major sourc complex ineffici parallel code distributedmemori machin number optim present later overcom thi distribut spars represent let denot spars matrix discuss abov ffi associ distribut distribut spars represent result combin ffi spars format understood follow distribut ffi interpret convent sens ie pair z x y number y dens fortran array ffi determin local function which p proc specifi local segment p p spars matrix distribut spars represent obtain construct represent element p base given spars format is da co ro automat convert set vector da p co p ro p p proc henc parallel code save comput storag use mechan appli origin program spars format use cr illustr idea data distribut introduc two differ scheme subsequ section decompos spars global domain mani spars local domain requir multipl recurs decomposit mrd common approach partit unstructur mesh keep neighborhood properti base upon coordin bisect graph bisect spectral bisect spectral bisect minim commun requir huge tabl store boundari local region expens algorithm comput it graph bisect algorithm less expen sive also requir larg data structur coordin bisect significantli tend reduc time comput partit expens slight increas commun time binari recurs decomposit brd propos berger bokhari belong last categori brd specifi distribut algorithm spars matrix recurs bisect altern vertic horizont partit step mani submatric processor submatrix map uniqu processor flexibl variant algorithm produc partit shape individu rectangl optim respect userdetermin function section defin multipl recurs decomposit mrd gener brd method also improv commun structur code assum processor array declar prime factor decomposit x order way prime factor x sort descend order come first follow factor y sort fashion mrd distribut method produc x partit matrix k step recurs perform horizont divis matrix prime factor x vertic one prime factor matrix partit p submatric way nonzero element spread across submatric evenli possibl submatrix partit horizont row nonzero entri uniqu assign either partit includ lower one vertic step column assign right partit submatrix result step i partit p submatric use criteria befor process termin creat q k submatric enumer consecut x use horizont order scheme submatrix number r map processor procsr distribut defin local segment processor rectangular matrix preserv neighborhood properti achiev good load balanc see figur fact perform horizont partit step vertic one reduc number possibl neighbor submatrix may have henc simplifi analysi perform compil runtim system combin cr represent local segment mrd distribut produc mrdcr distribut spars represent inmedi gener storag format howev sinc use cr illustr idea refer mrdcr mrd itself br distribut spars represent second strategi base cyclic distribut see figur a retain local access regular case suitabl workload spread evenli across matrix present period densiti matrix vari time mani common algorithm natur includ spars matrix decomposit lu choleski qr wz imag reconstruct algorithm section assum dimens distribut cyclic block length see figur b sever variant represent distribut segment context describ literatur includ mm ess bb method consid cr spars format result br block row scatter distribut spars represent similar distribut represent bc block column scatter spars format compress column chang row column vice versa map establish br choic requir complex auxiliari structur translat scheme within compil howev data use togeth cyclicallydistribut dens array structur properli align lead save commun extens support spars matrix comput languag consider section propos new languag featur specif spars data data parallel languag clearli block cyclic distribut offer hpf adequ purpos hand indirect distribut includ approv extens hpf allow specif structur inher distribut spars represent thu introduc unnecessari complex memori consumpt execut time propos make structur explicit appropri new languag element seen provid special syntax import special case userdefin distribut function defin vienna fortran hpf new languag featur provid follow inform compil runtim system ffl name index domain element type spars matrix declar done use regular fortran declar syntax array actual appear origin code sinc repres set array name introduc refer specifi distribut ffl annot specifi declar array spars provid inform represent array includ name auxiliari vector order data column row declar explicitli program size determin implicitli matrix index domain ffl dynam attribut use manner analog mean vienna fortran hpf specifi distribut spars represent determin dynam result execut distribut statement otherwis compon distribut spars represent construct time declar process often inform contain file whose name indic annot addit input spars matrix avail compiletim must read file standard format distribut runtim name file may provid compil addit direct concret exampl typic spars code illustr detail syntax as well hpf given figur solut spars linear system wide rang techniqu solv linear system among them iter method use success approxim obtain accur solut step conjug gradient cg oldest best known effect nonstationari iter method symmetr posit definit system converg process speed use precondition comput cg itself includ figur dataparallel code unprecondit cg algorithm involv one matrixvector product three vector updat two inner product per iter input coeffici matrix a vector scalar b also initi estim must comput xvec solut vector element initi residu r defin then everi iter two inner product perform order updat scalar defin make sequenc fulfil certain orthogon condit end iter solut residu vector updat lanczo algorithm figur illustr algorithm extend hpf tridiagon matrix lanczo method use new direct indic nsd specifi requir declar inform execut distribut direct result comput distribut spars represent point matrix legal access program sever matrixvector vectorvector oper perform comput diagon output matrix runtim analysi base languag extens introduc abov section show access spars data effici translat vienna fortran hpf explicitli parallel messag pass code context data parallel spmd paradigm rest paper assum input matrix avail compiletim assumpt matrix distribut postpon runtim obvious enforc global local index translat also perform runtim parallel code use indirect address compil typic use inspectorexecutor strategi loop access distribut variabl tranform insert addit preprocess loop call inspector inspector translat global address access indirect processor offset tupl describ locat element comput commun schedul executor stage use preprocess inform fetch nonloc element access distribut data use translat address obviou penalti use inspectorexecutor paradigm runtim overhead introduc inspector stage becom signific multipl level indirect use access distribut array seen frequent case sparsematrix algorithm use compact storag format cr exampl xvecdaroijj refer encount figur requir three preprocess step one access distribut array ro second access da yet third access xvec pay special attent issu section outlin effici solut parallel sar approach though base inspectorexecutor paradigm solut translat cr like spars indic runtim within dataparallel compil significantli reduc time memori overhead compar standard generalpurpos chao librari techniqu call spars array roll sar encapsul small descriptor inform input matrix distribut across processor allow us determin processor offset locat spars matrix element without plod distribut auxiliari array datastructur thu save preprocess time requir intermedi array figur provid overview sar solut approach distribut matrix repres cr format carri partition routin respons comput domain decomposit give output distribut represent well associ descriptor descriptor index translat process use row number nonzero index x locat processor offset matrix element store element found nonloc derefer process assign address local memori element place fetch executor stage use preprocess inform insid coupl gatherscatt routin fetch mark nonloc element place assign locat final loop comput access distribut data use translat address effici translat function memori overhead descriptor larg depend matrix distribut follow section provid detail distribut studi paper mrd descriptor translat mrd distribut map rectangular portion dens index space n theta m onto virtual processor space x theta correspond descriptor replic processor consist two part vector parth store row number x horizont partit made two dimension array partv size n theta keep track number nonzero element vertic partit row exampl mrd distribut matrix figur correspond descriptor replic among processor follow parth denot horizont partit made row row two vertic partit valu partv say first section row two nonzero element second section one assum parth parthxn partvk k n given nonzero element identifi ijj perform translat mean descriptor determin processor own nonzero element assum processor identifi posit myr myc x theta virtual processor mesh valu myr myc processor own element satisfi follow inequ search right myr myc satisfi inequ requir search space size x theta search optim first check see element local plug local processor valu myr myc assum high degre local check frequent succe immedi fail binari search mechan employ offset element locat xvecpartvimyc thu column number element ijj found coxvecpartvimyc processor myr myc nonzero valu access daxvecpartvimyc processor without requir commun addit preprocess step br descriptor translat unlik mrd br descriptor differ processor processor myrmyc element nx row map onto it br descriptor store local row matrix entri everi nonzero element row regardless whether element map local not element local entri store local index da nonloc element entri store global column number element origin matrix distinguish local entri nonloc entri swap sign local indic becom neg actual datastructur use crslike twovector represent vector call cs store entri element map local row anoth vector ra store indic row start cs exampl spars matrix partit show figur valu cs ra processor follow cs say element store global column nonloc cs signifi element map local store local index remain entri similar interpret processor own element rx identifi follow first local row identifi use simpl formula x entri element obtain use csrarjj neg impli element local access dam posit global row column number element impli processor own element save ijj indic list indic mark later retriev processor q executor gather routin send ijj indic q similar translat process repeat time howev element local found sent request processor compil section describ compil implement within vienna fortran compil system vfc input compil viennafortran code extend spars annot describ section compil process result fortran code enhanc messagepass routin well runtim support alreadi discuss previou section tool structur set modul shown figur describ modul separ frontend first modul part tool interact declar part program respons for scan pars new languag element present section oper gener abstract syntax tree annot tabl summar compiletim inform extract them tabl built spars direct need compil proce remov code insert declar local vector auxiliari variabl target code runtim support util parallel stage compil first scan code search spars refer extract inform avail compiletim ie indirect syntax indic loop condit insid refer is etcetera inform organ databas later lookup parallel process done loop decomposit start goal consist distribut workload sourc code evenli possibl among processor task turn particularli complex compil handl spars code mainli frequent use indirect access spars data frequent use spars refer loop bound case multipl queri distribut spars data requir processor order determin iter space lead larg number commun overcom problem address problem differ way rather tri access actual spars valu request loop header appli loop transform determin local iter space also map valu semant equival inform local distribut descriptor approach doubl advantag reus compil auxiliari structur ensur local access perform loop boundari result much faster mechan access data extra memori overhead mrd case exampl array parth partv determin local region data spars matrix base global coordin way loop partit driven similar strategi block differ region differ size but similar workload determin runtim descriptor gener runtim support br case solut straightforward let us take exampl conjug gradient cg algorithm figur dens vector distribut dens cyclic spars matrix follow br scheme note cg loop refer dens structur decomposit perform enforc stride loop number processor data dimens travers loop distribut consecut local data cyclic alway separ constant distanc term global coordin howev refer spars vector includ loop fact true first matrix dimens second one actual sparsiti degre matrix determin distanc consecut data term global column sinc becom unpredict compiletim recal assumpt spars matrix pattern avail runtim runtim check defin function br distribut descriptor need insert loop travers second matrix dimens success parallel check eventu move inspector phase executor comput number iter thu decreas overal runtim overhead see transform final code gener figur figur provid code excerpt outlin loop decomposit perform within vfc two spars loop figur ra cs vector br descriptor processor coordin myr myc ra store indic way local ro doe consid element place global row theta x myr given local row i cycliclik approach follow extract local iter first loop ra travers element second loop cs delimit local iter subsequ if note differ criteria follow parallel loop first loop wellknown owner comput rule appli second loop though underli idea avoid replic comput first calcul local partial sum given local element accumul valu singl reduct phase way comput distribut base owner everi singl da p valu given index k make match alway processor achiev complet local backend workload assign processor compil enter last stage whose output target spmd code reach goal code transform inspector executor phase loop figur show final spmd code spars loop parallel figur overal next sequenc step carri compil modul inspector loop insert prior loop comput header loop obtain syntax tree parallel statement insid loop gener collect indic distribut array auxiliari vector vector taken input translat process call translat derefer scattergath routin place inspector executor loop complet runtim job refer distribut variabl executor loop sintact chang index translat function produc output inspector see function f g figur addit io routin must insert begin execut part merg processor local data descriptor sar scheme done partition routin evalu distribut method choic distribut strategi matrix crucial determin perform control data local load balanc executor preprocess cost inspector memori overhead runtim support section discuss br mrd distribut affect aspect particular case spars loop conjug gradient algorithm account effect differ sparsiti structur chose two differ matric come harwellbo collect identifi psmigr bcsstk former contain popul migrat data rel dens wherea latter spars matrix use larg eigenvalu problem matrix characterist summar tabl commun volum executor tabl show commun volum executor processor theta processor mesh comput spars loop cg algorithm commun necessari accumul local partial product array q oper implement like typic reduct oper local matrix row processor row note two thing first relat commun volum processor mesh configur second balanc commun pattern note comparison commun volum across two matric rel number row gener x theta processor mesh n theta spars matrix commun volum roughli proport nx theta logi thu theta processor mesh time less total commun volum theta mesh br processor accumul exactli amount data mrd minor imbal stem slightli differ size horizont partit see figur commun time executor show black figur loop partit workload balanc explain section iter spars loop conjug gradient algorithm map owner da element access iter result perfect workload balanc mrd case sinc processor own equal number nonzero br workload balanc reli random posit element except patholog case result good load balanc tabl show load balanc index br maximum variat averag divid averag memori overhead vector store local submatrix processor requir similar amount memori distribut howev distribut descriptor use runtim support requir substanti differ amount memori tabl summar requir first row indic expect memori overhead next two row show actual overhead term number integ requir overhead column repres memori overhead percentag amount memori requir store local submatrix vector partv cs respons overhead distribut sinc keep track posit nonzero element mrd br respect overhead much higher br cs vector store column number even offprocessor nonzero length vector reduc use processor mesh runtim evalu section describ perform evalu spars loop conjug gradient algorithm parallel use vfc compil br mrd especif intent studi effect distribut choic inspector executor perform within dataparallel compil final manual version applic use baselin determin overhead semiautomat parallel platform intel paragon use nxlib commun librari experi ment account io time read matrix perform distribut inspector cost figur show preprocess cost spars loop mrd br version cg algorithm two matric preprocess overhead reduc increas parallel though effici drop high end also note br incur higher preprocess overhead mrd also scale better understand rel cost br rel mrd recal br translat mechan involv preprocess nonzero local row mrd dereferenc requir binari search distribut descriptor local nonzero though process fewer element size mrd search space proport size processor mesh processor ad translat requir search larger space though shown tabl measur indic br inspector actual faster mrd processor executor time sinc scheme distribut nonzero equal across processor found comput section executor scale well distribut processor commun overhead start reduc effici figur show executor time spars loop two cg version indic good load balanc fact find case superlinear speedup attribut cach effect executor commun time shown dark figur br commun overhead remain essenti invari across processor size suggest overhead extra commun startup offset reduc commun volum maintain total overhead mrd commun much unbalanc lead much poorer scale commun cost inde effect particularli appar bcsstk redistribut extrem unbalanc becom sever bottleneck processor size increas comparison manual parallel effici spars code parallel within vfc compil depend larg primari factor ffl distribut scheme select parallel either mrd br ffl sparsiti rate input matrix ffl cost inspector phase figur access pattern hand seen parallel spars loop cg algorithm within vfc lead target code executor perform commun gatherscatt routin consequ full local achiev data distribut local represent loop partit strategi apart actual comput executor contain commun accumul local partial product implement reduct routin exactli programm would do thu executor time becom accur estim effici smart programm attain addit cost use automat compil lie intir preprocess time inspector loop plu subsequ runtim call figur figur tri explain impact major factor influenc parallel effici provid comparison manual compilerdriven parallel execut time compil includ cost singl inspector plu executor per iter wherea manual version inspector requir far distribut concern figur show br introduc bigger overhead direct consequ expens inspector slower global local translat process howev even br case overal result quit effici number iter practic converg cg algorithm start exhibit stationari behaviour less one hundr iter time inspector cost alreadi wide amort total compil overhead alway kept regardless input matrix distribut chosen number processor parallel machin respect matrix sparsiti conclud higher degre sparsiti matrix is better result produc compil compar manual version overal comparison manual parallel also reflect good scalabl manual gain small number iter summar say cost paid automat parallel worthwhil long algorithm amort inspector cost minimum number iter remain cost conjug gradient algorithm lie multipl loop deal dens array distribut cyclic howev comput weight part never goe total execut time even though compil effici expect improv case influenc minimum lead signific variat full algorithm addit experi demonstr effici scheme develop trena implement manual version lanczo algorithm see figur use pvm routin br scheme relat work program design carri rang spars algorithm matrix algebra outlin code requir optim describ paper effici target code gener parallel system varieti languag compil target distribut memori multiprocessor attempt deal loop aris spars irregular comput one approach origin fortran vienna fortran base indirect data distribut cannot express structur spars data result memori runtim overhead scheme propos paper provid special syntax special class userdefin data distribut propos vienna fortran hpf hand area automat parallel outstand tool know parafras polari intend framework parallel spars algorithm address present work method propos saltz et al handl irregular problem consist endow compil runtim librari facilit search captur data locat distribut memori major drawback approach larg number messag gener consequ access distribut data address tabl associ overhead memori order enabl compil appli optim simplifi task programm bik wijshoff implement restructur compil automat convert program oper dens matric spars code method postpon select data structur compil phase though friendli end user approach risk ineffici result allow programm choos appropri spars structur way deal problem differ defin heurist perform effici map data languag extens describ map data parallel languag produc benchmark prototyp compil integr vfc abl gener effici code irregular kernel compil transform insert procedur perform runtim optim implement qualit differ effort cite number import respect particular respect use new data type spars format data distribut our distribut spars represent irregular comput basic idea distribut take account way spars data access map data pseudoregular way compil may perform number optim spars code specif pseudoregular distribut allow us describ domain decomposit use small descriptor can addit access local save memori overhead distribut tabl well commun cost need lookup gener applic code irregular problem normal code segment loop complex access function advanc analysi techniqu known slice analysi deal multipl level indirect transform code contain refer code contain singl level indirect howev multipl commun phase still remain sar techniqu implement insid spars compil novel abl handl multipl level indirect cost singl translat key attain goal consist take advantag compiletim inform semant relat element involv indirect access conclus paper spars data distribut specif languag extens propos dataparallel languag vienna fortran hpf improv handl spars irregular comput featur enabl translat code use typic spars code techniqu without necess rewrit show detail code may translat result code retain signific featur sequenti spars applic particular save memori comput typic techniqu retain lead high effici run time data distribut design retain data local appropri support good load balanc avoid memori wastag compil time run time support translat structur permit spars represent data processor parallel system languag extens requir minim yet suffici provid compil addit inform need translat optim number typic code kernel shown paper demonstr limit amount effort requir port sequenti code kind extend hpf vienna fortran result demonstr data distribut languag featur propos suppli enough inform store access data distribut memori well perform compil optim bring great save term memori commun overhead lowlevel support spars problem describ propos implement optim compil perform translat compil improv function dataparallel languag irregular comput overcom major weak field runtim techniqu use context inspectorexecutor paradigm howev set lowlevel primit differ use sever exist implement order take advantag addit semant inform avail approach particular runtim analysi abl translat multipl indirect array access singl phase make use expens translat tabl final result optim compil abl gener effici parallel code comput close expect manual parallel much faster comparison exist tool area r schedul spars matrixvector multipl massiv parallel dap comput partit strategi nonuniform problem multiprocessor automat data structur select transform spars matrix comput massiv parallel method engin scienc problem vienna fortran compil system program vienna fortran user defin map vienna for tran extend hpf advanc data parallel applic index array flatten program transform user guid harwellbo spars matrix collect fortran languag specif comput solut larg spars posit definit sy tem high perform languag specif numer experi partit unstructur mesh structur parafras advanc parallel compil c fortran data distribut spars matrix vector multipl solver parallel algorithm eigenvalu comput spars matric effici resolut spars indirect dataparallel compil evalu parallel techniqu spars applic vienna fortran languag specif version tr ctr chunyuan lin yehch chung jenshiuh liu effici data compress method multidimension spars array oper base ekmr scheme ieee transact comput v n p decemb rongguey chang tyngruey chuang jenq kuen lee effici support parallel spars comput array intrins function fortran proceed th intern confer supercomput p juli melbourn australia gerardo bandera manuel ujaldn emilio l zapata compil runtim support parallel spars matrix updat algorithm journal supercomput v n p nov manuel ujaldon emilio l zapata effici resolut spars indirect dataparallel compil proceed th intern confer supercomput p juli barcelona spain roxan adl marc aiguier franck delaplac toward automat parallel spars matrix comput journal parallel distribut comput v n p march v blanco p gonzlez j c cabaleiro d b hera t f pena j j pombo f f rivera perform predict parallel iter solver journal supercomput v n p may chunyuan lin yehch chung data distribut scheme spars array distribut memori multicomput journal supercomput v n p juli bradford l chamberlain lawrenc snyder array languag support parallel spars comput proceed th intern confer supercomput p june sorrento itali chunyuan lin yehch chung jenshiuh liu effici data distribut scheme ekmrbas spars array distribut memori multicomput journal supercomput v n p decemb m garz i garca approach base permut partit spars matric multiprocessor journal supercomput v n p octob thoma l sterl han p zima gilgamesh multithread processorinmemori architectur petaflop comput proceed acmiee confer supercomput p novemb baltimor maryland ali pinar cevdet aykanat fast optim load balanc algorithm partit journal parallel distribut comput v n p august bradford l chamberlain steven j deitz lawrenc snyder compar studi na mg benchmark across parallel languag architectur proceed acmiee confer supercomput cdrom pe novemb dalla texa unit state ken kennedi charl koelbel han zima rise fall high perform fortran histor object lesson proceed third acm sigplan confer histori program languag p june san diego california