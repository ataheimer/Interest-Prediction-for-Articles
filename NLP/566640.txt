t ray trace programm graphic hardwar a recent breakthrough occur graphic hardwar fix function pipelin replac programm vertex fragment processor near futur graphic pipelin like evolv gener programm stream processor capabl simpli feedforward triangl renderingin paper evalu trend programm graphic pipelin explain ray trace map graphic hardwar use simul analyz perform ray cast implement next gener programm graphic hardwar addit compar perform differ nonbranch programm hardwar use multipass implement architectur support branch also show approach applic ray trace algorithm whit ray trace path trace hybrid render algorithm final demonstr ray trace graphic hardwar could prove faster cpu base implement well competit tradit hardwar acceler feedforward triangl render b introduct realtim ray trace goal computergraph commun mani year recent vlsi technolog reach point raw comput capabl singl chip suffici realtim ray trace realtim ray trace demonstr small scene singl generalpurpos cpu simd float point extens wald et al b larger scene share memori multiprocessor parker et al parker et al cluster wald et al b wald et al a variou effort way develop chip special ray trace ray trace chip acceler offlin render commerci avail hall given realtim ray trace possibl near futur worthwhil studi implement differ architectur goal provid maximum perform lowest cost current nvidia corpor tpurcel ianbuck billmark hanrahangraphicsstanfordedu paper describ altern approach realtim ray trace potenti perform cpubas algorithm without requir fundament new hardwar use commod programm graphic hardwar implement ray trace graphic hardwar recent evolv fixedfunct graphic pipelin optim render texturemap triangl graphic pipelin programm vertex fragment stage nearterm next year two graphic processor gpu fragment program stage like gener includ float point comput complet orthogon instruct set capabl demand programm use current hardwar show capabl also suffici us write complet ray tracer hardwar programm stage becom gener hardwar consid generalpurpos stream processor stream process model support varieti highlyparalleliz algo rithm includ ray trace recent year perform graphic hardwar increas rapidli cpu cpu design optim high perform sequenti code becom increasingli difficult use addit transistor improv perform code contrast programm graphic hardwar optim highlyparallel vertex fragment shade code lindholm et al result gpu use addit transistor much effect cpu thu sustain greater rate perform improv semiconductor fabric technolog advanc converg three separ trend suffici raw perform singlechip realtim ray trace increas gpu programm faster perform improv gpu cpu make gpu attract platform realtim ray trace gpubas ray trace also allow hybrid render algorithm eg algorithm start zbuffer render pass visibl use ray trace secondari shadow ray blur line tradit triangl render ray trace allow natur evolut toward increas realism paper show effici implement ray trace gpu paper contain three main contribut show ray trace map stream process model parallel comput part map ping describ effici algorithm map innermost raytriangl intersect loop multipl render pass show basic ray caster extend includ shadow reflect path trace analyz stream gpubas ray caster perform show competit current cpubas ray cast also show initi result system includ secondari ray believ near futur gpubas ray trace much faster cpubas ray trace guid futur gpu implement analyz comput memori bandwidth requir ray cast gpu studi two basic architectur one architectur without branch requir multipl pass anoth branch requir singl pass show singl pass version requir significantli less bandwidth computelimit also analyz perform textur cach use ray cast show effect reduc bandwidth programm graphic hardwar current programm graphic pipelin applic vertex program raster fragment program display figur programm graphic pipelin diagram modern graphic pipelin shown figur today graphic chip nvidia geforc nvidia ati radeon ati replac fixedfunct vertex fragment includ textur stage programm stage programm vertex fragment engin execut userdefin program allow fine control shade textur calcul nvidia vertex program consist way simd float point instruct lind holm et al vertex program run incom vertex comput result pass raster stage fragment stage also programm either nvidia regist combin spitzer directx pixel shader mi crosoft pixel shader like vertex program provid way simd instruct set augment instruct textur unlik vertex program oper fixedpoint valu pa per primarili interest programm fragment pipelin design oper system fill rate approxi mate billion fragment per second programm shade recent innov current hardwar mani limit vertex fragment program simpl incomplet instruct set fragment program instruct set much simpler vertex instruct set fragment program data type mostli fixedpoint input textur output framebuff color typic bit per color compon intermedi valu regist slightli precis mani resourc limit program limit number instruct small number regist stage limit number input output eg number output vertex stage constrain number vertex interpol number activ textur number depend textur limit current hardwar permit certain instruct comput textur address certain point within program exampl directx ps pixel shader two stage first textur address stage consist four textur fetch instruct follow eight color blend instruct color comput stage consist addit textur fetch follow color combin arithmet program model permit singl level depend textur singl color valu may written framebuff pass program cannot loop condit branch instruct propos nearterm programm graphic pipelin limit current hardwar make difficult implement ray trace fragment program fortun due interest programm shade mainstream game applic programm pipelin rapidli evolv mani hardwar softwar vendor circul propos futur hardwar fact mani current limit mere result fact repres first gener programm hardwar paper show implement ray tracer extend hardwar model think approxim hardwar avail next year two model base loos propos microsoft directx marshal dlab opengl dlab target baselin architectur follow featur programm fragment stage float point instruct regist also assum float point textur framebuff format enhanc fragment program assembl instruct includ instruct avail vertex level furthermor allow longer program long enough basic ray trace compon may download singl program our longest program order instruct textur lookup allow anywher within fragment pro gram limit number textur fetch level textur depend within program multipl output allow float point rgba vector written framebuff fragment pro gram also assum fragment program render directli textur stencil buffer consid enhanc natur evolut current graphic hardwar alreadi mention featur activ consider variou vendor heart effici ray trace implement abil travers acceler structur test intersect ray list triangl abil requir loop construct note architectur includ datadepend condit branch instruct set despit limit program loop condit map baselin architectur use multipass render techniqu present peerci et al implement condit use techniqu condit predic first evalu use sequenc render pass stencil bit set true fals depend result bodi condit evalu use addit render pass valu written framebuff correspond fragment stencil bit true although algorithm develop fixedfunct graphic pipelin extend use programm pipelin assum addit two hardwar featur make peerci et al algorithm effici direct set stencil bit earli fragment kill similar z occlus cull kirk standard opengl pipelin stencil bit may set test alpha valu alpha valu comput fragment program written framebuff set stencil bit comput alpha valu requir addit pass sinc fragment program baselin architectur modifi stencil valu directli elimin extra pass anoth import render optim earli fragment kill fragment kill depth stencil test execut fragment program stage fragment program execut fragment pass stencil test stencil bit fals instruct execut textur framebuff bandwidth use except read bit stencil valu use combin two techniqu multipass render use larg fragment program control stencil buffer quit effici see ray trace involv signific loop although render pass effici extra pass still cost pass consum extra bandwidth read write intermedi valu textur each pass also requir bandwidth read stencil valu thu fewer resourc would use inner loop voxel triangl coalesc singl pass obviou way would add branch fragment process hardwar howev ad support branch increas complex gpu hardwar nonbranch gpu may use singl instruct stream feed sever fragment pipelin simultan simd comput gpu support branch requir separ instruct stream process unit mimd comput therefor graphic architect would like avoid branch possibl concret exampl trade off evalu effici ray cast two architec ture one one without branch multipass architectur support arbitrari textur read floatingpoint textur framebuff format gener float point instruct two float point vector output branch implement via multipass render branch architectur multipass architectur enhanc includ support condit branch instruct loop control flow stream graphic processor abstract graphic processor evolv includ complet instruct set larger data type appear like generalpurpos processor howev challeng introduc programm without compromis perform otherwis gpu would becom like cpu lose costperform advantag order guid map new applic graphic architectur propos view nextgener graphic hardwar stream processor stream process new idea media processor transform stream digit inform mpeg video decod imagin processor exampl generalpurpos stream processor khailani et al stream comput differ tradit comput system read data requir comput sequenti stream element element stream record data requir similar comput system execut program kernel element input stream place result output stream sens programm graphic processor execut vertex program stream vertic fragment program stream fragment sinc part ignor vertex program raster treat graphic chip basic stream fragment processor stream model comput lead effici implement three reason first sinc stream element comput independ other design add addit pipelin process element stream parallel second kernel achiev high arithmet intens is perform lot comput per small fixeds record result comput memori bandwidth ratio high third stream hardwar hide memori latenc textur fetch use prefetch torborg kajiya anderson et al igehi et al hardwar fetch textur frag ment fragment regist place fifo fragment processor start process anoth fragment textur fetch processor return fragment method hide latenc similar multithread alverson et al work abund parallel stream sum mari stream model allow graphic hardwar exploit par allel util bandwidth effici hide memori la tenci result graphic hardwar make effici use vlsi resourc challeng map ray trace onto stream model comput done break ray tracer kernel kernel chain togeth stream data origin data store textur framebuff stream ray trace section show reformul ray trace stream comput flow diagram stream ray tracer found figur gener eye ray travers acceler structur intersect triangl grid triangl list offset camera triangl triangl list shade hit gener shade ray materi normal figur stream ray tracer paper assum scene geometri repres triangl store acceler data structur render begin typic scenario applic would specifi scene geometri use display list graphic librari would place display list geometri acceler data structur consid cost build data structur sinc may expens oper assumpt impli algorithm describ paper may effici dynam scene second design decis use uniform grid acceler ray trace mani possibl acceler data structur choos from bound volum hierarchi bsp tree k tree octre uniform grid adapt grid hierarch grid etc chose uniform grid two reason first mani experi perform use differ acceler data structur differ scene for excel recent studi see havran et al studi singl acceler data structur appear effici appear within factor two other second uniform grid particularli simpl hardwar implement access grid data structur requir constant time hierarch data structur contrast requir variabl time per access involv pointer chase code grid travers also simpl highli optim hardwar system grid repres textur map memori organ current support graphic hardwar discuss pro con grid section split stream ray tracer four kernel eye ray gener grid travers raytriangl intersect shad ing eye ray gener kernel produc stream view ray view ray singl ray correspond pixel imag travers kernel read stream ray produc eye ray gener travers kernel step ray grid ray encount voxel contain triangl ray voxel address output pass intersect kernel intersect kernel respons test ray intersect triangl contain voxel intersector two type output raytriangl intersect hit occur voxel ray triangl hit output shade hit occur ray pass back travers kernel search voxel contain triangl continu shade kernel comput color ray termin hit color written accumul imag addit shade kernel may gener shadow secondari ray case new ray pass back travers stage implement ray trace kernel fragment program execut program render screensiz rectangl constant input place within kernel code stream input fetch screenalign textur result kernel written back textur stencil buffer control fragment screensiz rectangl screenalign textur activ bit stencil valu associ ray contain ray state ray state travers intersect shad ing done specifi correct stencil test render pass allow kernel run ray particular state follow section detail implement ray trace kernel memori layout scene describ sever variat includ ray cast whit ray trace whit path trace shadow cast ray trace kernel eye ray gener eye ray gener simplest kernel ray tracer given camera paramet includ viewpoint view direct comput eye ray screen pixel fragment program invok pixel screen gener eye ray each eye ray gener also test ray scene bound box ray intersect scene bound box process fur ther miss termin travers travers stage search voxel contain triangl first part travers stage set travers calcul second part step along ray enumer voxel pierc ray travers equival line draw perray setup cost pervoxel raster cost use ddda algorithm fujimoto et al travers step kernel queri grid data structur store textur grid contain null pointer voxel empti pointer null voxel contain triangl case rayvoxel pair output ray mark test intersect triangl voxel implement travers loop multipass architectur requir multipl pass per ray setup done two pass step voxel requir addit pass end pass fragment program must store step paramet use within loop textur must read next pass discuss multipass implement discuss intersect stage triangl textur vertex triangl list textur textur grid z x z x z x z x z x z x z x z x z x v z x z x z x z x z x z x figur grid triangl data structur store textur memori grid cell contain pointer list triangl pointer null triangl store voxel grid store textur triangl list store anoth tex ture voxel contain triangl point begin triangl list triangl list textur triangl list consist set pointer vertex data end triangl list indic null pointer final vertex posit store textur intersector triangl intersect stage take stream rayvoxel pair output raytriangl hit perform raytriangl intersect test triangl within voxel hit occur raytriangl pair pass shade stage code comput singl raytriangl intersect shown figur code similar use carr et al directx ps raytriangl intersector discuss system section triangl overlap multipl grid cell possibl intersect point lie outsid current voxel intersect kernel check case treat miss note reject intersect way may caus ray test triangl multipl time in differ voxel possibl use mailbox algorithm prevent extra intersect calcul amanatid woo mailbox difficult implement multipl ray trace parallel layout grid triangl textur memori shown figur mention abov voxel contain offset trianglelist textur trianglelist textur contain delimit list offset trianglevertex textur note triangl list textur trianglevertex textur textur fact textur use randomaccess readonli memori repres integ offset compon float point textur vertex posit three float point rgb textur thu theoret four billion triangl could address textur memori bit integ address howev much less textur memori actual avail current graphic card limit size textur overcom use textur gener find intersect shade hit shadow ray gener shade hit find nearest intersect eye ray gener shade hit find nearest intersect eye ray gener shade hit find nearest intersect eye raysshadow caster ray caster whit ray tracer path tracer a b c d figur data flow diagram ray trace algorithm implement algorithm depict a shadow cast b ray cast c whit ray trace d path trace ray trace raysurfac intersect gener l ray l number light scene correspond number shadow ray test two reflect refract ray path trace randomli choos one ray bounc follow feedback path one ray wide list po float h float list po trilist float float float return float t u v id figur code raytriangl intersect proper address translat well segment data across multipl textur travers stage inner loop triangl voxel involv multipl pass ray requir singl pass per raytriangl intersect shader shade kernel evalu color contribut given ray hit point shade calcul exactli like standard graphic pipelin shade data store memori much like triangl data set three rgb textur bit per channel contain vertex normal vertex color triangl hit inform pass shader includ triangl number access shade inform simpl depend textur lookup particular triangl specifi choos differ shade ray implement sever flavor ray trace use stream algorithm look ray cast whittedstyl ray trace path trace shadow cast figur show simplifi flow diagram method discuss along exampl imag produc system shade kernel option gener shadow reflect re fraction randomli gener ray secondari ray place textur locat futur render pass ray also assign weight final termin contribut final imag may simpli ad imag kajiya techniqu assign weight ray elimin recurs simplifi control flow ray caster ray caster gener imag ident gener standard graphic pipelin pixel screen eye ray gener ray fire scene return color nearest triangl hit secondari ray gener includ shadow ray previou effort implement interact ray trace focus type comput serv basic implement whit ray tracer classic whittedstyl ray tracer whit gener eye ray send scene upon find hit reflect model surfac evalu pair reflect refract ray set shadow ray one per light sourc gener sent scene path tracer path trace ray randomli scatter surfac hit light sourc path tracer emul arnold render fajardo one path gener per sampl path contain bounc shadow caster simul hybrid system use standard graphic pipelin perform hidden surfac calcul first pass use ray trace algorithm evalu shadow shadow cast use replac shadow map shadow volum shadow volum extrem expens comput shadow map tend difficult set proper resolut shadow caster view defer shade pass molnar et al shadow caster pass gener shadow ray light sourc add light contribut final imag blocker found multipass branch kernel instr memori word stencil instr memori word count r w rs ws count r w gener eye ray travers intersect shade shadow reflect path tabl ray trace kernel summari show number instruct requir implement kernel along number bit word memori must read written render pass r w number memori word read randomaccess textur m two set statist shown one multipass architectur anoth branch architectur multipass architectur also show number bit stencil read rs write ws kernel stencil read overhead charg ray whether kernel execut not implement evalu comput bandwidth requir stream ray tracer implement kernel assembl languag fragment program nvidia vertex program instruct set use fragment program addit instruct describ previous assembl languag implement provid estim number instruct requir kernel invoc also calcul bandwidth requir kernel break bandwidth stream input bandwidth stream output bandwidth memori random access read bandwidth tabl summar comput bandwidth requir kernel ray tracer multipass branch architectur travers intersect kernel involv loop count setup loop bodi shown separ branch architectur allow us combin individu kernel togeth result branch kernel slightli smaller sinc initi termin instruct remov branch architectur permit kernel run togeth within singl render pass use tabl comput total comput bandwidth cost scene r total number ray trace c r cost gener ray c v cost walk ray voxel c cost perform raytriangl intersect c cost shade p total number render pass c stencil cost read stencil buffer total cost associ stage determin number time kernel invok number depend scene statist v averag number voxel pierc ray averag number triangl intersect ray averag number shade calcul per ray branch architectur stencil buffer check c stencil zero multipass architectur must pay stencil read cost ray render pass cost ray tracer variou scene present result section final present optim minim total number pass motiv part delani implement ray tracer connect machin delani travers intersect kernel involv loop variou strategi nest loop simplest algorithm would step voxel ray encount voxel contain triangl intersect ray triangl how ever strategi would ineffici sinc intersect ray encount voxel triangl simd machin like connect machin result low processor util graphic hardwar yield excess number pass result larg number stencil read oper domin perform follow effici algorithm gener eye ray anyactiveray oracleray traverseray els eye ray gener ray tracer enter loop test whether ray activ activ ray requir either travers intersect inact ray either hit triangl travers entir grid pass oracl call oracl choos whether run travers intersect pass variou oracl possibl simpl algorithm run intersect pass ray requir intersect test better oracl first propos delani choos pass perform work done calcul percentag ray requir intersect vs travers experi found perform intersect ray requir intersect test produc minim number pass within factor two three optim simd algorithm perform singl comput per render pass implement oracl assum graphic hardwar maintain small set counter stencil buffer contain state ray total eight counter one per stencil bit would suffici need sinc four state altern could use opengl histogram oper oracl oper implement high perform stencil buffer methodolog implement function simul stream ray tracer multipass branch architectur simul high level simul architectur written c program languag simul comput imag gather scene statist exampl statist includ averag number travers step taken per ray averag number hall outsid soda hall insid forest top forest insid bunni ray cast figur fundament scene statist test scene statist shown match cost model formula present section recal v averag number voxel pierc ray averag number triangl intersect ray averag number shade calcul per ray soda hall m triangl forest m triangl stanford bunni k triangl scene render x pixel raytriangl intersect test perform per ray multipass architectur simul also track number type render pass perform well stencil buffer activ statist allow us comput cost render scene use cost model describ section multipass branch architectur simul gener trace file memori refer stream process textur cach simul cach simul use kb directmap textur cach byte line size line size hold four float point rgb texel three float point rgba texel wast space execut order fragment program effect cach behavior execut kernel though singl pixel wide graphic pipelin like gpu implement includ multipl parallel fragment pipelin execut concurr thu access interleav architectur specifi level detail therefor abl take effect account cach simul analyz perform ray tracer five viewpoint three differ scene shown figur soda hall rel complex model use evalu realtim ray trace system wald et al b wall made larg polygon furnish made small polygon scene high depth complex forest scene includ tree million tini triangl scene moder depth complex difficult perform occlus cull analyz cach behavior shadow reflect ray use scene bunni chosen demonstr extens ray tracer support shadow reflect path trace figur show comput bandwidth requir test scene comput bandwidth util broken kernel graph clearli show comput bandwidth architectur domin grid travers triangl intersect choos optim grid resolut scene difficult finer grid yield fewer raytriangl intersect test lead travers step coarser grid reduc number travers step increas number raytriangl intersect test attempt keep voxel near cubic shape specifi grid resolut minim grid dimens accept along dimens scene bound box bunni minim grid dimens yield final resolut larger soda hall forest model minim dimens yield grid resolut respect resolut allow algorithm spend equal amount time travers intersect kernel outsid insid hall top insid forest bunni ray cast ginstruct intersector travers othersgbyt multipass outsid insid hall top insid forest bunni ray castginstruct intersector travers other gbyte branch figur comput bandwidth usag scene column show contribut kernel left bar plot comput right bandwidth horizont line repres persecond bandwidth comput perform hypothet architectur scene render pixel architectur comparison compar multipass branch architectur first investig implement ray caster multipass architectur tabl show total number render pass distribut pass amongst variou kernel total number pass vari although number pass seem high total number need render scene convent graphic pipelin mani fewer per object use mani object drawn system pass draw singl rectangl speed geometri process part pipelin factor also evalu effici multipass algorithm recal ray may travers intersect shade done effici pass depend percentag ray process pass scene effici test scene except outsid view soda hall pass breakdown per ray maximum simd total travers intersect travers intersect effici hall outsid hall insid forest top forest insid bunni ray cast tabl breakdown pass multipass system intersect travers make bulk pass system rest pass come ray gener travers setup shade also show maximum number travers step intersect test per ray final simd effici measur averag fraction ray use work given pass outsid insid hall top insid forest bunni ray castgbyt stencil state variabl data structur figur bandwidth consumpt data type left bar multipass right bar branch overhead read bit stencil valu shown top state variabl data written read textur pass data structur bandwidth come readonli data triangl triangl list grid cell shade data scene render pixel viewpoint contain sever ray miss scene bound box entir expect result effici much lower sinc ray never use work rest compu tation although effici may seem low fragment processor util much higher use earli fragment kill avoid consum comput resourc nonstencil bandwidth fragment final tabl show maximum number travers step intersect test perform per ray sinc total number pass depend worst case ray number provid lower bound number pass need multipass algorithm interleav travers intersect pass come within factor two three optim number render pass naiv algorithm perform intersect soon ray hit full voxel requir least factor five time pass optim scene readi compar comput bandwidth requir test scene two architectur figur show bandwidth measur shown figur broken data type instead kernel graph show that ex pect bandwidth requir branch architectur read voxel triangl data structur memori multipass architectur convers use bandwidth write read intermedi valu textur memori pass similarli save restor intermedi requir extra instruct addit signific bandwidth devot read stencil buffer extra comput bandwidth consumpt fundament limit multipass algorithm one way reduc number render pass bandwidth consum intermedi valu multipass architectur unrol inner loop present data outsid insid hall top insid forest bunni ray cast shadow reflect forestnorm bandwidth stencil state variabl voxel data triangl data shade data figur ratio bandwidth textur cach bandwidth without textur cach left bar multipass right bar branch within bar bandwidth consum textur cach broken data type scene render pixel singl travers step singl intersect test perform per ray render pass instead unrol kernel perform four travers step two intersect test test scene reduc total bandwidth usag assum suppress triangl voxel memori refer ray finish middl pass total bandwidth reduct reach time total instruct count requir render scene increas less aggress loop unrol bandwidth save continu total instruct count increas vari factor two scene result indic loop unrol make overhead inher multipass architectur unrol achiev comput bandwidth ratio obtain branch architectur final compar cach behavior two implemen tation figur show bandwidth requir textur cach use bandwidth consumpt normal divid noncach bandwidth report earlier inspect graph see multipass system benefit much textur cach bandwidth use stream data particular either stencil buffer intermedi result sinc data uniqu kernel in vocat reus contrast branch architectur util textur cach effect sinc bandwidth devot read share data structur reus studi cach behavior triangl data onli see hit rate achiev multipass branch system high hit rate suggest triangl data cach well fairli small work set size summari implement ray caster multipass architectur achiev good balanc comput bandwidth ratio instruct count bandwidth match capabl modern gpu exampl rel extens instruct bandwidth shadow caster whit ray tracer path tracer tabl number instruct amount bandwidth consum extend algorithm render bunni scene use branch architectur normal ray cast cost nvidia geforc abl execut approxim g instruc tionss fragment processor roughli gb memori bandwidth expand travers intersect kernel perform multipl travers step intersect test per pass reduc bandwidth requir scene cost increas comput requir amount loop unrol chang match comput bandwidth capabl underli hardwar comparison branch architectur consum fewer instruct significantli less bandwidth result branch architectur sever computelimit base today gpu bandwidth comput rate howev branch architectur becom attract futur comput bandwidth ratio graphic chip increas introduct parallel fragment pipelin extend algorithm effici ray caster place implement extens shadow cast full whit ray trace path trace quit simpl method util raytriangl intersect loop analyz ray caster implement differ shade kernel gener new ray fed back system figur show imag bunni produc system ray cast extens simul total cost render scene depend number ray trace cach perform tabl show number instruct bandwidth requir produc imag bunni rel ray cast cost use branch architectur path trace bunni render pixel sampl bounc per pixel other render pixel ray cast bunni find valid hit pixel henc primari ray gener secondari ray ray equal one would expect shadow caster consum instruct bandwidth ray caster likewis path tracer would consum time ray caster note instruct usag close expect valu bandwidth consum more addit secondari ray cach well eye ray due gener incoher natur last two column figur illustr cach effect secondari ray measur separ primari ray test render insid forest scene two differ style shadow render three light sourc hit produc three shadow ray reflect appli two bounc reflect singl light sourc shade model primit scene multipass render system textur cach unabl reduc total bandwidth consum system stream data destroy local present triangl voxel data branch architectur result demonstr scene secondari ray benefit cach system achiev bandwidth reduct shadow comput howev cach reflect forest reduc requir band width current investig way improv perform system secondari ray section discuss limit current system futur work acceler data structur major limit system reli preprocess step build grid mani applic contain dynam ge ometri support applic need fast increment updat grid build acceler data structur dynam scene activ area research reinhard et al interest possibl would use graphic hardwar build acceler data structur graphic hardwar could scan convert geometri grid howev architectur studi paper cannot effici oper like raster within fragment processor would need abil write arbitrari memori locat classic scatter oper would move hardwar even closer gener stream processor research assum uniform grid uniform grid how ever may fail scene contain geometri empti space mani level detail sinc view textur memori randomaccess memori hierarch grid could ad system current graphic board contain rel small amount memori in typic board contain mb scene look requir mb mb textur memori store scene interest direct futur work would studi hierarch cach geometri commonli done textur trend toward unifi system graphic memori may ultim elimin problem cpu vs gpu wald et al develop optim ray tracer pc simd float point extens wald et al b mhz pentium iii report raytriangl intersect rate intersectionss carr et al achiev raytriangl inter sectionss ati radeon use limit fix point preci sion assum propos hardwar ran speed geforc g instructionss could comput raytriangl intersectionss branch architectur comput limit increas instruct issu rate factor four g in structionss would still use bandwidth avail geforc gb would allow us comput ray triangl intersect per second believ inher parallel natur fragment program number gpu instruct execut per second increas much faster number cpu simd instruct basic feasibl ray trace gpu demonstr interest consid modif gpu support ray trace effici mani possibl immedi suggest themselv sinc ray stream system would effici store stream buffer textur map would elimin need stencil buffer control condit execut stream buffer quit similar fbuffer use multipass render mark proudfoot current implement grid travers code map well vertex program instruct set thu quit ineffici sinc grid travers similar raster might possibl modifi raster walk grid final vertex program instruct set could optim raytriangl intersect could perform fewer instruct carr et al independ develop method use gpu acceler ray trace system gpu use acceler raytriangl intersect test system gpu memori use hold state mani activ ray system triangl turn fed gpu test intersect activ ray system differ store scene triangl grid gpu store acceler structur cpu also run entir ray tracer gpu system much effici sinc elimin gpucpu commun bottleneck tile render multipass architectur major memori bandwidth consum save restor temporari variabl sinc stream temporari use onc bandwidth save due cach unfortun stream variabl access textur displac cacheabl data structur size cach use larg enough store work set includ temporari variabl data structur best way deal problem separ stream variabl cacheabl variabl anoth solut problem break imag small tile tile render complet proceed next tile tile reduc work set size tile size chosen work set fit cach stream variabl displac cacheabl data structur perform preliminari experi along line result encourag conclus shown view programm graphic processor gener parallel comput devic help us leverag graphic processor perform curv appli gener parallel comput specif ray trace shown ray cast done effici graphic hardwar hope encourag graphic hardwar evolv toward gener programm stream architectur mani believ fundament differ architectur would requir realtim ray trace hardwar work demonstr gradual converg ray trace feedforward hardwar pipelin possibl acknowledg would like thank everyon stanford graphic lab contribut idea work thank matt papakipo nvidia thought next gener graphic hardwar kurt akeley review comment kati tillman stay late help edit would like thank hanspet pfister merl addit support work sponsor darpa contract dabtc mdaca ati nvidia soni sun r tr artscceler raytrac system render equat ray trace connect machin pixelflow highspe render use imag composit talisman tera comput system accommod memori latenc lowcost raster prefetch textur cach architectur interact ray trace isosurfac render interact ray trace interact multipass programm shade improv illumin model shade display userprogramm vertex engin fbuffer dynam acceler structur interact ray trace interact distribut ray trace highli complex model ctr edgar velzquezarmendriz eugen lee kavita bala bruce walter implement render cach edgeandpoint imag graphic hardwar proceed confer graphic interfac june quebec canada manfr weiler martin krau marku merz thoma ertl hardwarebas ray cast tetrahedr mesh proceed th ieee visual vi p octob h du m sanchezelez n tabrizi n bagherzadeh m l anido m fernandez interact ray trace reconfigur simd morphosi proceed confer design autom test europ design forum p march h du m sanchezelez n tabrizi n bagherzadeh m l anido m fernandez interact ray trace reconfigur simd morphosi proceed confer asia south pacif design autom januari kitakyushu japan anton l fuhrmann robert f tobler stefan maierhof realtim glossi reflect planar surfac proceed rd intern confer comput graphic virtual realiti visualis interact africa novemb stellenbosch south africa christian hen peter stephenson acceler ray trace height field proceed nd intern confer comput graphic interact techniqu australasia south east asia june singapor pradeep sen mike cammarano pat hanrahan shadow silhouett map acm transact graphic tog v n juli chihchang chen damon shingmin liu use hardwar zbuffer raster acceler ray trace proceed acm symposium appli comput march seoul korea nathan a carr jare hoberock keenan crane john c hart fast gpu ray trace dynam mesh use geometri imag proceed confer graphic interfac june quebec canada daniel reiter horn jeremi sugerman mike houston pat hanrahan interact kd tree gpu raytrac proceed symposium interact graphic game april may seattl washington victor moya carlo gonzalez jordi roca agustin fernandez roger espasa shader perform analysi modern gpu architectur proceed th annual ieeeacm intern symposium microarchitectur p novemb barcelona spain j stewart e p bennett l mcmillan pixelview viewindepend graphic render architectur proceed acm siggrapheurograph confer graphic hardwar august grenobl franc jingyi yu jason yang leonard mcmillan realtim reflect map parallax proceed symposium interact graphic game april washington district columbia kaoru sugita takeshi naemura hiroshi harashima perform evalu programm graphic hardwar imag filter stereo match proceed acm symposium virtual realiti softwar technolog octob osaka japan tim foley mike houston pat hanrahan effici partit fragment shader multipleoutput hardwar proceed acm siggrapheurograph confer graphic hardwar august grenobl franc christoph cassagnabr franoi roussel christoph renaud path trace use ar processor proceed nd intern confer comput graphic interact techniqu australasia south east asia june singapor karl e hillesland sergey molinov radek grzeszczuk nonlinear optim framework imagebas model programm graphic hardwar acm transact graphic tog v n juli karl e hillesland sergey molinov radek grzeszczuk nonlinear optim framework imagebas model programm graphic hardwar acm siggraph cours juli august f losasso h hopp s schaefer j warren smooth geometri imag proceed eurographicsacm siggraph symposium geometri process june aachen germani peiji huang wencheng wang gang yang enhua wu travers field ray trace dynam scene proceed acm symposium virtual realiti softwar technolog novemb limassol cypru xianfeng gu song zhang peisen huang liangjun zhang shingtung yau ralph martin holoimag proceed acm symposium solid physic model june cardiff wale unit kingdom a kolb l latta c rezksalama hardwarebas simul collis detect larg particl system proceed acm siggrapheurograph confer graphic hardwar august grenobl franc acceler structur gpu raytrac proceed acm siggrapheurograph confer graphic hardwar juli lo angel california chri wyman scott davi interact imagespac techniqu approxim caustic proceed symposium interact graphic game march redwood citi california sudipto guha shankar krishnan kamesh munagala suresh venkatasubramanian applic twosid depth test csg render proceed symposium interact graphic april monterey california nathan cournia chessboard domin programm graphic hardwar proceed th annual southeast region confer march melbourn florida nathan a carr jess d hall john c hart gpu algorithm radios subsurfac scatter proceed acm siggrapheurograph confer graphic hardwar juli san diego california ingo wald carsten benthin philipp slusallek distribut interact ray trace dynam scene proceed ieee symposium parallel largedata visual graphic p octob lionel baboud xavier dcoret render geometri relief textur proceed confer graphic interfac june quebec canada nolan goodnight cliff woolley gregori lewin david luebk greg humphrey multigrid solver boundari valu problem use programm graphic hardwar proceed acm siggrapheurograph confer graphic hardwar juli san diego california anthoni sherbondi mike houston sandi napel fast volum segment simultan visual use programm graphic hardwar proceed th ieee visual vi p octob yuan zhou michael garland robert haber pixelexact render spacetim finit element solut proceed confer visual p octob abhinav dayal cliff woolley benjamin watson david luebk adapt frameless render acm siggraph cours juli august nolan goodnight cliff woolley gregori lewin david luebk greg humphrey multigrid solver boundari valu problem use programm graphic hardwar acm siggraph cours juli august timothi j purcel craig donner mike cammarano henrik wann jensen pat hanrahan photon map programm graphic hardwar proceed acm siggrapheurograph confer graphic hardwar juli san diego california timothi j purcel craig donner mike cammarano henrik wann jensen pat hanrahan photon map programm graphic hardwar acm siggraph cours juli august ingo wald openrtapi acm siggraph cours juli august shihwei liao zhaohui du gansha wu gueiyuan lueh data comput transform brook stream applic multiprocessor proceed intern symposium code gener optim p march nathan a carr jess d hall john c hart ray engin proceed acm siggrapheurograph confer graphic hardwar septemb saarbrucken germani solomon boulo dave edward j dylan lacewel joe kniss jan kautz peter shirley ingo wald packetbas whit distribut ray trace proceed graphic interfac may montreal canada v singh d silver n cornea realtim volum manipul proceed eurographicsiee tvcg workshop volum graphic juli tokyo japan gregori s johnson juhyun lee christoph a burn william r mark irregular zbuffer hardwar acceler irregular data structur acm transact graphic tog v n p octob jrg schmittler ingo wald philipp slusallek saarcor hardwar architectur ray trace proceed acm siggrapheurograph confer graphic hardwar septemb saarbrucken germani greg coomb mark j harri anselmo lastra radios graphic hardwar proceed confer graphic interfac p may london ontario canada jrg schmittler sven woop daniel wagner wolfgang j paul philipp slusallek realtim ray trace dynam scene fpga chip proceed acm siggrapheurograph confer graphic hardwar august grenobl franc nolan goodnight rui wang cliff woolley greg humphrey interact timedepend tone map use programm graphic hardwar proceed th eurograph workshop render june leuven belgium ingo wald thiago ize andrew kensler aaron knoll steven g parker ray trace anim scene use coher grid travers acm transact graphic tog v n juli nolan goodnight rui wang cliff woolley greg humphrey interact timedepend tone map use programm graphic hardwar acm siggraph cours juli august feng liu scott owen ying zhu robert harrison iren weber web base molecular visual use procedur shader xd acm siggraph web program juli august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast comput databas oper use graphic processor acm siggraph cours juli august aaron e lefohn joe m kniss charl d hansen ross t whitak stream narrowband algorithm interact comput visual level set acm siggraph cours juli august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast comput databas oper use graphic processor proceed acm sigmod intern confer manag data june pari franc jen krger rdiger westermann linear algebra oper gpu implement numer algorithm acm siggraph cours juli august jen krger rdiger westermann linear algebra oper gpu implement numer algorithm acm transact graphic tog v n juli heiko friedrich johann gnther andrea dietrich michael scherbaum hanspet seidel philipp slusallek explor use ray trace futur game proceed acm siggraph symposium videogam p juli boston massachusett mark j harri greg coomb thorsten scheuermann anselmo lastra physicallybas visual simul graphic hardwar proceed acm siggrapheurograph confer graphic hardwar septemb saarbrucken germani jeff bolz ian farmer eitan grinspun peter schrder spars matrix solver gpu conjug gradient multigrid acm siggraph cours juli august jeff bolz ian farmer eitan grinspun peter schroder spars matrix solver gpu conjug gradient multigrid acm transact graphic tog v n juli vincent c h michael d mccool low latenc photon map use block hash proceed acm siggrapheurograph confer graphic hardwar septemb saarbrucken germani doug l jame kayvon fatahalian precomput interact dynam deform scene acm transact graphic tog v n juli r mark donald fussel realtim render system acm siggraph cours juli august ian buck tim foley daniel horn jeremi sugerman kayvon fatahalian mike houston pat hanrahan brook gpu stream comput graphic hardwar acm transact graphic tog v n august ingo wald solomon boulo peter shirley ray trace deform scene use dynam bound volum hierarchi acm transact graphic tog v n pe januari aaron e lefohn shubhabrata sengupta joe kniss robert strzodka john d owen glift gener effici randomaccess gpu data structur acm transact graphic tog v n p januari