t make graph reduc control node split a sever compil optim data flow analysi exploit instructionlevel parallel ilp loop transform memori disambigu requir program reduc control flow graph howev program satisfi properti new method transform irreduc control flow graph reduc control flow graph call control node split cn present cn duplic node control flow graph obtain reduc control flow graph cn result minimum number split minimum number duplic sinc comput time find optim split sequenc larg heurist develop result heurist close optimum straightforward applic node split result averag code size increas per procedur benchmark program cn heurist limit increas impact total code size complet program straightforward applic node split howev cn use heurist averag growth code size complet program dramat reduc b introduct current comput architectur improv obtain exploit instruct level parallel ilp ilp made possibl due higher transistor densiti allow duplic function unit data path exploit ilp consist map ilp applic onto ilp target architectur effici possibl map use long instruct word vliw superscalar architectur latter use workstat architectur may execut multipl oper per cycl effici usag requir compil fill instruct oper effici possibl process call schedul problem statement order find suffici ilp justifi cost multipl function unit data path schedul larger scope singl basic block time basic block sequenc consecut statement flow control enter begin leav alway end sever schedul scope found go beyond basic block level gener scope current use call region set basic block correspond bodi natur loop sinc loop nest region also nest other like natur loop region singl entri point the loop header may multipl exit speedup report extend schedul scope region problem region schedul requir loop control flow graph singl entri point flow graph call reduc flow graph fortun control flow graph reduc nevertheless problem irreduc flow graph cannot ignor exploit benefit region schedul irreduc control flow graph convert reduc control flow graph exploit ilp also requir effici memori disambigu accomplish nest loop must determin sinc irreduc flow graph nest loop clear memori disambigu techniqu cannot directli appli loop exploit benefit memori disambigu irreduc control flow graph convert reduc control flow graph well anoth pleasant properti reduc control flow graph fact data flow analysi essenti part compil done effici relat work problem convert irreduc flow graph reduc flow graph tackl frontend backend compil method normal control flow graph program frontend given method rewrit intermedi program normal form normal irreduc flow graph convert reduc one make graph reduc code duplic result larger code size sinc frontend unawar precis number machin instruct need translat piec code difficult minim growth code size anoth approach convert irreduc flow graph backend advantag select machinecod duplic one take result code size account solut solv problem backend given solut given cock miller time complex tri minim result code size method describ hecht et al even ineffici sens minim code size requir less analysi paper new method convert irreduc flow graph backend given effici term result code size paper overview section reduc irreduc flow graph defin method detect irreduc flow graph discuss principl node split convers method describ hecht et al straightforward applic node split given section approach control node split cn describ section known convers method convert irreduc flow graph without minim number copi control node split possibl minim number copi unfortun method requir much cpu time therefor develop heurist reduc cpu time still perform close optimum heurist algorithm control node split present result appli cn sever benchmark given section final conclus given section irreduc flow graph control flow program describ control flow graph control flow graph consist node edg node repres sequenc oper basic block edg repres flow control definit control flow graph program tripl n e finit direct graph n collect node e collect edg initi node n path everi node graph figur show exampl control flow graph node initi node s c e f c e f a b figur a reduc control flow graph b graph state introduct find suffici ilp requir input reduc flow graph mani definit reduc flow graph propos one adopt given base partit edg control flow graph g two disjoint set set back edg consist edg whose head domin tail set forward edg fe consist edg back edg thu node u flow graph domin node v everi path initi node flow graph v goe u domin relat figur are node domin node node domin node except node s node c domin node c d e f node domin node d e f therefor fg definit reduc flow graph is definit flow graph g reduc flow graph acycl everi node n n reach initi node s control flow graph figur reduc sinc acycl flow graph figur howev irreduc set back edg empti neither node node b domin other fe equal fs a s acycl definit deriv control flow graph g irreduc graph contain least one loop loop call irreduc loop remov irreduc loop must b figur basic irreduc control flow graph detect first sever method thi one use interv analysi method use hechtullman tt analysi method base two transform t transform illustr figur defin as definit let control flow graph let u n remov edg u u e selfloop edg exist deriv graph becom g short g u tu u figur definit let control flow graph let node v singl predecessor u transform consumpt node v node u successor edg node v becom successor edg node u origin successor edg node u preserv except edg node v set successor node v deriv graph g short g v definit graph result repeatedli appli transform possibl order flow graph flow graph result applic possibl call limit flow graph transform denot proven limit flow graph uniqu independ order transform appli theorem flow graph reduc repeatedli appli transform particular order flow graph reduc singl node proof theorem found exampl applic transform given figur flow graph figur reduc singl node conclud flow graph reduc f c c tc ta ta c e f e c f td te c f e f c tc figur exampl applic appli transform result flow graph consist multipl node graph irr ducibl transform detect irreduc also detect node caus irreduc exampl irreduc graph given figur theorem follow altern defin irreduc by corollari flow graph irreduc limit flow graph singl node anoth definit intuit flow graph irreduc least one loop multipl loop entri b c b c b c a b c d figur exampl extens basic irreduc control flow graph figur flow graph transform control flow graph occur irreduc graph transform techniqu use obtain reduc control flow graph past method given solv problem method convert irreduc control flow graph base techniqu call node split section techniqu reduc irreduc flow graph describ section show node split appli straightforwardli reduc irreduc graph node split node split techniqu convert graph g equival graph g assign label node graph label node x denot label duplic node creat new node label equival relat two flow graph deriv hecht given below definit path flow graph defin labelsp sequenc label correspond path is labelsp two flow graph g g equival if path p g path q g labelsp convers accord definit two flow graph figur equival note node labela node split defin as node split transform graph g graph g node n n multipl predecessor p split incom edg p n duplic n n made one incom edg p outgo edg n n defin n successor node n transform denot g split node n n principl node split illustr figur node graph g split note node n split limit graph correspond node n origin graph must split remov irreduc theorem equival relat two graph preserv transform g b b sa figur simpl exampl appli node split node a proof show node split transform graph g equival split graph g assum graph g node v n predecessor u successor w k shown figur a set labelsp path p graph g denot label g label notat path graph g figur describ k flabel label v label w k g a b figur two equival graph a node split b node split node v split n copi name v split graph g result set path graph g is k flabel label v graph given figur b sinc label v label v everi path g exist also g convers lead conclus graph g g equival sinc figur split node arbitrari number incom outgo edg may gener conclud split node graph result equival graph use reason clear equival relat transit split finit number node either origin graph equival graph result graph equival origin graph name node split decept suggest node split differ part fact node duplic uncontrol node split node split transform techniqu use convert irreduc control flow graph reduc control flow graph hecht adopt theorem theorem let denot split node let denot graph reduct transform eg control flow graph transform singl node transform repres regular express st proof theorem given hecht et al describ straightforward applic node split reduc irreduc control flow graph method select node split limit graph node multipl predecessor select node split sever ident copi one enter edg approach advantag rather simpl disadvantag select node split make graph reduc figur see node a b c candid node split figur b node split number node reduc applic two transform graph still irreduc split node neither make graph reduc see figur c split node b c convert graph reduc control flow graph see figur d although method ineffici node split transform irreduc control flow graph eventu reduc one consequ ineffici node split number duplic becom unnecessarili larg present control node split problem exist method result code size convert irreduc graph grow uncontrol control node split cn control amount copi result smaller growth code size cn restrict set candid node split first introduc necessari terminolog definit loop flow graph path n immedi successor n k set node contain loop call loopset figur fa bg fb cg fa b cg loopset definit immedi domin node u idu last domin path initi node graph u exclud node u itself b d c a a origin irreduc graph b split node c split node d split node b figur exampl node split figur node domin node a b c d e f immedi domin node b c definit share extern domin set sedset subset loopset l properti element share immedi domin immedi domin part loopset l sedset loopset l defin as definit maxim share extern domin set msedset k defin as sedset k maxim sedset m k ae definit say msedset cannot proper subset anoth sedset figur multipl sedset identifi like fa bg fb cg fa b cg one msedset fa b cg definit node sedset flow graph classifi three set ffl common node cn node domin sedset reachabl sedset domin ffl reachabl common node rc node domin sedset reachabl sed domin ffl normal node nn node sedset classifi one class node domin sedset initi graph figur identifi msedset fa bg c dg node a c element set nn node b element set rc edg c b present node b would element set cn note loop b c sedset theorem sedsetl one node correspond loop l singl header reduc proof theorem deriv exampl sedset one node graph figur transform section descript cn given treat method minim number node split section give method minim amount copi number copi equal number split split creat everi enter edg copi node n enter edg one split creat copi speed process minim amount copi heurist given algorithm implement heurist given section control node split node irreduc limit graph except initi node graph possibl candid node split sinc least two predecessor howev split node effici see section cn minim number split accomplish thi two restrict made set candid node restrict are node element sedset candid split node element rc candid split first restrict prevent split node sedset split node ineffici unnecessari exampl split shown figur figur b the sedset figur b fb cg second restrict complic impact restrict illustr figur figur show two differ sequenc node split initi graph figur graph appli figur three split need figur b two figur node b split node howev element set rc second restrict prevent split sequenc one figur a node split restrict altern eventu result singl node seen easili everi time node element sedset split reduc transform number node involv sedset decreas one sinc consid flow graph finit number node singl node eventu remain b c c a node split sequenc three node b node split sequenc two node c b c b figur graph two differ split graph theorem minimum number split need reduc msedset k node given by proof everi time node split appli number node msedset decreas one everi predecessor node split duplic made mean everi duplic one predecessor duplic reduc transform result msedset one node less origin msedset reduc complet msedset node one msedset must split one node left result k split theorem minimum number split need convert irreduc graph n msedset reduc graph given by split total number split k number node msedset i proof proof consist multipl part first relat lemma proven lemma msedset disjoint two msedset share node proof node share two msedset node must two differ immedi domina tor conflict howev definit immedi domin given sinc msedset disjoint number split individu msedset ad howev split node result merg msedset result hold anymor therefor prove cn merg msedset merg msedset lead less split lemma split node part msedset rc result merg msedset proof first shall prove split node element rc merg msedset afterward prove split node element cn nn merg msedset split rc node merg two msedset consid graph figur suppos subgraph g g msedset node subgraph form join loop possibl x figur merg two msedset go g g viceversa reason subgraph form singl msedset fact differ immedi domin split node rc case node x appli complet graph immedi domin subgraph g becom also immedi domin subgraph g sinc subgraph add singl loop share immedi domin msedset merg hold also gener case x domin reachabl n msedset split node rc merg msedset two type node left candid split node set nn cn split node element set nn merg msedset node edg go msedset therefor split node affect edg one msedset anoth therefor split never result merg msedset split node element set cn merg msedset node form loop msedset domin split node node msedset get immedi domin loop msedset therefor merg lemma reduc two merg msedset result split reduc graph reduc msedset separ proof suppos sedset consist x node sedset node merg cost one split sinc rc node must split reduc result sedset x split total number split x gamma y reduc two sedset separ result split one split less split need merg sedset combin lemma justifi restrict prevent split node element rc lemma exist alway node irreduc graph part msedset element rc proof node msedset element rc node must domin least two node node cannot domin domin node also element msedset rc graph therefor must infinit number node sinc consid graph finit number node must node part msedset element sinc msedset disjoint algorithm alway find node split without merg msed set result equat hold exampl figur msedset fa bg fc dg identifi two node result minim number split need reduc graph minim amount copi previou section saw algorithm minim number split result minimum number copi instruct basic block follow quantiti minim denot q q n mean quantiti node n qg quantiti graph g defin as purpos cn minim qg g transform g singl node use sequenc split formal q g two condit must satisfi achiev minimum freedom select node split must big possibl notic number split also minim prevent split node domin anoth msedset prevent split node element rc cn disadvantag lose freedom select node loss freedom illustr figur suppos node contain number b c figur graph common node set rc instruct want minim total result code size mean would like copi less instruct possibl number copi instruct prevent split node element rc cn is q a prevent split node element rc number copi instruct is min q a number instruct node b less node number copi instruct less latter case thu keep set candid node big possibl pay one would like minim amount copi sequenc split node must chosen optim exist multipl split sequenc solv irreduc graph tree build discov all figur show flow graph tree possibl split sequenc node tree indic mani copi introduc split b c b c c ba cb ab c bc figur irreduc graph copi tree edg give split sequenc number copi found follow path root leaf ad quantiti node suppos node contain number instruct want minim total result code size mean would like copi less instruct possibl choos differ split sequenc differ number copi minimum number copi instruct is minq a problem pick split sequenc minim number copi instruct theorem minim result qg irreduc graph convert reduc graph requir minimum number split g singl node total reduc graph short split produc g minim proof suppos node limit flow graph except initi node s candid split node msedset node element rc also candid split node one categori result number split greater minim number split prove split node alway result qg greater one obtain exclud node proven minimum number split requir order minim qg ffl split node msedset cannot result minimum qg seen previou section split node msedset make graph reduc sinc split node decreas number node msedset mean msedset still need number split ffl split node element rc cannot result minimum qg g sag ag g sa ga saga sa ga a split node set rc b split node set rc figur influenc number copi split rc node consid graph figur figur subgraph g least one msedset otherwis graph would irreduc figur show reduct graph case split rc node allow b split node allow node g reduc subgraph g notat sa node mean node consum copi node a result quantiti node sum quantiti node a see result total quantiti split sequenc figur qsqaqg result total quantiti reduc graph figur b qsqaqg without loss gener conclud split node rc never lead minimum total quantiti one easili see node msedset larger tree number possibl split sequenc increas take much comput time comput possibl therefor heurist construct pick node n split smallest h n defin by result heurist compar best possibl split sequenc given section algorithm method describ previou section detect irreduc control flow graph convert reduc control flow graph section algorithm method given algorithm consist three part transform select candid node split node algorithm control node split input control flow graph procedur reduc control flow graph procedur copi flow graph basic block flow graph g node appli repeatedli tt transform g g one node select split candid node appli repeatedli tt transform g algorithm expect input control flow graph basic block structur flow graph copi flow graph node two differ flow graph flow graph basic block flow graph node mean initi everi node repres basic block everi duplic introduc split flow graph node also perform flow graph basic block graph copi transform appli till graph node chang graph node reduc singl node graph reduc split need howev remain multipl node node split must appli first node split select done algorithm discuss later select node split defin definit graph basic block correspond basic block copi also split transform appli graph node still one node left process start again algorithm termin graph node reduc singl node thu graph basic block convert reduc flow graph algorithm transform node split quit straightforward given here algorithm select node split initi everi node candid node reject candid fulfil restrict discuss subsect node fulfil restrict heurist calcul equat node smallest heurist select split goal experi measur qualiti control node split sens minim amount copi experi four method node split use optim node split on method comput best possibl node split sequenc respect quantiti minim number basic block number instruct algorithm howev algorithm node select input control flow graph node node split node n n sedset n rc calcul valu hn return candid node requir lot comput time up sever day hp workstat uncontrol node split ucn straightforward applic node split restrict made set node candid split control node split cn node split restrict discuss section control node split heurist cnsh method cn heurist use select node set candid node algorithm appli select group benchmark benchmark procedur irreduc control flow graph obtain real world program a bison expand gawk gs gzip sed tr program compil gcc compil port risc architectur amount copi two differ quantiti consid tabl number copi basic block list tabl number copi instruct report result method ucn cn cnsh averag possibl split sequenc first column tabl list procedur name program name parenthes second column give number basic block instruct procedur algorithm appli column give number copi result algorithm absolut number copi given percentag indic growth quantiti respect origin quantiti given result on method conclud node split lead excess number copi furthermor conclud cn outperform ucn ucn lead enorm amount copi averag percentag growth basic block code size cn perform better growth basic block number instruct still big gap optim case use heurist control node split perform close optimum averag growth basic block method cnsh on respect growth use risc like move architectur move project research gener applic specif processor asp mean transport trigger architectur tta tabl number copi basic block atof output programbison copi definitionbison copi guardbison copi actionbison next fileexpand compil patterngawk gs copi blockgzip compil programs search sed squeez filtertr total code size method compar result on cnsh lead conclus cnsh perform close optimum experi one procedur small differ result tabl show substanti improv use cnsh question is impact code expans use simpl method like ucn code size complet program impact small bother except theoret aspect tabl effect complet code expans shown procedur benchmark irreduc control flow graph convert procedur reduc control flow graph tabl show impact basic block tabl impact code size list first column tabl list program name second column list total number basic block instruct remain column list increas basic block instruct method seen tabl impact node split substanti term number basic block instruct see ucn averag increas basic block instruct use ucn even result code size increas program bison use control node split increas smaller quit accept cnsh result expect smallest increas quantiti result show import clever transform irreduc control flow graph conclus method given transform irreduc control flow graph reduc control flow graph give us opportun exploit ilp larger scope singl basic block program method base node split achiev minimum number split set possibl candid node limit node specif properti sinc split node result minimum result code size algorithm use prevent uncontrol growth code size comput time determin optimum split sequenc veri larg heurist develop tabl number copi instruct instruct on ucn cn cnsh atof output programbison copi copi guardbison copi actionbison next fileexpand compil patterngawk gs lzwd read bufg copi blockgzip compil programs search sed squeez filtertr total method heurist call control node split heurist method appli set procedur contain irreduc control flow graph result compar result method method uncontrol node split control node split experi follow uncontrol node split lead enorm number copi averag growth code size per procedur control node split perform better still big gap optim case observ averag number copi use control node split heurist close optimum averag growth code size per procedur method also look impact total code size benchmark contain procedur irreduc control flow graph method use analysi per procedur use cnsh impact total code size small averag impact ucn howev surprisingli larg averag code size growth maximum bison tabl increas basic block per program program basic block on ucn cn cnsh bison expand gs sed tr total tabl increas instruct per program instruct on ucn cn cnsh bison expand gs sed tr total r global instruct schedul superscalar machin elimin algorithm data flow analysi tame control flow structur approach elimin goto statement controlflow normal algorithm complex analysi techniqu optim comput program flow analysi comput program certain graphtheoret properti program basi program optim program data flow analysi procedur flow graph reduc tr compil principl techniqu tool elimin algorithm data flow analysi global instruct schedul superscalar machin controlflow normal algorithm complex elimin algorithm bidirect data flow problem use edg placement new framework exhaust increment data flow analysi use dj graph loop use dj graph fast usual linear algorithm global flow analysi fast algorithm solv path problem program data flow analysi procedur microprocessor architectur flow analysi comput program transporttrigg versu operationtrigg ctr hansaem yun jihong kim soomook moon time optim softwar pipelin loop control flow intern journal parallel program v n p octob sebastian unger frank mueller handl irreduc loop optim node split versu djgraph acm transact program languag system topla v n p juli fubo zhang erik h dholland use hammock graph structur program ieee transact softwar engin v n p april reinhard von hanxleden ken kennedi balanc code placement framework acm transact program languag system topla v n p sept