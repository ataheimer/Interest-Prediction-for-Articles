t portabl perform data parallel languag a portabl program execut differ platform yield consist perform focu portabl paper present indepth studi perform three na benchmark ep mg ft compil three commerci hpf compil apr pgi ibm ibm sp benchmark evalu two version use loop use f construct andor hpf foral statement baselin comparison provid version benchmark written fortranmpi zpl data parallel languag develop univers washingtonwhil fforal program achiev scalabl perform compil result indic consider portabl problem hpf program two sourc problem identifi first fortran semant requir extens analysi optim arriv parallel program therefor reli compil capabl alon lead unpredict perform second wide differ parallel strategi use compil may requir hpf program custom particular compil improv compil optim may help reduc perform variat result suggest foremost criteria portabl concis perform model compil must adher user reli on b introduct portabl defin abil use program differ platform achiev consist perform develop parallel program portabl scalabl well recogn challeng endeavor howev difficulti necessarili intrins properti parallel comput assert especi clear case data parallel algorithm provid abund parallel tend involv comput regular data parallel model adequ gener parallel program howev simplic coupl preval data parallel problem scientif applic research support ibm resid studi program darpa grant nj motiv develop mani data parallel languag goal simplifi program achiev scalabl portabl perform languag high perform fortran constitut widespread effort involv larg consortium compani univers one hpf distinct first parallel languag recogn standard inde hpf regard integr sever similar data parallel languag includ fortran d vienna fortran cm fortran attract hpf manifold first use fortran base languag promis quick user accept sinc languag well establish target commun second use direct parallel sequenti program impli eas program sinc direct ad increment without affect program correct particular case compil may even abl parallel program without user assist hand hpf also potenti disadvantag first extens sequenti languag like inherit languag featur either incompat parallel difficult compil analyz second portabl program must affect differ technolog compil machin sinc princip purpos creat standard ensur program portabl hpf design present potenti conflict goal portabl instanc hide aspect commun programm conveni forc user reli complet compil gener effici commun differ compil alway present howev maintain program portabl languag differ must forc user make program modif accommod specif compil word user abl use compil develop program scale option migrat differ machin compil better scalar perform requir tight coupl languag specif compil sens compil implement must provid consist behavior abstract provid languag end languag specif must serv consist contract compil programm call contract perform model languag robust perform model dual effect program perform predict user portabl across differ platform focu portabl issu studi indepth perform three na benchmark compil three commerci hpf compil ibm sp benchmark are embarrassingli parallel ep multigrid mg fourier transform ft hpf compil includ appli parallel research portland group ibm evalu effect data depend compil analysi consid two version benchmark one program use loop second use f construct andor hpf foral statement comparison also consid perform benchmark written mpi zpl data parallel languag develop univers washington sinc messag pass program yield scalabl perform conveni mpi result repres level perform hpf program use point refer motiv includ zpl result follow zpl data parallel languag develop first principl lack parent languag allow zpl introduc new languag construct incorpor robust perform model creat concret delin parallel sequenti execut consequ program model present user clear compil rel unhind artifici depend complex interact languag featur one may expect easier develop zpl compil write zpl program scale well natur downsid design new languag without legaci challeng gain user accept studi zpl measur give indic whether consist scalabl perform achiev compil hamper languag featur unrel parallel comput result show program scale well use particular hpf compil may perform similarli differ compil indic lack portabl fforal program achiev scalabl perform result uniform program result suggest fortran sequenti natur lead consider difficulti compil er analysi optim commun analyz detail implement hpf compil find wide differ parallel strategi vari degre success contribut portabl problem hpf program improv compil optim may help reduc perform variat clear robust solut requir matur compil technolog result suggest foremost criteria portabl concis perform model compil must adher user reli on perform model serv effect contract user compil relat work apr publish perform hpf compil suit hpf pro gram along detail descript program restructur process use apr forg tool improv code program well tune apr compil mani case reli use aprspecif direct rather standard hpf direct although approach apr advoc program develop follow profilerbas program restructur success instanc result program may portabl respect perform particularli case employ apr direct there fore believ suit apr benchmark well suit evalu hpf compil gener similarli paper vendor describ individu hpf compil typic show perform number howev remain difficult make comparison across compil lin et al use apr benchmark suit compar perform zpl version program correspond hpf perform publish apr found zpl gener outperform hpf howev without access apr compil time detail analysi possibl limit comparison aggreg time paper make follow contribut indepth comparison analysi perform hpf program three current hpf compil altern approach mpi zpl comparison loop f array syntax foral construct assess parallel program model present hpf remaind paper organ follow section describ methodolog studi includ descript algorithm benchmark implement section examin analyz benchmark perform detail commun gener implement quantifi effect data depend hpf program section provid observ conclus zpl overview zpl array languag design univers washington expressli parallel ex ecut context paper serv two purpos first set bound perform expect high level data parallel languag extens exist sequenti languag second illustr import perform model parallel languag zpl implicitli parallel ie direct concurr deriv entir semant array oper array decomposit specifi run time partit array either block processor perform comput valu own scalar replic processor kept coher redundantli comput scalar comput zpl introduc new abstract call region use alloc distribut array specifi distribut comput zpl provid full complement oper defin region rel eg east r refer adjac element eg awest perform full partial prefix oper eg big max a express stride comput establish boundari condit eg wrap a accomplish power oper eg flood zpl also contain standard oper data type control structur use syntax similar modula benchmark select emphas portabl issu establish criteria benchmark deriv independ sourc insur object messag pass version includ studi establish target perform hpf separ version employ f loop fforal signific differ two type construct algorithm parallel algorithm differ version benchmark tune must adher languag specif rather specif compil capabl support hpf featur uniform benchmark requir featur support hpf compil follow criteria prove challeng given dispar benchmark availabil iti na benchmark version npb implement comput vendor intend measur best perform possibl parallel machin without regard portabl avail sourc npb gener sequenti implement although valid hpf program sequenti natur algorithm may difficult compil parallel may reflect natur approach parallel program instanc programm may simpli choos specif parallel algorithm implement hpf na version npb intend measur portabl perform better choic sinc program implement inher parallel algorithm use mpi interfac compil studi npb contain benchmark ideal includ studi unfortun portabl hpf version benchmark avail sever limit independ comparison apr hpf vendor publish benchmark use acquir perform measur benchmark gener tune specif compil portabl limit forc us care deriv hpf version npb sourc focu portabl avoid extern effect algorithm differ among benchmark cg avail npb sp bt lu includ studi requir block cyclic d data distribut support hpf compil limit prevent benchmark implement hpf zpl howev implement algorithm differ cannot factor perform leav ft mg potenti candid fortun ep definit highli parallel therefor sequenti implement trivial parallel benchmark implement hpf implement deriv revers engin mpi program commun call remov local loop bound replac global loop bound parallel program hpf direct ad recreat data partit mpi version hpf compil thu present program fulli data parallel not sequenti readi parallel conceptu task compil repartit problem specifi hpf direct regener commun benchmark chose requir basic block distribut support three compil use basic hpf intrins therefor stress compil without exceed capabl implement zpl languag deriv sourc hpf implement follow manner sequenti comput translat directli fortran correspond zpl syntax parallel execut express use zpl parallel construct one ad recent ep benchmark ep gener n pair pseudorandom float point valu interv accord specifi algorithm redistribut valu x j j onto rang scale x pair test condit true independ gaussian deviat comput new pair x test see fall within one squar annuli total count tabul annulu l maxjxj jy pseudorandom number gener accord follow linear congruenti recurs valu pair consecut valu recurs scale rang valu x k divid comput pair gaussian deviat proceed independ processor would maintain count gaussian deviat commun end obtain global sum random number gener howev present challeng two way comput random valu x k comput quickli preced valu x use one multipl one mod oper lead complex on howev major drawback true data depend valu x x k comput independ use k defin valu x result overal complex on fortun properti mod oper allow x k comput olog step use binari exponenti algorithm goal balanc method achiev parallel maintain on cost ep avail npb suit use implement provid apr loop version version structur achiev balanc batch random valu gener one sequenti batch time save seed batch comput use expens method remain valu comput use less expens method loop iter comput number batch requir constitut opportun parallel execut fforal version deriv loop version follow modif ffl variabl main loop caus output depend expand array size loop iter word output depend elimin essenti renam variabl comput express fulli data parallel manner sinc iter count number sequenti batch expans excess ffl direct ad partit array onto d processor grid ffl loop final summat also recod use hpf reduct intrins complic aris involv subroutin call within foral loop must free side effect order loop distribut slight code rearrang done remov side effect origin subroutin pure direct ad assert freedom side effect zpl version translat straightforward manner loop version notabl differ use zpl region construct express independ batch comput mg multigrid interest sever reason first illustr need data parallel languag hpf zpl npb implement contain line code commun program elimin program written data parallel languag second sinc main comput point stencil refer pattern requir commun simpli shift constant result simpl neighbor exchang processor grid compil zpl hpf recogn pattern well employ optim messag vector storag prealloc nonloc data therefor although benchmark rather complex initi indic hpf zpl abl produc effici parallel program benchmark vcycl multigrid algorithm comput approxim solut discret poisson problem r laplacian oper r algorithm consist iter follow three step residu correct appli correct trilinear finit element discret laplac oper r k vcycl multigrid oper defin npb benchmark specif algorithm implement npb version consist three phase first phase comput residu second phase set step appli k oper comput correct last phase appli correct hpf loop version deriv npb implement follow ffl mpi call remov ffl local loop bound replac global bound ffl use common block storag hold set hierarch array differ size incompat hpf therefor array renam declar explicitli ffl hpf direct ad partit array onto d processor grid array distribut maintain across subroutin call use transcript direct prevent unnecessari redistribut hpf fforal version requir addit step rewrit data parallel loop f syntax zpl version similar structur hpf fforal version notabl differ use stride region express hierarchi d grid stride region spars index set data declar comput specifi ft consid partial differenti equat point x d space ffit ft benchmark solv pde comput forward d fourier transform ux multipli result set exponenti valu comput invers d fourier transform problem statement requir solut therefor benchmark consist forward fft pair dot product invers fft npb implement follow standard parallel scheme d fft comput consist travers appli d fft along three dimens d array partit along third dimens allow processor independ carri d fft along first second dimens array transpos enabl travers third dimens transpos oper constitut commun program program requir move third dimens first dimens transpos memori stride favor d fft therefor hpf redistribut function alon suffici hpf loop implement deriv follow modif hpf direct ad distribut array along appropri dimens tran scriptiv direct use subroutin boundari prevent unnecessari redistribut commun transpos step replac global assign statement scratch array recast array differ rank size subroutin replac multipl array constant rank size although pass array section formal argument legitim hpf hpf compil difficulti manag array section data distribut specifi partit processor map memori layout hpf fforal version requir addit step rewrit data parallel loop f syntax zpl implement alloc d array region d array transpos oper realiz zpl permut oper platform program portabl evalu across multipl platform differ compil machin studi elect factor differ due machin architectur focu compil differ although machin architectur set upper bound possibl perform languag compil determin achiev perform target parallel platform ibm sp cornel theori center hpf compil use studi includ ffl portland group pghpf version ffl ibm xlhpf version appli parallel research xhpf version compil gener mpi call commun use mpi librari ensur commun fabric ident measur pgi apr hpf compil gener intermedi fortran code process standard ibm fortran compil xlf ibm hpf compil gener machin code directli otherwis base xlf compil zpl compil gener intermedi c code measur use compil option system environ na apr specifi public use sp wide node onli spotcheck confirm publish na apr perform reproduc parallel perform section examin perform program figur show aggreg time version mpi hpf zpl small larg problem size class s class a note ffl execut time may excess depend success compil first examin small problem size class s program reason perform speedup larg problem size class a ffl time axi use log scale wide perform spread ffl ep mpi version use class s fforal version shown ffl mg class a apr fforal version scale includ ffl ft class a one data point avail ibm fforal version processor timesec b ep class timesec a ep class processor timesec c mg class processor timesec d mg class timesec processor timesec f ft class mpi apr_do ibm_do pgi_do zpl apr_f ibm_f pgi_f figur perform ep mg ft see note section na ep benchmark figur a first surpris observ ibm pgi compil achiev speedup hpf loop version although apr compil produc program scale well recal ep loop version apr suit inspect code reveal distribut direct specifi array result default data distribut although default distribut implement depend convent choic replic array ibm pgi compil distribut comput strictli ownercomput rule therefor order program parallel data structur must distribut sinc array ep replic default comput partit among processor processor execut full program achiev speedup contrast apr parallel strategi strictli adher ownercomput rule allow main loop partit despit fact none array within loop distribut note hpf languag specif specifi default distribut data partit scheme comput omiss like intend maxim opportun compil optim howev observ ep suggest differ scheme adopt compil may result portabl problem hpf program direct insert distribut array found main array ep intend hold pseudorandom valu gener sequenti therefor exist true depend loop comput valu array distribut compil adjust loop bound local partit comput serial hpf fforal version correct problem explicitli distribut array ibm pgi compil abl parallel class perform figur b show compil achiev expect linear speedup howev expand array express comput data parallel form seem introduc overhead degrad scalar perform possibl advanc compil optim loop fusion array contract remov overhead optim either avail success case zpl version scale linearli expect scalar perform slightli better apr version na mg benchmark compar ep mg allow rigor test languag compil first discuss perform class figur c p column show consider variat scalar perform version show overhead order magnitud mpi perform base case origin mpi program zpl version scale well zpl compil partit problem straightforward manner accord region stride region semant commun vector littl effort scalar perform howev show x overhead compar mpi version hpf loop version clearli scale hpf compil explain below pgi compil perform poorli vector commun comput express loop commun call tend remain innermost loop result larg number small messag gener addit program use guard within loop instead adjust loop bound apr compil support d processor grid therefor d distribut specifi hpf direct collaps default d distribut limit affect asymptot speedup necessarili limit parallel point stencil comput one subroutin compil detect interprocedur analysi alia two formal argument constitut inhibitor loop parallel within subroutin howev analysi go detect index express array refer depend actual exist major loop program apr compil correctli partit comput along distribut array dimens gener conserv commun loop obtain latest valu rh loop updat lh result perform degrad number processor ibm compil parallel detect output depend number variabl although array replic case compil appear overli convers maintain consist replic variabl loop parallel contain statement independ direct treat differ compil pgi compil interpret direct liter parallel loop direct ibm compil hand ensur correct perform rigor depend check nevertheless detect depend parallel loop hpf fforal version ibm pgi compil success ibm compil perform scalabl approach zpl pgi compil experi littl problem vector commun inde scalar perform exce ibm apr compil result slowdown achiev speedup either partit comput fforal version similarli loop version abl reduc amount commun continu limit d distribut well alia problem one subroutin note version mg apr suit employ apr direct suppress unnecessari commun direct use studi part hpf worth note possibl use apr tool analyz program manual insert apr direct improv speedup apr compil given loop version fail scale compil one may conjectur whether program may written differ aid compil specif caus compil describ suggest apr compil would success apr direct use pgi compil may benefit hpf independ direct ibm compil would requir actual remov data depend therefor appear singl solut portabl across compil na ft benchmark ft present differ challeng hpf compil term refer pattern ft consist dot product fft butterfli pattern former requir commun readili parallel compil latter index express far complex optim commun fortun index variabl limit one dimens time therefor task compil partit comput along appropri dimens intend data distribut d thu within capabl apr compil figur e show full set perform result small problem size mg mpi zpl version scale well scalar perform data parallel implement show overhead order magnitud mpi implement hpf loop version apr compil exhibit problem mg gener conserv commun mani loop addit apr compil choos correct loop parallel discrep aris apr strategi choos partit base array refer within loop case main comput thu array refer packag subroutin call loop intent loop parallel subroutin oper local data compil proce analyz loop subroutin d fft find loop paralleliz pgi compil also gener suboptim commun although princip limit vector messag ibm compil parallel assign replic variabl hpf fforal version requir consider experiment code restructur arriv version accept compil partli differ support featur among compil partli nest subroutin structur origin program hpf compil achiev speedup vari degre apr particularli success sinc princip parallel loop move innermost subroutin scalar perform approach mpi perform although commun overhead limit speedup pgi show good speedup ibm speedup limit commun commun gener compil use indic effect parallel program version benchmark scale tabl show total number mpi messag pass call differ commun scheme employ compil apr pgi compil use gener send receiv ibm compil also use nonblock call collect commun may ramif portabl compil platform zpl compil use nonblock mpi call overlap comput commun well mpi collect commun benchmark version pointtopoint collect type mpi call ep class allreduc barrier ibm f send recv bcast mg class s mpi send irecv allreduc barrier zpl isend recv barrier apr f send recv barrier bcast ft class s mpi alltoal reduc apr f send recv barrier ibm f send irecv bcast tabl dynam commun statist ep class a mg class ft class s p data depend hpf compil deriv parallel data distribut loop oper data loop depend readili parallel adjust loop bound local bound loop depend may still paralleliz requir analysi instanc ibm compil recogn depend loop perform reduct gener appropri hpf reduct intrins instanc loop distribut may isol portion contain depend allow remaind origin loop parallel approxim quantifi degre difficulti program present parallel compil term depend analysi use follow simpl metric count loop depend count loop valu would indic loop trivial parallel valu would indic paralleliz loop depend analysi capabl compil use kapf tool collect loop statist benchmark major subroutin list tabl metric complet sinc account data distribut instanc nest loop d distribut loop need partit parallel program loop may contain depend ill effect addit metric static may correl directli dynam characterist program howev metric give coars indic demand compil loop depend statist show clear trend correl directli perform data observ expect reduct depend loop version fforal version reduct greatli aid compil parallel fforal program also highlight difficulti parallel program loop subroutin fforal ep embar get start seed ft fftpde cfft cfftz subroutin fforal mg hmg psinv resid rprj normu tabl statist depend ep mg ft count loop data depend subroutin call n total loop count fforal count obtain array statement scalar mg differ signific array syntax elimin depend case hpf compil implement optim array refer affin function loop indic particularli function constant optim effect mg loop version howev appear success note loop subroutin normu replac altogeth hpf reduct intrins ft low number depend fftpde come dotproduct easili parallel topdown order subroutin list also repres nest level subroutin increas depend inner subroutin reflect need achiev parallel higher level explain earlier prove challeng apr compil focus analyz individu loop partit work data parallel applic recent progress languag compil allow us experiment evalu import issu program portabl recogn mani factor affect develop success parallel languag studi focus portabl factor three na benchmark studi across three current hpf compil examin differ style express comput hpf also consid benchmark written mpi zpl understand interact perform portabl conveni program hpf compil show gener difficulti detect parallel loop compil success f array syntax foral construct although even case success parallel uniform signific variat scalar perform also exist compil hpf direct construct provid inform data comput partit sequenti semant fortran leav mani potenti depend pro gram hpf compil must analyz depend unabl so must make conserv assumpt analysi capabl differenti variou vendor impl mentat howev difficult compil parallel reliabl user cannot consist estim parallel behavior thu speedup program addit parallel strategi compil vari wide differ way express comput lead drastic differ perform unpredict variat reflect shortcom perform model hpf result user need continu experi compil learn actual behavior so user effect supplement perform model provid languag empir inform yet enhanc model tend platform specif portabl zpl program show consist scalabl perform illustr possibl incorpor robust perform model high level languag languag design ensur languag abstract behav predict manner respect parallel perform although zpl support multipl parallel system result studi directli show zpl portabl across platform multipl independ compil implement zpl avail howev exist perform model evid predict perform behavior ensur zpl program portabl across independ develop platform result also show signific overhead scalar perform remain implement compar mpi program one sourc overhead larg number temporari array gener compil across subroutin call parallel loop requir dynam allocationdealloc copi gener degrad cach perfor manc index comput also contribut significantli overhead clear becom viabl altern explicit messag pass compil data parallel languag must achiev much lower scalar overhead r david klepacki rick lawrenc effici parallel algorithm d fft na parallel benchmark appli parallel research na parallel benchmark rob van der wijngaart vienna fortran compil fortran dhpf distribut memori mimd comput compil high perform fortran factorjoin uniqu approach compil array languag parallel machin high perform fortran forum fortran parallel hand book hpf compil ibm sp compil high perform fortran distributedmemori system evalu compil optim fortran d zpl languag refer manual zpl array sublanguag zpl vs hpf comparison perform program style role perform model parallel program languag influenc program model share memori comput perform na parallel benchmark result zpl program guid cm fortran program guid tr compil fortran dhpf distribut memori mimd comput evalu compil optim fortran highperform parallel implement na kernel benchmark ibm sp compil high perform fortran distributedmemori system role perform model parallel program languag factorjoin zpl ctr bradford l chamberlain sungeun choi e christoph lewi lawrenc snyder w derrick weathersbi calvin lin case highlevel parallel program zpl ieee comput scienc engin v n p juli bradford l chamberlain steven j deitz lawrenc snyder compar studi na mg benchmark across parallel languag architectur proceed acmiee confer supercomput cdrom pe novemb dalla texa unit state m govett l hart t henderson j middlecoff d schaffer scalabl model system directivebas code parallel distribut share memori comput parallel comput v n p august bradford l chamberlain sungeun choi e christoph lewi calvin lin lawrenc snyder w derrick weathersbi zpl machin independ program languag parallel comput ieee transact softwar engin v n p march