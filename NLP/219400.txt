t find regular simpl path graph databas a consid follow problem given label direct graph g regular express r find pair node connect simpl path concaten label along path satisfi r problem motiv observ mani recurs queri relat databas express form implement queri languag bf g base observ show problem gener intract present algorithm run polynomi time size graph regular express graph free conflict also present class languag whose express alway evalu time polynomi size graph express character syntact express languag b introduct much success relat model data attribut simplic make amen mathemat analysi easi user comprehend latter respect avail nonprocedur queri languag great asset howev fact queri especi use new applic domain express tradit queri languag led propos power queri languag logicbas languag datalog queri languag g origin propos relat model includ two queri languag equival express power relat calculu relat algebra languag use yardstick bywhich queri languag classifi queri languag said relat complet at least express power relat calculu howev notion complet question sinc shown certain reason queri find transit closur binari relat cannot express calculu particular limit overcom languag datalog abil express recurs queri design g base observ mani recurs queri aris practiceand literatureamount graph travers for exampl g view databas direct label graph pose queri graph pattern answer queri set subgraph databas match given pattern use applic languag found system repres transport network commun network hypertext document on prototyp implement queri drawn workstat screen databas queri result also display pictori exampl let g graph describ hypertext document node chunk text edg link crossrefer reader read document follow link context one might interest queri as way get section section conclus without read node onc correspond g queri shown figur lefthand box figur contain pattern graph righthand box contain summari graph specifi preliminari version section paper appear proceed th intern confer larg data base amsterdam netherland august page comput system research institut univers toronto toronto ont ms a canada z depart comput scienc univers cape town rondebosch south africa ae ae ae conc link ae ae conc fig queri test exist simpl path hypertext document ae ae ac ae ae fig queri find pair citi connect air canada flight output present user node case label constant match databas edg pattern graph label regular express case desir express link repres nonzero sequenc link regular express use match edg label along simpl path g therebi satisfi origin request exampl let g graph repres airlin flight node g denot citi edg label citi b citi c mean flight b c airlin a assum want find pair citi connect sequenc flight a least one flight air canada ac b citi visit onc queri express graph pattern figur pattern graph exampl compris two node time label variabl edg label regular express ac where underscor match edg label g ac regard singl symbol again fact simpl path match queri evalu ensur desir answer comput although queri g lot gener exemplifi two exampl special case suggest exampl challeng enough algorithm point view want process queri effici problem address paper is given regular express r graph g find pair node g connect simpl path p concaten edg label compris p languag denot r tri find effici solut problem incorpor implement g somewhat surpris discov queri exampl fact npcomplet use result show x certain fix regular express such r exampl problem decid whether pair node answer queri npcomplet make gener problem nphard first attack problem determin languag r make problem hard x present class languag queri evalu solvabl time polynomi length regular express size graph character languag syntact term regular express denot finit automata recogn them character assum knowledg concern structur graph queri x consid extens given constraint cycl input graph known satisfi knowledg allow us character potenti larger class queri solv polynomi time design gener algorithm present x correct arbitrari graph queri guarante run polynomi time size graph regular express graph free conflict sens defin precis section special case queri free conflict acycl databas graph restrict express queri free conflict arbitrari graph sinc cannot restrict prototyp work conflictfre queri graph expens test conflictfreedom beforehand quit conveni singl algorithm work case fact incorpor algorithm x implement intract result section prove neg result regard complex find certain type simpl path particular class direct graph begin defin graph structur well class queri structur interest definit databas graph dbgraph short direct label graph n set node e set edg incid function map e n theta n note multipl edg pair node permit dbgraph label g drawn finit set symbol s call alphabet edg label function map e s definit let finit alphabet disjoint fffl g regular express r defin follow empti string ffl empti set regular express b regular express regular express noth els regular express express ab call alternationof b ab call concaten b a call closur a use underscor denot altern element s also denot aa posit closur a languag lr denot r defin follow ffflg lbg lbg regular express r r equival written r length regular express r denot jrj number symbol appear string r definit let g n e s dbgraph path not necessarili simpl path g call string e path label p denot p let r regular express s say path p satisfi r p lr queri qr dbgraph g defin set pair x y simpl path x g satisfi r x y qr g x y satisfi qr naiv method evalu queri qr dbgraph g travers everi simpl path satisfi r g exactli onc penalti algorithm take exponenti time g exponenti number simpl path nevertheless see gener cannot expect algorithm perform much better sinc prove that particular regular express problem decid whether pair node answer queri npcomplet hand refin lead guarante polynomi time evalu condit studi follow two section consid follow decis problem regular simpl path instanc dbgraph regular express r s question g contain direct simpl path x p satisfi r is e equival ask is x y qr g instanc compris dbgraph refer problem fix regular pathr is fix regular pathr measur complex term size dbgraph first prove that certain regular express r fix regular pathr npcomplet so refer follow two decis problem instanc direct graph e node x n question direct simpl path even length that is even number edg x y instanc direct graph e two pair distinct node w x y z n theta n question pair disjoint direct simpl path g one w x z follow theorem use two decis problem prove npcomplet fix regular pathr two particular regular express theorem let distinct symbol s fix regular pathr r either npcomplet proof even path shown npcomplet reduc even path fix regular pathr given instanc g x even path construct dbgraph h isomorph g except everi edg h label even simpl path x g simpl path x h satisfi r easi see fix regular pathr np conclud fix regular pathr fact disjoint path npcomplet follow immedi result reduc disjoint path fix regular pathr given instanc g w x y z disjoint path construct dbgraph h isomorph g except everi edg h label add new edg x y label h simpl path w z satisfi r h disjoint simpl path w x z g conclud fix regular pathr also npcomplet corollari regular simpl path npcomplet proof nphard follow theorem show regular simpl path np observ that arbitrari regular express r given simpl path x g path label w check polynomi time length r w whether w lr interest note g undirect even path disjoint path solv polynomi time even path solv polynomi time use match techniqu polynomi time algorithm disjoint path given two npcomplet result theorem gener first gener regular express express form w w jwj use follow npcomplet problem use show npcomplet even path path via node instanc direct graph e node x question direct simpl path x via m theorem fix regular pathr r w w proof again membership np easi demonstr reduc path via node fix regular pathr use variat construct given instanc g path via node construct dbgraph f f f proof divid two part depend whether w even odd length rather introduc addit node structur believ would obscur proof allow edg label string symbol length path length concaten edg label assum two copi edg type label w w edg type label w edg type label w claim simpl path x g simpl path x y satisfi r h path p x g let p subpath p x m p subpath p y let u predecessor p v successor p h travers simpl path x u satisfi w follow edg label w w u v respect follow simpl path v y satisfi w overal path thu satisfi w w guarante simpl assum simpl path p x y h satisfi r string lr length mn even path x y pass must length kn k odd conclud p must pass h henc simpl path x via g consid case one copi edg type h label n one copi edg type label w w type edg label w type edg label w easi see simpl path x via g must simpl path satisfi r h direct suffic note simpl path h x y pass length mn pass length kn also length string lr two never equal n conclud simpl path x y h satisfi r must simpl path x via g gener npcomplet result fix regular pathr s let also denot altern element theorem let r regular express form wt subset w addit assum either w appear neither symbol b c neither appear w fix regular pathr npcomplet proof again fix regular pathr obvious np use essenti reduct disjoint path fix regular pathr theorem gener case given instanc g w x y z disjoint path construct dbgraph h isomorph g except two copi edg h made one label b s one label c case b c symbol mention statement theorem case choos b c a assum add along path e label disjoint simpl path w x z g easi see must simpl path w z satisfi r h assum simpl path p w z satisfi r h p must form p pw p sinc case pw contain edg label appear nowher els h appear path h satisfi r conclud must disjoint simpl path w x z h henc g theorem rather neg result sinc impli queri might requir time exponenti size dbgraph regular express evalu thu regular express theorem certainli would expect evalu algorithm run polynomi time one exampl air canada queri use exampl as long alphabet contain least two symbol result howev function particular regular express rather natur languag denot regular express class languag regular simpl path p subject next section restrict regular express section character class queri regular simpl path evalu polynomi time first introduc terminolog definit definit nondeterminist finit automaton ndfam tupl s finit set state input alphabet ffi state transit function map theta s ffflg set subset s initi state f set final state extend transit function ffi defin follow s s s w ndfa accept w languag lm accept set string accept determinist finit automaton dfa ndfa state transit function map theta s definit let ndfa transit graph associ direct label graph s edg e em m confus represent sometim say transit state state or successor s ffi s a path ffi s w ae ff phi ae ff phi ae ff phi fig transit graph dfa definit appli dfa definit given ndfa pair state s s defin languag t denot l st set string take state state t then state set state defin languag denot l st st particular state s suffix languag s denot l sf or s short set string take final state clearli definit appli dfa given regular express r s fflfree lr construct polynomialtim on assum ndfa fflfree exampl figur show transit graph dfa state initi state state final denot doubl circl we show reject state path initi state final state lm denot regular express suffix languag state s regular express subsequ analysi use refer ndfa accept languag lr r construct ndfa defin follow definit let ndfa call transit graph intersect graph saw previou section that certain regular express r unlik find algorithm evalu qr arbitrari graph g alway run time polynomi size g one regular express howev turn regular express specifi instead qr evalu polynomi time dbgraph g reason arbitrari path node x node g satisfi r simpl path x satisfi r case need restrict look simpl path g instead look path satisfi r defin correspond decis problem below regular path instanc dbgraph regular express r s question g contain direct path not necessarili simpl p satisfi r is e lemma regular path decid polynomi time ae x ae ff phi z ae fig graph contain nonsimpl path proof given dbgraph g along node x g view g ndfa initi state x final state y construct intersect graph g ndfa accept lr path x satisfi r path x y f f f done polynomi time tarjan provid polynomialtim algorithm construct regular express repres set path two node given graph altern procedur one could decid polynomi time whether path x g satisfi r first use tarjan algorithm construct regular express r xy repres path x g determin whether intersect lr lr xy nonempti use ndfa result previou section show unlik polynomialtim analogu tarjan algorithm exist describ set simpl path two node definit let g dbgraph ndfa intersect graph g call node x initi node node y f final node interest condit regular simpl path which appropri semant reduc regular path follow lemma state one condit lemma regular simpl path decid polynomi time acycl db graph proof follow immedi lemma fact everi path acycl graph simpl suppos want character class regular express guarante regular simpl path solvabl polynomi time assum know noth structur dbgraph ensur that regular express r whenev string w lr everi string obtain w remov one symbol must also lr otherwis xay lr xy lr where x construct graph g compris singl simpl path u v pass z loop z label a path u z label x path z v label see figur nonsimpl path u v g satisfi r simpl path u v satisfi r definit abbrevi string w string obtain w remov one symbol w look class regular express denot languag close abbrevi consid follow definit class restrict regular express definit s denot regular express a as done grep util unix exampl given regular express r let r regular express obtain replac occurr symbol r a r restrict r j r r obtain r defin abov note definit restrict regular express semant rather syntact two signific consequ one hand abl prove equival theorem theorem relat restrict regular express languag automata other recognit problem restrict regular express becom difficult corollari exampl regular express restrict equival recal theorem fix regular pathr npcomplet restrict r restrict sinc r written equival definit dfa exhibit suffix languag contain properti the contain properti short if pair s path final state successor s s t that is l sf l tf follow result although use elsewher provid interest restrict structur dfa exhibit contain properti proposit let exhibit contain properti everi state path state f final minimum dfa exhibit contain properti minimum everi cycl loop proof everi final state accept ffl transit everi state path state f must also accept ffl henc must final minimum dfa equival state repres set equival state assum repres fs transit if transit s equival s t consid cycl loop let two state cycl sinc u v everi pair consecut state cycl conclud transit s t t s j t minimum contradict exampl consid regular express dfa accept whose transit graph given figur verifi exhibit contain properti note s denot obvious easi check s note also that proposit state final and sinc minim everi cycl loop fact exhibit contain properti r restrict coincid demonstr below theorem let r regular express s accept lr follow three statement equival r restrict regular express lr close abbrevi exhibit contain properti unix trademark att proof proof use ndfa e construct regular express r such lmr detail ffltransit usual present onetoon correspond nonffltransit mr occurr symbol r make sens refer transit mr correspond occurr symbol r vice versa furthermor replac occurr r a equival includ ffltransit sourc state target state transit mr correspond occurr a assum r restrict lr close abbrevi symbol string x xay lr xy lr consid mr let is set state mr read x sinc lmr r hand xay lmr state p q p a q sinc r restrict ad ffltransit p q leav lmr unchang so longer equal lr contradict conclud lr close abbrevi prove contraposit assum s t pair s reachabl state ffi s a t s is string t s let x string ffi follow xay lm xy lm sinc lm conclud lr close abbrevi prove contraposit assum r restrict atransit mr ad ffltransit alter string is string t r r consid dfa assum must state q ffi p a q q howev p otherwis xy lm would mean lm exhibit contain properti theorem regular simpl path decid polynomi time restrict regular express proof let dbgraph g regular express r r restrict constitut instanc regular simpl path lemma suffici show whenev path x g satisfi r simpl path x satisfi r assum nonsimpl path g sinc p nonsimpl assum j lr path label p abbrevi p theorem lr close abbrevi henc p remov cycl p leav simpl path x satisfi r thu class restrict regular express one queri evalu perform effici show that even though class restrict regular express regular languag close abbrevi subclass regular counterpart least close regular oper theorem let alphabet class regular languag close abbrevi also close altern concaten closur proof let l l regular languag close abbrevi immedi close abbrevi too let w abbrevi w clearli string abbrevi w sinc l l close abbrevi algorithm s comput suffix languag contain relat dfa input output pair s s whether s t not mark s t od order pair distinct state s ffi a ffi t a mark mark s t recurs mark unmark pair list s t list pair mark step els pair ffi a ffi t a mark put s t list ffi a od od fig comput suffix languag contain relat dfa l allow us conclud l close abbrevi let l regular languag close abbrevi sinc ffl l regular languag close abbrevi also close concaten l must close abbrevi corollari class restrict regular express close altern concaten closur exampl one simplest restrict regular express sinc class restrict regular express close altern concaten closur which alreadi seen restrict hand restrict express also sometim built express restrict exampl includ which alreadi seen given queri qr would like test whether r restrict order know safe use polynomi time evalu algorithm adapt algorithm minim number state dfa comput suffix languag contain relat pair state dfa suffix languag contain relat use subsequ section also provid obviou method test whether regular express r restrict use theorem algorithm comput suffix languag contain relat algorithm s shown figur line algorithm taken directli algorithm algorithm mark pair inequival state consid unord pair state line algorithm alter appropri order consid order pair state s t mark algorithm s s t n state algorithm run on assum constant alphabet an altern almost lineartim algorithm given sinc construct dfa accept lr may take exponenti time in size r use algorithm test whether regular express restrict effici howev import stress tri avoid possibl spend exponenti time size dbgraph answer queri also turn determin whether r restrict hard problem consid follow result proposit determin whether regular express alphabet fg denot npcomplet use result show problem decid whether regular express alphabet restrict nphard so first prove follow theorem let r star regular express alphabet fg decid whether r restrict npcomplet proof first show problem np r restrict lr close abbrevi theorem thu string lr consid dfa accept lr seen must jrj n lr nondeterminist polynomi time algorithm verifi r restrict first guess binari represent n test whether path transit graph ndfa accept lr length n final state latter step done determinist time polynomi length r reduc problem proposit present problem show r restrict r denot alreadi shown r restrict lr convers assum r denot let x shortest string lr sinc r star lr infinit string xy lr ffl x abbrevi xy henc theorem r restrict corollari decid whether regular express alphabet restrict nphard constrain cycl dbgraph instanc knowledg cyclic structur dbgraph g allow us determin without consult g itself particular queri qr evalu polynomi time g alreadi shown that extrem case g acycl qr alway evalu polynomi time let us assum know cyclic structur g constrain regular express c is everi cycl label g lc definit let c regular express s dbgraph let set cycl label g name cycl gg say g compli c ae lc regular express c call cycl constraint cycl constraint c defin class dbgraph whose cyclic structur satisfi c exampl way defin class bipartit graph loopfre graph acycl graph specifi regular express respect class dbgraph unconstrain cycl defin express denot continu need introduc terminolog regard properti intersect graph dbgraph transit graph definit let intersect graph dbgraph graph say path recal underscor shorthand dbsimpl v word p dbsimpl v simpl path g addit call simplici whenev path dbsimpl path v first compon node form subset first compon node p definit lemma clear intersect graph dbgraph transit graph correspond regular express r simplici qr evalu polynomi time size follow theorem character simplici intersect graph presenc cycl constraint theorem let c cycl constraint queri qr let accept lr transit graph everi dbgraph g compli c intersect graph g simplici whenev path reachabl state satisfi c s t proof if dbgraph compli c nonsimpl path satisfi r g henc path q v i notat simplic let w w compli c w assum ffi s t path satisfi c path v i henc assumpt s t string w t p satisfi r w s well follow w w lr therefor satisfi r process repeat obtain dbsimpl path q v first compon q form subset first compon q conclud simplici onli if assum path p satisfi c t constraint c cannot otherwis p would satisfi c sinc reachabl string w ffi s cannot otherwis s t let w string t s w path label p string w cannot ffl sinc p must length greater zero construct dbgraph compris singl nonsimpl path e compli c sinc cycl g label w lc path q lr henc path v i howev path satisfi r sinc w w lr otherwis w would s consequ dbsimpl path v conclud simplici result depend particular dfa accept lr consid two accept lr let pair state string x ffi g compli cycl constraint compat r r restrict g acycl fig relationship regular express r dbgraph g queri qr t lm must case word fact theorem true independ particular dfa chosen consequ myhillnerod theorem state languag accept dfa union equival class rightinvari equival relat finit index lead us follow definit definit let r regular express transit graph dfa accept lr say r compat cycl constraint c whenev path a reachabl state satisfi c s t theorem gener previou result case g acycl c path satisfi c result hold vacuous word everi regular express compat cyclic structur g unconstrain c denot everi path satisfi c s must contain t pair reachabl state correspond case restrict regular express is regular express r compat c where c denot r restrict relationship among properti shown figur appeal result lemma obtain follow corollari theorem corollari let c cycl constraint g dbgraph compli c queri qr g evalu polynomi time size r g r compat c simpl algorithm test whether regular express compat cycl constraint given figur construct dfa regular express r c algorithm take exponenti time length r c howev decid whether r c compat nphard sinc decid whether r restrict special case test compat theorem given regular express r cycl constraint c decid whether r c compat nphard exampl let r dfa mr accept lr shown figur a a b know r restrict fact saw theorem decid x y qr g npcomplet dbgraph gener howev qr evalu polynomi time bipartit graph alreadi seen regular defin class bipartit graph dfa mc accept lc shown figur b intersect graph mr mc given figur path satisfi c start node contain initi state mc end node contain final state mc a a a d b a b d sinc a a b b corollari tell us qr evalu polynomi time bipartit graph given queri qr dbgraph g know g compli cycl constraint c test whether r compat c use algorithm so use polynomi time algorithm evalu qr g hand know cyclic structur g seem might resort exponenti algorithm test whether regular express compat cycl constraint input regular express r cycl constraint c output whether r compat c construct dfa accept lr accept lc comput suffix contain relat mr algorithm x construct intersect graph mr theta mc comput transit closur s t edg s otherwis answer no fig test whether regular express compat cycl constraint ae ae a ae ae ae ae b fig dfa a mr bb ae ae ad ae ae ae bd fig intersect graph mr mc figur ae ff phi aae ff phi bae ff phi ff phi omega psi ae ff phi omega psi ae ae omega omega omega omega omega omega ae ae omega omega omega omega omega omega oe j j b fig dfa dbgraph g time algorithm r restrict next section howev describ evalu algorithm run polynomi time size g g happen compli cyclic constraint r compat evalu algorithm section describ algorithm evalu queri qr dbgraph g expect result x algorithm run polynomi time gener doe howev run polynomi time suffici condit identifi x x name g acycl r restrict g compli cycl constraint compat r fact show algorithm run polynomi time g r conflictfre condit impli abov evalu algorithm travers path g use dfa accept lr control search mark node visit must record state node visit sinc must allow node visit differ state which correspond distinct node intersect graph g order avoid visit node twice state would like retain state mark node long possibl unfortun follow exampl show that gener requir answer node connect simpl path g retain state mark lead incomplet queri evalu exampl consid queri qr accept lr dbgraph g shown figur note similar automaton figur x assum start travers node g follow path b c d node a b c mark state a a b b respect answer a c a d found sinc b final state cannot mark c state c a b c dc nonsimpl path backtrack node c result answer a e found node still mark b as shown figur backtrack c howev cannot mark b state c a b c b nonsimpl path backtrack a find e g r conflictfre g compli cycl constraint compat r r restrict g acycl fig relationship regular express r dbgraph g queri qr alreadi mark state b consequ search termin without answer a b found turn safe retain mark g acycl r restrict howev structur particular dbgraph g might case retain mark evalu qr polynomi time even g acycl r restrict definit let intersect graph dbgraph g dfa path path form v initi path p conflictfre p dbsimpl p q delta v s q conflictfre v appear q v t q t s v t q case conflict v everi simpl initi path conflictfre said conflictfre g r obviou g acycl conflictfre matter regular express r appear qr also r restrict then theorem exhibit contain henc conflictfre irrespect structur g final g compli cycl constraint compat r then theorem g r conflictfre show qr evalu polynomi time conflictfre henc conflict freedom anoth weaker suffici condit qr polynomi time evalu see figur result follow lemma use evalu algorithm lemma let intersect graph dbgraph accept lr initi path p conflictfre p dbsimpl p q delta v s q conflictfre v appear q first v t q t s proof if direct trivial assum p conflictfre dbsimpl furthermor assum p q delta v s q conflictfre v appear q prove induct number occurr v q t s v t first occurr v q basi v occur q trivial assum induct hypothesi true fewer n occurr v q let p q delta v s sinc p conflictfre know definit v r q r s induct hypothesi exampl consid dfa dbgraph g exampl shown figur intersect graph g shown figur recal that mark retain answer a b would found howev conflict i initi path a a via b a b c a c strictli weaker definit conflictfreedom given cc ae ba ae cb ae bc gammapsi r i fig intersect graph dbgraph g dfa figur algorithm c evalu queri dbgraph input dbgraph queri qr output qr g valu qr g construct dfa accept lr initi qr g node v n set cm v pm v test pair state node v n a call searchv v conflict see figur b reset pm w mark node w n fig evalu queri dbgraph algorithm c detect conflict unmark node backtrack enabl answer b found proceed descript algorithm c shown figur algorithm use dfa accept lr control depthfirst search db graph g line two reason dfa rather ndfa use first ensur conflict encount r restrict second reason avoid detect unnecessari conflict ndfa s t might case state q q ffi node v g first mark s follow cycl v satisfi l st travers conflict would regist unnecessari sinc v would subsequ mark q simpl path v satisfi t would found q t algorithm c travers transit graph dbgraph g simultan effect perform depthfirst search intersect graph g often refer tree depthfirst search forest gener algorithm c line a tree forest root initi node final node reach line add appropri pair node g qr g line forc algorithm consid path g satisfi r is path i travers restrict simpl path necessarili restrict dbsimpl path prove safe travers nondbsimpl path procedur search u v s var conflict u v node dbgraph state dfa dbcycl boolean flag conflict fals cm v cm v fsg f qr g edg g v w label firstcm conflict true els cm search u w t newconflict conflict conflict newconflict od cm v cm conflict pm v pm v fsg fi fig search procedur queri evalu absenc conflict node g mark state visit two set mark use node v set current mark cm v indic state v associ current path stack procedur line set previou mark pm v repres earlier mark v exclud current path line current mark use avoid cycl detect conflict previou mark use possibl prevent node g visit state singl execut line a function first appli mark set cm v return first state mark v current path fals mark node w visit state previou mark w either w current unmark cm w empti first state mark q v current path q t is conflict q line note may fact conflict later mark v current path affect correct algorithm demonstr below line implement conflict detect is conflict true conflict state q node w conflict set true line line ensur mark node stack time conflict detect remov node unstack conflict occur path root v s ad previou mark v line proof follow often say v s exampl stack procedur search variabl v refer middl two paramet search correspond node v s correspond intersect graph reason exclud two paramet search u the first remain unchang execut line a alway concern valu conflict a b a d b b c e b c c c c d b b c b c c c b c a a a c c b c b fig two possibl depthfirst search tree also sometim exclud conflict refer particular invoc search exampl searchu v s prove correct algorithm c demonstr behaviour mean exampl exampl consid intersect graph figur two possibl depthfirst search tree dfst travers algorithm c shown figur note node dfst repeat unmark exampl node d b appear three time figur a dot edg figur lead node search call either conflict those a node alreadi mark via either cm pm as b latter edg correspond forward back cross edg convent dfst assum algorithm c start travers node a a is searcha a a call line a order travers accord dfst figur a sinc initi node b c current mark line evalu fals search call success b a c b d b b final state c a d ad qr g line although c alreadi current mark name b fact b c mean line evalu fals search call c c first mark b a c conflict regist line algorithm backtrack remov current mark line assign previou mark line consid b c c b give rise conflict algorithm tri path via e b note d b c c longer mark revisit give rise conflict time algorithm backtrack a a node other unmark dbsimpl path b c final found a b ad qr g path b c via e b chosen first algorithm c as figur b conflict would detect result previou mark kept b e travers path c b line would ensur b c d b revisit conflict regist lemma conflict fals line searchu v s algorithm c perform entir depthfirst search node v s proof proof proce induct length longest simpl path p v s p length zero result follow trivial assum result hold node longest simpl path length longest simpl path length n conflict fals line searchu v s must that successor w t v s i either pm w line newconflict must fals line case conflict must fals line searchuw t order ad pm w case conflict must fals line searchuw t newconflict fals line sinc longest simpl path w t must length less equal n gamma conclud induct hypothesi entir depthfirst search w t perform algorithm c clearli line consid everi successor v s i result follow definit node v s depthfirst search tree call conflict predecessor if successor w t v s i w appear ancestor v s and first occurr from root say w q case q t word conflict q w lemma consid execut searchu v s df tree state ad pm v line descend v s conflict predecessor proof ad pm v line conflict must fals henc lemma entir depthfirst search v s must perform conflict predecessor node w t successor appear successor w t thu conflict predecessor appear descend v s descend v s conflict predecessor conflict fals descend henc v s itself thu ad pm v line dbgraph r regular express s let accept lr intersect graph g algorithm c correct is algorithm c add u z qr g dbsimpl path u z f f f that is simpl path u z g satisfi r proof algorithm c clearli termin sinc line ensur simpl path consid simpl path initi node consid onc onli algorithm add u z qr g must travers depthfirst search tree root u simpl path p u z r r f assum p dbsimpl dbnode v appear p let first occurr v p inod v s last occurr v t thu first state ad cm v order searchu v t call line line must ensur s t henc path p v s z q q f sequenc dbnode p ident path v t z r p sinc v s v t first last occurr respect v p path u z q q f dbsimpl respect v simpl induct number repeat dbnode p show dbsimpl path u z f assum dbsimpl path p u z f f f i obvious algorithm travers p done assum not let v s last node p travers w t successor v s p reason w t visit cannot conflict sinc p dbsimpl must case line lemma entir depthfirst search v s must perform sinc path v s z f i searchu z f must call case u z would ad qr g line theorem absenc conflict algorithm c run amount time bound polynomi size dbgraph proof essenti point that absenc conflict algorithm c perform normal depthfirst search intersect graph polynomi size dbgraph detail analysi time complex algorithm follow let qr queri r length m g dbgraph n node e edg although mani o state dfa accept lr constant term size g nevertheless assum q state includ q analysi time complex algorithm c sinc intersect graph g oqn node oq e edg line algorithm c done oq time line requir constant time line take on time line oq time line execut n time and execut node visit conflictfre v s stack ad cm v line ensur v s cannot restack v s unstack ad pm v line remov pm v present execut line a termin again line ensur v s cannot revisit present execut a constant time need line dbnode v cm v implement stack access bottom element function first henc line perform constant time line sinc fsg pm v disjoint by line line implement take oq time pair u v ad qr g final state pm v line also done oq time line inspect edg leav node i sinc node revisit search call time call take oq time singl execut line a take oq e time singl execut line b take on time total time spent line onq e consequ algorithm c run term size g algorithm c run one time under assumpt edg isol node relationship depict figur obtain follow corollari algorithm c evalu qr g time polynomi size g r restrict g acycl g compli cycl constraint compat r even presenc conflict algorithm c run polynomi time size g case exampl r free regular express let q length r r free finit number string lr length longest string q also upper bound length longest dbsimpl path i henc on q dbsimpl path even algorithm c travers everi dbsimpl path exactli the worst case still run polynomi time size g number circumst identifi lead polynomialtim solut exampl certainli queri evalu polynomialtim arbitrari dbgraph whose regular express restrict one class regular express form wa w string fix length unfortun dbgraph algorithm c take exponenti time evalu associ queri clearli much scope investig addit class queriesdb graph polynomialtim evalu possibl identifi appropri gener evalu algorithm develop algorithm c could enhanc react sophist manner detect conflict one possibl flag sourc conflict unmark node algorithm backtrack flag node conclus address problem find node label direct graph connect simpl path satisfi given regular express studi motiv observ mani recurs queri relat databas express form implement queri languag base observ began describ naiv algorithm might evalu queri although algorithm run exponenti time worst case show cannot expect better sinc evalu problem gener nphard use fact associ problem path gener as oppos simpl path solvabl polynomi time character class restrict regular express whose associ queri evalu polynomi time consid restrict structur regular express turn attent cyclic structur graph queri introduc notion cycl constraint show graph g compli cycl constraint compat regular express r qr g could evalu polynomi time final present algorithm evalu arbitrari express arbitrari graph algorithm run polynomi time a regular express restrict closur free b graph compli cycl constraint compat regular express a special case graph acycl c regular express graph conflictfre difficult say often condit encount practic show class restrict regular express close regular oper good start point investig larger class express graph polynomialtim evalu algorithm would attempt identifi class express graph conflictfre algorithm c run polynomi time emphasi paper identifi circumst regular simpl path problem solv polynomi time rather design effici algorithm case believ topic futur research exampl would interest see whether techniqu use spars graph could employ algorithm order improv effici spars graph point analysi paper implement itself assum graph entir store main memori reason assumpt mani case especi intend applic queri languag g graph often fraction databas present visual natur way relax assumpt provid interest area studi research investig similar algorithm transit closur claim amen effici secondari storag implement final note research done express power graphbas queri languag restrict simpl path semant drop one languag captur exactli queri comput nondeterminist logarithm space present onlin algorithm regular path find given survey mani result found r alpha extens relat algebra express class recurs queri design analysi comput algorithm univers data retriev languag complet queri languag relat databas data structur arc insert regular path find relat complet data base sublanguag graphlog visual formal real life recurs graphic queri languag support recurs direct subgraph homeomorph problem effici evalu subset recurs queri introduct automata theori equival effici transit closur algorithm effici algorithm transit closur linear worstcas complex result class spars graph evenpath problem graph digraph find regular simpl path graph databas practic approach support recurs applic polynomi solut undirect two path problem word problem requir exponenti time fast algorithm solv path problem implement logic queri languag databas tr ctr kemafor anyanwu amit sheth oper discov rank associ semant web acm sigmod record v n decemb kemafor anyanwu amit sheth oper discov rank associ semant web acm sigmod record v n decemb dan c stefanescu alex thomo lida thomo distribut evalu gener path queri proceed acm symposium appli comput march santa fe new mexico weight path queri semistructur databas inform comput v n p may gsta grahn alex thomo regular path queri approxim semant annal mathemat artifici intellig v n p februari phillip g bradford languag constrain graph problem microcosm engin research develop proceed nd wsea intern confer comput engin applic p januari acapulco mexico makoto murata extend path express xml proceed twentieth acm sigmodsigactsigart symposium principl databas system p may santa barbara california unit state frank neven thoma schwentick express effici pattern languag treestructur data extend abstract proceed nineteenth acm sigmodsigactsigart symposium principl databas system p may dalla texa unit state taesun chung hyoungjoo kim xml queri process use document type definit journal system softwar v n p decemb serg abiteboul victor vianu regular path queri constraint proceed sixteenth acm sigactsigmodsigart symposium principl databas system p may tucson arizona unit state gsta grahn alex thomo queri contain rewrit use view regular path queri constraint proceed twentysecond acm sigmodsigactsigart symposium principl databas system p june san diego california partial order regular languag graph queri journal comput system scienc v n p februari sergio flesca filippo furfaro sergio greco graph grammar base framework queri graphlik data data knowledg engin v n p decemb yaron kanza yehoshua sagiv flexibl queri semistructur data proceed twentieth acm sigmodsigactsigart symposium principl databas system p may santa barbara california unit state sangwon park hyoungjoo kim sigdaq enhanc xml queri optim techniqu journal system softwar v n p march gsta grahn alex thomo algebra rewrit optim regular path queri theoret comput scienc v n p march ravi kumar prabhakar raghavan sridhar rajagopalan andrew tomkin extract largescal knowledg base web proceed th intern confer larg data base p septemb georg a mihaila louiqa raschid anthoni tomas locat access data repositori websemant vldb journal intern journal larg data base v n p august ravi kumar prabhakar raghavan sridhar rajagopalan d sivakumar andrew tompkin eli upfal web graph proceed nineteenth acm sigmodsigactsigart symposium principl databas system p may dalla texa unit state yanni papakonstantin victor vianu dtd infer view xml data proceed nineteenth acm sigmodsigactsigart symposium principl databas system p may dalla texa unit state elisa bertino mohandsad hacid farouk toumani retriev semistructur web data intellig explor web physicaverlag gmbh heidelberg germani stephen dill ravi kumar kevin s mccurley sridhar rajagopalan d sivakumar andrew tomkin selfsimilar web acm transact internet technolog toit v n p august stephen dill ravi kumar kevin s mccurley sridhar rajagopalan d sivakumar andrew tomkin selfsimilar web proceed th intern confer larg data base p septemb finegrain access control system xml document acm transact inform system secur tissec v n p may mohandsad hacid farouk toumani ahm k elmagarmid constraintbas approach semistructur data fundamenta informatica v n p januari kemafor anyanwu amit sheth queri enabl queri semant associ semant web proceed th intern confer world wide web may budapest hungari elisa bertino ahm k elmagarmid mohandsad hacid order path constraint semistructur data journal intellig inform system v n p march serg abiteboul pari c kanellaki object ident queri languag primit journal acm jacm v n p sept denni shasha jason t l wang rosalba giugno algorithm applic tree graph search proceed twentyfirst acm sigmodsigactsigart symposium principl databas system june madison wisconsin