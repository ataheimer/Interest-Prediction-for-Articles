t optim algorithm scan span tree undirect graph a let g undirect graph v vertic e edg mani algorithm develop enumer span tree g earli algorithm use techniqu call backtrack recent sever algorithm use differ techniqu propos kapoor ramesh matsui shioura tamura find new span tree exchang one edg current one techniqu merit enabl us compress whole output span tree output rel chang edg kapoor ramesh first propos on etim algorithm adopt compact output n number span tree anoth algorithm time complex construct shioura tamura optim sens time complex term space complex take ove space refin shioura tamura algorithm decreas space complex ove ov e preserv time complex therefor algorithm optim sens time space complex b introduct let g undirect graph v vertic e edg span tree g defin connect subgraph g contain vertic cycl paper consid enumer span tree undirect graph mani algorithm solv problem develop eg may divid sever type depart inform scienc tokyo institut technolog ohokayama meguroku tokyo japan shiouraistitechacjp depart comput scienc inform mathemat univers electro commun chofugaoka chofushi tokyo japan tamuraimuecacjp z depart inform scienc tokyo institut technolog ohokayama meguroku tokyo japan unoistitechacjp first type belong mani earli algorithm use techniqu call backtrack use techniqu list kind subgraph eg cycl path on gabow myer refin minti algorithm read tarjan algorithm use onv v e time ov e space n number span tree enumer span tree output edg span tree algorithm optim term time space complex recent sever algorithm use anoth techniqu develop algorithm find new span tree exchang one pair edg instead backtrack furthermor enumer span tree output rel chang edg span tree compress size output nv henc total time complex may reduc fact kapoor ramesh propos onv e time ov e space algorithm adopt compact output optim sens time complex hand matsui develop onv v e time ov e space algorithm enumer span tree explicitli appli revers search scheme revers search scheme gener enumer problem see shioura tamura also develop algorithm gener compact output time space complex kapoor ramesh algorithm use revers search techniqu kapoorramesh algorithm shiouratamura algorithm howev effici term space complex take ov e space main aim paper obtain algorithm gener compact output optim sens time space complex refin shioura tamura algorithm process goe lower level node comput tree origin algorithm edg set effici divid without requir extra inform howev order effici restor edg set process goe back higher level node algorithm requir extra oe inform sinc depth comput tree v take ov e space propos use properti effici restor edg set techniqu restor use extra ov space all time complex remain onv e section explain techniqu enumer span tree compact output section defin nice childpar relat span tree propos naiv algorithm section show properti use effici manipul data structur implement implement g figur graph g graph present section time space complex analyz compact output let g undirect graph not necessari simpl v vertic defin two type edgeset necessari algorithm socal fundament cut fundament cycl let span tree g throughout paper repres span tree edgeset size v edg delet f yield two connect compon fundament cut associ f defin set edg connect compon denot cuttnf likewis defin fundament cycl associ set edg contain uniqu cycl g denot cyctg definit tnfg span tree f similarli g f cyctg tgnf also span tree properti use enumer span tree use fundament cut cycl construct differ span tree given one exchang exactli one edg given graph g let sgt a graph whose vertexset set span tree g whose edgeset consist pair span tree obtain exchang exactli one edg use fundament cut cycl exampl graph sg left one g shown figur algorithm find span tree g implicitli travers span tree sg order output v edg span tree jt jv time requir howev output edg first span tree sequenc exchang edgepair g obtain travers d need exactli two edg g exchang edg d furthermor scan compact output one construct span tree sinc adopt compact output becom desir find next span tree current one effici constant time basic idea naiv algorithm section explain basic idea naiv algorithm defin total order vertexset fv edgeset g indic especi call smallest vertex v root edg e call smaller incid vertex tail denot call larger one head denot e rel span tree g uniqu path vertex v root v contain vertex u u call ancestor v v descend u similarli two edg e f t call e ancestor f f descend e uniqu path f root v contain e depthfirst span tree g span tree found depthfirst search g known depthfirst span tree defin span tree edg g one incid vertex ancestor other algorithm make sever assumpt vertexset edgeset g assumpt depthfirst span tree g assumpt fe assumpt edg smaller proper descend assumpt vertex v smaller proper descend rel assumpt two edg e figur graph g vertic edg graph g figur satisfi assumpt fact one find sort vertic edg g ov e time g satisfi assumpt appli tarjan depthfirst search note assumpt suffici correct algorithm we howev need assumpt effici implement nonempti subset denot smallest edg s conveni assum lemma assumpt span tree c contain exactli one edg proof set n f exactli two compon one contain f therefor uniqu path cyct c f n f f contain least one edg cutt nf sinc depthfirst span tree may assum head edg descend tail rel without loss gener let e first edg f path e cutt nf head e descend tail e ancestor assumpt minim f connect c edg contain cutt nf path cyct c f n f henc e edg cyct c f n f cutt nf consid graph g figur let figur childpar relat graph g therefor cyct c f cutt nf given span tree c edg uniqu edg cyct c f cutt nf n f clearli fng span tree call p parent c c child guarante span tree uniqu parent sinc jt ancestor span tree graph g figur childpar pair shown arrow figur arrow goe child parent see arrow construct span tree sg root let span tree sg consist childpar pair span tree algorithm implicitli travers recurs scan children current span tree thu must find children given span tree exist next lemma give use idea thi lemma let p arbitrari span tree g let f g two distinct edg assumpt nfg child p f g satisfi follow condit proof assumpt c child p follow condit hold c span tree differ ng first show differ span tree assum contrari f c span tree f g contradict thu f p g ng must hold condit impli hand assumpt impli moreov impli show equival condit definit c henc impli distinct g cyct c f equival g cutt p nf therefor second condit equival second condit let e k largest edg less mint lemma find children p know edgeset cutt p ne ne consid graph defin figur case e e edg smaller mint therefor two children ne e ne rest paper shortli write cutt p ne ne ground edg cutt p ne ne enter p place consider construct algorithm below algorithm input graph g vertexset fv edgeset begin use depthfirst search find depthfirst span tree g vertic edg satisfi assumpt end procedur findchildr p input span tree p integ k e begin g entrt begin foutput children p contain e k g ne k g ffind children c g ffind children p contain e k g end algorithm procedur findchildren find children span tree call two argument p k find children p contain edg find child c recurs call find children c stage argument set c k k e k becom largest edg less mint children p figur enumer tree span tree g contain e k found recurs call find children p contain e k case argument p k initi algorithm allspanningtreesg call findchildren argument v span tree g found figur show enumer tree span tree graph theorem algorithm allspanningtre output span tree exactli onc proof lemma everi span tree differ output time parent output lemma span tree c parent alway exist uniqu determin sinc ancestor span tree algorithm output span tree exactli onc manipul data structur algorithm defin state find children p contain e k pair t p k call procedur findchildr p k current state becom find child c p contain e k state move t c k children p contain e k found state move t p k state t p k enter edgeset entrt requir output children p contain e k state move t c k or t p k necess enter edgeset entrt c e k occur first time key point find enter edgeset entrt c e k effici construct enter edgeset effici implement maintain edgeset defin below let p span tree e e ee e e e e figur movement state can k posit integ e edg e j j use notat sens cane set candid enter edg leav edg e j state t p k find easili maintain cane definit find child c p updat hand found children p contain e k construct effici implement depend maintain can effici figur show state edgeset can enumer span tree g figur exampl initi state t succeed state consid maintain edgeset first show initi edgeset found easili lemma assumpt proof sinc ne written as ne ne h assumpt edg e belong cutt ne j e descend e j e ancestor e e j addit assumpt e largest edg e cutt ne j lemma find cane appli depthfirst search lemma span tree p posit integ k e k arbitrari edg entrt assumpt follow relat hold span tree ne k g set ancestor edg e e proof note g entrt child p descend e k rel p descend g rel t vice versa therefor e j a entrt e ancestor e k entrt e j precis edg e descend e k rel p e belong entrt e j edg obvious belong entrt e j ancestor e lemma let p span tree let k posit integ e k assumpt edg g cane span tree ne k g follow relat hold proof assumpt two edg e f ancestor f rel e ancestor f rel p omit phrase rel or p edg let e edg exist let set edg ancestor e prove use relat case case edg e h therefor e j proper ancestor e entrt lemma guarante one set can updat want find children c children p contain figur state move t edg e follow equat hold hand state move t t candid edgeset updat edg implement use global variabl candi leav state repres edgeset cane variabl leav repres edgeset fe check constant time whether current span tree children check see leav suppos edgeset repres ascend order list realiz doubli link list also use data structur given graph g two incid vertic edg found constant time data structur initi span tree vertex v root uniqu edg e found constant time recal graph g satisfi assumpt two edg assumpt one find edgeset cane search order list candi k begin thu complet time proport size edgeset merg two edgeset execut time proport sum size two edgeset therefor take ojcan updat edgeset candi current state goe succeed state t k candi chang empti nonempti must insert edg e leav sinc leav ascend order list complet ojfeleaveje time hand state goe back t k t p k must reconstruct can thi must restor edg gg candi candi k shiouratamura algorithm restor effici execut record cane state t p goe t k idea howev requir ov e extra space sinc depth recurs call algorithm ov rest section discuss idea reduc extra space denot headset edg contain cane lemma assumpt headset head mutual disjoint state t p k proof lemma head initi state t nonempti thu assert true initi state assum lemma hold state t p prove hold next state t p ne k g k lemma follow relat hold hs headset edg cane head intersect hs headset mutual disjoint lemma headset hs edg cang head set head henc find hs restor candi easi pick edg figur state goe back t t edg cane must restor candi headset cane equal fv g case reconstruct cane implement use global variabl head repres head k state t p k suppos headset repres not necessarili ascend doubli link list lemma requir ov space manipul headset describ two procedur manipul data structur candi leav head current state t p goe succeed state t k goe back t p k respect procedur first case shown below procedur updatedatastructure k g f current state t p goe succeed state t ne k g k g begin e edg e move candi chang empti nonempti insert e leav hs head set edg fecandi k j maxim sublist consecut element hs head k begin record first element sublist posit head k stack delet sublist head k add end head record posit first element hs head stack end state chang t p t k must move headset hs edg cane gg head k head time move element hs one one move maxim sublist consecut element hs head k head figur extra space record posit maxim sublist ov number maxim sublist jhead k unchang state come back t p k easi manipul head time candi jhsj jcane omit detail thu time maxim sublist first element maxim sublist stack v figur updat head complex procedur ojcan cane second procedur restor data structur follow way procedur restoredatastructure k g f state t p ne k g k goe back t p begin e edg e find hs record posit first element head delet hs head move fecandi j e hsg candi begin candi k candi chang nonempti empti delet e leav move sublist hs correct place head k use record stack end sinc record first element head vertic ad head find hs constant time edg candi check constant time whether hs mark element hs advanc henc restor ojcan time delet edg leav complet constant time headset hs return head head k time proport number maxim sublist inform place head k therefor procedur restoredatastructur take ojcan optim implement analysi final describ effici implement analyz time space complex iti implement written below algorithm input graph g vertexset fv edgeset begin use depthfirst search simultan execut find depthfirst span tree g vertic edg satisfi assumpt e j e j end procedur findchildren current span treeg begin e k last entri leav delet e k leav begin last entri candi k delet g candi k add g begin q ne k gg restoredatastructure move entri q candi k restoredatastructure k e k add e k end leav end discuss time complex implement next lemma use analyz time complex lemma suppos span tree k posit integ assumpt edg g j span tree proof let span tree suppos j span tree j lemma ne j g j span tree algorithm allspanningtre time requir call findchildren ov e state t p k o children p contain e k time taken execut procedur findchildren mainten data structur consid time complex mainten data structur discuss section take ojcan cane maintain data structur state chang ne k g k e edg consid next two case case a mainten find children c ie g cane case b mainten find children p contain e k ie note case occur exactli one time span tree c case b occur one time span tree p edg e k feje case a number children c contain e moreov edg e j cane child c contain e therefor time complex case o children c case b bound number children p contain e least jfecan neither e k e similarli jfe bound number grandchildren p contain e k thu time complex case b o children p contain e k o grandchildren p contain e k recal procedur findchildren check constant time whether p children discuss total requir time findchildren state t p o children grandchildren p contain e k thu total time complex implement onv e final consid space complex state edgeset candi j intersect other neither headset head j thu need ov e space candi ov space head obvious cardin leav v describ section size stack record posit maxim sublist hs ov all total size local variabl q findchildren oe edg store one global variabl candi local variabl q henc space complex implement ov e theorem time space complex implement onv e ov e respect paper propos effici algorithm enumer span tree optim sens time space complex acknowledg greatli indebt dr yoshiko ikeb tokyo institut technolog kind valuabl comment manuscript r a basi enumer algorithm linear system geometr applic a pivot algorithm convex hull vertex enumer arrang polyhedra revers search enumer find span tree direct undirect graph algorithm gener span tree undirect direct weight graph an algorithm find span tree undirect graph a simpl algorithm list tree graph bound backtrack algorithm list cycl path span tree effici scan span tree undirect graph depthfirst search linear graph algorithm tr