t optim regist assign loop embed code gener a abstract one challeng task code gener embed system regist assign live variabl regist exist variabl necessarili access data memori loop typic execut mani time often timecrit good regist assign loop exceedingli import sinc access data memori degrad perform issu find optim regist assign loop one minim number spill regist memori open time paper address issu present optim exponenti algorithm assign regist loop bodi result spill code minim also show heurist modif perform well exponenti approach typic loop scientif code b introduct typic embed system consist embed programm processor interconnect memori special acceler work support part onr grant k preliminari version paper appear proceed th intern symposium system synthesi isss author address dj kolson a nicolau n dutt depart inform comput scienc univers california irvin irvin ca k kennedi depart comput scienc rice univers houston permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copyright notic titl public date appear notic given copi permiss acm inc copi otherwis republish post server redistribut list requir prior specif permiss fee acm transact design autom electron system vol no april page applicationspecif compon embed processor realiz either processor core applicationspecif instructionset processor asip architectur embed processor may resembl generalpurpos processor datapath regular may degre irregular datapath effici implement applicationspecif instruct andor featur either case proce sor memori may consolid one memori modul may distribut variou modul which size one correspond singl regist exampl embed processor consolid memori mip rc microsparcii wherea texa instrument tm seri motorola exampl distribut memori current much research focus code gener embed system one challeng task gener code embed processor regist assign assign process program valu map architectur regist valu avail appropri regist comput number simultan live variabl larger number regist avail valu resid data memori ie spill memori requir data transfer memori regist valu updat necessari comput typic embed processor small number regist with perhap regist restrict special use limit regist assign exceedingli critic especi innermost loop execut mani time often timecrit thu map variabl regist contain poor choic variabl spill advers affect perform compil domain optim regist assign solut extens studi horwitz et al hsu et al kennedi although approach effect straightlin code address issu optim assign regist loopsinnermost loop probabl place extrem method practic thu adapt extens work problem assign embed processor regist program valu requir overcom fundament difficulti previou techniqu address satisfactorilythat match regist usag entri exit loop iter is loop code correct map variabl regist begin iter end iter must equival ie right valu must right place correct iter loop code articl demonstr algorithm regist assign basic block given hsu et al kennedi extend assign regist loop incorpor loop unrol tech see lanneer et al liem et al marwedel marwedel goossen strik et al d j kolson et al niqu algorithm also present heurist deriv algorithm that practic seem perform well exponenti counterpart section discuss relat work section describ problem address section discuss optim assign regist basic block architectur consolid regist file section extend techniqu loop section discuss converg optim loop algorithm section extend loop algorithm assign regist architectur multipl regist file special purpos regist section give experiment observ result section conclud articl relat work regist assign problem import issu becom pervas mani area compil design typic number regist fix uniform access regist avail highlevel synthesi number interconnect regist synthes code gener embed system embed processor limit number regist with perhap partit regist file specialpurpos regist compil domain popular approach regist assign heurist graph color approach brigg chaitin et al assign regist graph color graph construct node repres variabl edg node repres overlap respect variabl lifetim task color graph number color equal number physic regist color found variabl spill memori process repeat key good regist assign scheme select particular variabl spill heurist select receiv attent brigg et al along method color graph chow hennessi also loop address hendren et al without regard number registerto regist transfer potenti requir techniqu end iter mani research felt particularli critic code segment innermost loop timesensit applic optim assign necessari horwitz et al present method obtain optim regist assign index regist minim number load store work either improv upon effici horwitz algorithm luccio extend basic algorithm deal simpl loop kennedi lose optim degrad perform recent research hsu et al extend basic idea horwitz algorithm includ regist assign gener purpos regist highlevel synthesi problem regist assign tradit refer determin number regist necessari save valu optim regist assign timestep kurdahi parker paulin knight order reduc interconnect multiplexor cost scatter regist research focus group regist memori mod ule research address assign regist loop variabl whose lifetim cyclic natur park et al stok approach arbitrarili break cyclic variabl lifetim loop boundari creat two coupl variabl assign process tri assign regist coupl variabl assign regist regist transfer necessarili insert end loop correctli set next iter techniqu develop regist alloc consid case variabl store within variou level memori hierarchi work code gener embed system extend leftedg algorithm incorpor regist class regist assign liem et al formul problem regist assign ilp formul wilson et al howev techniqu introduc registertoregist move loop boundari lanneer complex search scheme use navig larg search space mani tradeoff one regist assign work done minim number spill accumulatorbas architectur liao et al howev none previou work address issu find optim assign regist loop ie assign variabl regist requir registertoregist transfer minim cost due ad spill code target architectur problem descript exampl architectur organ target found figur architectur embed processor interconnect program memori typic readonli memori data memori one asic embed processor realiz either processor core asip previous mention embed processor may offer function datapath regular generalpurpos processor gpp compar gpp follow narrow datapath bitwidth smaller instruct set fewer number regist or embed processor may offer applicationspecif instruct set degre irregular datapath either case avail regist set may consolid one regist file may distribut multipl regist file exampl former mip rc sun microsystem microsparcii exampl latter texa instrument tm seri motorola thu task regist assign embed processor correspond ahm chen balakrishnan et al kim liu marwedel d j kolson et al either determin map program variabl regist contain within one regist file determin map program variabl regist distribut regist file while case honor access ie port restrict regist file addi tion model target instruct set noperand instruct also call naddress instruct aho et al approach task regist assign follow code select schedul oper time step resourc shortag occur regist assign phase ie live variabl regist exist thu requir multipl variabl share regist spill code explicit data transfer oper regist data memori becom necessari given applic contain loop goal minim number transfer oper due spill regist data memori repeatedli execut within loop regist assign begin analysi intermedi represent algorithm determin variabl access execut thu deriv variabl access stream intermedi represent sequenc finegrain noperand instruct effici map target architectur instanc risc processor target intermedi represent algorithm might sequenc operand instruct wherea accumulatorbas pro cessor intermedi instruct might compos oper instruct exampl operand oper b variabl access stream b a read variabl write denot write variabl denot concurr access parenthes bracket read write perform parallel exampl oper case nest loop oper innermost loop fig target architectur organ optim regist assign execut concurr variabl access stream bdeac variabl b d e read concurr variabl c written concurr variabl access stream deriv input assign algorithm optim assign regist basic block use variant algorithm present hsu et al deriv optim ie spill minim algorithm assign variabl regist basic block algorithm call optassignbb found figur optassignbb take input variabl access stream code segment map variabl regist immedi preced segment which could null signifi regist initi free algorithm build assign tree node tree correspond variabl map configur repres content regist found particular point execut root tree given initi map variabl regist path tree root leaf uniqu map variabl regist assign tree built success level tree deriv examin variabl stream current configur determin contain variabl consider fig regist assign algorithm d j kolson et al variabl contain within configur node duplic next level tree zerocost edg connect two variabl contain within node variabl access miss occur spill code might necessari configur caus access miss variabl current configur replac turn access fault variabl edg join access miss node newli creat node repres cost spill code go first map second cost compos cost possibl store replac regist live dirti the store algorithm andor cost possibl load fault variabl the loadcostv algorithm variabl read set load store cost one give total cost equal number memori oper thu r regist fault configur current level gener r configur next level result optim exponenti method heurist and been use prune search space horwitz et al hsu et al kennedi last variabl access consid leav assign tree examin lowest cost node trace path root lowest cost node yield assign regist variabl result minim cost term memori load store due spill code exhaust gener everi possibl assign figur a exampl code segment appear figur b contain variabl access stream segment exampl two regist r r initi assign b respect optassignbb algorithm begin initi map construct assign tree figur c first two variabl access variabl b variabl contain current configur therefor spill code necessari howev next access c caus variabl access miss spill code becom necessari two configur gener next level correspond assign c r r left child assign c r displac variabl a need store it valu consist memori spill code gener load c cost one possibl assign c r repres right child displac variabl b b dirti it previous written b must store c load cost two process examin next variabl access check whether contain within current configur continu remaind variabl access stream full tree figur c everi variabl assum uniqu memori locat may kept spill variabl necessari dirti refer case valu regist inconsist valu store memori locat prioriti given load store simpli chang cost optim regist assign fig build assign tree d j kolson et al gener figur c node dash outlin node prune tree ident node level gener ident subtre within group ident node one lowest cost need kept break tie arbitrarili extend basic block algorithm loop appli optassignbb algorithm bodi loop get optim assign singl execut code code contain within loop construct necessari regist map begin end code segment match order correctli iter segment gener assign produc optassignbb satisfi criteria ie lowest cost configur leaf assign tree necessarili match root thu basic algorithm adequ optim assign regist loop code remedi thi one might tri simpli add registertoregist move andor spill code load andor store enforc match howev cost addit spill code may vari greatli conceiv map anoth would vari unrol loop number time optassignbb result ignor effect cannot guarante optim anoth suboptim approach forc match loop top bottom is choos exponenti tree deriv optassignbb least cost leaf node ident initi configur leaf configur match root configur necessarili guarante lowest cost algorithm immedi obviou mani iter suffic produc assign result minim amount spill code fact problem open issu process unwind loop appli optassignbb continu cost may decreas iter unrol one loop iter appli optassignbb result code find new loop bodi potenti span sever iter origin loop that a cost spill per iter loop bodi minim b entri exit configur new loop match algorithm assign regist loop code refer optassignloop found figur gener structur algorithm iter unrol loop one iter appli optassignbb new iter possibl previou iter exit map algorithm analyz result exit map new iter determin match node iter ancestor ie node assign tree lie path root node also lie iter boundari so legal regist assign unrol loop optim regist assign found not exit map becom one map use initi configur next iter time match found algorithm comput averag cost per iter assign becaus assign may span multipl iter loop fulli unrol assign lowest averag cost per iter would optim assign loop full unrol loop necessarili practic parameter algorithm k number unrol loop bodi perform lowest cost map found cutoff scheme local minimum global number iter unrol far k note algorithm must alway get averag cost less equal optassignbb would get deal strictli cost calcul optassignbb add noth morebeyond unrol heurist prune although algorithm may comput prohibit even moder long loop provid strong start point determin fig loop regist assign algorithm d j kolson et al good heurist comput complex algorithm aris replac regist current configur variabl read write miss occur heurist modif simplist prune strategi best configur kept futur expans map particular level gener is node current level access miss occur possibl spill consid then newli gener node lowest cost node retain consider converg optim loop algorithm previous known whether optim regist assign loop could accomplish regardless effici algorithm difficulti ensur optim overal loop requir match regist top bottom loop bodi impos addit spill optim minim spill loop unwind differ regist assign unwound iter may need further more known whether finit unwind guarante converg result optim assign answer question introduc notion configur graph node configur graph correspond specif map variabl regist found iter boundari direct edg configur graph correspond cost spill code use sourc node initi map iter appli loop algorithm sink node one result node thu edg repres cost spill code sourc node initi regist assign to sink node result from iter loop figur illustr method build configur graph use assign tree figur label leaf node partial configur graph shown b construct assign tree a travers path root configur label p leaf configur give direct edg configur graph p respect node weight equal cost path instanc path root first leaf node left label q cost three thu edg configur graph p q ad edg weight three similarli edg ad configur graph travers variou path partial configur graph b result construct complet graph requir build assign tree possibl exit configur converg order guarante algorithm converg must shown unrol new exit configur ie map variabl regi ter previous exist gener algorithm exhaust replac regist time variabl access miss occur optim regist assign conceiv map gener state anoth way unrol loop bodi assign iter perform cost associ go initi deriv exit map becom known thu edg configur graph connect initi configur possibl exit configur gener assign algorithm appli node eg unrol loop bodi anoth iter direct edg exit configur one anoth obtain converg algorithm therefor equival find cycl configur graph thu algorithm converg number variabl number regist finit therefor number permut variabl regist finit although exponenti optim optim assign one memori traffic minim loop bodi unrol optim assign assign minim memori traffic spill cost iter fig build configur graph assign tree d j kolson et al contain within unrol loop thu optim assign ratio spill cost new unrol loop bodi number iter contain minim configur graph correspond ratio total cost cycl number node cycl therefor optim assign found examin averag cost possibl cycl possibl length configur graph take minimum note necessarili correspond minim cycl length one graph worstcas possibl optim cycl must make complet tour graph extend model distribut memori algorithm present earlier regist assign loop underli assumpt access avail regist equival found instanc generalpurpos processor embed processor is regist consolid one regist file variabl map regist uniformli avail oper use variabl howev case architectur avail regist partit disjoint regist file avail regist special purpos assumpt must modifi gener feasibl regist assign previous assumpt enough port regist file exist support read write variabl access particular step howev possibl restrict present number regist concurr access ie number readwrit port regist file constrain number readswrit regist file section discuss extens algorithm loop regist assign target embed processor architectur contain distribut regist file andor specialpurpos regist specif restrict regist access exist start discuss addit regist class model consid separ modif necessari algorithm handl specialpurpos regist distribut regist file ad regist class model extend algorithm introduc notion regist class regist class use compil aho et al stallman microcod synthesi feuerhahn liem et al denot function equival regist howev combin regist potenti usag one class precis enough regist assign target architectur class see thi consid simpl case two regist file compos gener purpos regist regist file connect differ alu clearli cycl length one would impli assign loop bodi minim initi configur natur ie without spill move match exit configur optim regist assign oper schedul either alu must operand present respect regist file howev collect regist group one regist class call generalpurpos possibl necessari operand assign way honor regist class invalid execut thu make regist assign invalid main caus problem due regist group equival rather equival establish approach two type regist class defin connect regist class oper regist class connect regist class conn_rc defin equival regist function architectur connect wherea oper regist class oper_rc defin equival regist function oper semant motiv deriv class connect architectur defin regist may read written function unit wherea semant particular oper execut particular function unit may preclud use connect regist a load oper instanc may requir memori address resid specif regist function unit execut load oper may connect mani regist serv purpos figur contain algorithm deriv regist class given architectur connect regist class deriv input output function unit architectur base upon regist may access input output oper regist class deriv examin oper function unit execut select readabl and writabl regist impos oper semant larg number case conn_rc oper_rc equival fig algorithm deriv regist class d j kolson et al extens specialpurpos regist algorithm optassignbb exhaust gener variabl map place variabl regist either read miss occur requir load variabl variabl written access regist uniform strategi correct howev regist special usag strategi gener map invalid variabl assign regist cannot perform requir special function thu necessari restrict placement variabl regist variabl resid regist perform necessari function notion regist class extend optassignbb algorithm handl regist special usag variabl caus access miss regist perform necessari function consid found intersect oper regist class access oper connect regist class function unit execut oper recal perform regist assign schedul dataflow graph thu perform regist assign oper and type access variabl well function unit oper execut on knownretriev inform simpl matter figur contain extend version optassignbb algorithm regist assign special regist usag function op_of return oper current access variabl v thi type oper function unit execut oper found via call function operationtyp functionalunit respec tive appropri oper regist class connect regist class found intersect rc_intersect intersect class defin feasibl regist variabl v may resid variabl one regist spill code necessari not regist contain rc_intersect candid replac spill code gener extens multipl regist file extend algorithm assign regist multipl regist file requir notion node assign tree alter assign regist architectur consolid regist file semant node regist uniformli avail instanc eight regist fill variabl a h map variabl regist repres abcdefgh signifi map regist one b map regist two on model multipl regist file chang inform contain node reflect group regist regist file node assign tree compos number regist set equal number regist file optim regist assign assign variabl figur contain extend version optassignbb algorithm assign regist multipl regist file main modif requir multipl regist file exist regist respect regist file examin determin variabl resid variabl contain within necessari regist file rather load memori check first made see variabl contain within one regist file so move oper use transfer valu necessari regist file necessari connect exist transfer like lower latenc load slower memori otherwis variabl load memori spill consid access restrict present regist file number regist simultan access consid restrict satisfi assign valid maintain futur assign otherwis map repres assign caus access conflict exist node remov futur consider assign differ cost spill memori fetch memori fetch anoth regist file fig extend optassignbb specialpurpos regist d j kolson et al note optim addit regist class extens special purpos regist algorithm deriv optim ie spill minim result howev multipl regist file version algorithm present may possibl suboptim result obtain previous variabl assign regist regist view candid replac extend case regist special purpos mere remov number regist candid and thu serv restrict growth assign tree howev case multipl regist file algorithm may longer deriv optim solut one variabl displac anoth regist file displac variabl may need store data memori requir load need futur howev free regist exist regist file might possibl store displac valu temporarili futur use further even free regist remot file still possibl remot variabl spill without loss perform thu free regist gener effect cascad effect becom quit complex variabl hop regist file regist file futur use extend algorithm handl would straightforward impract fig extend optassignbb multipl regist file optim regist assign experi result examin benefit techniqu conduct two set experi first target architectur consolid regist file second target architectur partit regist file special use regist experi benchmark suit consist six numer code written c compil risclik code typic code execut embed core processor asip code variabl access stream deriv use input algorithm experi deriv regist assign optim basic block algorithm optassignbb optim loop algorithm optassignloop heurist version loop optim algorithm heurist optassignloop count number spill ie load store assign gener assign optassignbb algorithm regist assum empti upon initi assign loop optassignbb guarante produc assign initi exit map match note point regist becam full ie point live variabl regist exist introduc spill code andor move match usag minim leaf node previous note initi node also order creat opportun optassignbb well use enlarg loop bodi construct unwind loop three time thu result optassignbb whole number repres averag singl iter origin loop experiment consolid regist file use microsparcii target code gener architectur consolid regist file microsparcii risc instruct set similar found mani embed core processor use variabl access stream regist assign produc optassignbb optassignloop heurist optassignloop algorithm regist assign number spill code oper count section compar optassignbb optassignloop result next compar heurist version optassignloop graph color approach implement gnu compil section section compar optim heurist loop version section compar number iter span optim heurist loop assign comparison optassignbb optassignloop tabl contain observ result contain number spill per iter optassignbb optassignloop well absolut percentag improv optassignloop optassignbb code produc compil gener accept high qualiti granlund kenner d j kolson et al measur as spill bb spill loop spill loop gener trend percentag improv increas number regist increas ie dispar loop assign basic block assign increas number regist increas attribut fundament differ optassignbb optassignloop optassignbb assign regist without regard effect iter regist usag wherea optassignloop examin iter effect regist usag natur discov minim assign loop minim assign produc optassignbb guarante match loop entri exit point therefor spill code becom necessari match regist usag two point howev optassignloop explor possibl keep variabl regist found loop end assign regist next iter discov better regist usag place insert spill code essenti optassignloop tabl i basic block optim vs loop optim microsparcii optim regist assign produc superior result natur ie without addit load store andor regist move find match loop entri exit configur assign process comparison heurist optassignloop graph color gcc configur produc sparc code regist assign modul modifi gcc would produc code use four six eight regist heurist version optassignloop use prune factor paramet best configur tabl ii summar result spill code produc gcc well heurist algorithm percentag improv measur as spill gcc spill heur spill heur case heurist produc assign superior gcc graph color approach variabl assign regist entir lifetim segment code variabl assign regist current access keep variabl regist caus high regist pressur load store gcc produc intern compil error real regist count set two recal prune strategi keep best configur consid possibl time variabl miss occur tabl ii graph color vs heurist microsparcii d j kolson et al variabl which current access gener necessari unaccess variabl previous spill memori segment anoth interest result heurist produc assign better optassignbb the optim assign basic block number case compar tabl ii show heurist result better optim basic block assign averag although heurist version loop algorithm abl deriv better result optassignbb abil find match regist assign loop execut optassignbb algorithm not comparison optassignloop heurist optassign loop tabl iii contain number spill per iter optassignloop heurist optassignloop algorithm column tabl iii comparison loop assign microsparcii optim regist assign three four respect column five contain heurist result percentag within optim measur as spill heur spill opt spill opt measur lower number better ie lower number closer heurist approxim optim half case heurist produc result equal optim also case within optim within optim result demonstr that although optim may comput prohibit simpl heurist version execut matter second produc result accept close enough optim code size loop regist assign one concern techniqu increas code size result loop unrol method typic produc regist assign span multipl itera tion especi concern context embed code gener program code resid rom thu directli affect tabl iv comparison loop code size microsparcii d j kolson et al rom size tabl iv note number iter span assign produc optassignloop heurist optassign loop column three four respect column five tabl iv indic whether heurist version deriv assign amount spill code optim major case number iter span version same case heurist version deriv assign amount spill code optim nine case case heurist span iter optim and those amount spill code produc three case one case heurist version span fewer number iter optim due natur heurist howev case heurist version produc spill code overal number iter span loop assign rang two five which feel within accept limit perform gain result fewer memori access runtim algorithm method propos exponenti natur execut time techniqu concern tabl v note minimum averag maximum execut time cpu second optassignbb optassignloop heurist optassignloop algorithm well regist alloc phase gcc execut sun system run unix although runtim exponenti method optassignbb opta signloop order sever cpu minut reason context embed code gener longer compil time toler obtain highqual code also includ tabl v averag number spill per iter regist configur previous studi result demonstr tradeoff runtim qualiti produc regist assign again runtim optassignbb optassignloop order sever cpu minut qualiti assign produc as compar graph color approach least better both measur heurist optimaloptim increas number regist increas also result tworegist case heurist version appear tabl appear tabl ii mention earlier avail gcc tabl v comparison run time microsparcii optim regist assign heurist version loop algorithm deriv result close optim wherea runtim compar gcc regist alloc phase experiment distribut regist file use tmxc exampl architectur distribut regist file figur show simplifi view architectur section give brief overview purpos code gener use scaleddown version tmxc parameter number regist regist bank tabl regist column denot number ie mean bank contain two registerstwo extend precis two generalpurpos two auxiliari registersfor total six gener assign optassignbb optassignloop heurist version optassignloop section compar result basic block optim loop optim access commerci avail compil tmxc comparison heurist anoth heurist unavail howev section compar result optassignloop heurist optassignloop section compar code size loop assign tmxc overview figur show simplifi view tmxc architectur three regist file extend precis regist bit wide use floatingpoint long integ arithmet auxiliari regist bit wide use address pointer dedic address gener hardwar autoincr autodecr address valu generalpurpos regist bit wide regist file connect reg reg buse avail multipli alu multipli alu may write extend precis regist fig simplifi view tmxc d j kolson et al one may write either auxiliari regist gener purpos regist addit operand may suppli multipli alu memori comparison optassignbb optassignloop tabl vi contain observ result contain number spill per iter optassignbb optassignloop well absolut percentag improv optassignloop optassignbb measur spill bb spill loop spill loop befor gener trend percentag improv increas number regist increas due optassignloop abil natur match regist usag loop top bottom upon inspect assign produc note case assign produc basic block scheme assign address variabl gener purpos regist near end iter variabl heavili use top loop spill code spill address variabl current within auxiliari regist necessari gener accommod variabl comparison optassignloop heurist optassign loop tabl vii present result spill code produc optim heurist algorithm column three four respect column five contain heurist result percentag within optim measur spill heur spill opt spill opt measur lower number better ie lower number closer heurist approxim optim case heurist produc result equal optim case result produc within optim rest case tabl vi basic block optim vs loop optim tmxc optim regist assign percentag within optim higher howev actual differ spill code produc one instruct code size loop regist assign again code size directli affect size program rom studi number iter produc loop assign tabl viii contain number iter span loop method given tabl viii comparison loop code size tmxc tabl vii comparison loop assign tmxc d j kolson et al number regist well indic whether heurist method produc equal amount spill code optim major case heurist deriv assign span number iter optim and those gener amount spill code three case case heurist assign span one iter produc amount spill code one case overal rang number iter span assign two four believ within accept limit runtim algorithm note runtim algorithm case tmxc result tabl ix contain minimum averag maximum execut time cpu second optassignbb optassignloop heurist optassignloop algorithm execut sun system run unix includ tabl ix averag number spill per iter regist configur previous examin tmxc although anoth heurist unavail comparison heurist loop algorithm deriv result close optim runtim effici enough practic use full regist set previous experiment use scaleddown model tmxc number regist regist file reduc section present result regist alloc one benchmark number regist use alloc actual number tmxc architectur auxiliari regist extend precis regist generalpurpos regist benchmark select partial differenti integr excerpt result experi may found tabl x column two three give number spill basic block loop method respect column four give percentag improv loop method basic block method result demonstr that presenc realist resourc constraint techniqu deriv assign variabl regist natur match loop boundari point definit advantag optim basic block method arbitrarili forc regist usag tabl ix comparison run time tmxc optim regist assign conclus articl motiv present algorithm optim assign regist loop case optim assign one memori traffic result spill code minim work answer longstand question whether possibl principl achiev optim minim spill code loop demonstr feasibl use techniqu task regist assign embed code gener conduct experi risclik code typic embed core processor also extend algorithm assign regist irregular datapath found mani asip regist special use andor regist partit multipl regist file experiment method demonstr heurist method obtain suitabl perform outperform graph coloringbas approach use gnu c compil gcc r compil principl alloc multiport memori data path synthesi ieee tran regist color via graph color color heurist regist alloc regist alloc via color prioritybas color approach regist alloca tion elimin branch use superoptim gnu c compil regist alloc framework base hierarch cyclic interv graph index regist alloc minim loadsstor local regist alloc spill code result use regist tmxc util multiport memori data path synthesi real program regist alloc data rout paradigm effici datapath synthesi code gener instruct select use binat cover code size optim regist assign resourc classif asip microcod gener comment index regist alloc mimola design system tool design digit processor code gener embed processor regist alloc data flow graph condit branch loop use port gnu cc interconnect optimis data path alloc effici code gener inhous dspcore integr approach retarget code gener revis januari tr real program regist alloc color heurist regist alloc minim loadsstor local regist alloc prioritybas color approach regist alloc util multiport memori data path synthesi regist alloc via graph color regist assign resourc classif asip microcod gener data rout integr approach retarget code gener treebas map algorithm predefin structur index regist alloc regist alloc framework base hierarch cyclic interv graph interconnect optimis data path alloc ctr catherin h geboti low energi memori regist alloc use network flow proceed th annual confer design autom p june anaheim california unit state weikai cheng younlong lin code gener nest loop dsp processor heterogen regist structur pipelin acm transact design autom electron system toda v n p juli