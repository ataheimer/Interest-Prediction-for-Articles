t comparison three round algorithm ieee floatingpoint multipl a abstracta new ieee compliant floatingpoint round algorithm comput round product carrysav represent product present new round algorithm compar round algorithm yu zyner quach et al round algorithm logic descript block diagram given correct proven latenc analyz conclud new round algorithm fastest round algorithm provid inject which depend round mode sign ad reduct partial product carrysav encod digit string doubl precis format latenc new round algorithm logic level compar logic level algorithm quach et al logic level algorithm yu zyner b introduct everi modern microprocessor includ oatingpoint multipli compli ieee standard latenc fp multipli critic oatingpoint perform sinc larg portion fp instruct consist fp multipl exampl oberman report fp multipl account percent fp instruct benchmark applic lot research devot optim latenc ad partial product produc product eg recent work round product accord ieee standard publish assum multipli output carrysav encod digit string repres exact product follow natur question aris fastest method comput round product given exact product repres carrysav encod digit string consid compar three round algorithm a algorithm quach et al denot qtf algorithm b algorithm yu zyner denot yz algorithm c new algorithm base inject base round denot es algorithm provid block diagram round algorithm optim speed measur latenc algorithm logic level enabl technolog independ comparison main build block algorithm similar consist compound adder comput sticki carri bit thu cost three algorithm similar interest question nding fastest algorithm focu doubl precis multipl signicand repres bit algorithm assum signicand normal name rang therefor product rang consid case deal denorm special valu sinc support denorm valu obtain use extend expon rang comput special valu done parallel three algorithm share follow techniqu product repres carrysav encod digit string digit case doubl precis partit lower part upper part upper part ad compound adder comput binari represent sum sum ulp ulp denot unit last posit sum denot sum upper part carrybit roundbit stickybit comput lower part round decis comput two path nonov ow path work assumpt exact product rang ow path work assumpt product rang although sum upper part denot sum equal exact product signic bit sum control select two path main dierenc three round algorithm outlin follow round decis qtf es algorithm simplifi round decis earli addit valu thi valu call predict qtf algorithm inject es algorithm qtf algorithm predict depend round mode carrysav digit posit digit right radix point es algorithm inject depend round mode assum ad partial product thu product alreadi includ inject round decis yz algorithm base customari round tabl posit carrysav encod product partit lower part upper part dier three algorithm yz algorithm lower upper part separ buer three carrysav digit posit posit digit denot mani digit right radix point two algorithm upper part consist posit lower part consist posit latenc propos design implement algorithm term logic level follow latenc es algorithm logic level latenc qtf algorithm logic level latenc yz algorithm note modi adapt qtf yz algorithm minimum latenc support four round mode ieee standard error prone task therefor provid correct proof three algorithm formal clarifi tricki aspect point view yz algorithm easiest prove qtf algorithm intric especi round decis logic paper organ follow section preliminari issu describ as notat convent use regard ieee round gener set section straightforward round algorithm review algorithm describ provid outlin task round exact product comput attempt parallel task round therefor long latenc section round algorithm describ proven analyz section discuss latenc algorithm increas precis increas section summari conclus given due space limit section omit found full version preliminari notat let x x binari string denot binari string x z x z x z also sometim refer x xi sinc deal fraction index binari encod bit string x x associ weight valu encod xz denot jxz ieee round ieee standard dene four round mode round toward round toward round toward round nearest even base sign number round mode round toward round toward reduc round mode rz round zero ri round inniti thu leav three round mode ri rz rne round nearest even furthermor quach et al suggest implement rne round nearest up denot rnu round mode rnu dene follow x two success represent r rnu reason rne implement rnu r rnu x r rne x least signic bit lsb binari encod therefor obtain r rne x r rnu x accomplish pull down lsb sake clariti dene round zero rz signicand rang doubl precis note denit exclud postnorm shift take place number binad denit let x r rz x dene r rz x div integ q satis gener set paper consid doubl precis multipli assum signicand prenorm name valu two signicand rang signicand repres binari string bit posit exact product two signicand rang encod binari string bit posit note weight bit posit sake simplic ignor expon signbit path float point multipli perform comput two phase rst phase addit tree reduc partial product carrysav encod digit string repres exact product second phase binari string repres round product comput carrysav encod string paper discuss implement second phase naiv ieee round section review simpl slow ieee compliant algorithm round multipl descript input consist two binari string sum carri bit index sum binari number repres sum carri equal exact product exact round comput follow the comput expon string omit reduc round mode one three round mode base one sign product compress sum carri string ad obtain singl binari string name note sinc exact product rang signic bit x posit normal jxj jx jxj implement condit shift one posit right note x index comput sticki stickybit equal comput round decis round decis rd f g base round mode bit stickybit note round mode stage alreadi incorpor sign increment comput binari string repres sum postnorm jy signicand string round product given delay analysi latenc step naiv round procedur least logarithm length binari string sum carri step requir constant delay everi pipelin stage accommod one logarithm depth circuit implement naiv round procedur requir least pipelin stage es round algorithm section review inject base round present implement doubl precis requir under assumpt speci sec logic level inject base round round inject reduc round mode ri rnu rz reduct base ad inject depend round mode follow eect ad inject summar follow equat mode frzrnurig figur depict reduct rnu ri rz inject assum number round rang exact product denot exact rang inject must xed order make reduct rz correct correct amount denot inj correct dene therefor x rang eect ad inject correct amount summar follow equat mode frzrnurig assumpt inject ad multipli adder array therefor complet descript inject base round number rang round algorithm section present new es algorithm round oatingpoint multipl base inject base round figur depict block diagram es round algorithm round algorithm work assumpt sum carrystr alreadi includ inject but inject correct proce follow sum carrystr divid high part low part high part consist posit low part consist posit low part input box comput carri round stickybit dene follow binari string satis higher part input line half adder produc output x sum note bit lx posit carri gener posit exact product less even ad inject input compound adder output sum increment sum jy increment decis box receiv roundbit r carrybit c lsb lx msb y round mode rn ri output signal inc indic whether select signic bit indic whether rang depend bit normal follow shif righti shif righti round result except least signic bit select z z accord increment decis inc follow case round mode rne least signic bit need correct sinc rne rnu alway result least signic bit correct least signic bit comput two parallel path one path work assumpt round result ow ie greater equal path work assumpt round result ow path comput correct lsb noover ow assumpt implement box call x l novf input x l novf box round bit r sticki bit s signal rne indic whether round mode round nearest even output denot notpd equal zero lsb pull down path comput correct lsb over ow assumpt implement box call x l ovf input x l ovf box lx bit carrybit c round bit r sticki bit s signal rne output denot notpd equal zero lsb pull down note pull signal inact round mode rne least signic bit round result xing lsb in case discrep rne rnu equal one three valu a round result ow lsb equal lx c b round result ow increment decis increment c round result ow increment decis increment lsb xing lsb implement combin use andgat pulldown signal correspond candid lsb signal output andgat denot by l inc l ninc linc sake clariti introduc signal lninc equal linc lsb round result equal lninc ow occur increment took place lsb round result equal linc ow occur increment took place lsb round result equal l ninc ow occur increment took place lsb round result equal l inc ow occur increment took place accord case lsb round result select depend ow signal increment decis detail section describ function three box gure fulli describ yet fix l novf box belong path assum product rang recal might discrep rne rnu tie occur name exact product equal midpoint two success represent number let exact denot valu exact product fix l novf gener signal notpd satis exact occur rne tie occur two possibl a rnu rne agre yield round result lsb equal zero pull lsb case requir caus damag b rnu rne disagre lsb rnu result must pull down without addit inject tie occur inject alreadi includ tie occur therefor notpd signal dene by fix l ovf box belong path assum product rang fix l ovf gener signal notpd satis exact occur rne dierenc notpd notpd notpd use assumpt product greater equal without addit inject tie occur in case ow lx inject alreadi includ tie occur lx therefor notpd signal dene by increment decis increment decis box two path depend whether ow occur path work assumpt ow occur ie produc increment decis lx path work assumpt ow occur ie need take account correct inject denot inj correct produc increment decis lx therefor inc signal dene by correct proof tricki part algorithm correct inc signal long bit indic correctli whether exact product greater equal equat impli inc signal correct one also consid case fail indic correctli binad exact product name a exact product greater equal b exact product without inject less sourc error due fact jy alway equal mostsignic bit exact product recal lower part product correspond posit regist sum carri well lx eect valu howev inject might eect sinc addedin multipli array depend multipli array implement wallac tree etc follow claim show mismatch occur round product equal moreov case path one work assumpt ow occur one work assumpt ow occur yield result therefor correct round obtain even fail indic correctli binad exact product exact denot exact product let sum carri satisfi jsumj exact inject correct round exact comput follow r mode r rz exact r rz exact proof consid two main case a a suppos exact claim follow eq exact exact reason possibl contribut lx f g therefor exact correct inject satis inj correct therefor exact accord eq case r mode howev case r rz exact round zero map interv b suppos exact claim follow eq exact sinc inject follow exact proof follow proof case a prove use control select right round result follow claim prove implement comput r mode exact correct note claim deal xing lsb obtain rne rnu r rz exact r rz exact exact tail impli r rz exact inc signal case equal addit lx c gener carri posit inc simpl addit take place r rz exact inc two case rst case increment caus ow simpl addit take place ow caus sinc bit output bit l x c discard complet proof rst part lemma suppos therefor exact impli r rz exact lemma follow delay analysi section present delay analysi round algorithm depict fig analysi base follow assumpt consid carri lookahead adder let dcla denot delay bit adder measur logic level assum msb sum delay dcla logic level assumpt easi satisfi carri lookahead adder brent kung use otherwis satisfi assumpt may requir arrang parallelprex network msb readi one logic level earlier compound adder implement delay sum dcla delay increment sum dcla obtain ore carrygener carrypropag signal lemma consid box carri round sticki bit comput accord rst assumpt sinc width box compound adder similar delay carri bit dcla logic level delay round bit dcla logic level delay sticki bit estim dcla logic level base fast sticki bit comput present assum delay associ buer fanout one logic level figur depict block diagram inject base round algorithm annot time estim assign dcla valu logic level impli sticki bit valid logic level carrybit c valid logic level roundbit valid logic level similarli sum valid logic level msb valid logic level increment sum valid logic level msb valid logic level figur depict implement fix l novf fix l ovf increment decis box annot time estim time estim use fig obtain estim delay logic level round product yz round algorithm section review analyz round algorithm yu zyner report implement ultrasparc risc microprocessor refer algorithm yz round algorithm descript figur depict block diagram yz round algorithm descript dier descript two way sum output bit adder three bit believ mistak sum four bit we denot sum z sum increment sum fed mux select one either shift right not propos normal sum increment sum select take place earli normal help reduc delay round circuit cost two shifter rather one algorithm describ below sum carrystr divid high part low part high part consist posit low part consist posit low part input box comput carri sticki bit dene follow binari string satis higher part input line half adder produc output x sum note carri gener posit exact product less high part x sum divid two part posit fed compound adder output sum increment sum jy ad carri bit c produc sum z process z split two path one work assumpt round product ow ie less path work assumpt round product ow noover ow path comput round decis rd round dec novf box round decis rd ad z novf box produc sum claim prove bit addit produc carri bit posit sum z novf two role posit result bit posit ow occur posit use detect carri gener posit ow occur bit z novf decid whether upper increment sum select noover ow case ow path comput round decis rd round dec ovf box round decis rd ad z ovf box produc sum claim prove bit addit produc carri bit posit sum z ovf two role posit serv result bit posit ow occur posit use decid whether increment take place upper part decis path chosen made select decis box first ow signal ovf comput follow ow signal ovf determin whether z ovf z novf chosen carrybit eect posit therefor determin increment decis inc z ovf z novf two least signicand bit round product comput follow ow occur therefor lower mux select bit result ow occur bit result depend whether increment take place not inc note inc z ovf ovf sinc signal z ovf readi earlier inc use z ovf control select z ovf z ovf select done sel multiplex fig signic bit indic whether rang depend bit normal follow shif righti shif righti round result except least signic bit select z z accord increment decis inc signal follow correct section provid proof ad round decis gener carrybit posit claim appli noover ow path ow path denot sum output bit adder depict fig let rd denot round decis noover ow path let rd denot round decis ow path then proof partial compress caus halfadd line impli jx sum follow fact x sum i x carri i cannot equal one ad c increas rang yield contribut rd rang therefor eq follow contribut rd rang therefor eq follow delay analysi figur depict yz round algorithm annot time estim use assumpt delay signal use sec argu least logic level requir path sum increment sum comput lie critic path critic path consist carrybit comput bit adder round dec novf box novf box select decis box driver upper mux consid follow optim minim delay lower bound requir number logic level bit adder implement condit sum adder late carryin bit c select sum increment sum fast implement bit x carri x sum valid one logic level carrybit c valid logic level round decis box implement cascad two level multiplex control z noover ow path z ow path ow path z combin stickybit henc round decis requir logic level noover ow path logic level requir addit round decis bit requir one logic level use condit sum adder inc signal valid logic level due need comput signal ovf two logic level see eq one select accord eq inc signal pass driver due larg fanout driver incur delay one logic level control upper mux output result logic level qtf round algorithm quach et al present method ieee compliant round techniqu gener round algorithm santoro et al section present round algorithm base method quach et al aim minimum delay apart reduc round mode rzrnu ri key idea use method quach et al santoro et al inject predict bit base round mode valu sum carri inject predict bit reduc number possibl round result section deviat quach et al follow point present paper quach et al separ accord round mode sinc investig round algorithm support round mode integr round mode one algorithm quach et al suggest sever option choic predict logic rnu one possibl suggest mode rz ri sinc predict logic lie critic path chose simplifi predict logic much possibl dene pred quach et al separ round decis compound adder use way compound adder comput sum sum correct sum select control logic interest faster design therefor break way adder halfadd line way compound adder mux control logic use output way compound adder lsb in case ow gener control logic well increment decis descript figur depict block diagram round algorithm suggest base quach et al mani similar round algorithm base inject round round algorithm base quach et al point dierenc new notat input compound adder high part sum carri pass two line halfadd rst line make room predict bit second pass enabl separ bit lx posit thi is fact part way compound adder increment decis two path one ow noover ow msb select path output increment decis inc addit increment decis comput lsb befor xing rne case ow occur detail section describ detail increment decis box lsbx rne box increment decis box output increment decis box increment decis inc bit l equal lsb round product xing case ow occur increment decis partit two path one case ow occur comput signal inc ovf path case ow occur comput signal incnovf follow equat dene signal inc ovf inc novf inc inc r pred pred inc s _ r _ pred pred output inc equal inc novf inc ovf bit accord bit inc novf inc ovf bit l equal lsb round product befor xing case ow occur dene by r lx c rnu pred ri note case ri complic due possibl pred c pred c pred c eect wrong predict revers pred c lsbx rne lsbx rne box output two signal notpd use pulldown lsb tie occur ow occur notpd use pulldown lsb tie ow occur signal dene follow contrast inject base round inject predict contain lx r sbit comput rne ow occur tie occur case lsb pull rne therefor ow occur tie occur case lsb pull rne therefor correct section prove correct select signal inc proof divid two part rst part assum exact product rang second part prove even signal ow incorrectli select signal inc still correct correctli whether exact product rang inc signal signal correctli whether increment requir round proof consid separ case ow ow case consid three possibl round mode question address whether round decis conjunct compress lower part carrysav represent produc carri posit inc signal carri gener posit suppos ow occur name round mode rz truncat take place therefor carri posit gener round mode rnu round decis increment in posit roundbit equal increment gener carri posit henc carri gener posit round mode ri round decis increment in posit one need take account predict alreadi ad product consid two subcas a pred contribut pred c cancel out therefor c ignor round decis gener carri posit r b c pred impli therefor round decis without predict would increment posit pred increment alreadi took place addit carri gener posit suppos ow occur name round mode rz sinc truncat take place case ident case ow round mode rnu round decis determin bit posit therefor two case either carri gener posit sinc lx carri gener posit round decis combin case impli carri gener posit round mode ri consid two case i pred may ignor c predict sinc contribut cancel out case round decis increment l x pred consid two subcas a lx eect predict restrict chang lx therefor round decis base r _ s sinc round decis increment b lx eect predict gener carri posit second halfadd line chang lx mean without predict lx would equal impli round decis would increment sinc increment alreadi took place addit increment requiredth select inc ovf inc novf control although might signal correctli case ow follow claim show signal ow correctli choic equal henc inc signal correct signal ow correctli name exact exact then inc inc novf proof proof divid two case exact case occur pred therefor restrict round mode ri sinc pred follow lx impli case inc ovf inc novf requir exact discrep occur therefor smaller multipl follow impli lx consid three round mode rz inc inc novf ri exclud possibl case rnu sinc claim follow delay analysi figur depict round algorithm base quach et al delay annot delay assumpt use similar use two previou round algorithm round algorithm depict fig use predict logic lie critic path delay predict logic two logic level follow quach et al fig depict nonoptim process order post normal shift take place round select increment decis box assum organ follow bit s c r valid logic level respect minim delay implement round equat level multiplex result select condit signal arriv thu total delay logic level obtain perform postnorm round select take place one logic level save obtain total delay logic level higher precis round algorithm scale higher precis use one see part present round algorithm depend length signicand are halfadd compound adder sticki round carrybit comput select multiplex driver amplifi signal control wide multiplex precis increas width upper lower part carri save string grow still stay almost equal other impli assumpt rel delay carrybit comput compound adder need chang moreov expect precis grow gap delay comput carrybit stickybit grow stickybit comput lie critic path impli rst order estim ignor addit delay due increas fanout interconnect length delay round algorithm precis p state follow delay inject base round algorithm logic level plu delay sum comput pbit compound adder dcla p delay yz round algorithm delay round algorithm base quach et al optim in postnorm take place select level summari conclus new ieee compliant oatingpoint round algorithm comput round product carrysav represent product present new round algorithm compar two previou round algorithm make comparison relev possibl consid optim previou algorithm improv delay round algorithm logic descript block diagram given correct proven latenc analyz conclus new es round algorithm fastest round algorithm provid inject ad reduct partial product carrysav encod digit string es algorithm round product comput logic level doubl precis ie signicand bit long precis independ term critic path consist compound adder addit logic level inject ad reduct partial product carrysav encod digit string extra step ad inject requir step amount carrysav addit latenc associ fulladd name logic level thu inject ad late latenc es round algorithm logic level addit inject reduct partial product accomplish without slowdown small slowdown justic is a partial product usual obtain booth recod select eg multiplex henc valid much later inject b delay ad partial product increas strictli monoton function number partial product delay incur ad inject ani depend length signicand organ adder tree two round algorithm requir inject doubl precis latenc qtf round algorithm logic level critic path consist compound adder addit logic level yz round algorithm rank slowest round algorithm latenc logic level critic path consist compound adder addit logic level r area perform optim cmo multipli fast multipl algorithm implement regular layout parallel adder method round use redund code multipli result scheme parallel multipli method apparatu round highspe multipli recod partial compress round fast multipli bitproduct matrix reduct use bit order pariti gener dual mode ieee multipli comparison three round algorithm ieee oat point multipl parallel method apparatu detect complet oat point oper involv special operand ieee standard binari oatingpoint arithmet multistep gradual round design strategi optim multipli circuit design issu high perform float point arithmet unit snap project design oat point arithmet unit method speed optim partial product reduct gener fast parallel multipli use algorithm approach reduc number counter need integ multipl gener high speed cmo multipli accumul float point multipli perform ieee round addit parallel fast ieee round round algorithm ieee multipli half latenc ieee compliant oatingpoint multipl reducedarea scheme carryselect adder fast multipl algorithm vlsi implement suggest parallel multipli new design techniqu column compress multipli oat point multipli method apparatu partial suport subnorm operand oat point multipl share round hardwar multipli divisionsquar root unit use condit sum adder circuitri round oat point multipli l l l l l l l l l l l l tr ctr petermichael seidel guy even delayoptim implement ieee floatingpoint addit ieee transact comput v n p februari ahmet akka michael j schult dualmod floatingpoint multipli architectur parallel oper journal system architectur euromicro journal v n p octob nhon t quach naofumi takagi michael j flynn systemat ieee round method highspe floatingpoint multipli ieee transact larg scale integr vlsi system v n p may