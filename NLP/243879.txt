t modulo schedul loop controlintens nonnumer program a much previou work modulo schedul target numer program which often major loop wellbehav loopcounterbas loop without earli exit controlintens nonnumer program loop frequent characterist make difficult effect appli modulo schedul characterist includ multipl control flow path loop base loop counter multipl exit loop presenc unimport path high resourc usag long depend chain penal import path path contain hazard anoth nest loop prohibit modulo schedul loop control depend sever restrict overlap block within across iter paper describ set method allow effect modulo schedul loop multipl exit techniqu includ remov control depend enabl specul extens modulo variabl expans new epilogu gener scheme method use superblock hyperblock techniqu allow modulo schedul select path loop arbitrari control flow case studi present show method combin superblock techniqu enabl modulo schedul effect appli controlintens nonnumer program perform result sever spec cint benchmark unix util program report demonstr applic modulo schedul class program b introduct schedul instruct loop great interest mani program spend major execut time loop often necessari schedul overlap success iter loop order find copyright ieee publish proceed th annual intern symposium microarchitectur decemb pari franc person use materi permit howev permiss reprintrepublish materi resal redistribut purpos creat new collect work resal redistribut server list reus copyright compon work work must obtain ieee contact manag copyright permiss ieee servic center hoe lane po suffici instructionlevel parallel ilp effect util resourc highperform processor softwar pipelin loop schedul scheme allow motion instruct one iter anoth maintain overlap loop iter throughout execut loop descript variou approach softwar pipelin given paper focus class softwar pipelin method call schedul modulo schedul simplifi gener overlap schedul initi iter constant rate requir iter loop common schedul constant interv start success iter call initi interv ii initi candid ii chosen maximum two lower bound resourceconstrain lower bound ii resmii equal number cycl heavili use resourc use singl iter worstcas constraint among cycl depend graph determin recurrenceconstrain lower bound ii recmii previou work modulo schedul target numer program which often major loop wellbehav do loop loopcount base loop without earli exit extens perform evalu modulo schedul techniqu loop seem exist percept modulo schedul primarili applic program controlintens nonnumer program loop frequent characterist make difficult appli modulo schedul obtain signific speedup characterist includ multipl control flow path loop base loop counter multipl exit sever techniqu develop allow modulo schedul loop intraiter control flow hierarch reduct predic execut revers ifconvers work assum path loop bodi includ schedul includ path detriment overal loop perform presenc unimport path high resourc usag long depend chain result schedul penal import path infrequ path contain hazard anoth nest loop function call prohibit modulo schedul loop previou work also done modulo schedul loop base loop counter key difficulti type loop may take mani cycl determin whether start next iter limit overlap iter difficulti overcom specul initi next it erat work also mention sourcetosourc transform convert loop multipl exit singleexit loop result loop contain multipl path control dealt use one method modulo schedul loop intraiter control flow refer abov howev method add extra instruct delay earli exit end loop bodi work need evalu perform approach especi architectur without predic execut paper describ new set method allow effect modulo schedul loop multipl path control multipl exit use superblock and futur hyperblock techniqu exclud unimport detriment path loop loop multipl exit often occur natur controlintens program benefici exclus path via format superblock hyperblock loop creat mani them thu effect method handl multipl exit essenti rather transform loop singl exit loop propos method modulo schedul loop as is multipl exit present new code gener scheme describ creat correct epilogu exit specul use increas overlap basic block within iter overlap success iter extend modulo variabl expans allow specul instruct write variabl live loop exit altogeth method describ paper allow effect modulo schedul select path loop arbitrari control flow paper report speedup result sever spec cint benchmark unix util first report perform result modulo schedul controlintens nonnumer program demonstr applic modulo schedul class program valid correct propos method paper organ follow section describ method develop present case studi show method combin superblock tech niqu enabl modulo schedul effect appli controlintens loop section report perform result section provid summari direct futur work modulo schedul controlintens loop detail exampl use illustr difficulti caus controlintens loop benefit techniqu develop loop chosen case studi one frequent execut loop lex lexic analyz gener sourc code loop shown figur tempj break return i figur sourc code exampl loop lex loop gener purpos nonnumer program frequent complex control flow evid exampl loop outer loop contain ifstat inner loop earli exit via return statement inner loop contain ifstat earli exit via break statement obvious loop contain number hazard modulo schedul modulo schedul would ordinarili target inner loop howev profil inform indic inner loop infrequ invok usual iter condit ifstat evalu fals time figur show simplifi version control flow graph loop block x contain code load statei j comparison statement s block consist postincr pointer j code bodi ifstat s control flow within block omit clariti block z contain code updat test exit condit z z a b figur superblock format exampl loop detriment path contain inner loop exclud loop via superblock format effect superblock format done use profil inform andor static analysi structur hazard program superblock loop consist frequent path outer loop block x z form shown figur b path block exclud via tail duplic block z superblock loop consist singl path loop singl entranc one exit loop consist block x z appear inner loop multipl exit target modulo schedul detail descript superblock format see shown superblock optim acycl schedul techniqu provid substanti speedup gener abil superblock and similarli hyperblock exclud undesir path execut provid follow benefit modulo schedul ffl decreas resmii exclud unimport path high resourc usag ffl decreas recmii exclud unimport path contribut long depend cycl ffl increas number loop modulo schedul exclud path contain hazard nest loop function call although modulo schedul method develop paper describ use superblock exampl equal applic hyperblock code figur show assembl code exampl superblock loop instruct number later refer enc block x control flow graph consist instruct instruct block z assembl code shown produc impact compil classic optim appli element array state four byte size regist shown virtual regist regist alloc done modulo schedul inst assembl regist content ble r l figur assembl code superblock loop control exit superblock loop instruct taken instruct taken paper exit associ fallthrough path loop back branch term final exit exit superblock loop via taken branch term earli exit virtual regist r r r live earli exit l block y taken valu r r decrement block z valu r increment block y virtual regist live loop exit via final exit instruct loop complex control flow occur frequent gener purpos nonnumer program tabl show statist percentag dynam instruct singl basic block loop basic block multipl exit superblock loop superblock spec cint benchmark sever unix util program column label total sum two column time spent two type loop spent exclud path inner outer loop acycl code tabl percentag dynam instruct singl basic block superblock loop benchmark basic superblock total block espresso compress sc gcc cmp eqn lex tbl wc yacc program except gcc tbl littl time spent singl basic block loop program except tbl time usual much more spent multipl exit superblock loop singl basic block loop tabl clear modulo schedul must abl effect handl loop control flow applic program remaind section describ propos techniqu overcom control depend regist antidepend associ loop multipl exit liveout virtual reg ister code gener scheme loop multipl exit also present overcom control depend use specul code motion control depend major impedi exploit ilp loop generalpurpos nonnumer program crossiter control depend restrict overlap loop iter delay start subsequ iter branch current iter execut frequent branch depend earlier comput loop bodi cannot execut late iter sever limit overlap intraiter control depend combin crossiter data depend creat recurr limit throughput modulo schedul loop also increas length critic path singl iter result longer schedul iter import consider short trip count loop describ crossiter control depend loop back branch instruct next iter relax allow specul code motion overlap iter loop multipl exit concept must extend earli exit branch often necessari remov crossiter control depend earli exit branch instruct subsequ iter achiev desir level overlap also often necessari remov intraiter control depend allow overlap block within iter achiev good perform short trip count loop remov either type control depend quit simpl howev current assum store branch specul execut reorder branch subject futur work order specul execut load instruct caus except either processor architectur must contain support specul execut compil must abl prove via program analysi specul execut instruct except paper assum instruct set architectur contain silent nontrap version instruct caus except furthermor instruct write virtual regist live loop exit requir special attent remov control depen denc issu discuss section show effect control depend exampl superblock loop figur show depend graph node number id from figur instruct repres branch node shade data control depend shown solid dash line respect transit depend shown none regist antidepend shown assum remov remov antidepend discuss section control data a figur depend graph exampl loop arc label two number first minimum delay cycl requir start two instruct second number distanc number iter two depend in struction arc distanc zero intraiter depend distanc greater zero crossiter depend instruct set assum similar hp parisc branch delay slot except branch delay shown pa assum instruct fallthrough path branch potenti execut cycl branch instruct taken path execut cycl follow branch sever nontrivi recurr appar graph longest recurr circuit run instruct back total delay six span one iter result recmii six loop schedul use depend graph overlap iter crossiter control depend loop back branch instruct next iter except instruct remov allow specul code motion overlap itera tion howev still limit control depend present recurr circuit consist instruct limit recmii five break recurr intraiter control depend instruct must remov enabl specul execut instruct control depend instruct instruct must also remov break remain limit recurr figur b show depend graph limit control depend remov reduc recmii one instruct legal move modulo schedul branch branch data depend instruct exampl instruct could legal schedul instruct instruct move branch automat move path branch gener epilogu follow actual modulo schedul process section shown special attent must paid type code motion correct code gener multipl exit loop assum issu processor execut one branch per cycl resmii exampl loop two recmii one result ii two speedup three modulo schedul use depend graph figur a overcom antidepend use modulo variabl expans thu far noth said antidepend constraint impos virtual regist live loop exit origin form instruct write virtual regist v live exit branch b cannot move b overwrit valu v use exit b taken constraint upward code motion exactli v one operand b ie antidepend constraint repres differ mani compil instead ad explicit antidepend arc mani compil includ impact overload control depend arc repres control depend antidepend sever exampl antidepend case studi loop instruct use r later defin instruct virtual regist r live branch l instruct taken anti depend instruct instruct antidepend remov renam modulo variabl expans unrol kernel renam success lifetim correspond loop variant longer overlap time allow regist antidepend remov schedul ing know modulo variabl expans correct overlap lifetim lack depend allow modulo variabl expans algorithm origin describ allow remov crossiter antidepend howev intraiter antidepend also remov lifetim analysi renam algorithm extend includ lifetim cross iter assum done paper describ chang need figur illustr relax crossiter antidepend use modulo variabl expans describ three iter abstract loop bodi contain definit use virtual regist r shown intraiter flow depend mark f crossiter antidepend mark a cycl instruct issu shown squar bracket right abstract in struction assum delay flow depend two antidepend zero origin form shown left minimum ii achiev two use modulo variabl expans antidepend remov prior schedul reduc ii one two virtual regist use shown right use r f use r f use r f use r f use r f use r f a b figur relax crossiter anti depend figur show relax intraiter anti depend case use appear definit origin iter lifetim r cross iter remov intraiter anti depend prior schedul allow definit move use within iter shown right previou case two regist use ii reduc use r use r f use r f use r use r f use r f a b figur relax intraiter anti depend lifetim virtual regist extend first definit last use lifetim loopvari virtual regist v definit use u comput use follow equat assum lifetim start issu end u issu issu issueu issu time instanc u origin iter distv number iter separ instanc u use valu defin origin loop note equat use u could branch v live out correct renam lifetim analysi must extend includ use addit consider live virtual regist instruct move downward across branch b code motion occur definit move path branch epilogu gener v longer liveout lifetimev comput equat becom less equal thu lifetim v comput use except associ exit move across figur show execut two iter case studi loop modulo schedul first iter start time instruct denot subscript second iter start time instruct denot subscript second it erat instruct also shade distinguish two iter lifetim virtual regist written loop shown right execut record virtual regist lifetim begin schedul gener schedul singl iter origin loop schedul work analyz lifetim modulo variabl expans definit first iter subsequ tic mark denot either explicit use virtual regist sourc operand branch regist liveout lifetim extend last use regist cycl issu slot lifetim figur execut record lifetim two iter lifetim r entir contain within one iter ation defin instruct use instruct issu issu distr ii use equat length lifetim lifetim r cross iter defin instruct use instruct next iter live instruct next iter issu issu distr use equat total length lifetim definit v renam cycl set virtual regist assign v use v renam first find iter contain correspond definit v the current iter di tancev zero previou iter distancev one use virtual regist name definit iter longest lifetim r cycl loop must unrol three time modulo variabl expans figur show unrol kernel modulo schedul loop modulo variabl expans instruct renumb renam one name use origin virtual regist name set regist use r r r r set regist use r r r r instruct put sequenti order would done gener code superscalar processor target fallthrough path first two copi loop back branch instruct revers prepar epilogu gener block l origin fall path loop inst assembl cycl ble r l l figur unrol kernel superscalar processor review code gener scheme singl exit loop subsect review exist code gener scheme singl exit loop prepar introduc modifi scheme multipl exit loop complet discuss possibl code scheme singl exit loop see use abstract code represent reduc complex exampl figur show singl iter gener singleexit loop modulo schedul squar repres code one stage ii cycl singl iter origin sourc loop number stage call stage count ii cycl b unrolledkernel code structur a one iter figur abstract represent iter figur b show code structur modulo schedul loop kernel unrol gener prologu epilogu iter progress left right one start one stage previou one backedg arrow row row identifi start end unrol kernel the degre unrol unrel stage count squar kernel repres prologu squar afterward repres epilogu squar also given number specifi version code use version use differ name regist avoid overwrit live valu code structur figur b simplist allow arbitrari number iter correctli execut illustr basic concept prepar reader complex and correct code scheme describ later section paper loop back branch refer loop back branch origin loop bodi multipl copi branch modulo schedul kernel unrol prologu gener copi except one becom loop back branch kernel target fallthrough path revers shown figur loop exit branch taken rather fall through exit associ copi loop back branch call final exit exit earli exit chain depend lead loop back branch determin earliest stage loop back branch place stage loop back branch schedul determin number iter specul initi assum stage iter number stage correspond stage b correspond on use terminolog loop back branch schedul stage specul execut stage iter first exampl figur b loop back branch schedul stage b stage everi iter first execut specul paper last iter refer last iter would execut origin nonpipelin loop exit last iter taken specul iter abort figur show structur code gener possibl stage loop back branch could place threestag schedul figur a b c loop back branch schedul end stage a b c respect a c figur code gener scheme singl exit loop arrow except backedg repres control transfer prologu kernel epilogu shown final exit schedul end stage arrow origin close bottom row squar epilogu contain code complet nonspecul iter progress time exit taken although explicitli shown end epilogu exist code move live valu regist code outsid loop expect find jump origin target block exit compar figur b one see structur gener code chang loop back branch schedul end stage b instead stage a loop back branch execut one stage later fewer stage left execut epilogu last iter predecessor thu epilogu one less row one specul iter progress loop exit abort one less column epilogu one less exit prologu one epilogu disappear altogeth gener loop back branch place stage instead stage rightmost column epilogu remov correspond abort specul iter result epilogu stage count figur c loop back branch schedul end last stage thu last iter predecessor complet loop exit epilogu consist code need move live valu shown code gener scheme multipl exit loop figur illustr chang code gener scheme multipl exit loop figur assum loop two exit earli exit loop back branch schedul stage figur a b c branch schedul stage a b c respect exit modulo schedul loop thu epilogu arrow associ earli exit origin close top row dash line distinguish final exit two key differ final exit earli exit first final exit schedul end stage earli exit branch middl stage thu final exit epilogu start begin stage follow one contain final exit branch earli exit remaind row contain exit branch kernel must examin copi epilogu iter last one remaind iter stage row contain exit branch copi epilogu treatment last iter discuss shortli figur small letter use denot partial stage result exit branch middl stage c c c c c c c c c a figur code gener scheme multipl exit loop second key differ loop back branch alway last instruct origin loop bodi earli exit branch somewher middl origin loop bodi final exit taken last iter alway fulli execut remain stage last iter copi epilogu entireti howev earli exit taken instruct last iter appear exit branch origin loop bodi execut assum basic block superblock assign numer id sequenti zero sc gamma defin home block instruct basic block instruct resid origin loop bodi earli exit instruct remain stage last iter copi epilogu id home block less equal home block id exit branch figur shade squar use denot stage home block check copi instruct figur epilogu final exit figur epilogu earli exit alway one row usual one column correspond final exit stage extra row consist remaind row kernel earli exit branch resid thu squar extra row mark small letter extra column correspond last stage oldest iter progress time exit taken final exit iter finish exit taken earli exit part last stage remain complet epilogu epilogu earli exit prologu extra column none iter start execut last stage rightmost column earli exit epilogu shade column correspond last iter last iter instruct appear exit branch origin loop bodi copi epilogu figur show algorithm gener epilogu exit branch algorithm start instruct follow exit branch copi row instruct unrol kernel epilogu wrap around kernel last row epilogu complet squar copi correspond instruct iter last instruct last iter appear exit branch origin loop bodi algorithm shown assum processor branch delay slot follow paragraph describ data structur concept need understand algorithm unrol kernel divid section ii cycl call kernel row kmin row kmin degre unrol kernel row contain link list instruct contain row data structur instruct contain pointer inform structur contain among item stage instruct schedul instruct home block id row kernel contain instruct sc gamma row epilogu number zero stage exit branch schedul row zero partial row empti final exit the link list kernel row end final exit row epi row epilogu last iter execut stage instruct stage less epi row must iter last thu copi simplic algorithm shown gener correct epilogu exit kernel exit prologu practic algorithm contain addit code map exit prologu correspond exit kernel prologu gener similar manner epilogu copi select instruct row unrol kernel map prologu exit correspond kernel exit facilit copi row epilogu also practic epilogu exit prologu algorithm copi instruct later stage stage first iter execut instruct correspond nonexist iter prior first one appli code gener scheme exampl loop schedul singl iter exampl loop contain stage stage consist instruct origin loop see figur stage b contain instruct instruct earli exit final exit stage c code scheme figur c similar would gener exampl loop depend structur loop opportun downward code motion across earli exit branch thu earli exit branch taken remain instruct last iter appear exit branch origin loop bodi algorithm genepiexit branch creat epilogu block gener row epilogu determin start copi epirow partial row exit final exit exitnextop null instruct copi partial row els full row gener one full partial row oper null copi instruct iter previou last iter last iter appear exit branch origin loop bodi operstag insertopafterepiloguelastop newop rotat row kernel insert move end epilogu variant live exit insertmovesforlivevariantsepilogu exit last exit branch fall epilogu exit last exit unrol kernel creat jump target exit branch make epilogu block target exit branch figur epilogu gener algorithm shade epilogu empti insert move liveout valu mention earlier code must append end epilogu move valu liveout correspond exit regist code outsid loop expect find them singl exit superblock loop valu use outsid loop must defin last iter thu final exit instruct last iter examin correspond epilogu kernel valu produc instruct liveout destin regist one expect outsid loop move instruct insert end epilogu multipl exit loop procedur final exit howev earli exit addit consider live valu could defin last iter one instruct preced exit branch origin loop bodi could defin secondtolast iter one instruct follow exit branch origin loop bodi thu last iter examin instruct origin resid earlier home block earli exit branch secondtolast iter examin instruct origin resid later home block exit exampl loop earli exit instruct figur taken live valu r r secondtolast iter live valu r last iter valu live final exit figur show code gener exampl loop use multipl epilogu code scheme figur c instruct renumb move live valu instruct also shown block label pro l prologu unrol kernel respect block label le le le epilogu block immedi follow kernel epilogu reach fall loop back branch block l origin fall path loop label l start block y epilogu final exit instruct empti code move downward across loop back branch virtual regist live final exit rather branch empti epilogu final exit branch directli l except loop back branch fall epilogu jump l earli exit instruct requir move one live virtual regist branch epilogu mention end renam one name use origin virtual regist name thu live valu alreadi correct regist move necessari case r epilogu le r epilogu le jump place end earli exit epilogu transfer control block y inst assembl cycl ble r l jump l jump l l figur final assembl code exampl loop virtual regist renam modulo variabl expans use livein virtual regist first iter refer origin virtual regist name thu move requir livein valu exampl virtual regist r livein first iter prologu use r instruct rather one renam version r r experiment result section report experiment result applic modulo schedul controlintens nonnumer program result obtain use impact compil interprocedur alia analysi data depend analysi done front end memori depend arc pass back end give optim schedul accur depend inform addit classic optim optim perform back end increas ilp code modulo schedul done prepass acycl schedul global regist alloc modulo schedul implement rau iter modulo schedul use machin descript system get inform instruct latenc resourc requir modulo schedul use pipelin loop high issu rate version parisc in paper sparc architectur loop elig modulo schedul inner loop outer loop may becom inner loop superblock format singl basic block superblock loop contain function call includ path function call may exclud loop superblock format enabl modulo schedul target processor experi multipl issu processor issu rate vari resourc constraint tabl show function unit mix processor processor assum integ regist doubleprecis floatingpoint regist latenc use hp pa processor tabl processor characterist number name issu integ memori branch fp slot alu port unit alu base speedup report singleissu base pro cessor base processor ilp optim modulo schedul appli multipl issu pro cessor code gener three way without modulo schedul modulo schedul singl basic block loop modulo schedul superblock loop use techniqu describ pa per code softwar pipelin schedul use acycl superblock schedul none loop unrol acycl schedul modulo schedul gener prior unrol improv perform acyclicli schedul modulo schedul loop howev complex interact unrol optim schedul add anoth variabl tri focu effect modulo schedul purpos paper primarili describ effect method modulo schedul loop controlintens nonnumer pro gram result paper use demonstr applic modulo schedul class program valid correct method effect unrol prior schedul perform comparison modulo schedul acycl schedul unrol loop controlintens nonnumer program subject futur work describ section execut time whole program calcul use schedul cycl count basic block profil inform cach hit rate assum benchmark profil transform insur accuraci profil done instrument target virtual processor assembl code emul aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa superblock modulo schedul basic block modulo schedul schedul espresso eqntott compress gcc cmp lex wc yacc figur speedup singl issu processor without modulo schedul hp seri workstat execut produc benchmark output use verifi correct target processor assembl code benchmark chosen experi four spec cint four unix program tabl espresso eqntott compress gcc cmp lex wc yacc spend time basic block superblock loop loop appli modulo schedul chosen program dynam instruct loop total loop modulo schedul figur show speedup result white part bar show speedup base processor acycl schedul appli code espresso eqntott lex yacc perform flat resourc increas without overlap iter ilp exploit limit black part bar show slightli increas perform modulo schedul appli singl basic block loop benchmark except gcc less dynam instruct basic block loop thu slight perform improv expect benchmark gcc spend half much time singl basic block loop superblock loop show speedup crosshatch part bar show increas perform superblock modulo schedul appli elig loop modulo schedul almost doubl perform lex issu processor almost tripl perform issu processor shown case studi limit ilp within singl iter loop program modulo schedul provid good speedup across benchmark processor particular speedup obtain across processor espresso eqntott com press lex yacc aggress processor perform improv benchmark except gcc wc superblock modulo schedul perform espresso eqntott lex yacc longer flat processor resourc increas ilp exploit overlap loop iter result clearli show modulo schedul use techniqu describ paper applic controlintens nonnumer program conclus paper describ set method allow effect modulo schedul loop multipl exit method use allow modulo schedul select path loop arbitrari control flow case studi present show method enabl modulo schedul effect appli controlintens nonnumer program perform result sever spec cint benchmark unix util program demonstr modulo schedul significantli acceler loop class program previou work shown unrol prior modulo schedul improv perform numer program unrol enabl addit optim effect ii integ acycl schedul unrol done allow optim overlap iter modulo schedul unrol done optim effect resmii recmii much research need done studi effect unrol prior modulo schedul nonnumer program understand amount unrol necessari achiev minimum ii possibl given loop next step effort appli modulo schedul controlintens nonnumer program one result next step abil compar modulo schedul global acycl schedul unrol loop within common framework acknowledg research paper benefit convers mike schlansker bob rau hp lab thank bob rau scott mahlk grant haab provid feedback earli version paper brian deitrich john gyllenha anonym refere suggest submit version author would also like thank jurgen mihm whose work inspir thought modulo variabl expan sion nanci warterperez noubar partamian past present member impact research group provid underli technolog modulo schedul built research support nation scienc foundat nsf grant mip intel advanc micro devic hewlettpackard sun microsystem ncr nation aeronaut space administr nasa contract nasa nag cooper illinoi comput laboratori aerospac system softwar iclass r realist resourceconstrain softwar pipelin algorithm use profil inform assist classic code optim three architectur model compilercontrol specul execut overlap loop support cydra new compil techniqu parallel loop unpredict branch vliw architectur memori disambigu facilit instructionlevel parallel compil machin descript languag compil superblock format use static program analysi superblock effect techniqu vliw superscalar compil softwar pipelin effect schedul techniqu vliw machin sentinel schedul model compilercontrol specul execut effect compil support predic execut use hyperblock effici schedul fine grain parallel loop iter modulo schedul algorithm softwar pipelin loop schedul techniqu easili schedul horizont architectur high perform scientif comput code gener schema modulo schedul loop parallel loop exit pipelin architectur enhanc modulo schedul loop condit branch tr softwar pipelin effect schedul techniqu vliw machin overlap loop support cydra new compil techniqu parallel loop unpredict branch vliw architectur parallel loop exit pipelin architectur advanc languag compil parallel process use profil inform assist classic code optim effect compil support predic execut use hyperblock code gener schema modulo schedul loop enhanc modulo schedul loop condit branch sentinel schedul instructionlevel parallel process superblock iter modulo schedul unrollingbas optim modulo schedul effici schedul fine grain parallel loop superblock format use static program analysi three architectur model compilercontrol specul execut schedul techniqu easili schedul horizont architectur high perform scientif comput ctr elana granston eric stotzer joe zbiciak softwar pipelin irregular loop tmsc vliw dsp architectur acm sigplan notic v n p aug fei chen timothi w oneil edwin hm sha optim overal loop schedul use prefetch partit ieee transact parallel distribut system v n p june suhyun kim soomook moon jinpyo park kemal ebcioglu unrollbas copi elimin enhanc pipelin schedul ieee transact comput v n p septemb moon evalu schedul techniqu sparcbas vliw testb proceed th annual acmiee intern symposium microarchitectur p decemb research triangl park north carolina unit state ganesh lakshminarayana kamal s khouri niraj k jha wavesch josep llosa stefan m freudenberg reduc code size modulo schedul absenc hardwar support proceed th annual acmiee intern symposium microarchitectur novemb istanbul turkey enric gibert jess snchez antonio gonzlez interleav cach cluster vliw processor proceed th intern confer supercomput june new york new york usa mari lou soffa interprocedur condit branch elimin acm sigplan notic v n p may nystrom alexandr e eichenberg effect cluster assign modulo schedul proceed st annual acmiee intern symposium microarchitectur p novemb dalla texa unit state satish pillai margarida f jacom compilerdirect ilp extract cluster vliwep machin predic specul modulo schedul proceed confer design autom test europ p march alexand g dean complement softwar pipelin softwar thread integr acm sigplan notic v n juli samuel larsen rodric rabbah saman amarasingh exploit vector parallel softwar pipelin loop proceed th annual ieeeacm intern symposium microarchitectur p novemb barcelona spain sangmin shim soomook moon splitpath enhanc pipelin schedul ieee transact parallel distribut system v n p may michael dupr nathali drach olivi temam vhc quickli build optim complex embed architectur proceed intern symposium code gener optim feedbackdirect runtim optim p march palo alto california