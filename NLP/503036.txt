t check infer via drive dag grammar a abramov glck recent introduc techniqu call ura invert first order function program given desir output valu ura comput potenti infinit sequenc substitutionsrestrict correspond relev input valu case process terminatein present paper propos new program analysi invert program techniqu work comput finit grammar describ set input relat given output product grammar origin program implicitli transform use socal drive step wherea ura sound complet sometim fail termin techniqu alway termin complet sound exampl demonstr deriv type infer type checkingth idea approxim function program grammar new instanc second author develop techniqu use tree grammar approxim termin behaviour deforest howev present purpos necessari invent new type grammar extend tree grammar permit notion share product dag grammar seem independ interest b introduct programtransform techniqu collect call supercompil shown eectiv handl problem partial evalu deforest cannot han dle appar strength supercompil stem drive object program is specul unfold express contain variabl base possibl execut describ program exampl drive consid haskelllik program where convent main denit serv interfac program possibl execut program variabl v vs main v vs drive program result process tree describ possibl comput program program one possibl process tree append con v vs nil con v append vs nil append vs nil let u append nil nil vsnil append con x xs nil vscon x xs con v u gener process tree construct follow root process tree label righthand side main denit new leav ad tree repeatedli inspect label leaf either unfold outermost call instanti variabl hinder unfold generalis creat two disjoint label whenev label leaf ident label ancestor up renam variabl leaf unfold k new slightli ecient program easili extract process tree name main interest paper transform checker descript input satisfi checker is given program answer true fals transform program descript input checker answer true activ gener known program invers descript satisfi input yet anoth program is howev nontrivi task perform program invers follow exampl show exampl consid program check whether two list ident auxiliari function isnil iscon need allow pattern match one argument time reason restrict associ everi pattern match particular function denit result invert program wrt true anoth program produc pair ident list howev unreason assum produc program even though easi imagin program produc innit stream pair list ident spine element come from base type element could enumer enumer clearli lead nontermin gener case wors still imagin program per se give us good descript input set mere get indic input set run observ everincreas output instead invert program one might perform comput backward gener method perform invers comput propos abramov gluck name univers resolv algorithm ura ura construct process tree object program produc process tree potenti innit set constraint uninstanti input variabl xs ys exampl constraint describ set input valu mean substitutionrestrict pair produc constraint pairwis disjoint sens set describ pairwis disjoint variabl appear sever time constraint indic ident valu exampl ura would produc someth like xs nil ys nil xs con x nil ys con x nil xs con x con x nil ys con x con x nil ura would never termin merit ura sound complet termin result precis captur input set paper sacric sound develop approach alway produc nite descript satisfi input overview section present formalis certain kind contextfre grammar name dag grammar instanc checker describ grammar nil nil con x con grammar consist two product form acycl direct graph also known dag rst say rewritten dag consist two singl node label nil second say rewritten complex dag two root two product view nite represent dag grammar precis express data control ow program someth possibl standard tree grammar section present automat method extract dag grammar program conceptu extract work two step first drive object program produc process tree second extract grammar process tree precursor drive program precis formul semant program languag present section extract dag grammar approxim input set section consid variou way improv precis method applic section show that given type checker term possibl deriv type scheme term dag grammar denot fs set contain g binari relat denot d domain set determinist binari relat ie partial function denot partial function g denot set biject denit given set s graph g consist label function lab n connectedbi relat mean node is kth successor node j js th predecessor i relat satisfi properti label node successor predecessor number consecut formal order successor predecessor immateri simpli use binari relat write j whenev k n i k j follow use subscript like lab g g otherwis obviou graph refer to denot transit closur gener superscript binari relat denot transit closur superscript denot exiv closur denit graph g dag contain cycl ie i n i i dag natur talk root leav root g g i leav g g j two dag e equival denot e e transform one anoth renumb node is set dag denot ds exampl two structur depict equival class dag fs nil con xg sens structur describ famili equival dag node set n left unspeci order successor predecessor howev speci adopt convent head tail arc order left right concretis right dag is exampl leav f g root fg denit given set dag grammar set nite dag set dag grammar denot g exampl two dag compris dag grammar fs x nil consg dag grammar describ dag languag everi dag gener number rewrit initi dag give formal denit rewrit languag exampl order exampl dag rewritten dag grammar nil nil con x con con x nil con con x con x con con symbol use maintain order otherwis unord set root nd formal denit graph grammar rewrit exampl hope illustr rewrit work inform dag rewritten leaf node match root node j dag graph grammar match mean j label number predecessor match number successor j result rewrit leaf root j dissolv were predecessor becom predecessor successor j right order illustr below k kn k kn denit generalis notion rewrit sever leav need gener section denit denot p set nite sequenc set s sequenc tupl denot angl h i denit given dag e dene match ng lab maxmatch denit given set disjoint write case disjoint union dene and unden otherwis given relat set dene remov ns disjoint union two binari relat dene domain disjoint follow care pay attent exact set node n particular dag compris avoid node clash rewrit graph use fact that given nite dag g innit mani equival dag g denit given dag grammar g one steprewrit relat dene hi ji maxmatch g denit given dag grammar initi dag i dag languag li set normal form li grammar framework readili express set input next step show dag grammar extract program start dene semant object languag and top semant build machineri calcul desir grammar object languag object languag rstorder function languag pattern match oper term equal boolean and denit given set variabl x function name f patternfunct name g constructor c includ constant true fals dene g usual requir variabl occur lefthand side function denit leftlinear variabl righthand side function definit subset lefthand side close final requir pattern dene gfunction pairwis distinct modulo variabl name non overlap particular gfunction one catchal pattern concret program use haskelllik syntax includ datatyp denit syntax view intermedi languag obtain type check rule term like nil nil nil true denit given term t denot v variabl t collect left right term exampl tripl x denit function x regard substitut usual way and write result substitut given program p write say g c mean p function denit ident t variabl name give normalord semant object languag dene smallstep relat take redex contracta separ redex context follow syntact class true figur normalord semant denit e dt denot result replac term t ground term either valu uniqu decompos context redex ie decomposit properti allow us dene semant below semant impos lefttoright evalu except equal oper evalu argument two outermost constructor compar denit given program p smallstep semant p dene smallest relat rt close term dene fig follow use subscript like p otherwis obviou program refer to get full semant languag simpli need close relat context semant determinist lemma proof sketch induct case analysi syntact structur term term either cannot decompos context redex uniqu decompos case redex one smallstep deriv explicit previou section aloow us deal execut ground term abl drive program howev need handl term contain variabl use follow syntact class combin previous dene one describ term cannot decompos context redex denit variabl letterm v let use letterm describ below previou section obtain uniquedecomposit properti term either valu uniqu decompos context redex uniqu decompos context specul ie ds extra syntact class enabl us identifi term need driven ie instanti supercompil drive use obtain process tree object program process tree serv two orthogon purpos keep track data control ow essenti variabl instanti recurs call provid conveni way monitor drive process perform generalis need ensur nite process tree generalis need t replac term let point make generalis abl treat independ exam ple might want revisit introduct thorough introduct techniqu see srensen gluck approach program invers call explicit assum generalis necessari ensur termin comput advanc olin generalis analysi specic assum term replac term form let program interest respect data control ow program ow express dag grammar elabor later section sinc thu elimin need process tree will keep thing simpl drive object program without construct actual process tree construct process tree although import practic essenc approach remark note exist olin generalis analysi essenti explicit process describ follow could incorpor wellknown nontermin detect perform necessari generalis incorpor would induc unnecessari clutter present concentr descript extract dag grammar drive birdsey view explicit process singl branch specul execut work follow start main term object program dag grammar gradual built drive term time specul cf def hinder normal reduct perform instanti term dag gram mar reduct term proceed ect structur input variabl fact drive step term result new product grammar everi term meet drive program product meet term seen befor loop introduc grammar drive term stop term cannot driven compar output desir name nonfals output fals result empti grammar otherwis accumul grammar gener parameteris explicit process discrimin function h purpos fashion produc grammar everi specul execut program possibl instanti term give rise slightli dierent term grammar nal grammar union grammar produc execut exampl instanti dag grammar consid dag xs ys xs ys con iscon ys x xs xs ys con iscon ys x xs repres call argument un known e repres bodi same pattern match variabl xs call iscon three argument cf exampl order arrow import sinc present method prevent nontermin perform generalis danger term were base certain quasiord extens method appli lan guag prove extend method inde guarante termin explicit appli gener framework prove termin program transform present second author dene data ow view feg dag grammar rewritten mean feg shown abov formal denit given dag e dag substitut fegd dene cf def d otherwis substitut extend grammar obviou way construct dag term use follow shorthand denit given term t full explicit process explain detail be low formal sum follow denit denit given program p function h explicit p dag grammar eh p describ fig follow explan explicit process carri number refer hope guid understand fig explicit start main term program empti dag grammar empti set previous seen term step inspect structur current term t either stop add product make new step ad seenbefor set seen befor product alreadi present grammar return accumul unchang renam seen captur biject introduc recurs grammar ad product connect pre viousli seen t respect number variabl redex unfold use standard semant cf def product link unfold ad process continu unfold generalis term hinder unfold dt process independ there fore product ad grammar link dt product dangl root name x v v ect data ow approxim trace tell us noth output t function h cf unmatch root allow dag rewrit cf def eh let ftg tthen c ac r x ac x c x true x fals figur explicit drive suppos discrimin variou output replac function xyy discrimin alway return accumul grammar pattern match function process continu dene pattern pattern q substitut argument match bodi put back context turn receiv instanti fx qg add grammar product ect instanti comparison three case rst simpli make sure variabl left side com parison settl righthand side anoth variabl two possibl explor either comparison fail henc replac specul fals comparison succeed replac specul true updat grammar context ect side must ident grammar equal variabl coalesc mean special symbol r need maintain invari inout degre term correspond number distinct variabl righthand side nari constructor either comparison fail as abov succeed case propag variabl must particular outermost constructor children must test equal children constructor boolean express depend variabl variabl evalu either true fals inform propag branch term cannot driven ie v fed function h turn decid accumul grammar exampl let p program exampl h dene explicit eh depict fig grammar produc fa b f jg deriv grammar suboptim product intermedi sens directli unfold inlin were say grammar normalis contain intermedi product easili normalis grammar denit dag grammar normalis denot b follow root g leav g exampl normalis grammar exampl almost get grammar promis introduct xs ys xs ys con con r xs ys particular grammar bookkeep symbol r elimin yet anoth normalis process desir given object program contain necessari gen eralis lemma surpris howev incorpor standard onlin termin strategi explic process explain remark follow lemma would still hold lemma explicit produc nite grammar proof process tree program nite sinc program contain necessari generalis thu nite number dag produc assum h function total comput interestingli explicit return dag grammar contain solut express complet theorem need precis formul set term gener dag grammar given below infor malli term extract dag simpli follow edg left right collect label except label variabl bookkeep symbol r everi variabl given distinct name r treat indirect left term denit given dag grammar label ariti n set variabl g term languag n set tupl term extract underli dag languag fhi relat possibl execut program set term gener explicit eh same xs ys fsame xs ysg eh fsame xs ys isnil ysg eh fsame xs ys isnil ysg eh iscon ys x xs fsame xs ysg eh fsame xs ys iscon ys x xsg fsame xs ys iscon ys x xsg fif xy same xs ys falseg fif xy same xs ys fals if fals same xs ys fif xy same xs ys falseg fsame xs ys xs ys nil isnil ys con iscon ys x xs nil x xsg same xs ysfals x fals same xs ysfals same xs ysfals r x true same xs ys isnil ys xs ys con iscon ys x xs iscon ys x xs con fals same xs ys xs ys true same xs ys xs ys figur explicit sameprogram theorem given program p main hold applic type infer show type check algorithm transform type infer algorithm explicit specif ical check calculu express given type given environ use standard relat exampl consid express mean what type xyzxzyz empti environ would expect answer someth like perform explicit express type checker take encod proof tree p express environ return true p inde valid proof type encod xyzxzyz becom becom empti want explicit express add denit main implement type checker which refer specialis typecheck data ab int term data data proof infer premis type data intro proof expchk var x z match z x elimchk elim x y z v w implement assum primit integ type int arrowcheck v x z w match bind x z v v x w y match z v w match x arrowcheck ar x y z v w conclus z conclus infer x fals x explicit specialis typecheck give term languag consist singl pair ar ar x ar z ar ar x y ar x z rst element inde encod type second proof tree left out improv sound automat method invers turingcomplet program make compromis respect com plete sound termin made compromis result possibl unsound result explicit program produc grammar gener mani term practic point view feel right compromis better obtain approxim obtain answer all moreov explicit produc grammar precis identi input set seen two exampl previou section indic explicit tight enough least practic problem howev still remain identifi exactli caus loss sound gener case method inher imprecis three reason generalis caus term split separ part by mean letterm prevent instanti left branch process tree aect right branch vice versa neg inform taken account drive exampl drive specul term x propag fact x right branch process tree although fact propag left branch mean substitut moreov dag grammar cannot repres neg inform occur check perform specul term like is situat n discov obvious equal would never impli similarli symmetr properti x x never impli x x use either occur check counterpart easili incorpor rule respect fig interest ingli explicit type checker specialis would sound check incorpor neg inform describ handl propag inform anoth paper incorpor neg inform propos paper would simpl task incorpor neg inform dag grammar howev would destroy simplic thu sever crippl usabl henc generalis inabl dag grammar repres neg inform true culprit one could therefor imagin variant explicit algorithm let call exp one incorpor extens suggest abov improv sound exp one target way generalis carri out posit conjectur follow roundabout relationship exp ura describ introduct given program p without generalisa tion exp termin p whenev ura termin p moreov result ura contain restrict neg ativ inform result grammar exp sound relat work program invers literatur program invers carri hand one except romanenko describ pseudo algorithm invert small class program written refal later paper romanenko extend refal languag nondeterminist construct akin seen logic program facilit exhaust search also consid invert program respect subset paramet socal partial invers would like extend method handl partial invers write unclear done fulli autom program invers method know of one present abramov gluck method construct process tree object pro gram solut extract leav tree form substitutionrestrict pair process tree perfect gluck klimov sens inform lost branch complet everi branch node divid inform disjoint set sound unfortun sound togeth complet impli nontermin small class program method present sacric sound termin common method build upon ground break work turchin cowork rst english paper contain exampl program invers drive seem refer see srensen gluck grammar idea approxim function program grammar new instanc jone present ow analysi nonstrict languag mean tree gram mar base work second author develop techniqu use tree grammar approxim termin behaviour deforest tree grammar how ever cannot captur precis data control ow denit branch tree grammar develop ind pendent render imposs kind synchronis need variabl function call dag grammar present precis captur data control ow singl specul comput trace synchronis lost sever altern recurs product exist grammar seem possibl devis precis ow analysi base dag grammar could use along line inde way use dag grammar trace data control ow turn strike similar use sizechang graph present lee jone ben amram sizechang graph approxim data ow one function anoth captur sizechang paramet dagrewrit mechan present turn lot common faninfanout rewrit present lamp quest optim reduct calculu faninfanout repres complex way synchronis dierent part graph wherea dag rewrit perform simpl useonc synchroni sation rewrit mechan also akin graph substitut hypergraph grammar see bauderon courcel noncategorytheori formul except allow number leav rewritten allow inner node rewritten strengthwis hypergraph grammar appar equival attribut grammar present sure gener power dag grammar conclus futur work develop method invert given program respect given output result invers nite dag grammar give complet descript input run dag grammar produc possibl innit set term contain tupl term result given output method seem particularli use object program checker is one return either true fals exempli deriv type scheme type checker given term thu eectiv synthesis type infer algorithm follow line one could imagin program check whether document valid xml invert program would result dag grammar could compar speci cation valid xml mean verifi program invert program specialis particular doc ument would result document type denit one could even imagin invert proofcarryingcod verier respect particular program thu obtain proof skeleton correct code experi kind applic carri establish strength usabl method r graph express graph rewrit flow analysi lazi higherord function program algorithm optim lambda calculu reduct sizechang principl program termin compil proof gener invers function refal invers metacomput de tr algorithm optim lambda calculu reduct invers metacomput converg program transform metric space tree sizechang principl program termin introduct supercompil perfect supercompil occam razor metacompu roadmap metacomput supercompil semant definit refal automat product compil univers resolv algorithm grammarbas dataflow analysi stop deforest compil proof ctr siaucheng khoo kun shi outputconstraint special proceed asian symposium partial evalu semanticsbas program manipul p septemb aizu japan aaron tomb cormac flanagan automat type infer via partial evalu proceed th acm sigplan intern confer principl practic declar program p juli lisbon portug siaucheng khoo kun shi program adapt via outputconstraint special higherord symbol comput v n p marchjun morten hein srensen jen peter secher type infer configur essenc comput complex analysi transform springerverlag new york inc new york ny principl invers comput univers resolv algorithm essenc comput complex analysi transform springerverlag new york inc new york ny