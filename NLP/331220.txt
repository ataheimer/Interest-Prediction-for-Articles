t tight bound prefetch buffer manag algorithm parallel io system a abstractth io perform applic multipledisk system improv overlap disk access requir use appropri prefetch buffer manag algorithm ensur use block access retain buffer paper answer sever fundament question prefetch buffer manag distributedbuff parallel io system first deriv prove optim algorithm pmin minim number parallel io second analyz pcon algorithm alway match replac decis wellknown demandpag min algorithm show pcon becom fulli sequenti worst case third investig behavior onlin algorithm multipledisk prefetch buffer manag defin analyz plru parallel version tradit lru buffer manag algorithm unexpectedli find competit ratio plru independ number disk final present practic perform algorithm randomli gener refer string result confirm conclus deriv analysi worst case input b introduct increas imbal speed processor io devic result io subsystem becom bottleneck mani applic use multipl disk build parallel io subsystem advoc increas io perform system avail highperform system incorpor form io parallel perform improv overlap access sever disk use judici prefetch buffer manag algorithm ensur use block access retain buffer parallel io system consist independ disk disk buffer access parallel data comput spread among disk unit block block unit retriev disk comput character comput sequenc order sequenc block refer model access read onli prefetch read data block need comput research partial support grant schlumberg foundat research partial support nsf grant ccr natur mechan increas io parallel comput demand diskresid block data concurr data block prefetch disk parallel held buffer need requir discard block buffer make space prefetch block natur question aris are condit worthwhil discard bufferresid block make room prefetch block use time later futur and decid discard block replac polici use choos block replac paper answer sever fundament question prefetch buffer manag parallel io system question address are optim prefetch buffer manag algorithm good algorithm propos earlier sequenti singl disk system context obtain sever interest result inform state precis state section find prove optim algorithm pmin minim number parallel io contrast recent result prefetch obtain cpudisk overlap effici algorithm find optim polici known secondli show pcon algorithm attempt optim number io disk poor parallel perform final investig behavior semionlin algorithm use parallel io concept semionlin algorithm consid paper captur dual requir prefetch which need futur knowledg onlin behavior no futur knowledg defin analyz plru semionlin version tradit least recent use lru buffermanag algorithm find perform plru independ number disk contrast pcon perform degrad proport number disk contrast singledisk system sequenti io issu studi extens eg formal studi issu parallel io context sequenti set number block or io use perform metric scale averag block access time provid estim io time contrast multipl disk case direct relationship number io io time sinc depend io parallel attain goal minim number io done disk minim parallel io time conflict tradit buffer manag algorithm singledisk system gener focus minim number io parallel context may use perform greater absolut minim if disk oper isol number io disk allow larg number overlap rest paper organ follow section summar relat work section develop formal model summar main result section deriv tight upper bound pcon algorithm section prove optim pmin section analyz perform semionlin algorithm plru relat work singledisk system buffer manag or page problem algorithm studi sever polici lru fifo longest forward distanc etc propos analyz longest forward distanc polici minim number page fault therefor call min algorithm polici use demand io determinist replac ie fetch block referenc buffer choic replac block determinist random replac algorithm eg see beyond scope paper sequenti case well known prefetch reduc number io requir sleator tarjan analyz competit ratio onlin page algorithm rel offlin optim algorithm min show lru perform penalti proport size fast memori onlin algorithm can worst case much better fundament result extend sever way often includ model allow differ form lookahead work deal question buffer block evict contrast situat addit question aris fetch block evict other cao et al examin prefetch singl disk overlap cpu io oper defin two offlin polici call aggress conserv obtain bound elaps time rel optim algorithm use prefetch obtain io parallel multipl disk use number parallel io elaps io time cost function pmin pcon algorithm analyz gener aggress conserv polici respect howev aggress suboptim model pmin prove optim algorithm model prefetch algorithm multipl disk analyz assum global buffer readonc random data also investig semionlin algorithm use parallel io sinc prefetch involv read block requir futur rel comput progress present natur situat lookahead necessari inspir us defin lookahead version lru plru minimum possibl lookahead one block beyond current buffer known disk find perform plru independ number disk contrast pcon whose perform degrad proport number disk preliminari comput refer block disk order specifi consumpt sequenc sigma block referenc buffer disk check block present buffer consum comput recent breslauer arriv lookahead definit independ sequenti demand context proce refer next block sigma referenc block present disk buffer io known demand io miss block initi disk demand io initi disk system would idl block fetch howev everi demand io disk provid prefetch opportun disk may use read block referenc near futur exampl consid disk system hold block a b disk respect strictli demand io would requir four nonoverlap io fetch block better strategi overlap read use prefetch demand io block second disk could concurr prefetch b b consum demand io block b made concurr prefetch block number parallel io case two prefetch increas io parallel problem complic finit buffer size everi block read disk previous fetch block correspond buffer must replac prefetch block replac decis made earlier absolut necessari sinc comput continu without prefetch block earli replac choic much poorer replac choic made later sinc comput proce other use replac candid may becom avail cours block becom demand block replac cannot defer poor replac result greater number io prematur discard discard block may fetch repeatedli buffer thu tradeoff io parallel achiev by use prefetch increas number io requir due poorer replac choic definit consumpt sequenc sigma order block request comput subsequ sigma consist block disk denot sigma comput occur round round consist io phase follow comput phase io phase parallel io initi number block one disk select read select disk block correspond disk buffer chosen replac new block read disk comput phase begin cpu consum zero block present buffer order specifi sigma point next block sigma present buffer round end next round begin block whose absenc forc io known demand block block fetch togeth demand block known prefetch block io phase may also initi comput requir demand block case block fetch prefetch block often refer io phase round io time step io schedul makespan sequenc hf f k set block at one disk fetch parallel io time step k makespan schedul number io time step requir complet comput valid schedul one axiom satisfi block must present buffer consum a buffer size block disk buffer time optim schedul valid schedul minim makespan among valid schedul normal schedul valid schedul f k k contain demand block sequenti schedul valid schedul block disk fetch order sigma start round let u denot next referenc block sigma current buffer disk i defin minblock disk i block disk is buffer longest forward distanc next refer normal sequenti schedul io step k u f k unless block disk is buffer referenc u u f k replac minblock disk u normal sequenti schedul everi io step k u f k provid minblock disk minblock u fetch demand u replac minblock disk u normal sequenti schedul everi io step k u f k unless block disk is buffer referenc u u f k among block buffer whose next refer u choos least recent use block replac u notic three schedul defin normal everi io step one disk perform demand fetch rest either perform prefetch idl pmin plru greedi strategi almost alway attempt prefetch next unread block disk situat disk idl everi block buffer referenc block fetch note greedi prefetch may requir make suboptim replac choic result increas number io done disk show howev pmin polici minim io time therefor optim exampl present below let block disk round disk disk cpu pmin schedul round disk disk cpu pcon schedul round disk disk cpu gammagamma bb b plru schedul fig exampl io schedul figur show io schedul use differ polici exampl se quenc entri second third column indic block fetch replac disk round bold ital face block indic demand block prefetch block respect contrast pmin conserv strategi pcon pessimist perform prefetch unless replac best block number io done disk smallest possibl howev minim number io done disk may result serial access perform significantli wors optim algorithm note figur step block fetch disk pcon candid replac time the current minblock block b howev b demand block minblock would b take advantag prefetch opportun algorithm must know next unread block sigma is requir lookahead upto least one block beyond current buffer replac decis made plru base sole examin current block buffer track referenc next unread block whose next refer next unread block least recent consum block chosen replac candid plru appli sequenc sigma use pmin pcon schedul io step obtain see fig next section quantifi precis perform three algorithm summari result let tpgammamin tpgammacon tpgammalru number io time step requir pmin pcon plru respect let opt number io step requir optim schedul let n denot length sigma also recal number disk size disk buffer block technic result paper follow worstcas ratio makespan pcon schedul correspond optim schedul bound d is worst pcon serial disk access without increas number io perform disk see theorem worstcas bound pcon state tight is consumpt sequenc pcon complet serial access see theorem pmin optim schedul minim number parallel time step valid schedul see theorem worstcas ratio makespan plru schedul correspond optim schedul bound is worst plru inflat number io perform disk done serial lru algorithm see theorem worstcas bound plru state tight is consumpt sequenc plru inflat access disk factor see theorem detail result bound pcon begin simpl upper bound tpgammacon let tmin denot maximum number io done sequenti min algorithm singl disk theorem consumpt sequenc tpgammacon opt proof show tpgammacon dtmin dt opt io made pcon disk consumpt sequenc sigma exactli io done sequenti min algorithm disk sequenc sigma henc number io perform disk pcon bound tmin worst none access disk overlap whenc first inequ follow final second inequ follow sinc optim parallel time disk cannot smaller minim number io singl disk ut theorem bound theorem tight proof sketch construct follow four lengthm sequenc b j j th block disk i aslo defin sigma follow u n mean n repetit parenthes sequenc argu sigma pmin schedul length nm thu tpgammacon t opt lower bound optim pmin section show pmin requir minim number parallel io step among valid schedul proof show transform optim schedul opt makespan l pmin schedul makespan schedul ff fi said match time step t everi t block fetch replac disk two sequenc same lemma assum ff valid schedul length w let fl anoth schedul match ff t gamma io time step buffer ff fl disk differ one block specif ff block v block u fl block u block v assum v referenc u consumpt sequenc follow refer time gamma construct valid schedul fi length w fi ff match fi fl match time step proof let first time step ff fetch discard either block v u either discard block v fetch block u both construct schedul fi follow fi match ff time step w except time step fi fetch replac block fl one follow must occur ff fetch block z u discard block construct fi also fetch block z discard block u ff fetch block u discard block z z also discard block z ff fetch block u discard block fetch discard block three case abov follow io block buffer sinc fi fetch replac block ff buffer ff fi time step io time step t w fi consum block done ff t clearli fi satisfi axiom a show fi valid schedul show axiom satisfi block consum fi sinc ff fi buffer io io block consum ff time step t also consum fi time step first time step io either block u v consum ff sinc ff u buffer till least io hypothesi v consum u henc block x u v consum ff time step t sinc buffer ff fi agre except fu v g x also consum fi time step sinc ff valid schedul consumpt fi also satisfi axiom a henc fi valid schedul ut theorem pmin optim schedul proof let delta andomega denot schedul creat pmin opt algorithm respect success transformomega anoth valid schedul match delta length asomega show pmin schedul optim proof induct induct hypothesi assum time step tomega transform valid scheduleomega match delta time step t show toomega t below discuss transform arbitrari disk time step construct appli disk independ delta andomega match letomega t asomega suppos delta andomega differ time step one follow three case must occur consid case separ butomega fetch block let delta fetch block p discard block q sinc delta alway fetch block order referenc p referenc q induct hypothesi delta andomega buffer start time henc io andomega differ one block delta block p block q whileomega q p use lemma ff construct valid scheduleomega t matchesomega time step t delta time henc induct hypothesi satisfi omega fetch block delta fetch block sinc delta fetch block time step everi block buffer start time step consum block current buffer referenc andomega buffer start time step bring fresh block p must discard block q sinc delta chose retain block q prefer fetch block p either q must referenc p neither p q referenc again first case use lemma ff constructomega t schedul satisfi induct hypothesi second caseomega t asomega except time step omega t fetch block sinc buffer andomega t agre block except p q two block never referenc again block consum byomega time step also consum byomega t time andomega fetch differ block suppos delta fetch block p discard block q andomega fetch block discard block z assum q z sinc otherwis buffer ofomega delta differ pair block fp g easili constructomega t use lemma ff induct hypothesi delta andomega buffer start time step henc io andomega differ two block specif set block buffer schedul theta first time fetch replac block w fp q y zg either discard block q fetch block p z appropri combin see case below construct t matchesomega time step fetch p discard q follow action delta time step henc io zg one follow occur fflomega fetch block discard q t also fetch s discard z io fflomega fetch p discard q fetch discard z io bufferomega fflomega fetch z discard q noth step io fflomega fetch t also fetch s discard p io t ffi fzg t fetch block time step io fzg fflomega fetch z discard fetch q discard p io bufferomega fflomega fetch p discard block fetch discard block s io fflomega fetch z discard block fetch q discard block s io consid consumpt made byomega time step t t notic consumpt sequenc p must preced q z must preced q constraint p follow sinc delta fetch p discard q fetch p prefer constraint z follow sinc delta discard q rather z show toomega t buffer io t otherwis buffer must differ either pair block fq zg fy pg constructomega t concaten prefix step schedul fi construct use lemma describ below let ff fl be respect schedul consist suffix t time step greater equal end io buffer t differ fy pg let differ fq zg let appli lemma construct desir sequenc fi omega t obtain concaten prefix fi consumpt block inomega t follow time step consumpt consumpt determin fi consumpt till valid sinceomega valid schedul andomega t andomega match t construct block consum valid need show consum block asomega time step p z buffer end io consum p z io time later also sinc q must consum p none block consum io io buffer andomega t agre except fp q y zg block consum also consum byomega t time step conclud proof ut bound plru obtain upper bound worstcas perform plru show bound tight use follow lemma whose proof omit breviti lemma let contigu subsequ sigma refer less distinct block disk i consum s none block fetch plru theorem consumpt sequenc tpgammalru mt opt proof induct assum consumpt made first step pmin done less step plru thi hold set refer made pmin sinc distinct block consum disk time step pmin sinc plru fetch block u lemma pmin consumpt done addit step ut theorem worstcas bound theorem tight proof sketch show construct sigma two disk b block disk respect note first access sigma com mon plru pmin plru make access everi access pmin paper defin model parallel io system answer sever fundament question prefetch buffer manag system found prove optim algorithm pmin minim number parallel io while possibl increas number io done singl disk contrast pcon algorithm alway match replac decis wellknown singledisk optim al gorithm min becom fulli serial worst case behavior onlin algorithm lookahead plru analyz perform plru independ number disk similar result shown hold pfifo parallel version fifo lookahead r influenc lookahead competit page algorithm studi replac algorithm virtual storag new measur studi onlin algo rithm studi integr prefetch cach strategi oper system theori competit onlin page lookahead competit page algorithm beyond competit analysi markov analysi multipledisk prefetch strategi extern merg amort effici list updat page rule tr ctr mahesh kallahalla peter j varman analysi simpl random buffer manag parallel io inform process letter v n p april mahesh kallahalla peter j varman optim prefetch cach parallel io sytem proceed thirteenth annual acm symposium parallel algorithm architectur p juli crete island greec mahesh kallahalla peter j varman pcopt optim offlin prefetch cach parallel io system ieee transact comput v n p novemb michael penner viktor k prasanna cachefriendli implement transit closur journal experiment algorithm jea kai hwang hai jin roy sc ho orthogon stripe mirror distribut raid iocentr cluster comput ieee transact parallel distribut system v n p januari