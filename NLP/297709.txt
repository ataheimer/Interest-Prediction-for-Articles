t automat compilerinsert prefetch pointerbas applic a abstracta dispar processor memori speed continu grow memori latenc becom increasingli import perform bottleneck softwarecontrol prefetch attract techniqu toler latenc success limit thu far arraybas numer code paper expand scope automat compilerinsert prefetch also includ recurs data structur commonli found pointerbas applicationsw propos three compilerbas prefetch scheme autom wide applic scheme greedi prefetch optim research compil experiment result demonstr compilerinsert prefetch offer signific perform gain uniprocessor largescal sharedmemori multiprocessor b introduct oftwar control data prefetch offer potenti bridg everincreas speed gap memori subsystem today highperform processor recognit potenti number recent processor ad support prefetch instruct prefetch enjoy consider success arraybas numer code potenti pointerbas applic remain larg unexplor paper investig compilerinsert prefetch pointerbas applicationsin par ticular contain recurs data structur recurs data structur rdss includ familiar object link list tree graph etc individu node dynam alloc heap node link togeth pointer form overal structur purpos recurs data structur broadli interpret includ pointerlink data structur eg mutuallyrecurs data structur even graph heterogen object memori perform perspect pointerbas data structur expect import concern follow reason applic suffer larg memori penalti due data replac miss typic must larg data set rel cach size asid multidimension array recurs data structur one common conveni method build larg data structur eg btree databas applic octre graphic applic etc travers ck luk depart comput scienc univers toronto toronto ontario ms g canada email lukeecgtorontoedu t c mowri comput scienc depart carnegi mellon univers pittsburgh pa email tcmcscmuedu larg rd may potenti visit enough interven node displac given node cach revisit henc tempor local may poor final contrast arrayswher consecut element contigu addressesther littl inher spatial local consecutivelyaccess node rd sinc dynam alloc arbitrari address cope latenc access pointerbas data structur propos three compilerbas scheme prefetch rdss describ section ii implement widelyapplic schemesgreedi prefetchingin modern research compil suif discuss section iii evalu scheme perform detail simul impact uniprocessor multiprocessor system section iv v respect final present relat work conclus section vi vii ii softwarecontrol prefetch rdss key challeng success prefetch rdss schedul prefetch suffici far advanc fulli hide latenc introduc minim runtim overhead contrast arraybas code prefetch distanc easili control use softwar pipelin fundament difficulti rdss must first derefer pointer comput prefetch address get sever node ahead rd travers typic involv follow pointer chain howev act touch intermedi node along pointer chain mean cannot toler latenc fetch one node ahead overcom pointerchas problem propos three scheme gener prefetch address without follow entir pointer chain first two scheme greedi prefetch historypoint prefetchingus pointer within current node prefetch address differ greedi prefetch use exist point er wherea historypoint prefetch creat new point er third schemedatalinear prefetch gener prefetch address without pointer derefer a greedi prefetch kari rd node contain k pointer node greedi prefetch exploit fact one k neighbor immedi follow next node travers often good chanc neighbor visit sometim futur therefor prefetch k pointer node first visit hope enough preordertreenod t f prefetchtleft prefetchtright preordertleft preordertright partial latenc cach miss cach hit cach miss a code greedi prefetch b cach miss behavior fig illustr greedi prefetch prefetch success hide least fraction miss latenc illustr greedi prefetch work consid preorder travers binari tree ie figur a show code greedi prefetch ad assum comput process take half long cach miss latenc l would want prefetch two node ahead fulli hide latenc figur b show cach behavior node obvious suffer full cach miss root node node sinc opportun fetch ahead time howev would suffer half miss penalti l visit node miss penalti eventu visit node sinc time visit subtre root node greater l exampl latenc fulli hidden roughli half node reduc half minu root node greedi prefetch offer follow advantag i low runtim overhead sinc addit storag comput need construct prefetch point er ii applic wide varieti rdss regardless access whether structur modifi frequent iii rel straightforward implement compilerin fact implement suif compil describ later section iii main disadvantag greedi prefetch offer precis control prefetch distanc motiv next algorithm b historypoint prefetch rather reli exist pointer approxim prefetch address potenti synthes accur pointer base observ rd travers pat tern prefetch node ahead historypoint prefetch scheme add new pointer call historypoint node n record observ address n id the node visit node n recent travers rd subsequ travers rd prefetch node point histori pointer scheme effect travers pattern chang rapidli time construct historypoint maintain fifo queue length contain pointer last node visit visit new node n oldest node queue n igammad ie node visit node ear lier henc updat historypoint n igammad point n first complet travers rd historypoint set contrast greedi prefetch historypoint prefetch offer improv first travers rd potenti hide latenc subsequ travers historypoint prefetch offer potenti advantag improv latenc toler come expens i execut overhead construct historypoint ii space overhead store new pointer minim execut overhead potenti updat historypoint less frequent depend rapidli rd structur chang one extrem rd never chang set historypoint onc problem space overhead potenti worsen cach behavior desir elimin space overhead altogeth motiv next prefetch scheme c datalinear prefetch idea behind datalinear prefetch map heapalloc node like access close togeth time contigu memori locat map one easili gener prefetch address launch earli enough anoth advantag scheme improv spatial local major challeng howev gener data layout theori one could dynam remap data even rd initi construct may result larg runtim overhead may also violat program semant instead easiest time map node creation time appropri either creation order alreadi match travers or der safe reorder so sinc dynam remap expens or imposs scheme obvious work best structur rd chang slowli or all rd chang radic program still behav correctli prefetch improv perform iii implement greedi prefetch three scheme propos greedi prefetch perhap wide applic sinc reli travers histori inform requir addit storag comput construct prefetch ad dress reason implement version greedi prefetch within suif compil simul two algorithm hand implement consist analysi phase recogn rd access schedul phase insert prefetch a analysi recogn rd access recogn rd access compil use type declar inform recogn data object rdss control structur inform recogn object travers rd type record type r contain least one pointer point either directli indirectli record type s note r restrict type sinc rdss may struct f int data struct left struct right struct f int struct b kid struct c f int j doubl f a rd type b rd type c rd type fig exampl type recogn rd type l f list m f list n ftree t f ktree tn f a b c d fig exampl control structur recogn rd travers compris heterogen node exampl type declar figur a figur b would recogn rd type wherea figur c would not discov data structur appropri type compil look control structur use travers rdss particular compil look loop recurs procedur call new loop iter procedur invoc pointer p rd assign valu result derefer pwe refer recurr pointer updat heurist correspond rd code typic written detect recurr pointer updat compil propag pointer valu use simplifi but less pre cise version earlier pointer analysi algorithm figur show exampl program fragment compil treat rd access figur a l updat lnextnext insid whileloop figur b n assign result function call gn insid forloop sinc implement perform interprocedur analysi assum gn result valu nnext figur c two derefer function argument pass paramet two recurs call figur d similar figur c except record rather pointer pass function argument ideal next step would analyz data local across rd node elimin unnecessari prefetch although autom step compil evalu potenti benefit earlier studi b schedul prefetch rd access recogn compil insert greedi prefetch follow point rd object traversedi recurr pointer updat occursth compil insert prefetch pointer within object point rdstype object earliest point address avail within surround loop procedur bodi avail prefetch address comput prop l f l f prefetchlnext a loop tree q testtdata els q null tree q prefetchtleft prefetchtright testtdata els q null b procedur fig exampl greedi prefetch schedul benchmark characterist node recurs data input memori benchmark structur use data set alloc octre bisort binari tree kb integ emd singlylink list hnode kb enod local health fourway tree level kb doublylink list mst array singli node kb link list perimet quadtre kxk imag kb power multiway tree kb singlylink list custom treeadd binari tree k node kb binari tree citi kb doublylink list voronoi binari tree point kb agat earliest gener point pointer valu along valu themselv two exampl greedi prefetch schedul shown figur detail implement found luk thesi iv prefetch rdss uniprocessor section quantifi impact prefetch scheme uniprocessor perform later section v turn attent multiprocessor system a experiment framework perform detail cyclebycycl simul entir olden benchmark suit dynam schedul superscalar processor similar mip r olden benchmark suit contain ten pointerbas applic written c briefli summar tabl i rightmost column tabl show amount memori dynam alloc rd node simul model vari slightli actual mip r eg model two memori unit ii uniprocessor simul paramet pipelin paramet issu width function unit int fp memori branch reorder buffer size integ multipli cycl integ divid cycl integ cycl fp divid cycl fp squar root cycl fp cycl branch predict scheme bit counter memori paramet primari instr data cach kb way setassoci unifi secondari cach kb way setassoci line size b primarytosecondari miss cycl primarytomemori miss cycl data cach miss handler data cach bank data cach fill time cycl requir exclus access main memori bandwidth access per cycl assum function unit fullypipelin model rich detail processor includ pipelin regist renam reorder buffer branch pre diction instruct fetch branch penalti memori hierarchi includ content etc tabl ii show paramet model use pixi instrument optim mip object file produc com piler pipe result trace simul avoid miss initi dynam alloc object use modifi version irix mallopt routin wherebi prefetch alloc object initi determin prefetch address straightforward sinc object size typic alloc contigu memori optim alon led twofold speedup rel use malloc major applic particularli frequent alloc small object b perform greedi prefetch figur show result uniprocessor experi ment overal perform improv offer greedi prefetch shown figur a two bar correspond case without prefetch n greedi prefetch g bar repres execut time normal case without prefetch broken four categori explain happen potenti graduat slot the number graduat slot issu width case multipli number cycl bottom section busi number slot instruct actual graduat top two section nongradu slot immedi caus oldest instruct suffer either load store miss inst stall section slot instruct graduat note load stall store stall section firstord approxim perform loss due cach miss sinc delay also exacerb subsequ data depend stall see figur a half applic enjoy speedup rang half within origin perform applic largest memori stall penaltiesi health perimet treeaddmuch stall time elimin case bisort mst prefetch overhead offset reduct memori stall thu result slight perform degrad problem eight applic understand perform result greater depth figur break origin primari cach miss three categori i prefetch subsequ hit primari cach pf hit ii prefetch remain primari miss pf miss iii prefetch nopf miss sum pf hit pf miss case also known coverag factor ideal emd power voronoi coverag factor quit low un der miss caus array scalar referencesh prefetch rdss yield littl improv case coverag factor four case achiev nearli perfect coverag pf miss categori larg indic prefetch schedul effectivelyeith issu late hide latenc els earli prefetch data displac cach could referenc categori promin mst compil unabl prefetch earli enough travers short link list within hash tabl sinc greedi prefetch offer littl control prefetch distanc surpris schedul imperfectin fact encourag pf miss fraction low help evalu cost prefetch figur c show fraction dynam prefetch unnecessari data found primari cach applic show four differ bar indic total dynam unnecessari prefetch caus static prefetch instruct hit rate given threshold henc bar label correspond unnecessari prefetch wherea bar label show total unnecessari prefetch exclud prefetch instruct hit rate etc breakdown indic potenti reduc overhead elimin static prefetch instruct clearli littl valu exampl elimin prefetch hit rate would elimin half unnecessari prefetch perimet thu decreas overhead significantli con trast reduc overhead flat distribut eg bh difficult sinc prefetch sometim hit also miss least time therefor elimin may sacrific latencyhid benefit found elimin prefetch hit rate improv perform applic final measur impact greedi prefetch memori bandwidth consumpt observ av normal execut time load stall bh bisort emd health mst perimet power treeadd tsp voronoi store stall inst stall busi a execut time origin load dcach nopf_miss bisort health perimet treeadd voronoi bh emd mst power tsp pf_miss pf_hit hit bh bisort emd health mst perimet power treeadd tsp voronoi b coverag factor c unnecessari prefetch fig perform impact compilerinsert greedi prefetch uniprocessor erag greedi prefetch increas traffic primari secondari cach traffic secondari cach main memori experi almost impact perfor manc henc greedi prefetch appear suffer memori bandwidth problem summari seen automat compilerinsert prefetch result signific speedup uniprocessor applic contain rdss investig whether two sophist prefetch scheme offer even larger perform gain c perform historypoint prefetch data linear prefetch appli historypoint prefetch data linear prefetch hand sever applica tion historypoint prefetch applic health list structur access key procedur remain unchang across ten thousand time call result historypoint prefetch achiev speedup greedi prefetch better miss coverag fewer unnecessari prefetch although historypoint prefetch fewer unnecessari prefetch greedi prefetch significantli higher instruct overhead due extra work requir maintain historypoint datalinear prefetch applic perimet treeadd creation order ident major subsequ travers order case result data linear requir chang data layout case henc spatial local unaffect reduc number unnecessari prefetch and henc prefetch overhead maintain good coverag factor datalinear prefetch result speedup greedi prefetch perimet treeadd respect overal see scheme potenti offer signific improv greedi prefetch applic v prefetch rdss multiprocessor observ benefit automat prefetch rdss uniprocessor investig whether compil also acceler pointerbas applic run multiprocessor earlier studi mowri demonstr compil success prefetch parallel matrixbas code compil use studi attempt prefetch pointerbas access pattern howev handinsert prefetch ing mowri abl achiev signific speedup barn pointerintens sharedmemori parallel applic splash suit barn perform hierarch nbodi simul evolut galaxi main comput consist depthfirst travers octre structur comput gravit forc exert given bodi bodi tree repeat bodi system bodi static assign processor durat time step cach miss occur whenev processor visit part octre alreadi cach either due replac commun insert prefetch hand mowri use strategi similar greedi prefetch upon first arriv node prefetch immedi children descend depthfirst first child iii memori latenc multiprocessor simul destin access read write primari cach cycl cycl secondari cach cycl cycl remot node cycl cycl dirti remot remot home cycl cycl normal execut time memori stall synchron instruct origin dcach nopf_miss pf_miss pf_hit hit dcach a execut b coverag c unnecessari time factor prefetch fig impact compilerinsert greed prefetch barn multiprocessor compilerinsert greedi prefetch handinsert prefetch evalu perform compilerbas implement greedi prefetch multiprocessor compar handinsert prefetch barn sake comparison adopt simul environ use mowri earlier studi briefli summar simul cachecoher sharedmemori multiprocessor resembl dash multiprocessor simul machin consist processor two level directmap cach use byte line tabl iii show latenc servic access differ level memori hierarchi absenc content our simul model content howev make simul fea sibl scale problem size cach size accordingli we ran bodi time step kk cach hierarchi done and explain detail origin studi figur show impact compilerinsert greedi prefetch g handinsert prefetch h barn execut time figur a broken follow bottom section amount time spent execut instruct includ prefetch instruct overhead middl top section synchron memori stall time respect see figur a compil achiev nearli ident perform handinsert prefetch compil prefetch origin cach miss miss unnecessari see figur b c respect prefetch miss latenc fulli hidden half case pf hit partial hidden case pf miss elimin roughli half origin memori stall time compil abl achiev speedup compil greedi strategi insert prefetch quit similar done hand follow except effort minim unnecessari prefetch compil default strategi prefetch first byte within given rd node case barn node longer byte discov handinsert prefetch achiev better perform prefetch entir node case improv miss coverag prefetch entir node worth addit unnecessari prefetch therebi result speedup compilerinsert prefetch overal howev quit pleas compil abl well nearli match best perform could achiev hand vi relat work although prefetch studi extens arraybas numer code rel littl work done nonnumer applic chen et al use global instruct schedul techniqu move address gener back earli possibl hide small cach miss latenc cycl found mix result contrast algorithm focu rd access issu prefetch much earlier across procedur loop iter boundari overcom pointerchas problem zhang torrella propos hardwareassist scheme prefetch irregular applic sharedmemori multiprocessor scheme program annot bind togeth group data eg field record two record link pointer prefetch hardwar con trol compar compilerbas approach scheme two shortcom i annot insert manual ii hardwar extens like applic uniprocessor joseph grunwald propos hardwarebas markov prefetch scheme prefetch multipl predict address upon primari cach miss markov prefetch potenti handl chaotic miss pattern requir consider hardwar support less flexibl select prefetch control prefetch distanc compilerbas scheme knowledg compilerbas pointer prefetch scheme literatur spaid scheme propos lipasti et al base observ procedur like derefer pointer pass argument spaid insert prefetch object point pointer argument call site therefor scheme effect interv start procedur call derefer pointer compar cach miss latenc earlier studi found greedi prefetch offer substanti better perform spaid hide latenc pay less overhead vii conclus automat compilerinsert prefetch shown consider success hide memori latenc arraybas code compil technolog success prefetch pointerbas data structur thu far lack paper propos three prefetch scheme overcom pointerchas problem autom wide applic scheme greedi prefetch compil evalu perform modern superscalar uniprocessor sim ilar mip r largescal sharedmemori multiprocessor uniprocessor experi show automat compilerinsert prefetch acceler pointerbas applic much addit sophist algorithm which current simul hand offer even larger perform gain multiprocessor experi demonstr compil potenti provid equival perform handinsert prefetch even parallel ap plicat encourag result suggest latenc problem pointerbas code may address larg prefetch instruct alreadi exist mani recent microprocessor acknowledg work support grant ibm canada centr advanc studi chikeung luk partial support canadian commonwealthfellowship todd c mowri partial support faculti develop award ibm r softwar prefetch toler latenc softwarecontrol data prefetch com piler techniqu data prefetch powerpc data prefetch hp pa the mip r superscalar microprocessor design evalu compil algorithm prefetch suif infrastructur research parallel optim compil compilerbas prefetch recurs data structur contextsensit interprocedur pointsto analysi presenc function pointer interprocedur modif side effect analysi pointer alias optim cach perform nonnumer applic support ing dynam data structur distribut memori machin trace pixi fast fit toler latenc multiprocessor compilerinsert prefetch parallel applic share memori the stanford dash multiproc sor an effect onchip preload scheme reduc data access penalti data access microarchitectur superscalar processor compilerassist data prefetch speed irregular applic sharedmemori multiprocessor memori bind group prefetch prefetch use markov predic tor spaid softwar prefetch pointer callintens environ tr ctr subramanian ramaswami jaswanth sreeram sudhakar yalamanchili krishna v palem data trace cach applic specif cach architectur acm sigarch comput architectur new v n march shimin chen phillip b gibbon todd c mowri improv index perform prefetch acm sigmod record v n p june tatsushi inagaki tamiya onodera hideaki komatsu toshio nakatani stride prefetch dynam inspect object acm sigplan notic v n may evangelia athanasaki niko anastopoulo kornilio kourti nectario koziri explor perform limit simultan multithread memori intens applic journal supercomput v n p april chikeung luk toler memori latenc softwarecontrol preexecut simultan multithread processor acm sigarch comput architectur new v n p may