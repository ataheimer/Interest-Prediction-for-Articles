t parallel ram own global memori determinist contextfre languag recognit a identifi studi natur frequent occur subclass concurr read exclus write parallel random access machin crewpram call concurr read owner write crowpram machin global memori locat assign uniqu owner processor processor allow write it consid difficulti would involv physic realizinga full crewpram model demonstr stabil sever definit chang second precis character power crowpram show class languag recogniz time olog n and implic polynomi number processor exactli class logdcfl languag log space reduc determinist contextfre languag third use basic machineri show recognit problem determinist contextfre languag solv quickli determinist auxilliari pushdown autom random access input tape log n space work tape pushdown store small maximum height exampl time on egr achiev pushdown height olog n result extend unifi work von braunmhl cook mehlhorn verbeek klein reif rytter b sever definit chang second precis character power crowpram show class languag recogniz time olog n exactli class logdcfl languag log space reduc determinist context free languag third use basic machineri show recognit problem determinist contextfre languag solv time on ffl sn ffl log n sn n determinist auxiliari pushdown automaton log n space work tape pushdown store maximum height sn random access input tape result extend unifi work von braunmuhl cook mehlhorn verbeek klein reif rytter introduct relat work fairli larg bodi literatur parallel random access machin pram model algorithm nearli mani definit model paper subject agre gener featur model collect less ordinari sequenti processor privat local memori access share global memori model synchron time unit processor execut one instruct much divers regard featur model exampl differ whether model singl multipleinstruct stream mani processor are number activ instruct set have input convent use simultan read write request singl global storag locat arbitr variat make littl differ power model two featur seem substanti impact power model one uniform gener consid uniform model paper ie one singl program suffic input length singl processor initi activ creat processor desir second sensit featur arbitr memori access conflict two main variant intens studi follow nomenclatur introduc vishkin crcw concurrentread concurrentwrit pram allow memori access conflict processor read given locat given step receiv valu among processor crowpram dcfl recognit write given locat given step one allow succeed eg one lowest processor number other resolut rule write conflict propos known equival power constant factor run time polynomi factor number processor global memori size although model separ processor memori tightli constrain crew concurrentread exclusivewrit model concurr read allow abov concurr write not crew algorithm must arrang two processor attempt write global memori locat time paper introduc third variant argu natu ral model crew pram give surpris character power sever reason studi restrict crew pram crewpram model critic power serv realist model physic realiz parallel machin due unbound fanin anderson snyder point twostag program process first use crewpram model develop straightforward fulli parallel algorithm eg or n bit emul algorithm physic realiz network could lead suboptim algorithm thetalog n exampl nevertheless crewpram arguabl popular theoret model design specif analysi parallel algorithm due princip simplic use global memori model programm use therefor consid power restrict crow pram model order understand feasibl model parallel program note abov crewpram algorithm fact crowpram algorithm easili modifi so crewpram algorithm ensur obey exclusivewrit restrict two except discuss below crewpram algorithm consid achiev easili modifi achiev write exclus follow simpl stratagem global memori locat own one processor processor ever allow write cell further map global memori address processor number easi comput processor difficulti determin cell own ex ampl processor p might block k consecut cell begin global memori address kp call ownerwrit restrict call pram obey restrict concurrentread ownerwrit pram crowpram ownership restrict seem natur framework design exclusivewrit algorithm similar ident notion ownership appear earlier lower bound work cook et al also proven use practic certain cach coher protocol see eg archibald baer mani current architectur parallel system machin provid global memori program model implement use physic hardwar everi memori cell local processor cach techniqu use amelior cost access nonloc memori nonloc write prohibit necessari cach coher algorithm simplifi fact posit solut crow versu crew problem discuss section would presum suggest interest new approach cach coher problem give precis definit crowpram model section below main goal paper investig power crow pram unexpectedli question turn intim relat complex determinist contextfre languag dcfl recognit recognit problem determinist contextfre languag l decid given word x whether x l sequenti complex problem wellstudi mani practic sequenti algorithm solv space time on smallspac parallel time complex problem less wellunderstood two main result area von braunmuhl cook mehlhorn verbeek klein reif cook present sequenti algorithm dcfl recognit problem run polynomi time ture machin use polynomi log n space result improv von braunmuhl et al give ture machin algorithm optim timespac product space bound rang log n n build somewhat idea klein reif present olog n time crewpram algorithm dcfl recognit it known result stockmey vishkin combin crowpram dcfl recognit algorithm ruzzo yield olog n time algorithm gener cfl recognit power crcwpram model main result follow character crowpram theorem languag l accept crowpram olog n time l logspac reduc dcfl class logdcfl languag logspac reduc dcfl first defin studi sudborough show equal class languag recogniz polynomi time logspac bound determinist auxiliari pushdown automata dauxpda defin cook result appear first precis character parallel time complex class up constant factor term sequenti one exampl sudborough hardest dcfl provid natur exampl problem complet crowpram time olog n complet problem discov chandra tompa crcwpram time class know analog natur problem complet crew class follow earlier version paper lang niedermei establish character pram variant term sequenti complex class use dcfl character demonstr stabil crowpram complex class definit chang exampl follow dcfl simul crowpram simul time loss parallel machin global memori processor contain singl extern visibl regist may read but written processor model seem closer way parallel machin actual construct model independ global memori associ processor dcfl recognit algorithm von braunmuhl et al klein reif difficult one use superfici differ approach third goal paper provid unifi approach problem which although base both believ simpler either obtain small time parallel algorithm small space sequenti algorithm dcfl recognit use basic approach small space algorithm provid improv result rytter technic refin optim result von braunmuhl et al rytter shown use sequenti implement possibl obtain polynomi time olog n space algorithm dcfl recognit use space mainli pushdown store more precis log n space dauxpda olog n bound pushdown rather unrestrict olog n space improv result perform simul dauxpda like rytter attain timespac product similar von braunmuhl et al section present crowpram model discuss variat definit section present simul determinist auxiliari pushdown automata establish crowpramtimelog n logdcfl section introduc definit notat need dcfl recognit algorithm section present high level descript correct proof dcfl recognit algorithm section discuss crowpram implement algorithm establish inclus need theorem ie logdcfl crowpram timelog n final section refin simul section obtain faster sequenti algorithm obtain combin crow pram algorithm section gener simul section work involv own global memori concept pram appear follow preliminari version paper fich wigderson give lower bound separ erow crow pram rossmanith introduc studi owner read owner write pram show exampl list rank olog n time nishimura consid owner concept crcwpram nieder meier rossmanith consid owner concept pram variant lin et al show crowpram suffici power execut variant cole parallel merg sort algorithm time olog n work restrict crowpram model lam ruzzo dymond et al describ end section two crowpram dcfl recognit definit crowpram start defin crewpram model use mention abov detail definit critic specif use definit fortun wylli call simpli pram there ha unbound global memori unbound set processor accumul instruct counter unbound local memori memori cell hold arbitrari nonneg integ instruct repertoir includ indirect address load store add subtract jump jumpifzero read fork halt input place sequenc special readonli regist one bit per regist read instruct allow processor read input bit concurr read allow fork instruct caus new processor creat local memori cell zero accumul initi valu accumul creator initi one processor activ local memori zero length input given accumul model accept initi activ processor halt one accumul reject two processor attempt write global memori locat time crewpram processor number id builtin concept need them adopt follow processor number scheme uniqu processor activ initi number first child processor creat processor number second number correspond natur embed arbitrari tree the processor activ tree binari tree rule eldest child becom right child next younger sibl becom left child reversepreord travers activ tree binari tree ident see mani number scheme also work one fairli natur processor automat know number easi program comput it need algorithm crewpram algorithm exist function owneri n comput determinist space olog n input length n processor p attempt write global memori locat intuit definit given earlier said owner function simpl particular requir logspac comput oblivi ie independ input except length requir model detect illbehav program ie one attempt global write violat ownership constraint program simpli crow program seem natur choic also show main result fairli insensit issu could gener model follow way g allow owner function depend input g allow owner function depend time g allow bound multipl ownership ie owneri n set size o processor number g allow illbehav program defin model halt reject attempt write violat ownership constraint g allow processor number scheme give processor uniqu number allow one comput logarithm space parent given processor p number older sibl ha number k th child g allow owner parent sibl function comput determinist logspac auxiliari pushdown automaton run polynomi time altern could restrict model follow way r requir owner function ident equival say machin global memori instead collect processor privat local memori one global readabl commun regist r requir processor use o local memori locat crowpram dcfl recognit r requir machin writeoblivi ie time locat write global memori independ input except length one consequ result crowpram even one satisfi rel weak condit gg simul crow pram satisfi strict condit rr constant factor increas time polynomi increas number processor possibl crew crowpram equival power posit side condit gg fairli gener difficult imagin protocol pram algorithm could achiev writeexclus would cover these exampl note gener crew pram algorithm consid crowpram algorithm owner function allow input timedepend condit g g abov sens comput crewpram real time know that say crewpram time olog n simul logarithm space determinist auxiliari pushdown automaton run time n olog n realtim crewpram comput function may differ n o dauxpda comput one thu seem possibl time crowpram crewpram might ident least provid intuit support empir observ known crewpram algorithm crowpram algorithm one context know two model equival follow appear extend abstract paper ragd person com munic see also fich nisan observ nonuniform crow pram ie one arbitrari instruct exponenti mani processor initi activ allow differ program valu n run time equival boolean decis tree depth nisan establish set recogn nonuniform crew pram time olog n n equival boolean decis tree problem depth tn taken togeth result show time two model constant factor nonuniform set leav open stronger conjectur set recogn crewpram time log n recogn crowpram time olog n ordinari uniform varieti use polynomi mani processor note nisan simul crew crow use nonuniform fundament way use tn initi activ pro cessor nonuniform model languag recogniz olog n step one restrict set know two uniform nonuniform model differ suppos processor n activ know one bit b want comput or bit given one b crewpram solv one step processor bit write global locat writeconflict happen sinc one bit howev marc snir person commun shown crowpram n step solv problem initi state snir result settl gener question howev problem discuss defin one input bit one thi call partial domain fich contrast usual situat algorithm requir produc correct answer nbit input sequenc know result cook et al even crewpram requir time omegagammam n test whether input contain one bit conceiv crew algorithm exploit someth like snir or could alway transform crow algorithm use preprocess time better advantag full domain problem known us uniform crew pram seem power crowpram recognit problem unambigu contextfre languag problem rytter given olog n crewpram algorithm appear use power nonown exclus write fundament way loos speak seem unambigu underli grammar allow one repeatedli exploit featur like snir or crowpram appear nearli power crew pram interest compar possibl weaker parallel model parallel pointer machin dymond cook ppm consist unbound pool finitest transduc finit set pointer processor ppm oper sens output neighbor processor move pointer processor adjac current neighbor cook propos model exampl simplest possibl parallel machin variabl structur crowpram dcfl recognit lam ruzzo establish time ppm linearli relat time restrict version crowpram doubl ad one arithmet oper permit in fact also show simultan linear relationship amount hardwar use two machin conjectur crowpram abil access twodimension array constant time cannot directli emul crowpram whose arithmet capabl limit prove recent dymond et al sinc twodimension array appear play import part dcfl simul algorithm section suggest quit differ techniqu would need recogn dcfl time olog n ppm inde possibl analog nonconst lower bound two dimension array access prove sequenti unit cost successor ram dymond simul crowpram dauxpda section prove first half theorem name theorem set recogn time olog n crowpram logdcfl recal logdcfl class languag log space reduc determinist contextfre languag sudborough defin class character set languag recogn polynomi time logarithm space determinist auxiliari pushdown automaton main construct similar analog one given pratt stockmey fortun wylli goldschlag show pram time log n contain dspacelog n defin three mutual recurs procedur statet p return state processor p time t ie th instruct execut localt return content locat local memori processor p time t globalt i return content global memori locat time t depend valu procedur time gamma recurs depth t furthermor procedur requir olog n bit local storag wellknown techniqu procedur implement logarithm space determinist auxiliari pda whose pushdown height olog n much proof essenti main novelti proof algorithm run polynomi time rather time n log n earlier result possibl owner function allow us globalt i directli identifi possibl writer global memori locat time gamma allow procedur make recurs call per invoc give polynomi run time simul gener crewpram algorithm would appear necessari check processor time gamma see whether wrote i so whether one did appear requir polynomi time extens basic procedur accommod gener g g quit direct except g illbehav program g also possibl delic sinc effect must check step none mani nonown attempt write global cell maintain properti algorithm make o recurs call per invoca tion it possibl similar gener crew model would increas power proof theorem detail descript three procedur follow typic pram instruct global indirect store l whose mean store accumul global memori locat whose address given content local memori locat l describ rest pram instruct set great detail see fortun wylli state processor p time order pair contain instruct counter content accumul p end th step defin three auxiliari function accumul instructioncount instruct that state s give accumul portion s instruct counter portion s instruct point instruct counter s respect assum valu instruct counter design halt instruct crowpram dcfl recognit convent instruct execut step processor p activ halt also assum instruct halt instruct otherwis defin eg jump locat beyond end program conveni assum local memori processor set zero soon halt accumul retain last valu assum processor initi execut instruct processor activ fork l instruct initi execut instruct l also assum processor maintain local memori locat count number fork instruct execut thi count initi increment immedi fork execut easi modifi pram algorithm achiev thi also use two function parentp siblingcountp that processor number p return processor number parent p number older sibl p respect processor number scheme chosen function easi comput name k largest integ p evenli divis k procedur simulatecrowpram comment main program begin ne comment upper bound run time pram statet function globalt i comment return content global memori locat time t begin store l return accumul els return function localt comment return content local memori locat processor p time t begin case local store i return accumul indirect local store l return accumul return crowpram dcfl recognit function statet p comment return state processor p time t begin comment ac initi length input return n els comment processor idl time return ac accumul ic instructioncount case indirect load l return ic global indirect load l add sub read similar load return l ac els return ic parent activ p step return l accumul els comment p activ pass ac return ac correct simul straightforward induct t implement procedur dauxpda also easi note procedur local variabl requir olog n bit storag dauxpda need much space work tape recurs depth equal pram run time ie olog n pushdown height product two quantiti ie olog n procedur make o recurs call per recurs level run time simul o olog n n o complet proof theorem simul given easili adapt accommod gener gg definit crowpram propos earlier allow gener owner function say depend input time gg trivial add appropri paramet call use differ processor number convent equal easi provid parentp siblingcountp easili comput g allow function logspac polynomi time dauxpda comput effect asymptot complex bound g bound multipl ownership g also easi global procedur check whether owner global memori cell wrote it would need check among set owner see wrote sinc set size o run time would still polynomi chang procedur accommod illbehav pram algorithm g subtl first chang requir must determin exact run time algorithm use upper bound caus us fals reject due invalid global store processor valu easili determin evalu statet halt accept if accept need worri ownership violat second interest chang check store instruct activ processor p time basic depthfirst search processor activ tree crowpram dcfl recognit procedur simulategcrowpram comment modifi main program incorpor g begin instructionstatet halt accumulatorstatet halt reject treewalk halt accept procedur treewalkt p comment visit processor p time descend creat interv each verifi nonown write occur begin store l halt reject comment owner violat quit correct procedur argu follow crowpram algorithm owner write violat procedur correct befor hand suppos violat say time processor p procedur correctli determin state pram t time t state pram undefin wherea procedur call return valu violat occur how ever eventu treewalk detect fault may reject evalu branch processor activ tree happen explor ps branch latest howev detect fault evalu statet p count thi sinc simul faith time state pram time contain inform need deduc processor p activ time t execut store violat ownership constraint henc eventu evalu statet p detect fault halt run time algorithm still polynomi sinc treewalk p call exactli activ processor p polynomi mani processor check thu shown follow theorem set recogn time olog n gener crowpram ie one satisfi gener gg basic defi nition logdcfl complet proof onli if direct theorem convers shown follow section dpda definit notat assum familiar determinist pushdown automata dpda defin exampl harrison well standard variat model dpda state set q input alphabet sigma pushdown alphabet gamma empti string denot ffl length string jsj string concaten delta step either current topmost pushdown symbol pop pushdown singl new symbol push onto pushdown current symbol assum transit function defin everi possibl state input symbol pushdown symbol thu dpda begin state q initi pushdown content input head left input accept enter state q fl pushdown content advanc input head right end input assum dpda never fail read crowpram dcfl recognit input alway empti pushdown symbol except fl end comput furthermor assum oe gamma transit push oe standard techniqu see eg harrison section constant c dpda assum properti halt time c delta n most maximum pushdown depth n input length n effici simul dpda describ make use concept surfac configur instantan descript defin rel particular input configur tripl q i oe q state integ code binari n repres posit input head oe repres topmost pushdown symbol set surfac configur denot u instantan descript id dpda pair hu si u surfac configur string repres topmost symbol pushdown with bottommost pushdown repres rightmost posit s conveni refer stack thu initi id hq uniqu accept id hq n fl ffli id stack compon ffl call fflid note fflid correspond pushdown one symbol surfac configur id hu si defin heighti jsj defin project function surfac configur said pop transit defin q x oe pop pushdown push otherwis id pop push surfac configur pop push write id follow id one step dpda input x follow exactli step definit id repres configur machin least one pushdown symbol pop fflid id thu pop fflid said block true even though dpda make one final move depend input state singl pushdown symbol surfac configur empti pushdown conveni assum final accept configur defin pop block id denot hu id modifi symbol place symbol stack illustr notat three use proposit proposit bottompad surfac configur u v string note convers true gener follow case proposit bottomunpad surfac configur u v string proposit blockcontinu surfac configur addit restrict dpda discuss abov assum id occur twice comput dpda start given id section justifi use id refer particular point comput eg j could refer id j uniqu identifi point comput step id i crowpram dcfl recognit basic dpda simul algorithm describ procedur effici simul dpda input x length n algorithm motiv repeat doubl idea use eg fortun wylli klein reif describ set follow suppos comput surfac configur u u string si could easili comput k step transit function k compos k itself howev effici consider preclud defin k possibl stack observ comput k step top k symbol stack access split write contain everyth first k symbol s s empti length could rewritten although could use limit number stack consid length k still mani polynomi number processor comput olog n time key observ construct effici algorithm number stack need consid much limit suggest abov shown suffici consid polynomials set stack provid use stack split somewhat complic doubl techniqu simplifi set stack consid comput function delta k place describ abov give result least k step rather exactli step advantag use appropri chosen break point keep stack simpl first describ algorithm assum stack explicitli manipul section describ pram implement avoid use succinct represent stack them selv two function id use delta k low k defin induct paramet k id return id result step dpda start id valu implicitli determin algorithm itself shown block id reach less k step case number step need reach block id formal id delta k satisfi block function low k return id id lowest height among id comput delta k inclus one id minim height comput earliest id ie one closest formal a c given definit determin dpda accept x suffici check whether sinc dpda run time c delta n input length n discuss necessari restrict number stack must defin care definit delta inform need comput delta k delta k restrict consider id whose stack content suffix stack produc delta k oper fflid polynomi mani on fact state precis defin ss k mnemon simpl stack set string repres bottom portion stack id rang delta k oper fflid ie suffix stack contain on element one u u suffix uniqu stack determin u motiv crowpram dcfl recognit pp pp ppp pp ppp ppp pppp pppppppppp ppppp pp ppp ppp ppppp pp pp pppp pppppp pppp pp time height stack figur illustr ss k definit ss k consid diagram figur plot stack height versu time part comput dpda diagram show stack built delta k comput start hu ffli must complementari comput start hv eventu empti stack figur part remov comput start continu hw i rest consist remov later begin hy i note suffix illustr ss k contain stack aris delta k oper fflid also suffix stack show later k stack ss k restrict concaten two string ss k ie ss technic reason import maintain inform specifi stack ss k split two stack ss k rather simpli treat stack undifferenti charact string interest simplic howev larg ignor issu current section treat fulli section argu correct algorithm prove follow induct k welldefin id stack ss k ss k satisfi properti abov respect crux algorithm correct proof captur follow lemma show progress least k step simul simultan restrict attent limit set stack appli delta k select low point lemma the id ss k let a j b j unblock k c stackj ss k delta ss k proof see figur plot stack height versu time comput dpda three distinct case first simplest not shown diagram dpda block attempt pop stack height zero complet k step second comput hsurfacel ffli block complet k step argu overal lowdelta comput complet least step third case none subcomput block part a follow directli properti correct properti l lowest point comput l at least stackl must suffix ss k assumpt thu stackl ss k definit also ss k thu stackj ss k delta ss k satisfi c assum j unblock let delta stackl unblock correct properti j least k step past l part b follow hand block j unblock stackl must nonzero height case j cannot preced delta k i sinc otherwis id succeed j would point lower height l rang crowpram dcfl recognit height stack pp ppp ppppp ppppp pp ppp pp ppp ppp ppppp pp pppp ppppppppppp ppppp ppp pp time stack j ss k stack stack figur lowdelta lemma delta k i inclus contradict correct properti follow unblock part b follow correct properti the express j lemma occur frequent conveni introduc special notat it defin e l stackl exampl lowdelta lemma show e step block note i l j lowdelta lemma heightl j necessarili unblock e necessarili progress k step lemma appli id stack ss k need analog result stack consist two three segment ss k desir low point stack found follow iter low function use later defin function handl constant number stack segment rather three see figur ppp pp pp pp pppp pp ppp ppppp pppp pp pp pppppp pp ppp ppp ppppppp ppppp pp time e sd stack height e figur ilow k function ilow k return id comment assum u theta ss k return id low k point nonzero height comput i one exist not return result fflid begin return comment everi segment empti return hu ffli desir gener lowdelta lemma follow crowpram dcfl recognit id a j b j unblock k c stackj ss k d proof part a follow proposit let modifi stack argument call stackl suffix stacki henc hypothesi ss k stack segment ad call e k establish part c key point establish b low k point henc lowdelta lemma appli specif let last valu taken loop let u valu taken u last call low k let i l last valu taken hu si return then let j easi see delta now lemma appli particular j unblock least k step past henc j least k past i satisfi part b thu suffic show j unblock whenev j unblock two case consid first suppos ilow k return heightl necessarili unblock hand ilow k return heightl inspect thu either case j unblock j unblock part b follow code ilow k given indic determin decomposit stack paramet segment ss k brief suggest remark follow definit ss k retain decomposit inform stack initi comput detail explan issu defer next section defin low k conveni use auxiliari function min take argument sequenc id return id minim height sequenc sever minim height return leftmost applic alway earliest time construct final readi defin delta k low k correct follow part definit function provid enclos squar bracket appropri part correct argument establish basi j j j otherwis ie block correct assumpt oe gamma state push oe see ss must exactli gamma ffflg exactli set stack domain delta low inspect domain block thu satisfi hold two point rang point consider min select lower these hold vacuous induct definit delta k low k done two phase first consid id empti stack determin ss k consid id stack ss k gamma ffflg induct definit delta k low k empti stack see figur k u basic procedur comput deltalowdelta assum comput block id reach first delta k step past start point satisfi hypothesi lowdelta lemma thu subsequ lowdelta pair achiev anoth k step progress keep result stack simpl ie ss k argument main ingredi correct proof below case initi id crowpram dcfl recognit ppp pp pp ppp ppppppp pppp pp pp ppppppppp pppp pp ppp pppp ppppppp ppp ppp pppp pp pp ppp pppppp ppppppppp ppppppp pppp ppppp pp pppp pp pp ppp pp pp height stack time e figur delta k hu ffli nonempti stack turn similar except need preced anoth low two correct let delta k hu ffli note definit ss k hypothesi lowdelta lemma satisfi i delta k hu ffli block immedi satisfi block neither i least k step past hu ffli properti appli lowdelta lemma e least k step past i henc k past hu ffli thu delta k hu ffli also satisfi clearli hu ffli earliest id height zero itself properti trivial satisfi low k hu ffli properti follow directli lowdelta complet definit delta k low k must defin id nonempti stack ss k as defin delta k s action fflid induct definit delta k low k nonempti stack use ilow k defin delta k i low k i hu si result follow comput see time pppp pp ppp pp ppp pp ppppp pppppp pp ppp ppp pppp ppp ppp pp ppppppp pppppp ppp ppp pp ppp ppppppppppp ppp pppp ppppppp ppp pp height stack ilow k i e e e figur figur correct properti follow immedi appli ilowdelta lemma twice properti satisfi low k i sinc two point min appli subsum low point subcomput compris delta k properti inapplic remark ilowdelta lemma stackj may consist three stack segment even though stacki contain two main reason defin ilow k two stack segment final remark ilow k ident function id empti stack equal low k crowpram dcfl recognit definit reduc exactli comput given earlier empti stack case sinc case similarli definit low k i also suffic case ffl thu one could use gener definit handl case complet definit delta low proof correct summar key featur construct low k delta k requir constant number call level procedur guarante least k progress simul need defin domain polynomi size next two section exploit featur give fast implement pram small space implement pda crowpram implement one import issu ignor discuss far question effici handl stack obtain desir olog n run time need manipul stack lengthomegagamma n unit time particular defin ss k necessari abl split two segment stack ss k done retain inform split compon origin construct fact decomposit inform realli inform need appli induct definit actual content stack never consult definit except base case fact allow us replac actual stack abbrevi avoid explicit manipul long charact string provid decomposit inform kept avail introduc succinct notat stack revis algorithm use notat discuss crowpram implement use notat definit stack ss k suffix stack surfac configur u name specifi k u valu h give length suffix consid stack refer level k abbrevi krefer pair u h stack refer said valid krefer u h said base u height h level k conveni ffl also consid valid krefer denot empti stack height k algorithm maintain array summari k index surfac configur valu store summari u actual symbol stack ffli valu summari k u pair valid krefer turn recurs specifi actual symbol stack delta k hu ffli valid krefer u h may refer suffix stack thu conveni extend summari notat handl refer summari valid krefer length h suffix summari u k pair krefer summari k u adjust height h adjust carri follow suppos summari k u order pair krefer v order pair v singl krefer v h correspond pop referenc stack desir height h reach below defin variant r k l k il k min function delta k low k respect section oper use stack refer summari inform place stack themselv function min behav like version section except return surfac configur height rather full id leftmost earliest argument minimum height code r k need provid case empti stack the definit delta k hu si ffl given section support definit low k hu si associ correct assert otherwis use final note that code below content global array summari k alway set function r k referenc l k crowpram dcfl recognit function r u surfac return surfac refer comment return surfac refer correspond side effect store stack global array var begin u pop return u ffl let hu ffli hv oei oe r u return v r function l u surfac r refer return surfac refer comment return surfac refer low point interv u r r u r var string begin return v ffl function il k u surfac r sequenc krefer return surfac sequenc krefer comment return surfac sequenc krefer defin stack unblock low point if ani comput start u r procedur handl fix number krefer var r krefer begin return u ffl function r k u surfac return surfac comment return surfac refer correspond side effect store summari stack var refer begin return v r crowpram dcfl recognit function l return surfac comment return surfac refer correspond low point interv u r r k u r var sequenc krefer refer begin let r w h result prepend r sequenc return correct follow argument given section use correspond elucid below induct defin string b r associ valid krefer r follow valid refer string b r consist length h suffix string store summari u furthermor k valid associ induct string b induct k one show r string associ krefer r return r k u exactli stack defin section provid algorithm section stack b decompos specifi summari s re call exact decomposit use ilow k left unspecifi section note that proof given there particular proof lemma ilowdelta lemma hold decomposit stack substr ss k although need proof hold specif decomposit given summari final function r k l k defin use time olog n parallel algorithm dcfl recognit crowpram algorithm tabul r k summari k l k success higher valu k k dlog cn e u u parallel comput store tabl global memori side effect store summari k u u v u h valid krefer parallel comput store tabl global memori iter loop perform constant number refer previous store valu r k l k summari k implement tabl index surfac configur ref erenc initi uniqu processor everi array entri done use nowstandard parallel ram program techniqu see gold schlager wylli exampl surfac refer code integ olog n bit use tabl sub script techniqu also suffic implement algorithm crowpram satisfi restrict rr sinc on surfac on refer number array entri and henc number processor kept on reus array space rather separ array valu k log n valu summari k exampl discard soon valu summari k comput thu shown follow theorem theorem everi dcfl recogn crowpram satisfi restrict rr time olog n on processor theorem togeth establish theorem also obtain follow corollari crowpram dcfl recognit gener gg simul crowpram subject restrict rr constant time loss polynomi increas number processor proof shown section gener crowpram satisfi gg simul determinist auxiliari pda log n space polynomi time thu languag recogn machin sudborough class logdcfl languag log space reduc determinist contextfre languag log spacebound reduct done crowpram time olog n use determinist pointer jump techniqu fortun wylli see cook dymond detail descript simul log space parallel pointer machin olog n time see lam ruzzo simul later model olog n timebound crowpram simul easili made obey restrict rr final theorem result languag recogn crowpram also obey restrict follow appear earlier version paper monien et al gave crewpram algorithm dcfl recognit that ffl use olog n time n ffl processor algorithm use function similar our suggest approach improv processor bound crowpram algorithm theorem small space sequenti implement section present algorithm simul olog n time crowpram determinist auxpda use polynomi time olog n stack height thi combin theorem yield altern proof follow result rytter theorem rytter l accept polynomi time logarithm space dauxpda l accept machin furthermor use stack height olog n analog result previous known nondeterminist pda ruzzo best result previou rytter stack height reduct dauxpda requir superpolynomi time harju cf altern proof corollari harju dcfl dauxpda space olog n stack height olog n follow result also corollari corollari cook von braunmuhl et al dcfl time bound algorithm sketch abov polynomi particularli attract shown von braunmuhl cook mehlhorn recognit simultan space sn time on ffl sn dtm random access input tape log n sn n algorithm make gener use space resourc ie use pushdown store even stack in stack automaton sens ginsburg greibach harrison goal remaind section sketch improv algorithm achiev time bound match von braunmuhl et al still use dauxpda modif borrow key idea von braunmuhl et al construct first outlin direct algorithm bypass simul gener crowpram section present algorithm simul dpda base procedur r k l k procedur r k set global summari k array side effect l k read it easi reformul procedur recurs fulli recurs version r k would return summari inform addit compon function valu access summari k l k would replac appropri call r k recomput desir stack summari recurs procedur straightforward implement spacebound determinist auxiliari pda auxpda work tape need long enough hold local variabl procedur pushdown crowpram dcfl recognit height must time larg depth recurs hold stack frame hold copi local variabl return address etc procedur local variabl consist integ plu bound number surfac requir olog n space recurs depth dlog cne thu procedur implement dauxpda use space olog n pushdown height olog n furthermor procedur level k make bound number call level k procedur sinc depth recurs olog n total number call o olog n n o exclus recurs call procedur take time olog n manipul surfac etc plu necessari on read input thu total time algorithm polynomi main idea improv time bound gener construct section give integ procedur r k etc reflect comput length least k rather k befor easili done machineri alreadi develop exampl basic dfold composit f r k delta itself level od call level k procedur thu number recurs call main compon run time log again keep induct simpl arrang stack need consid suffix built r k u turn concaten suffix stack built r k v variou vs befor import list vs provid succinct use summari stack content one final refin idea simul sn step dpda base case procedur rather one step r k simul least sn delta k step implement procedur dauxpda olog n work tape olog n stack height straightforward befor random access input tape use algorithm von braunmuhl et al follow reason simul pop move requir recomput portion stack necessit access portion input read correspond push move ordinari sequenti access input tape even though reposit tape head may timeconsumingomegagamma n von braunmuhl et al show dcfl recognit possibl simultan space sn time on sn log provabl optim techniqu appear like use case well although pursu thi acknowledg thank michael bertol philipp derom faith fich klausjorn lang prabhakar ragd marc snir care read earli draft use discuss special acknowledg due allan borodin without would never begun research r comparison share nonshar memori model parallel comput cach coher protocol evalu use multiprocessor simul model complex short twoperson game character pushdown machin term timebound comput determinist cfl accept simultan polynomi time log squar space toward complex theori synchron parallel compu tation upper lower time bound parallel random access machin without simultan write parallel pointer machin indirect address time relationship model sequenti comput hardwar complex parallel computa tion pointer versu arithmet pram parallel random access machin own global memori determinist contextfre languag recognit complex comput parallel random access machin toward understand exclus read parallel random access machin stack automata com pile univers interconnect pattern parallel comput er simul result auxiliari pushdown automata introduct formal languag theori parallel time olog n accept determinist cfl exclusivewrit pram power parallel pointer manipul implement cole parallel mergesort algorithm ownerwrit parallel random access machin logic algorithm fast recognit determinist cfl smaller number processor optim orowpram algorithm comput recurs defin function pram toward realist parallel bram crew pram decis tree restrict crcw pram character power vector machin owner concept pram recognit contextfre languag parallel time olog n recognit unambigu contextfre languag simul parallel random access machin circuit tape complex determinist contextfre lan guag synchron parallel comput survey recognit determinist cfl small time space complex parallel comput tr cach coher protocol evalu use multiprocessor simul model upper lower time bound parallel random access machin without simultan write parallel ram own global memori determinist contexfre languag recognit parallel time italico log italicn recognit unambigu contextfre languag parallel time italicolog italicn accept determinist cfl exclusivewrit pram power parallel pointer manipul complex short twoperson game toward understand exclus read owner concept pram crew pram decis tree fast recognit determinist cfl smaller number processor restrict crcw pram parallel pointer machin pointer versu arithmet pram stack automata compil character pushdown machin term timebound comput tape complex determinist contextfre languag univers interconnect pattern parallel comput introduct formal languag theori dataindepend parallel random access machin pram toward realist parallel parallel merg sort concurrentread ownerwrit pram parallel random access machin determinist cfl accept simultan polynomi time log squar space complex parallel comput ctr bertsch mj nederhof fast parallel recognit lr languag suffix inform process letter v n p decemb