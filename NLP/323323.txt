t leadingon predict concurr posit correct a abstractthi paper describ design leadingon predict lop logic floatingpoint addit exact determin shift amount normal adder result leadingon predict techniqu calcul number lead zero result parallel addit howev predict might error one bit previou scheme correct error result delay increas design present incorpor concurr posit correct logic oper parallel lop detect presenc error produc correct shift amount describ error detect part overal lop perform estim delay complex compar previou scheme b introduct leadingon predict use floatingpoint adder elimin delay determin leadingon posit adder output critic path determin need perform normal result sinc latenc floatingpoint addit signific mani applic predict might practic import direct way perform normal illustr figur a result comput leadingon detector lod count code number lead zero then result left shift howev procedur slow sinc necessari wait result comput determin shift amount altern shown figur b normal shift determin parallel significand addit leadingon predictor anticip amount shift normal operand result addit obtain normal shift perform sinc shift alreadi determin approach use recent floatingpoint unit design commerci processor describ below basic scheme develop leadingon predictor give posit possibl error one bit thi second step consist detect correct error step increas overal delay avoid delay increas propos correct procedur detect error parallel lod also call lzd lead zero detector lop also call lza lead zero anticip lod input input b result result input input b significand adder sub shift code a b adder sub significand shift code figur magnitud addit normal floatingpoint adder unit determin posit correct perform concurr first stage shifter evalu comparison present show plausibl achiev specif implement singl datapath doubl datapath case previou work sever lop recent propos literatur briefli discuss them lop describ gener structur shown figur a describ detail section preencod examin pair bit operand produc string zero one lead one posit correspond lead one addit result string use lod produc encod leadingon posit characterist preencod result leadingon posit might error one bit therefor necessari correct error addit one bit left shift call compens shift perform basic normal shift compens shift increas delay floatingpoint addit design perform case align step operand compar swap result subtract alway posit simplifi implement adder lop howev cannot use case floatingpoint adder doubl datapath explain section b a b a b a compens shift normal lod adder p preencod adder lod preencod p adder detect tree c shift lod p correct preencod normal shift a carri select correct shift normal shift carri figur lop architectur a without concurr correct b concurr correct base carri check c concurr correct base parallel detect tree lop concurr posit correct base carri check de scribe gener structur shown figur b design part multiplyaddfus maf unit previou scheme lop possibl wrong predict one posit perform correct carri adder go anticip leadingon posit check posit correct accord carri valu correct done last stage normal shift therefor principl correct increas delay howev show section carri detect slow introduc addit delay floatingpoint addit similar scheme propos contribut main contribut paper propos evalu method perform correct one posit error basic lop normal shift without produc delay degrad achiev detect error condit concurr basic lop and therefor significand adder describ develop detect correct scheme systemat way sinc descript much common descript basic lop also includ latter propos lop oper gener case output adder posit neg version case operand adder previous compar result subtract alway posit describ approach figur c basic lop similar extend case output adder posit neg base locat bit pattern produc leadingon binari code posit mean binari tree moreov includ anoth preencod tree detect occurr error basic lop output tree use correct output lod correct shift perform sinc detect correct perform last stage normal shift delay addit increas sinc almost floatingpoint processor use ieee standard consid case signandmagnitud represent operand paper organ follow section structur lop present that differ modul lop describ leadingon posit encod section concurr posit correct section then section design evalu compar lop final section effect floatingpoint addit latenc discuss gener structur give overview structur leadingon predictor propos then follow section consid individu modul state introduct two significand signandmagnitud lop applic effect oper subtract shown figur b lop predict posit leadingon result parallel subtract significand lop oper significand align denot b signific bit oper perform magnitud adder ja gamma bj develop lop gener case either note consid posit align significand consid sign floatingpoint operand correct normal concurr correct leadingon encod string symbol n symbol string n bit detect vlog n bit correct modul coars b from adder normal figur gener structur propos lop b contrast simplifi lop consid b propos ad concurr correct extens necessari lop describ suitabl floatingpoint adder operand swap obtain alway posit result case effect subtract discuss section effect singledatapath floatingpoint adder compar parallel align shift contrast lop propos incorpor also floatingpoint adder swap operand depend expon differ case result effect subtract may neg expon equal shown figur lop divid two main part encod leadingon posit correct posit moreov part compos follow compon encod ffl preencod modul provid string zero one defin leadingon posit lead one immateri rest string is ffl encod tree also call leadingon detector lod encod posit mostsignific drive shifter normal addi tion bit v indic result correct ffl preencod modul provid string symbol use determin whether correct need indic figur signific common preencod modul ffl detect tree determin whether posit indic encod tree correct increment one ffl correct modul perform correct necessari parallel oper barrel shifter section describ two part correspond modul tree posit encod preencod modul indic figur modul produc string zero one first step product string perform radix signeddigit subtract significand obtain oper done bit slice without carri propag clariti gamma repres consid string w determin posit lead one for malli determin posit requir convers signeddigit represent convent binari represent howev see convers actual requir simplifi discuss consid separ case w notat use throughout paper follow x denot arbitrari substr k k k denot string k s s s respect k altern situat locat lead one describ diagram figur last level diagram indic possibl combin w radix signeddigit nonredund binari represent togeth locat leadingon sinc w first digit w differ equal therefor top diagram show w string k x substr x two situat identifi follow digit w follow first either case lead one locat posit k shown consid two case see digit follow first is clearli convers w convent represent posit k sinc borrow produc neg x absorb posit k situat lead one posit identifi substr digit follow first is now two possibl exist respect x name ffl x posit zero posit lead one k sinc borrow x ffl x neg posit lead one borrow produc x is problem situat possibl detect inspect digit w sinc depend number zero consequ assum posit k correct later lead posit identifi substr ae ae ae ae ae ae ae ae ae z z z z z z z z z z kj ae ae ae ae ae ae ae ae ae z z z z z z z z z z k omega omega omega omega omega omega omega omega omega omega omega posit neg zerok xomega omega omega omega omega omega omega omega omega omega omega posit neg zerok correct correct assum posit pattern assum posit pattern figur bit pattern w tabl leadingon posit w bit pattern leadingon posit substr first fposit zerog first first last string k fposit zerog last string k first last correct need summari lead one posit identifi substr first w follow string s is string length j posit lead depend similar situat s consequ use approach assum posit k correct later lead one posit identifi substr discuss summar tabl combin case leadingon posit determin substr case analysi extend determin lead one posit w achiev exchang role w case therefor leadingon posit identifi follow substr case case lead one encod tree provid signal indic situat therefor immateri encod is string identifi leadingon posit produc string zero one first one leadingon call string correspond bit f obtain combin substr describ befor simplifi descript f valu digit w equal call respect is bit posit input operand follow function defin notat substr are ffl w ffl figur a b show exampl comput f po f neg accord equat would possibl use string f po f neg encod posit lead one separ lod choos sign known howev effici combin string singl lod simplest way combin would two express howev produc incorrect result becaus instanc f neg signal leadingon posit correct posit w exampl given figur c abovement problem use also w igamma substr ore produc combin f figur see substr w w identifi lead one w similarli substr w w identifi posit w consequ extend express e contrast discuss section use two separ string detect pattern correct b a w w f c a fpo b fneg d combin f b w a w figur comput intermedi encod similarli neg string combin equat obtain transform e exampl calcul string f given figur d note case postpon descript implement modul discuss also preencod concurr correct sinc modul share compon figur design bit lod a tree implement b logic structur bit lod block encod tree string f obtain posit lead one f encod mean lod tree figur a show structur bit lod follow scheme notat describ bit v lod block indic group bit consider block p encod rel posit exampl figur b show logic structur bit lod block block lod tree note logic structur lod block similar multiplex bit input bit output rel posit insid group obtain concaten depend block v v respect final p encod posit lead one case obtain final indic shift n bit perform concurr posit correct explain section posit lead one predict input operand one bit error follow pattern w a tree tree posit preencod logic correct neg correct g g posit encod neg encod concurr correct present pattern present pattern present pattern neg posit figur detect correct pattern case posit correct ad encod calcul tree therefor concurr posit correct two step detect necessari correct correct posit encod first step carri parallel leadingon encod second one normal shift detect figur show gener scheme detect correct pattern explain detect perform two modul preencod modul detect tree preencod logic two differ string obtain g p use detect presenc posit correct pattern case w detect neg correct pattern case w done posit encod previou section possibl combin string one tree detect type pattern howev found complic substanti tree opt use two differ tree g p process posit tree g n neg tree describ modul tabl relat w a g p b g n otherwis z a otherwis z preencod modul preencod use w string obtain befor two new encod construct carri detect g p detect posit correct pattern g n detect neg one case necessari distinguish digit valu therefor digit string g p g n take valu fgamma g simplifi notat use n z p respect specif posit case detect two pattern w construct string g p detect pattern similarli g n detect pattern let us consid g need detect pattern consist lead one follow zero termin follow ffl use f p string describ express section give us lead one follow zero ffl combin w give us posit result relat substr w digit g p shown tabl a note substr w n g p set accord previou discuss case interpret n interpret perform posit detect tree figur indic pattern w correspond string g p seen g p pattern z k pz q n case correct need a correct need c d correct need f figur pattern string g p w case similar way preencod g n obtain tabl b show relat w digit g n implement preencod modul implement express f g p g n name ffl f ffl g p ffl g n implement shown figur detect tree detect one two pattern correct present binari tree use input tree intermedi encod g howev singl tree use detect posit pattern pz k n neg one nz k p number valu node tree would larg result complex slow hardwar implement therefor propos use two differ tree one detect posit pattern posit tree detect neg pattern neg tree shown figur two tree oper parallel one pattern present correspond tree detect it posit tree posit tree receiv input string g p detect pattern z k pz q nx present node tree five possibl valu z p n u repres figur implement preencod logic follow substr indic pattern detect u indic string incompat pattern node tree receiv input output two node preced level produc combin valu figur a illustr node differ level combin tabl a show function tabl node tree left input node repres first column tabl right input first row output result combin left p right n valu valu set combin right input result tabl node function a posit tree b neg tree z u u u u u u a z u u u u u u sinc string found mostsignific digit string leastsignific digit effect figur b show exampl detect pattern case pattern z pz n x present string result posit correct valu note that first digit differ z g p n is examin neg w string posit tree valu obtain output last level tree n simpl implement encod five valu four variabl assign code valu u encod logic equat are input right input respect neg tree neg tree obtain exchang role p n posit tree receiv input g n string node function shown tabl b similarli posit detect tree posit w string process final valu obtain p string g p leastsignific digit node node level level a z p z n n z z z z z z z z z left right z z z z z z z p z z z z z string detect mostsignific digit figur binari tree detect correct pattern implement hardwar implement node posit tree equat neg tree shown figur correct normal shift last step lop propos correct leadingon posit correct done increment one shift amount done reduc delay shifter conveni decod shift amount parallel adder if suffici time moreov implement constraint shifter one stage shown figur stage organ coarsest finest last one perform shift one sever contigu posit say k f binari posit indic figur perform correct last stage shifter modifi shift posit neglig effect delay last stage notic select correct nocorrect made parallel previou stage shifter z p n z figur hardwar implement tree node evalu comparison section lop architectur propos evalu term delay critic path ad hardwar complex then compar implement two scheme discuss section name lop without concurr correct lop concurr correct base carri check evalu evalu lop carri time analysi architectur critic path addit normal shift bit calcul moreov estim addit hardwar need concurr correct time analysi estim delay differ block architectur use unit delay simpl gate input nand delay summar tabl a estim obtain thorough comparison perform lop describ delay preencod logic f g p g n calcul accord hardwar implement propos figur comput delay lod detect tree consid tree six level first level decod decod ls bit decod partial shift f leadingon posit ms bit unnorm a b first stage shifter shifter second stage last stage shifter normal a b correct from correct tree detect shift partial shift partial shift figur concurr correct leadingon posit lod compos gate delay remain level determin input multiplex howev level control input multiplex known advanc input obtain previou level therefor delay level estim nand each result total delay lod nand delay level detect tree determin twolevel nand nand network see figur note z output load gate howev load slowest path node output gate therefor load z affect global delay node consid normal shift carri two stage coars shift fine shift oper three bit shift amount consequ shifter implement input multiplex moreov buffer need control input shifter due heavi load line figur a show gener structur delay parallel path adder lop shifter note slowest path goe adder tabl a delay basic compon lop b gate count lop buffer input mux preencod f preencod g p g n detect tree shift correct adder coars shifter fine shifter valu obtain a element gate preencod f preencod g p g n detect tree shift decod correct nand wherea path preencod f lod tree almost delay nand path detect tree lower delay point concurr correct critic path hardwar compon evalu hardwar complex concurr correct includ compon lop estim includ activ compon gate interconnect tabl b summar total count logic gate bit gate count preencod logic f g p g n obtain implement shown figur count logic f includ gate except gate exclus comput g p g n therefor bit consid gate devot comput f comput g p g n said befor lod detect tree compos dlog n number bit significand lod differ modul level tree thu modul except first level compos gate input multiplex howev number bit multiplex input depend level bit total number input multiplex modul first level multiplex number gate level coars select adder adder c preencod adder detect correct carri preencod a lod coars control line buffer comp coars lod preencod lod correct adder fine buf detect tree g f buflodcoars dec shift corr a adder f buflod coars fine shift compbuf dec shift adder fine coars fprefix tree finecarri corr buf select carri dec coars buf dec c figur gener structur critic path delay a lop concurr correct base detect tree b lop without concurr correct c lop concurr correct base carri check detect tree deriv implement figur includ also gate count shift decod shift correct comparison section compar lop architectur concurr correct two lop altern lop without concurr correct lop correct scheme base util addit carri use estim modul delay number gate three scheme main characterist follow lop without concurr correct figur b extens one describ case output adder either posit neg sinc lod determin posit leadingon within error one bit compens shift includ normal perform estim delay compens shifter nand addit delay buffer requir shift control correspond delay diagram shown figur b lop concurr correct base carri figur c discuss error leadingon posit detect check carri correspond posit therefor scheme carri adder calcul explicitli correspond carri select accord output lod accomplish select prefer lod output consist string follow s therefor lod implement prefix tree carri select perform set input gate follow gate characterist lod output delay fine decod larger scheme howev critic path note carri select shift correct done parallel coars shifter thi conveni reduc much possibl delay fine shift accomplish thi done coars shifter hexadecim figur c show correspond time diagram tabl summar critic path three scheme show that estim lop concurr correct present result reduct estim number gate lop two scheme compar given tabl total gate count three lop summar tabl lop concurr correct present larger number gate almost doubl gate count lop without concurr correct approxim larger gate count lop concurr correct tabl comparison critic path delay lop without lop concurr lop concurr correct correct base carri critic path delay nand improv tabl gate count a lop without concurr correct b lop concurr correct base carri check element gate preencod f coars shift decod fine shift decod compens shift a element gate preencod f prefix tree carri select coars shift decod fine shift decod correct base carri check howev gate count small part number gate floatingpoint adder actual implement put perspect comparison estim present briefli summar actual lop implement recent describ literatur implement floatingpoint adder use lop without concurr correct present includ compens shifter normal floatingpoint adder fabric m cmo process technolog tripl metal interconnect main differ respect lop without concurr correct describ section come fact result subtract alway posit preencod logic simplifi delay lop ns time devot compens shifter ns therefor conclud incorpor concurr correct base detect tree and consequ elimin compens shifter delay tabl gate count concurr correct lop gate lop detect tree lop without concurr correct lop carri check lop could improv ns implement ibm rs floatingpoint unit m cmo technolog use triplelevel metal describ incorpor floatingpoint multiplyaddfus unit use lop concurr correct base carri check lod design accommod partialdecod scheme use shifter normal shift accomplish two stage first stage produc hexadecim shift second stage fine shift lod calcul hexadecim posit leadingon string follow s necessari decod binari posit leadingon configur use kind lop comparison lop design detail leadingon posit anticip carriedout digitwis is input data process block bit provid shift signal block shift signal constitut coars shift obtain shift signal prefix tree use receiv input gener g input propag p one input zero z input signal also use adder output tree specifi leadingon posit insid group four bit signal use control shifter select carri floatingpoint addit latenc reduct consid effect propos concurr correct overal latenc floatingpoint addit depend delay part adder and pipelin implement processor cycl time consid separ effect singledatapath doubledatapath implement latenc reduct singledatapath floatingpoint adder figur a show block diagram singledatapath floatingpoint adder use lop without concurr posit correct adder pipelin five stage done significand addit perform one complement signif signif exp exp stage mux mux muxexpon differ correct concurr detect concurr without sign exp diff exp diff adder adder one comp one comp bit shift msb bit shift sign bit msb bit invert msb sign bit shift correct control sign addsub right bit invert control mux a output align incr exp compens control bit invert output align mux figur a singl datapath floatingpoint adder without comparison we includ concurr round b reduc latenc singl datapath floatingpoint adder without comparison with concurr round lop concurr correct form way result neg recomplement consist bit invers altern compound adder could use fourth stage perfom round normal adder result note invert recompl result also includ stage shown figur oper perform two parallel path one invers massiv left shift bit shift round possibl valu comput significand adder neg whe expon differ zero case full normal left shift may need round requir consequ bit invert oper parallel round logic hand expon differ larger zero two situat occur ffl two mostsignific bit adder result zero occur expon differ one or zero case analyz separ normal left shift one bit need and that result exact round requir mux select output shift modul addit result ffl least one two mostsignific bit adder result one situat occur expon differ note normal adder result includ situat maximum normal shift one normal result round limit normal shift carri bit shift modul then mux select output round modul result case effect addit round alway requir never normal left shift howev significand overflow occur need one bit rightshift normal right shift also carri bit shift modul figur adder lop concurr correct similar except compens shifter expon increment fifth stage elimin might permit merg two last stage shown figur b note merg might possibl without concurr correct delay compens shifter expon increment similar scheme latenc reduct obtain singl datapath floatingpoint adder comparison case compar includ second stage assur that case effect subtract smaller operand subtract larger one and therefor result alway posit latenc reduct obtain kind adder analyz round additionsubtract signif exp signif exp expon differ sign bit lop without correct concurr effect subtract round bit shift msb msb far close exp diff effect oper eff add sign exp diff control addsub sign control shift eff sub adder compound bit bit shift bit invert right bit invert compound adder align bit shift exp incr control mux output align exp incr shift compens figur latenc doubl datapath floatingpoint adder latenc reduct doubledatapath floatingpoint adder figur show doubledatapath architectur it far datapath comput effect subtract expon differ larger one well effect addit hand effect subtract expon differ equal smaller one comput close datapath pipelin adder four stage deriv transform pipelin singl datapath floatingpoint adder without comparison figur consid compon delay specifi section path additionsubtract combin round compound adder adder comput select one perform round moreov close datapath use perform two complement result bitwis invers array half adder includ compound adder far datapath comput requir round infin significand overflow howev describ modif replac array right shift operand one posit effect addit way result either normal one lead zero situat subtract consequ round perform way addit subtract shift operand implement right shifter parallel bit shifter modif reduc delay sinc elimin de array half adder far datapath assur posit result adder smaller operand complement effect subtract way result convers elimin moreov path fulllength normal requir sinc maximum left shift result one bit respect close datapath case equal expon result neg but align right shift result exact round necessari case expon differ equal one maximum align shift one bit complet align shifter requir hand case may requir fulllength normal shift therefor lop need close datapath note that datapath effect oper alway subtract bit invert smaller operand includ insid compound adder sinc case effect subtract operand equal expon result neg neg result convert sign andmagnitud represent convert result form bitinvert output b compound adder is way result convers reduc bitwis invers output compound adder sinc bit align shift bit normal shift small delay implement shorter critic path singl datapath case figur determin influenc lop concurr correct latenc analyz total delay two path use lop without concurr correct see that expect elimin compens shifter close datapath reduc total delay path then describ below flexibl pipelin two path sever stage latenc reduc consid block close far path see path almost modul signif exp signif exp expon differ compound adder four level adder compound sign bit msb exp diff effect oper control mux far close sign exp diff eff sub concurr lop detect control addsub sign eff add control shift shift corr bit bit shift bit invert bit shift shift right compound adder two level exp incr mux bit shift output align bit invert figur doubl datapath floatingpoint adder reduc latenc close expon differ operand swap bit right shifter align compound adder bit invert normal left shifter compens shifter mux output align far expon differ operand swap align right shifter bit in verter compound adder bit left shifternorm mux output align then differ two datapath compens shift close datapath consequ concurr correct use compens shift elimin path delay allow pipelin four stage smaller stage delay might even possibl obtain three stage pipelin shown figur conclus present leadingon predict lop algorithm implement obtain exact predict normal shift floatingpoint adder predict permit reduc delay adder sinc lop oper parallel adder normal shift known result significand addit lop algorithm present gener sinc oper adder result posit neg predict lead one posit error one bit approach includ logic necessari concurr detect predict wrong correct normal shift permit elimin compens shifter requir adder lop includ concurr shift correc tion although concurr correct increas number gate requir lop increas signific sinc lop small portion overal floatingpoint adder detect correct logic oper parallel lop signific adder introduc addit delay adder improv perform respect lop concurr correct base check carri significand adder logic necessari carri check introduc addit delay estim delay signific addit normal shifter reduc approxim use lop algorithm respect lop without concurr correct lop concurr correct base carri check improv use reduc latenc pipelin floatingpoint adder shown latenc singl datapath adder reduc five four cycl maintain critic path delay similarli latenc doubl datapath floatingpoint adder reduc four three cycl r round floatingpoint addit use compound adder ultrasparc next gener superscalar bit sparc design ibm risc system floatingpoint execut unit snap project design floatingpoint arithmet unit variabl latenc pipelin floatingpoint adder algorithm novel design lead zero detector cir cuit comparison logic synthesi comput architectur improv algorithm highspe floatingpoint addit design implement snap float point adder tr ctr r v k pillai d alkhalili a j alkhalili s y a shah low power approach float point adder design dsp applic journal vlsi signal process system v n p march chi huang xinyu wu jinmei lai chengshou sun gang li design high speed doubl precis float point adder use macro modul proceed confer asia south pacif design autom januari shanghai china khalid h abe raymond e siferd cmo vlsi implement lowpow logarithm convert ieee transact comput v n p novemb