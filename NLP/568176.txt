t searchbas bind time analysi use typedirect prune a introduc new way perform bind time analysi rather analyz program use constraint solv abstract interpret use method base search search guid type inform significantli prune size search space make algorithm practic claim comput new better inform comput new novel way clarifi process involvedth method base upon novel use higherord multistag type rich express medium express bindingtim specif type could use start point bta goal work demonstr singl unifi system seamlessli integr manual stage automat btabas stage possibl b introduct bind time analysi bta thought automat addit stage annot welltyp semant meaning term base languag permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee asiapepm septemb aizu japan programm suppli two thing welltyp base languag program bind time specif a set instruct part program static part dynam analysi produc new program old program plu stage annot success new program call well annot erasur stage annot new program produc origin base languag program introduc new kind bta work search space annot term produc ad one stage annot welltyp base term ad stage annot must consist origin type program user suppli bindingtim specif search space explor lazili ad stage annot maintain consist path discov could longer produc wellannot term path immedi prune search produc one wellannot term direct search algorithm adjust produc better wellannot term first motiv work motiv work metaml metaprogram system meta program sy tem metaprogram manipul objectprogram metaprogram may construct objectprogram combin object program fragment larger objectprogram observ structur properti objectprogram design use medium express runtim code gener found mani use well metaml conserv extens core ml includ featur standard ml except modul system add four kind stage annot con struct manipul execut code first class object discuss three here stage annot partit program stage bracket _ surround express lift surround express next stage escap _ which appear within bracket drop surround express previou stage lift lift _ evalu argument ground valu a first order valu like construct program next stage constant valu two stage world bracket code dy namic unbracket code static apriori restrict two stage common use metaml stage program interpret overhead improv runtim per formanc reason partial evalu often employ use consid accomplish metaml earlier work identifi step process greatli abbrevi here exampl use tradit one stage power function but use process mani program order magnitud larger first write unstag program n els x power n x second identifi sourc interpret overhead power exampl loop variabl repres expon n third consid type unstag function here int int int consid extens type obtain ad code type constructor one place make sourc interpret overhead static paramet dynam may sever type exampl two dierent extens power type int int int int fourth choos one extens type place stage annot bracket escap lift origin program produc wellannot program exampl stage version power type int function pow n els x pow n x choic extend type use guid annot often depend context gener use in sometim obviou time so subtleti beyond scope short introduc tion relev here sinc even automat base system user must suppli stage specif stage version use produc comput without interpret overhead exampl pow use sever context gener code fragment right evaluatesto arrow fn z pow fn z z z z z unifi vision winter one author taught cours stage comput pattern emerg typic assign consist unstag function type t target extend type instruct write stage version unstag function target type discuss aros class possibl automat produc stage version function could mix manual stage function singl system caus class instruc tor consid process follow stage function answer obviou use type inform contain type origin program target type guid placement stage annot argu manual annot give programm finer control automat process ever achiev but must admit mani time automat annot would suce place less burden programm tightli integr system support manual annot practic metaml automat bta built view key obstacl system reconcil bind time specif given bta rich type structur possibl mix code type data structur higher order function mani bta driven bind time specif simpl direct indic certain global variabl andor paramet simpli static dynam newer one extend partial static first order data metaml code type complet first class metaml possibl data structur emb function manipul code kind partial static higher order function ie metafunct take metafunct argument miss bindingtim specif key insight use metaml rich type bind time specif key insight understood sever smaller hurdl easili resolv bta describ part partial evalu system system almost alway base upon sourc sourc transform work sourcefil level produc new sourcefil compil exist compil hard reconcil metaml view stage annot first class semant object part languag definit view metaml type stage specif easi next step view direct compil produc new program whose mean given term metaml semanticli meaning stage annot output bta opaqu user consist gener extens appli static argument produc residu program annot gener extens partial evalu paradigm encourag user look understand gener ex tension user idea look like use metaml user alreadi know stage program look like write manual annot program conceptu barrier lower idea use higherord partial static type func tion arrow code type direct guid automat bta otherwis manual stage system provid fine level control previous miss ing yet still enabl automat stage desir elabor vision integr system encompass manual automat bta simpl extens metaml produc annot term suggest stage type metaml add new declar form stage user wish indic desir annot version f function f annot extens type t write stage f t compil job produc function automat caus compiletim error cant declar follow stage power int caus compil gener compil new function pow n els x pow n x output produc hand abov similarli declar stage power int int int caus compil gener compil function pow if n els x pow n x scheme quit flexibl use stage function partial static data partial static higher order type stage function two stage partial static data consid list a list map f stage a b a list b list lead automat introduct map f higher order partial static type consid stage a ba list b list lead automat introduct map f stage program two stage consid inner product function stage run three stage first stage know size two vector oer opportun special inner product function size remov loop overhead bodi function second stage know first vector oer opportun special base valu vector inner product vector taken mani time vector special remov overhead look element first vector time third stage know second vector comput brought complet nth v nnth w els stage iprod int oper greaterthan oper metaml use oper normal greater oper conflict metaml use symbol stage annot befor stage declar would caus compil automat produc three stage annot version lift nth v n nth w n els framework section describ minim languag use describ bta exampl previou section express metaml languag consider richer minim languag describ next properti show hold minim languag also hold metaml base term structur base term defin induct set product product defin set syntact correct term exampl variant lambda calculu integ constant could defin by annot term stage annot ad set product defin set syntact correct annot term exampl add product bracket e lift erasur process remov annot annot term produc base term base type set base type base term also induct defin actual form type depend upon construct concept inher base languag lambda calculu variant type base term defin introduc type constant like constructor like list function type list annot type also extend set base type ad code type constructor produc set annot type note bracket overload work annot term annot type environ assum languag full complement primit function oper base type etc built data structur head tail t n et br es figur judgment welltyp base term extens wellannot term con nil null etc environ map global constant lambdabound variabl type welltyp term type judgment select subset syntact well form term semant meaning call term welltyp top half figur give set judgment base term form judgment n read environ term e assign type stage n n natur number term level term without stage annot gener term level n surround n set match bracket base term stage inform safe ignor inde eras stage inform top half figur reduc familiar type judgment lambda calculu wellannot term ad type judgment stage annot judgment base term defin new judgment select subset syntact correct annot term call wellannot term bottom half figur extend top half judgment annot bracket escap lift stage inform the n judgment count number bracket surround current term count ensur escap appear within bracket variabl use stage later bind stage annot extens two input process welltyp base term e base type target annot type type annot extens type type annot term wish bta find relat base type annot extens relat relat relat pbasetyp annotatedtyp intuit mean obtain remov stage annot from made precis follow induct rule use notat b basetyp annotatedtyp remind reader two argument relat come dierent set b b list list relat simpli formal notion erasur type describ precis manner one type erasur anoth eras note eras act homomorph type constructor except code bracket type constructor ad annot program e type cannot produc anoth program arbitrari type type must relat fashion made precis given two partial function repres envi ronment map term variabl basetyp map term variabl annotatedtyp domain lift relat pointwis environ ment x dom x x overload term overload relat pterm annotatedterm term well type two mean similar problem conceptu b b b b b b use b baseterm annotatedterm lift relat simpli formal notion erasur term e erasur e e e stage check system given term e type t target type extens wish find annot term e need adjust notat captur precis first extens term may seem syntact rigid exampl term equival relat bound variabl same problem sinc intend gener annot term righthandsid relat alway use name bound variabl second order term quit satisfactori possibl relat annot term well annot welltyp base term sinc care relat welltyp term wellannot term well defin new relat captur distinct overload combin type judgment type term relat one given e e infer e could well annot type relat e term overload formal write new set judgment appear figur lam app code escap figur relat welltyp term well annot term judgment deriv straightforward manner figur relat type term check infer move type check system check two term relat stage annot algorithm comput stage program unstag program judgment figur describ sever rule check relationship e e four known e unknown use rule guid search slight restructur rule help illustr thi let notat e denot search well annot term e whose erasur e let type e target type soughtaft term e current state well discuss state moment rule proceed search annot subterm e combin form e occasion search annot subterm fulli intend wrap new set bracket around result get it call number pend bracket level search part state search let n level search check rule like lead natur search rule like if e e e note environ check rule chang environ search rule check rule map term variabl type search algorithm map term variabl annot term infer algorithm comput annot term everi unannot counterpart term map unannot term variabl wellannot term check rule tell us order appli search rule rule fail point need make choic implement mechan use implement search prolog come immedi mind would probabl made good choic investig suggest sever annoy detail choos function languag haskel eas could modifi program even drastic chang consid search becom clear follow except rule code escap lift rule syntax direct structur e rule driven syntact structur n use structur decid rule applic unfortun point one rule usual applic must also care rule code esc circular could lead deriv infinit height henc search infinit depth algorithm control paramet way key algorithm control two import aspect search partial may fail and search nondeterminist may one annot term given type eectiv way control search attempt escap rule first follow syntax direct rule structur e next appli lift code rule rule fail eectiv strategi discuss section control circular code escap emb algorithm small state machin three state clear up down if ab app if ab app if ab app code escap escap code clear algorithm start state clear use rule code move state up escap allow use escap move state code al low appli rule recurs sub term current term move machin back state clear exampl integ constant i were search term type i state s term suce term substructur need search an notat particular type given term subterm exampl z z clear app code find annot version f f given type annot version x x find annot version applic f x search subterm fail search whole term fail but search subterm produc one result search whole term may produc one result term two subterm b search produc n result search b produc result search whole term produc n m result fortun wellstudi formal describ algorithm notion monad com putat sever paper give good overview monad comput assum familiar monad program case monad nondetermin monad some time call list monad data structur base monad multipleresult consid search rule specifi abov subsearch perform first specifi one fail succeed specifi combin two set result job monad express search implicit rule explicitli equat use monad notat z x return f x perform search annot subterm x first succe search annot f next succe combin result search wise build newli annot term f x use check rule figur build search rule use notat control search ele ment rule lead small search compon complet search construct use notat con trol sequenc combin compon search complet algorithm found appendix written work haskel program program use follow definit type term data code list data el string e ev string x ei int check rule figur deriv one search compon written haskel function compon type type monad multipl result rule lead singl compon consid rule app goal search e e known e e not know e e welltyp type thu possibl comput type e possibl comput domain e label rule know search rule base check rule choos correctli relat simpl choic lead two dierent search rule program addit rule possibl gener treatment discuss section give tast compon construct discuss two rule two way stage express would stage whole term f type t assum f type s t first way captur follow compon appcas compon trace app n e let dom sig e comput domain type e return ea e e note state search subterm reset clear compon follow structur type judgment relat one direct rule appli nonappl default claus appcas _ _ _ _ compon fail second compon account code properti argument appcas _ n sig phi tte ea e trace app n e let dom sig e comput domain type e arr code s t e return ea e e appcas _ _ _ _ main algorithm compos search strategi appli individu search compon next section comment control mechan use direct strategi main algorithm control search notat use control order search action failur propag failur aris mean singl failur anywher caus whole algorithm fail need mechan set sever search combin success result one larg set result monad multipl result m support sever oper facilit thi leftchoic leftchoic leftchoic xs first m a first first donen first first first xs mani m a mani mani mani oper leftchoic take two comput produc multipl result first succe return result ignor second first fail run return result second comput oper first iter leftchoic list comput return result first success comput list oper mani run comput list return concaten result oper use specifi branch search main algorithm main algorithm call regroup syntax direct argument tupl call a algorithm defin larg search whose search strategi construct use first mani compon search strategi one possibl strategi strategi possibl discuss strategi section function take input level n environ map term variabl type sig term variabl annot term phi two type t t term e produc multipl result henc return type m e meant correspond roughli notat step n sig phi first esccas step n sig phi x note esc case first intcas step n sig phi x varcas step n sig phi x abscas step n sig phi x appcas step n sig phi x appcas step n sig phi x appcas step n sig phi x ifcas step n sig phi x liftcas step n sig phi x codecas step n sig phi x exampl trace section show trace search stage term fxf x type i i i ab fn f fn x f x int int int ab fn x fail app fail fail app fail fail app fail fail app fail fail succeed f esc succeed f esc fail var succeed x succeed lift x esc succeed lift x app succeed f lift x code succeed f lift x ab succeed fn x f lift x ab succeed fn f fn x f lift x correct construct believ sound search algorithm respect check rule prove although yet done so everi node search space consid search algorithm gener welltyp sourc express check rule search program never consid invalid term algorithm may return multipl result result may better other valid extens base term type given section discuss use strategi order return solut best one first algorithm use strategi employ appendix a easi argu algorithm alway termin measur function easili construct argument state decreas wellfound relat everi recurs call a n may increas code rule alway accompani decreas size t bracket strip o must decreas size e one syntax direct rule failur three state automata encod state enforc thi sinc measur function decreas everi recurs call cannot fall zero algorithm must termin polyvari polyvari allow singl function use multipl bind type algorithm need chang support polyvari recal one paramet search algorithm environ map term variabl type annot term allow environ map term variabl dierent type dierent annot term polyvari achiev exampl consid function f environ function h type int int int stage int produc bta environ sever stage h could better stage int stage int stage int stage h could work static use h h annot version f produc automat compil although definit f mention h automat make use declar stage h gener stage f polyvari use h tight integr automat manual stage use mutual advantag both consid manual stage version op primit multipl oper metaml manual stage version exploit arithmet ident x beyond scope automat bta without use semant inform yet programm easili stage manual inject semant inform system time time time time inform automat bta time use variant stage declar stage stage without type sux stage declar check time time manual stage version stage type as made precis relat add environ process thu manual stage version function use semant inform forc comput earlier stage use polyvariantli polymorph techniqu easili extend languag hindleymiln polymorph hindleymiln polymorph univers quantifi type appear outer level allow simpl preprocess step extend bta languag hindleymiln polymor phism consid exampl programm want stage standard function type i c i c consid type univers quantifi at outermost level free type variabl those tick mark like a stage type annot less gen eral type map order handl stage declar like stage int c int c first unifi erasur target type i c i c type map a b a b obtain substitut i b d appli sourc type uneras target type proceed algorithm must treat type variabl unknown type henc rule actual structur type immateri may appli right thing strategi strategi use order individu compon matter two dierent properti output tri achiev simultan minim optim work precis definit properti complet work yet inform minim mean answer produc minimum number stage annot exampl f x f extens f x f type b x type a first prefer fewer stage annot second wish arrang search strategi minim annot found larger one better yet search space contain nonminim one prune complet three state automata guid use code escap rule prevent infinit deriv also prune nonminim one annot prune sinc code rule cannot appli immedi escap rule without first descend subterm inform optim mean comput perform earliest stage possibl static if if x els prefer dynam one as if x els z first allow test perform earlier stage current search strategi use heurist push optim solut front result list tri esc rule first compon esccas alway fail level level greater zero search solut lower level ie earlier stage place first first mani strategi order stage earliest possibl comput first explain compon escap first function a analysi proof alway lead optim result remain futur work complex hard estim complex algorithm without know quit bit search strategi use strategi use appendix extrem simpl consist singl first control oper caus search whose maximum depth proport depth term e plu number bracket target type environ map term variabl singl annot term type algorithm alway find exactli result breadth search easi estim depend upon term annot type annot sought sourc algorithm complex identifi two place clever implement techniqu overcom complex first naiv algorithm perform redund computa tion redund comput possibl search space annot program direct acycl graph often two or more path subproblem exampl algorithm trace show behavior stage if large_calc e els e rule fire stage large_calc bool larg calcul rule fail rule fire stage if large_calc e els e bool rule fire stage large_calc bool larg calcul fail fail solv standard techniqu dynam pro gram memoiz away result tabl comput them tabl lookup attempt subsearch make sure were recalcul anyth second problem caus multipl app rule men tion section type check rule app figur lead mani possibl search rule app one search rule everi possibl solut side condit deepli applic nest deepli nest code type appear target type branch blow up observ structur two search rule appcas appcas see much common clever program merg rule singl case thu drastic reduc branch henc size search space trick perform subsearch instanti type variabl maintain list constraint type variabl thereaft whenev algorithm call equal check two type algorithm employ unif type failur unifi becom failur search constraint initi form type variabl base type inequ constraint either strengthen stronger inequ collaps equal upon unif follow singl app rule encompass previou two mani other unif new variabl gener constraint mainten handl underli monad machineri thu structur algorithm chang slightli appcas _ n sig phi t t eea e trace app n e let arr t e return ea e e appcas _ _ _ _ gener new type variabl add constraint chang dynam program use unif implement rework underli monad upon search implement observ travers search space notabl smaller current work quantifi precis complex bound algorithm employ two techniqu believ import work lie describ new simpl framework describ bta advanc featur higherord function poli morphism polyvari partial static firstord data higherord partial static function unbound number stage believ potenti tune algorithm highli ecient one remain relat work mogensen bondorf consel present bta higher order languag base upon abstract interpret three paper bta type lambda calculi close relat work present express type infer problem nielson nielson give bta base upon type infer twolevel simpli type lambdacalculu given simpl bind time compiletim runtim free variabl type express show algorithm comput uniqu express optim set annot minim runtim comput complex algorithm worst case exponenti size express gomard present on algorithm annot untyp lambdacalculu term similar manner work interest use crude type system perform bta untyp languag type system treat second stage term singl type code term except function type valu use arrow simpl type specifi bindingtim function henglein present ecient algorithm use similar trick express bindingtim similarli simpl type system algorithm complex on n n invers ackerman function n n intent purpos small constant algorithm use constraint solv system determin annot place algorithm may look like type infer prob lem realli search base algorithm easi identifi search space search strategi employ possibl multipl solut also separ type infer use type bta specif found work le meur lawal consel describ modul base system write bind time specif program c system allow programm name multipl bind time specif function global variabl modul use name specif specif specif written stageannot type modul system propag inform multipl usesit annot function allow dierent special dierent occurr unlik use annot type bind time specif limit first order function mani bta base upon abstract analysi bta partial static data present launchburi mogensen polyvari bta present consel dussart et al rytz gengler amongst other glueck joregensen pioneer use multilevel languag work gener standard abstract interpret techniqu multipl level show search base techniqu also gener multipl level techniqu describ incorpor featur simpl framework base upon search contribut paper describ radic new approach construct bind time analys approach base upon explor search space wellannot extens welltyp term type inform effect mean prune search space make algorithm practic algorithm surprisingli simpl yet support advanc featur higherord function polymorph polyvari partial static firstord data higherord partial static data unbound number stage complex algorithm fulli analyz remain futur work algorithm base upon use codeannot extens basetyp bind time specif type rich express mechan subsum mechan known author express bindingtim specif argu integr system combin manual stage function automat stage func tion eas burden programm yet allow fine control manual stage system support now includ use semant inform stage version could never fulli autom propos system integr bta semant part languag depend upon intervent extern tool whose semant separ languag acknowledg work describ support nsf grant ccr mj murdock charit trust depart defens author would also like thank student class cse fundament stage comput winter particip mani live discuss use stage r fixpoint comput polyvari static analys higherord applic program automat autoproject higher order recurs equat comput logic bind time analysi higher order untyp function languag polyvari bindingtim analysi applic languag polyvari constructor specialis automat program gener multilevel special partial evalu untyp lambda calculu project factor partial evalu defer compil autom runtim code gener toward bridg gap program languag partial evalu bind time analysi polymorph type higher order languag partial static structur selfapplic partial evalu automat bind time analysi type lambdacalculu polyvari bind time analysi advanc function program accomplish research challeng metaprogram dsl implement use stage monad comprehend monad essenc function program monad function program tr automat bind time analysi type myampersandlgrcalculu comprehend monad bind time analysi high order untyp function languag automat autoproject higher order recurs equat effici type infer higherord bindingtim analysi essenc function program polyvari bindingtim analysi applic languag fixpoint comput polyvari static analys higherord applic program polyvari constructor specialis multistag program explicit annot automat program gener multilevel special dsl implement use stage monad toward bridg gap program languag partial evalu accomplish research challeng metaprogram effici multilevel gener extens program special bind time analysi polymorph type higher order languag monad function program defer compil autom runtim code gener