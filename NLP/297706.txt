t trace cach microarchitectur evalu a abstracta instruct issu width superscalar processor increas instruct fetch bandwidth requir also increas eventu becom necessari fetch multipl basic block per clock cycl convent instruct cach hinder effort long instruct sequenc alway contigu cach locat trace cach overcom limit cach trace dynam instruct stream instruct otherwis noncontigu appear contigu paper present evalu microarchitectur incorpor trace cach microarchitectur provid high instruct fetch bandwidth low latenc explicitli sequenc program higher level trace term control flow predict instruct suppli spec integ benchmark tracelevel sequenc improv perform percent percent otherwis equal sophist contigu multipleblock fetch mechan perform improv due trace cach howev one benchmark whose perform limit branch mispredict perform gain almost entir due improv predict accuraci b introduct high perform superscalar processor organ divid natur instruct fetch mechan instruct execut mechan two mechan separ instruct issu buffer exampl issu queue reserv station conceptu instruct fetch mechan act produc fetch decod dispatch instruct buffer instruct execut engin consum issu instruct buffer execut them subject data depend resourc constraint instruct issu buffer collect call instruct window window mechan expos instructionlevel parallel ilp sequenti pro gram larger window increas opportun find dataindepend instruct may issu execut parallel thu trend superscalar design construct larger instruct window provid wider is sueexecut path exploit correspond increas avail ilp trend place increas demand instruct suppli mechan particular peak instruct fetch rate match peak instruct issu rate benefit aggress ilp techniqu diminish paper concern instruct fetch bandwidth becom perform bottleneck current fetch unit limit one branch predict per cycl therefor fetch one basic block per cycl previou studi shown howev averag size basic block integ code small around four six instruct fetch singl basic block cycl suffici implement issu four instruct per cycl processor higher peak issu rate multipl branch predict use fetch unit least fetch multipl contigu basic block cycl shown paper fetch multipl contigu basic block import upper bound fetch bandwidth still limit due frequenc taken branch therefor taken branch encount necessari fetch instruct taken path cycl branch fetch trace cach job fetch unit feed dynam instruct stream decod problem instruct place cach compil order store program static form favor fetch code infrequ taken branch larg basic block neither case typic integ program figur a show exampl dynam sequenc basic block store instruct cach arrow indic taken branch even multipl branch predict per cycl four cycl requir fetch instruct basic block abcd instruct store noncontigu cach locat a instruct cach b trace cach figur store noncontigu sequenc instruct reason sever research propos special instruct cach captur long dynam instruct sequenc structur call trace cach line store snap shot trace dynam instruct stream refer figur dynam sequenc block appear noncontigu instruct cach contigu trace cach figur b primari constraint trace maximum length determin trace cach line size may number implementationdepend constraint number type embed control transfer instruct special termin condit tune variou perform factor trace fulli specifi start address sequenc branch outcom describ path fol low first time trace encount alloc line trace cach line fill instruct fetch instruct cach trace encount cours execut program ie start address predict branch outcom avail trace cach fed directli decod singl cycl otherwis fetch proce normal instruct cach high bandwidth fetch mechan propos base convent instruct cach everi cycl instruct noncontigu locat fetch instruct cach assembl predict dynam sequenc typic requir multipl pipelin stage level indirect special branch target tabl gener pointer noncontigu instruct block moder highli interleav instruct cach provid simultan access multipl line possibl bank conflict complex align network shift align block dynam program order readi decod ingrenam trace cach approach avoid complex cach dynam instruct sequenc themselv rather inform construct them predict dynam sequenc exist trace cach recreat fli instruct cach static represent cost approach redund instruct storag instruct may resid primari cach trace cach redund among differ line trace cach relat prior work altern high bandwidth fetch mechan four previou studi focus mechan fetch multipl possibl noncontigu basic block cycl instruct cach branch address cach subgraph predictor collaps buffer multipleblock ahead predictor trace cach develop melvin shebanow patt propos fill unit multinodeword cach first work qualit describ perform implic smaller larger atom unit work instructionset architectur isa compil hardwar level author argu small compil atom unit larg execut atom unit achiev highest perform fill unit propos hardwar mechan compact smaller compil unit larg execut unit store reus decod instruct cach evalu perform potenti larg execut atom unit although work evalu size singl vax instruct basic block also suggest join two consecut basic block interven branch highli predict softwar basic block enlarg discuss spirit trace schedul trace select compil use profil identifi candid basic block merg singl execut atom unit hardwar sequenc level execut atom unit creat compil advantag approach compil optim schedul across basic block boundari franklin smotherman extend fill unit role dynam assembl vliwlik instruct word risc instruct stream store shadow cach structur eas issu complex wide issu processor appli fill unit decod instruct cach improv decod perform complex instructionset comput cisc case cach line augment store tree improv util line four work independ propos trace cach complexityeffect approach high bandwidth instruct fetch johnson propos expans cach address cach align branch predict throughput instruct run merg expans process also predetermin execut schedul instruct line unlik pure vliw cach schedul may consist multipl cycl via cycl tag peleg weiser describ design dynam flow instruct cach store instruct independ virtual address defin characterist trace cach rotenberg bennett smith motiv concept comparison high bandwidth fetch mechan propos literatur defin trace cach design space patel friendli patt expand upon present detail evalu design space argu promin role trace cach mispredict recoveri cach propos bondi nanda dutta cach instruct thread altern path mispredict branch goal work quickli bypass multipl fetch decod stage long cisc pipelin follow branch mispredict nair hopkin employ dynam instruct format cach larg schedul group similar spirit cycl tag approach expans cach also recent work incorpor trace cach new process model vajapeyam mitra sundararaman franklin rotenberg jacobson sazeid smith exploit data control hierarchi impli trace overcom complex architectur hurdl superscalar processor jacob son rotenberg smith propos control predict model well suit trace cach call next trace pre diction discuss later section friendli patel patt propos new process model call inact issu reduc effect branch mispredict dynam optim trace store trace cach reduc execut time significantli microcod vliw blockstructur isa clearli concept trace exist softwar realm instructionlevel parallel earli work fisher hwu chang other trace schedul trace select microcod recogn problem impos branch code optim subsequ vliw architectur novel isa techniqu exampl promot abil schedul long sequenc instruct contain multipl branch trace cach microarchitectur section introduc concept trace cach instruct cach captur dynam instruct sequenc trace present microarchitectur organ around trace tracelevel sequenc premis propos microarchitectur shown figur provid high instruct fetch bandwidth low latenc achiev explicitli sequenc program higher level trace control flow predict suppli instruct cach instruct branch trace trace cach outstand trace buffer execut engin branch outcom updat figur microarchitectur next trace predictor treat trace basic unit explicitli predict sequenc trace trace unit predict rather individu branch high branch predict throughput implicitli achiev singl trace predict per cycl jacobson et al demonstr explicit trace predict remov fundament constraint number branch trace usual consequ adapt singl branch predictor multipl branch predictor counterpart also hold potenti achiev higher overal branch predict accuraci singl branch predictor detail next trace predict present section output trace predictor trace identifi given trace uniqu identifi start pc outcom condit branch embed trace trace identifi use lookup trace trace cach index trace cach deriv start pc combin pc branch out come use branch outcom index advantag provid path associ multipl trace emi nate start pc resid simultan trace cach even direct map output trace cach one trace depend cach associ trace identifi store trace order determin trace cach hit analog tag convent cach desir trace present cach one cach trace identifi match predict trace identifi trace predictor trace cach togeth provid fast tracelevel sequenc unfortun tracelevel sequenc alway provid requir trace particularli true start program new region code reach neither trace predictor trace cach learn trace yet instructionlevel sequenc discuss next section requir construct nonexist trace repair trace mispredict instructionlevel sequenc outstand trace buffer figur use construct new trace trace cach track branch outcom becom avail execut engin allow detect mispredict repair trace contain them fetch trace dispatch execut engin outstand trace buffer case trace cach miss trace predict receiv alloc buffer trace predict provid enough inform construct trace instruct cach although typic requir multipl cycl due predictedtaken branch case trace cach hit trace dispatch buffer allow repair partial mispredict trace ie branch outcom return execut match path indic within trace event branch mispredict trace buffer begin reconstruct tail trace or trace start pc incorrect use correct branch target instruct cach subsequ branch trace secondlevel branch predictor use make predict advoc aggress instruct cach design provid robust perform broad rang trace cach miss rate instruct cach way interleav full cach line fetch cycl independ pc align secondlevel branch predict mechan simpl bit counter branch target store branch logic instruct counter target store instruct cach as oppos separ cach branch target buffer allow fast parallel predict number nottaken branch call instruct fetch mechan seqn keep terminolog number de note n sequenti basic block line size fetch singl cycl trace buffer construct trace written trace cach dispatch execut engin newli construct trace result mispredict recoveri trace identifi also sent trace predictor repair path histori next trace predict next trace predictor shown figur base jacobson work pathbas highlevel control flow predict index correl predict tabl form sequenc past trace identifi hash function use gener index call dolc func tion depth specifi path histori depth term trace oldest indic number bit select trace identifi except two recent one last path pc path pc path hash pc path predict tabl path trace cach figur jacobson next trace predictor current indic number bit select secondmost recent recent trace identifi respect entri correl predict tabl contain trace identifi bit counter replac predictor augment sever mechan ffl hybrid predict addit correl tabl second smaller tabl index recent trace identifi second tabl requir shorter learn time suffer less alias pressur ffl return histori stack call instruct path histori push onto special stack correspond return point reach path histori call restor improv accuraci control flow follow subroutin highli correl control flow call altern trace identifi entri correl tabl may augment altern trace predic tion form associ predictor trace mispredict detect outstand trace buffer respons repair trace use altern predict consist known branch outcom trace so trace buffer resort secondlevel branch predic instructionlevel sequenc avoid altogeth altern trace also hit trace cach trace select perform trace cach strongli depend trace select algorithm use divid dynam instruct stream trace trace select primarili affect averag trace length trace cach hit rate which turn affect fetch bandwidth interact trace length hit rate howev well under stood preliminari studi indic longer trace result lower hit rate may artifact naiv trace select polici sophist select techniqu consciou control flow construct loop backedg loop fallthrough point call site reconverg point gener may lead differ conclus reader refer interest controlflow consciou select heurist trace select paper constrain maximum trace length instruct indirect branch return jumpcal indirect termin trace hierarch sequenc figur a portion dynam instruct stream shown solid horizont arrow left right stream divid trace t sequenc trace produc independ instruct come trace predictortrac cach trace predictorinstruct cach branch predictorinstruct cach mispredict branch a hierarch mispredict branch b nonhierarch figur two sequenc model exampl trace predictor mispredict t trace buffer assign resort instructionlevel se quenc shown diagram seri step depict smaller block fetch instruct cach trace buffer strictli adher boundari t dictat trace select even final instruct cach fetch produc larger block sequenti instruct need itself call process hierarch sequenc exist clear distinct intertrac control flow intratrac control flow intertrac control flow ie trace boundari effect predetermin trace select unaffect dynam effect trace cach miss mispredict contrast sequenc model shown figur b model trace select reset point mispredict branch produc shift trace sequenc model work well pathbas next trace predict resolv branch mispredict trace subsequ trace must somehow predict howev requir sequenc trace lead sequenc avail in dicat question mark diagram potenti problem hierarch sequenc mispredict recoveri latenc explicit next trace predict use level indirect trace first predict trace cach access impli extra cycl ad latenc mispredict recoveri how ever extra cycl expos first consid case altern trace predict use primari altern predict suppli trace predictor time store togeth trace buffer therefor altern predict immedi avail access trace cach mispredict detect second altern use secondlevel branch predictor instruct cach use fetch instruct correct path case instruct cach access immedi correct branch target pc return execut engin evalu assum trace must fulli construct instruct dispatch execut engin trace effici renam unit aggrav trace mispredict trace cach miss recoveri latenc want make clear howev due fundament constraint fetch model artifact dispatch model simul methodolog fetch model evalu perform trace cach microar chitectur compar sever constrain fetch model first determin perform advantag fetch multipl contigu basic block per cycl convent singl block fetch then benefit fetch multipl noncontigu basic block isol model next trace predictor use control predict two reason first next trace predict highli accur whether predict one mani branch time compar better best singl branch predictor literatur second desir common underli predictor fetch model separ perform due fetch bandwidth due branch predict more section differenti follow model trace select algorithm ffl seq sequenti block trace singl basic block instruct length ffl seqn sequenti n block trace may contain number sequenti basic block instruct limit trace cach trace may contain number condit branch taken nottaken instruct first indirect branch seq seqn model use trace cach interleav instruct cach capabl suppli trace singl cycl consequ sequenti select constraint therefor one may view seqseqn fetch unit ident trace cach microarchitectur figur except trace cach block replac convent instruct cach is next trace predictor drive convent instruct cach trace buffer use construct trace l cachemain memori present cach final establish upper bound perform noncontigu instruct fetch introduc fourth model tcperfect ident tc trace cach alway hit isol trace predictortrac cach perform interest sideeffect trace select significantli affect trace predict accuraci gener smaller trace result constrain trace selec tion result lower accuraci determin least two reason thi first longer trace natur captur longer path histori compens use trace identifi path histori trace small is good dolc function one trace length necessarili good anoth tc model dolc a depth trace consist perform well benchmark seq seqn brief search design space show depth trace perform well observ howev tune dolc paramet enough trace select affect accuraci way graph figur show trace predictor perform use unbound tabl ie use full unhash path histori make predict graph show trace mispredict per instruct seq seqn tc trace select histori depth var i go benchmark trace mispredict seqn model dip per instruct wherea tc model reach trace mispredict per instruct unconstrain trace select result creation mani uniqu trace trace explos gener neg impact trace cach perform hypothes also creat mani uniqu context make predict larg predict tabl exploit addit context ideal trace predict go histori depth trace trace misp instr seqn figur impact trace select unbound trace predictor perform conclud difficult separ perform advantag trace cach trace predictor show posit improv longer trace nonetheless compar tc seqn seq would like know much benefit deriv trace cach itself end develop methodolog statist adjust overal branch predict accuraci given fetch model match anoth model trace predictor adjust produc predict normal fashion howev make predict predict trace compar actual trace determin advanc function simul run parallel time simul predict in correct actual trace substitut mispredict trace probabl word fraction mispredict trace correct probabl inject correct chosen perbenchmark basi achiev desir branch mispredict rate methodolog introduc two addit fetch mod el seqadj seqnadj correspond ad just seq seqn model clearli model unrealiz use perform comparison adjust branch mispredict rate match tc model simul benchmark detail fullyexecut driven superscalar processor simul use evalu trace cach microarchitec ture simul develop use simplescalar platform platform use mipslik instruct set gccbase compil creat binari datapath fetch engin shown figur faith model next trace predictor tri dolc function compress path histori bit index describ earlier section tc seq model trace cach configur size associ index vari suffici outstand trace buffer keep instruct window full trace buffer share singl port combin instruct cach secondlevel branch predic tor instruct cach kb way setassoci way interleav line size instruct cach hit miss latenc cycl cycl respect secondlevel branch predictor consist bit counter branch target assum logic store branch instruct cach instruct window instruct use experi processor way superscalar ie processor fetch issu instruct cycl five basic pipelin stage model instruct fetch dispatch take cycl each issu take least cycl possibl instruct must stall operand instruct includ load store may issu cycl execut take fix latenc base instruct type plu time spent wait result bu instruct retir order load store address gener take cycl cach access cycl hit data cach kb way setassoci line size byte miss penalti cycl realist aggress memori disambigu model load may proceed ahead unresolv store memori hazard detect store address becom avail recoveri via select reissu misspecul load depend instruct seven spec integ benchmark shown tabl simul complet tabl benchmark benchmark input dataset dynam instr count gcc o genrecogi jpeg vigoppm li queen perl scrabblpl scrabblin vortex person result perform fetch model figur show perform six fetch model term retir instruct per cycl ipc model section use kb instruct storag onli way setassoci trace cach trace cach index use pc ie explicit path associ except afford waysgo gcc jpeg li perl mk vortex ipc tcperfect figur perform fetch model draw sever conclus graph figur first compar seqn model seq model appar predict fetch multipl sequenti basic block provid signific perform advantag convent singleblock fetch graph figur show perform advantag seqn model seq model rang major benchmark show greater improv similar result hold whether branch predict accuraci adjust seqn seq model first observ import seqn model requir sophist highlevel control flow predictor retain moreorless convent instruct cach microarchitectur go gcc jpeg li perl mk vort improv ipc seqn seq seqnadj seqadj figur speedup seqn seq second abil fetch multipl possibl noncontigu basic block improv perform significantli sequentialonli fetch graph figur show perform advantag tc model seqn model rang speedup tc seqn go gcc jpeg li perl mk vort improv ipc trace cach trace predictor figur speedup tc seqn figur also isol contribut next trace predict trace cach perform lower part bar speedup model seqnadj seqn sinc overal branch mispredict rate seqn adj adjust match tc model part bar approxim isol impact next trace predict perform top part bar therefor isol impact trace cach perform go suffer notic branch mispredict benchmark benefit model come next trace predict case longer trace tc model clearli valuabl improv context use next trace predictor provid raw instruct bandwidth gcc howev next trace predict trace cach contribut equal perform five benchmark benefit mostli higher fetch bandwidth final figur show moder larg trace cach tc model nearli reach perform upper bound establish tcperfect within tabl show trace branchrel measur averag trace length tc rang li jpeg instruct time longer seqn trace tabl also show predictor perform primari altern trace mispredict per instruct overal branch mispredict rate the latter comput check branch retir see caus mi predict whether origin trace predictor secondlevel branch predictor case predict improv longer trace tc fewer trace mispredict seq result jpeg mksim fewer total branch mispredict note adjust branch mispredict rate seq model nearli equal tc shorter trace howev gener result better altern trace predict accuraci shorter trace result fewer total trace thu less alias fewer possibl altern trace given start pc benchmark except gcc go altern trace predict almost alway correct given primari trace predict incorrect predict taken togeth result fewer trace mispredict per instruct trace cach introduc redund instruct appear multipl time one trace tabl show two redund measur overal redund factor rf overal comput maintain tabl uniqu trace ever retir redund ratio total number instruct total number uniqu instruct trace collect tabl rf overal independ trace cach configur captur dynam behavior dynam redund factor rf dyn comput similarli use trace trace cach given cycl final valu averag cycl rf dyn measur use kb way trace cach rf overal vari vortex go rf dyn less rf overal rang fix size trace cach limit redund perhap tempor less redund trace cach size associ section measur perform tc model function trace cach size associ figur show overal perform ipc trace cach config urat direct map way way associ four size kb kb kb kb associ notic impact perform tabl trace statist model measur gcc go jpeg li mk perl vort trace length trace misp seq alt trace misp branch misp rate adjust misp rate trace length trace misp seqn alt trace misp branch misp rate adjust misp rate trace length trace misp alt trace misp branch misp rate control instr per trace rf overal rf dyn trace cach size ipc jpeg perl vort go gcc li figur perform vs sizeassoci benchmark except go go particularli larg work set uniqu trace total capac import individu trace conflict curv jpeg li fairli flat size littl import yet increas associ improv perform two benchmark suffer gener conflict miss otherwis size improv perform yet conflict among trace start pc signific associ allow simultan cach pathassoci trace perform improv largest configur kb way respect smallest one kb direct map rang go gcc figur show trace cach perform miss per instruct trace cach size vari along x axi six curv direct map dm way w way w associ cach without index path associ pa chose somewhat arbitrarili follow index function achiev path associ loword bit pc form set index highord bit index xore first two branch outcom trace identifi gcc go benchmark fit entir within largest trace cach observ earlier go mani heavilyreferenc trace result fewer miss instruct path associ reduc miss substanti particularli direct map cach except vortex path associ close gap direct map way associ cach half often entir miss instr go miss instr limksimmiss instr perl trace cach size trace cach size miss instr dm dmpa wpa figur trace cach miss summari import design instruct fetch unit capabl fetch past multipl possibl taken branch cycl trace cach provid capabl without complex latenc equivalentbandwidth instruct cach design evalu microarchitectur incorpor trace cach follow major result ffl trace cach improv perform otherwis equallysophist contigu multipleblock fetch mechan ffl longer trace improv trace predict accuraci mispredictionbound benchmark go factor contribut almost entir observ perform gain ffl moder larg associ trace cach perform well perfect trace cach go howev trace mispredict mask poor trace cach perform ffl overal perform sensit trace cach size associ one might expect due part robust instructionlevel sequenc ipc vari wide rang configur ffl complex advantag trace cach come price redund instruct storag gcc factor redund among trace creat correspond factor redund trace cach ffl instruct cach combin aggress trace predictor fetch number contigu basic block per cycl yield improv singleblock fetch acknowledg research trace cach genesi stimul group discuss guri sohi student todd austin scott breach andrea moshovo dionisio pnevmatikato t n vijaykumar contribut grate acknowledg would also like give special thank quinn jacobson valuabl input provid access next trace predict simul work support part nsf grant mip mip us armi intellig center fort huachuca contract dabt c arpa order no d eric rotenberg support ibm fellowship r integr mispredict recoveri cach mrc superscalar pipelin evalu futur mi croprocessor simplescalar toolset optim instruct fetch mechan high issu rate control flow predict treelik subgraph superscalar processor trace schedul techniqu global microcod compact altern fetch issu polici trace cach fetch mechan put fill unit work dynam optim trace cach microproc sor branch fixedpoint instruct execut unit increas instruct fetch rate via blockstructur instruct set ar chitectur trace select compil larg c applic program microcod control flow specul multiscalar processor expans cach superscalar processor perform benefit larg execut atom unit dynam schedul machin exploit finegrain parallel combin hardwar softwar techniqu hardwar support larg atom unit dynam schedul machin exploit instruct level parallel processor cach schedul group improv trace cach effect branch promot trace pack critic issu regard trace cach fetch mechan dynam flow instruct cach memori organ around trace segment independ virtual address line trace cach low latenc approach high bandwidth instruct fetch ing trace cach low latenc approach high bandwidth instruct fetch ing trace processor improv cisc instruct decod perform use fill unit multiscalar execut along singl flow control improv superscalar instruct dispatch issu exploit dynam code se quenc increas instruct fetch rate via multipl branch predict branch address cach tr ctr emil talp diana marculescu power reduct work reus proceed intern symposium low power electron design p august huntington beach california unit state s bartolini c a prete propos inputsensit analysi profiledriven optim embed applic acm sigarch comput architectur new v n p june emil talp diana marculescu execut cachebas microarchitectur powereffici superscalar processor ieee transact larg scale integr vlsi system v n p januari emil talp diana marculescu increas scalabl power effici use multipl speed pipelin acm sigarch comput architectur new v n p may michael behar avi mendelson avinoam kolodni trace cach sampl filter acm transact comput system toc v n pe februari oliverio j santana ayos falcn alex ramirez mateo valero branch predictor guid instruct decod proceed th intern confer parallel architectur compil techniqu septemb seattl washington usa oliverio j santana alex ramirez josep l larribapey mateo valero lowcomplex fetch architectur highperform superscalar processor acm transact architectur code optim taco v n p june sangjeong lee penchung yew augment trace cach highbandwidth valu predict ieee transact comput v n p septemb xianglong huang stephen m blackburn david grove kathryn s mckinley fast effici partial code reorder take advantag dynam recompilatior proceed intern symposium memori manag june ottawa ontario canada s bartolini c a prete optim instruct cach perform embed system acm transact embed comput system tec v n p novemb yoav almog roni rosner naftali schwartz ari schmorak special dynam optim highperform energyeffici microarchitectur proceed intern symposium code gener optim feedbackdirect runtim optim p march palo alto california michel co dee a b weikl kevin skadron evalu trace cach energi effici acm transact architectur code optim taco v n p decemb independ trace processor proceed nd annual acmiee intern symposium microarchitectur p novemb haifa israel roni rosner yoav almog micha moffi naftali schwartz avi mendelson power awar select dynam optim trace acm sigarch comput architectur new v n p march roni rosner micha moffi yiannaki sazeid ronni ronen select long atom trace high coverag proceed th annual intern confer supercomput june san francisco ca usa alex ramirez oliverio j santana josep l larribapey mateo valero fetch instruct stream proceed th annual acmiee intern symposium microarchitectur novemb istanbul turkey