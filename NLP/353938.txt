t integr objectori program protect object ada a integr concurr objectori program activ research topic sinc late s plethora method achiev integr major approach taken sequenti objectori languag made concurr approach taken concurr languag made objectori import latter class ada languag extens objectbas concurr program languag ada arguabl ada fulli integr model concurr objectori program exampl neither task protect object extens articl discuss way protect object made extens b introduct arguabl ada fulli integr model concurr objectori program atkinson weller well et al burn well exampl neither task protect object exten sibl ada design extens ada objectori program were part consid separ extens concurr model although consider given abandon protect type instead use javalik synchronis method place public debat issu similarli public debat issu associ allow protect type task extend purpos paper discuss way ada concurr model better integr objectori program paper structur follow section introduc main problem associ integr objectori concurr program section describ main featur ada languag relev work section argu ada wellintegr objectori concurr model achiev better integr section propos ada protect type mechan made extens discuss main syntact semant issu section consid extens protect type integr ada gener model abstract inherit section discuss propos address inherit anomali use conjunct current objectori mechan section present extend exampl section draw conclus work concurr objectori program integr concurr objectori program activ research topic sinc late s plethora method achiev integr see wyatt et al review major approach taken sequenti objectori languag made concurr for exampl variou version concurr eiffel meyer caromel karaorman bruno approach taken concurr languag made objectori import latter class ada languag extens objectbas concurr program languag ada full discuss languag given next section gener two main issu concurr objectori program ffl relationship concurr activ object distinct often concept activ object which definit execut concurr activ object exampl maio et al mitchel well newman concurr execut creat use asynchron method call or earli return method call yonezawa et al yokot tororo corradi leonardi ffl way concurr activ commun synchronis and yet avoid socal inherit anomali matsuoka yonezawa see mitchel well summari variou propos perhap interest recent develop concurr objectori program java lea oak wong have notion alli new languag abl design concurr model within objectori framework without worri backward compat is sue java model integr concurr objectori framework combin activ object concept asynchron method call descend predefin class thread predefin method run start start call new thread creat execut run subclass thread overrid run method allow applic express activ object it also possibl obtain start run implement interfac runnabl method avail thread class allow wide rang thread control commun synchronis achiev allow method object specifi synchronis synchronis method execut mutual exclus lock associ object class java deriv object class method implement simpl form condit synchronis thread can therefor wait notif singl event use conjunct synchronis method languag provid function similar simpl monitor hoar arguabl java provid eleg although simplist model objectori concurr ada program languag ada languag allow program construct sever basic build block packag subprogram procedur function task these task consid type integr type model languag type ada mani instanc task type declar task place array record pointer task declar creat ada fulli integr concurr model sequenti compon languag task encapsul data object well task built use consist underli type model dataori synchron protect type ada extend facil ada area languag weak perceiv one innov introduct dataori commun synchron protect type instanc protect type call protect object basic monitor hoar avoid disadvantag associ use lowlevel condit variabl instead protect type may guard entri similar provid condit critic region brinchhansen protect type ada encapsul data item access protect type oper declar shown follow exampl protect type shared_int public oper procedur function get return entri wait_until_zero privat encapsul data current privat oper might follow oper protect type implement correspond bodi protect bodi shared_int procedur integ begin current valu function get return integ begin return current entri wait_until_zero current entri barrier guard begin instanc protect type ie protect object declar like variabl protect object name x oper share object invok follow way some_vari xget call oper protect type socal protect action guarante mutual exclus access protect object usual semant multipl reader function call readonli one writer procedur entri call entri call barrier fals call queu call task block call final execut otherwis call accept execut protect action end procedur entri call barrier entri examin barrier becom true possibl queu call execut part protect action ie without relinquish mutual exclus between servic entri queue repeat either queu call barrier fals protect action termin follow exampl illustr use entri simpl bound buffer item taken buffer empti item put full protect type integer_bounded_buff entri entri get privat array integ first last natur nof_item natur protect bodi integer_bounded_buff entri nof_item bufferlength begin buffer last i last last mod bufferlength nof_item entri get nof_item begin bufferfirst first first mod bufferlength nof_item nof_item get call nof item zero call queu anoth task call put nof item increment entri queue servic call put finish barrier get true queu call allow proceed thu unblock task made call requeu statement form requeu target_entri allow entri put call alreadi begun process back entri queue again requeu immedi leav current entri requeu call initi entri queue servic requeu call execut control return task made origin call exampl requeu statement found section within oper protect type attribut ecount repres number call queue entri e potenti block call particular entri call forbidden within protect action languag rule help avoid deadlock due nest monitor problem also avoid possibl unbound prioriti invers might otherwis occur mean procedur protect type may call procedur function protect object entri function protect type may call protect function protect object avoid circumv readonli restrict howev may call protect function procedur protect object entri may call procedur function entri may requeu anoth entri objectorient tag type one main extens ada introduct objectori program facil design ada face dilemma ada s facil encapsul packag unfortun packag unlik task fulli integr type model packag type rather introduc classlik construct languag as done almost objectori languag ada follow oberon wirth approach achiev objectorient type extens design argu ada alreadi abil deriv type type overrid oper consequ objectorient achiev via introduct tag type tag type ada record type extend thu class ada repres follow packag object type class tag record data attribut class follow primit oper type procedur method o class param some_typ procedur method o class param some_typ object class creat use by object use object param some_typ begin contrast call object method typic objectori paradigm call form objectmethodparam differ pure syntact form express power denot languag construct name call primit oper tag type call method class respect inherit ada achiev extend parent type overrid primit oper object use object packag extended_object type extended_class new class new data attribut overridden primit oper procedur method o extended_class param some_typ procedur method o extended_class param some_typ new primit oper procedur method o extended_class param some_typ polymorph ada achiev use classwid type pointer classwid type possibl exampl declar pointer hierarchi tag type root place tree type extens pointer refer object type hierarchi primit method call pass dereferenc pointer runtim dispatch occur correct oper type pointer access objectclassclass class indic classwid type ap pointer new object deriv objectclass dispatch appropri method ada dispatch occur actual paramet call primit oper classwid type contrast objectori program languag dispatch default eg java order forc dispatch ada paramet must explicitli convert classwid type invok primit oper situat often occur one primit oper object want dispatch primit oper object call redispatch achiev convert operand classwid type shown follow exampl type tag record procedur p x t procedur q x t begin redispatch type new record procedur p x t here procedur q redispatch explicitli convert paramet x classwid type invok p convers omit call px call would static bound procedur p t regardless actual paramet pass q note ada allow call overridden oper static bound outsid defin tag type exampl although extend object packag defin earlier extend class tag type overridden method possibl client write follow eo extended_class call overridden method explicitli arguabl broken extend class abstract perhap disallow explicit convers safe done within overridden method wish call parent method objectori program concurr although task type protect type fulli integr type model ada possibl creat tag protect type tag task type design shi away possibl partli felt fulli integr objectori program concurr wellunderstood topic and therefor suitabl iso standard profession program languag also inevit concern scope potenti languag chang propos larg ada commun accept spite thi level integr tag type task protect object tag type part type mechan therefor use protect type task type way type inde paradigm use develop see burn well chapter howev approach cannot get around basic limit protect type task type cannot extend make concurr program ada objectori dust begin settl around ada standard import begin look futur objectori paradigm larg welcom ada commun even realtim commun origin sceptic facil worri impact would predict begin see advantag furthermor peopl becom profici use languag begin realis better integr concurr objectori featur would benefici goal paper continu debat best achiev full integr futur version languag follow class basic type ada ffl scalar type integ type enumer type real type etc ffl structur type record type array type ffl protect type ffl task type ffl access type access type special provid mechan pointer type creat note that although access type subprogram procedur function creat subprogram basic type languag provid tag type ada provid mechan wherebi structur type extend stress though record type extend array type understand record primari mechan group togeth item repres heterogen attribut object furthermor variabl length array manipul alreadi cater languag similarli scalar type alreadi extend use subtyp deriv type allow record extend thu consist allow variabl length array subtyp deriv type protect type similar record group item togeth in case protect type item must access mutual exclus would consist then allow protect type extend addit item follow section discuss issu allow extens protect type issu associ extens task type subject ongo research extens protect type requir extens protect type easi articul par ticular extens tag protect type allow ffl new data field ad ffl new function procedur entri ad ffl function procedur entri overridden classwid program perform simpl requir rais mani complex semant issu further more propos extens fulli integr ada model objectori program declar primit oper consist usag elsewher ada word tag indic protect type extens describ section protect type encapsul oper perform protect data consequ primit oper tag protect type are effect alreadi defin are cours similar primit oper tag type spirit syntax sinc primit oper defin declar packag specif tag type consid follow exampl protect type tag procedur w function x return entri privat data attribut w x view primit oper t interestingli call ox take syntact form similar objectori languag inde ada protect object syntax conflict languag usual represent object see section inherit tag protect type extend manner tag type henc protect type new procedur w overrid tw procedur z new method privat new attribut issu overrid protect entri consid section one consider whether privat field parent type t seen child type t protect type data declar privat chang without first obtain mutual exclus four possibl approach visibl issu prevent child protect object access parent data would limit child power modifi behaviour parent object allow invok oper parent allow child protect object full access privat data declar parent would flexibl potenti compromis parent abstract provid addit keyword distinguish data fulli privat data privat visibl child type keyword would use similar way privat much like c use keyword protect permit descend class direct access inherit data item allow child protect type access privat compon parent protect type declar child packag parent protect type declar would slightli inconsist way protect type current work ada protect type reli use packag provid encapsul remaind paper assum second method provid flexibl requir new keyword also consist normal tag type procedur child protect type call procedur function parent wait obtain lock protect object enter parent otherwis deadlock would occur one lock instanc protect type lock use protect object convert parent type consist current ada approach one procedurefunct call anoth protect object dispatch redispatch given hierarchi tag protect type possibl creat classwid type access classwid type exampl type pt access protect type tclass p pt new type hierarchi dispatch appropri project object cours within pw possibl convert back classwid type redispatch anoth primit oper unfortun oper insid tag protect type option convert object on origin dispatch classwid type object pass implicitli oper two possibl strategi taken make call oper within tag protect type dispatch use form syntact chang make possibl specifi whether redispatch not first strategi ideal often use abl call oper type parent type without redispatch addit first strategi inconsist ordinari tag type redispatch automat solut accord second strategi use call form typeoper type type implicit protect object con vert follow exampl syntax redispatch protect bodi procedur p begin tclass indic type protect object which hierarchi type tclass view type t pass implicitli p view convert allow defin q procedur call syntax also necessari allow oper call overridden oper parent exampl protect bodi extens procedur w overrid w procedur begin call parent oper new syntax conflict part languag strictli type preced period could instanc protect type call could misinterpret extern call altern syntact represent might typeoper ada refer manual intermetr distinguish extern intern call use not full protect object name burn well call would bound error requeu also lead situat redispatch desir procedur redispatch would occur explicitli request exampl protect type t requeu e would dispatch wherea requeu tclass would dispatch requeu parent entri would requir barrier reevalu requeu protect object accept statement task could also involv dispatch correct oper similar way entri call allow entri primit oper extens protect type rais mani interrel complex issu includ child entri call parent entri objectori per spectiv essenti allow child entri call parent reus achiev unfortun protect object perspec tive call entri potenti suspend oper allow within bodi protect oper see section clear compromis requir child entri must abl extend facil provid parent relationship ani parent barrier child barrier three possibl relationship child weaken parent barrier child strengthen parent barrier frlund frlund suggest child method extend parent method child must restrict synchronis constraint order ensur parent state remain consist howev also indic behaviour child method total redefin parent possibl redefin synchronis constraint altern also argu synchronis constraint child weaken par ent strengthen them order avoid violat substitut properti subtyp liskov wing mani queue implement need maintain overridden relationship parent child barrier necessari maintain separ entri queue overridden entri one queue count attribut reflect thi henc count might give differ valu call parent call child problem use separ entri queue differ barrier overridden overrid entri harder theoris order entri servic normal entri servic firstin firstout fifo order separ queue separ barrier might possibl exampl later call overridden entri accept perhap note child access parent state barrier strengthen suffici condit ensur consist state child make barrier fals call entri see also discuss section earlier call overrid entri barrier overridden entri becom true overrid entri barrier remain fals happen parent entri requeu anoth entri entri call requeu anoth entri control return call entri task origin made entri call see section mean child entri call parent parent entri requeu control return child given code parent invis child would effect prohibit child entri undertak postprocess order reduc number option discuss assum child entri must strengthen parent barrier remaind paper syntax use indic z avoid bodi child protect object depend bodi parent necessari move declar barrier bodi specif protect type privat part consid protect type tag privat i integ barrier given privat part protect type new privat entri e call made ae would static defin call te would subject barrier ecount barrier would repeat entri bodi even barrier strengthen issu barrier evalu must address consid case tag protect object convert parent type use view convers extern protect type entri call type clear barrier need pass three possibl strategi taken use barrier associ exact entri call ignor barrier associ entri overrid exact entri parent type know new data ad child could argu allow entri parent execut child strengthen barrier entri safe unfortun case consid bound buffer extend put get oper lock here lockabl buffer view convert normal buffer getput call buffer barrier evalu lock buffer access even lock furthermor approach would z short circuit control form could also made avail also mean would separ entri queue overridden entri problem associ maintain one entri queue per overridden entri alreadi mention use barrier associ entri dispatch would occur object convert class wide type ie barrier entri object actual type strongest barrier would allow safe redispatch entri bodi method result one entri queue per entri instead one entri everi overridden entri howev perhap mislead parent code execut child barrier express evalu allow view convers insid protect object requir extern call dispatch call henc one entri queue extern call would alway invok primit oper object actual type problem approach current ada dispatch default consequ approach would introduc inconsist way tag type extens protect type treat remaind paper assum extern call protect object alway dispatch x call parent entri parent requeu far section discuss variou issu associ overridden entri call howev detail child entri actual call parent left unspecifi main problem ada forbid entri explicitli call anoth entri see section sever approach problem use requeu although ada forbid nest entri call allow entri call requeu henc child requeu parent requeu give impress call parent possibl child postprocess parent entri execut as call return caller child entri requeu parent barrier would reevalu given child barrier strengthen parent barrier parent barrier would normal open case except rais to queue call would requir one entri queue furthermor atom maintain parent requeu part protect action parent entri must servic entri whose barrier also happen open henc requeu slightli differ semant requeu unrel entri allow child entri call parent entri treat call procedur call clear call parent entri differ x harmon regular tag type new pragma could introduc call ex ternal call alway dispatch appli regular tag type requeu approach multipl entri queue need relationship parent child barrier approach alreadi rule previou subsect normal entri call special syntax alreadi introduc facilit see section approach parent call view procedur call therefor potenti suspend oper howev parent barrier still potenti caus concern one option view barrier assert rais except true k option test barrier all base premis barrier true child call and therefor need reevalu whole protect action complet either approach still problem control return child parent entri requeu request entri servic thi cours could made illeg except rais howev requeu essenti part ada model effect forbid use extens protect type would sever restrict remaind paper assum model parent call treat procedur call the issu assert left open requeu parent allow consequ postprocess allow parent call integr full ada model section consid basic extens protect type model cours propos introduct facil must also consid full implic introduct section consid follow topic ffl privat type abstract type ffl gener mixin inherit privat type encapsul mechan ada packag give programm great control visibl entiti declar packag par ticular ada support notion privat limit privat type ie type whose intern structur hidden client packag where type declar modifi primit oper declar packag for type protect type limit type henc necessari show extens protect type integr limit privat type follow illustr easili achiev order make type privat full definit move privat part packag also done extens protect type packag exampl protect type pt tag privat privat k special consider would need given barrier use count attribut parent sinc clearli chang child begin execut protect type pt tag primit oper privat data item etc note exampl primit oper type pt declar privat part packag thu visibl child packag packag exampl packag cannot anyth type pt access type primit oper nevertheless construct use classwid program use access type eg type pt_ref access ptclass privat type also give finer control visibl one might declar type make primit oper publicli visibl primit oper would privat and thu visibl child packag exampl packag exampl protect type pt tag primit oper visibl anywher privat data item etc privat protect type pt tag privat primit oper visibl child packag privat data item etc note public declar type pt use with privat instead privat start privat section suppos give syntact indic public view pt incomplet type must complet later privat part packag altern protect type declar privat extens given protect type pt packag base protect type pt tag privat privat extens written as base packag exampl protect type pt new basept privat privat protect type pt new basept addit primit oper privat addit data item here featur inherit pt publicli visibl addit featur introduc privat part packag privat henc visibl child packag packag exampl privat type use ada implement hidden semihidden inherit two form implement inherit as oppos interfac in herit ie subtyp instanc one may declar tag type publicli root type ie deriv type privat deriv anoth tag type reus latter implement hidden inherit also possibl extend protect type given packag base hidden inherit pt implement follow base packag exampl public view pt root type protect type pt tag primit oper visibl anywher privat data item etc privat privat view pt deriv pt protect type pt new basept addit primit oper visibl child packag privat addit data item etc deriv pt pt publicli visibl oper data item inherit pt cannot access packag primit oper inherit pt fact visibl public view pt too pt must redeclar implement callthrough privat inherit primit oper pt child packag packag exampl deriv relationship expos henc inherit featur access child packag semihidden inherit similar spirit expos part inherit relat given exist hierarchi extens protect type packag example_bas protect type pt tag privat protect type pt new pt privat one declar new type pt use interfac inherit pt implement inherit type deriv pt eg example_bas use example_bas packag exampl protect type pt new pt privat privat protect type pt new pt privat exampl show extens protect type offer express power concern privat type ordinari tag type fact protect type encapsul unit right in addit encapsul provid packag extens protect type offer even greater visibl control ordinari tag type primit oper extens protect type declar type privat section visibl within type within child extens type combin kind visibl which similar java protect declar visibl rule packag give visibl specif exist ordinari tag type one difficulti scheme though current possibl ada defin limit privat type implement protect type rais question whether follow legal packag exampl type tag limit privat privat protect type tag privat here although child packag could treat extens protect type client packag could littl type furthermor mixtur protect nonprotect view one type may give rise incalcul implement problem case access object would done mutual exclus even view object type protect simpli full view protect type consequ kind privat complet shown exampl probabl best disallow abstract extens protect type ada allow tag type primit oper abstract mean instanc type cannot creat abstract type extens anoth abstract type concret tag type extens abstract type abstract primit oper declar abstract type howev abstract type nonabstract primit oper ada model easili appli extens protect type follow exampl illustr integr protect type ept abstract tag concret oper function f return procedur p abstract oper function f return abstract procedur p abstract entri e abstract privat one issu perhap obviou concern whether abstract entri barrier one hand abstract entri cannot call barrier superflu hand programm may want defin abstract appropri guard abstract entri exampl protect type lockable_oper abstract tag procedur lock procedur unlock entri oper abstract privat entri oper lock bodi lock unlock set lock variabl correspond valu barrier strengthen rule lock barrier automat enforc concret implement oper remaind paper assum abstract entri bar rier exampl rewritten concret entri oper null bodi note howev concret null oper one cannot forc concret children suppli implement entri abstract entri one can gener mixin inherit ada support multipl inherit howev support variou approach use achiev desir affect one approach mixin inherit gener packag take paramet tag type declar version ada extens protect type must also allow paramet gener henc take part mixin inherit normal tag type two kind gener formal paramet defin type base_typ abstract protect tag privat type derived_from abstract new protect deriv with privat former gener bodi knowledg extens protect type actual paramet latter actual type must type tree extens protect type root deriv unfortun facil enough cope situat involv entri one caus inherit anomali matsuoka yonezawa see also section ad code child object affect synchronis code parent consid case predefin lock mix protect object defin lockabl version without extra function way express thi reason gener modifi entri use mean entri actual paramet lockabl mixin type achiev type base_typ abstract protect tag privat packag lockable_g protect type lockable_typ new base_typ procedur lock procedur unlock privat entri lock lockable_g code entri lock indic entri parent protect type barrier strengthen boolean express lock entri featur make possibl modifi barrier entri unknown time gener unit written time gener unit instanti entri actual gener paramet suppli base type known entri denot welldefin set primit oper gener barrier modifi similar frlund allexcept specifi frlund except latter also appli primit oper ad later deriv wherea entri not new primit oper ad deriv programm respons make sure new entri get right barrier ie includ lock clearli effect limit entri procedur unaffect give rise follow anomali barrier need strengthen ad condit lock may well inherit procedur need similarli guard cannot done without introduc mechan overrid procedur entri adaspecif inherit anomali discuss next section inherit anomali combin objectori paradigm mechan concurr program may give rise socal inherit anomali matsuoka yonezawa inherit anomali exist synchron oper class local may depend whole set oper present class subclass add new oper may therefor becom necessari chang synchron defin parent class account new oper section examin extens protect type deal inherit anomali synchron extens protect type done via entri barrier entri barrier interpret two slightli differ way ffl precondit which must becom guard concurr introduc objectori program languag meyer ar gue sens entri equival partial oper herlihi wing ffl synchron constraint use entri barrier ie guard synchron make extend protect type immun one kind inherit anomali identifi matsuoka yonezawa guard subject inherit anomali caus partit state avoid major break encapsul mandatori concurr objectori program languag way reus exist synchron code defin parent class increment modifi inherit synchron child class propos given claus increment modifi inherit entri barrier henc inherit synchron code inherit anomali ada extend protect type still occur though mitchel well argu root caus inherit anomali lie lack express power concurr objectori program languag five criteria identifi bloom fulfil inherit anomali may occur ada satisfi three criteria synchron base histori inform cannot express directli use entri barrier local state must instead use record execut histori synchron base request paramet valu also possibl directli ada exampl resourc control shown section exhibit inherit anomali barrier entri alloc n cannot depend paramet n itself intern re queue wait n must use instead synchron constraint wait n historysensit oper allow call dealloc freed resourc result dealloc must overridden record histori inform local state although synchron constraint dealloc well function remain unchang addit that extens protect type may suffer ada specif inherit anomali synchron done via barrier entri synchronis procedur synchron constraint subtyp restrict inherit primit oper implement procedur parent type subtyp would overrid procedur entri howev use classwid program task may assum protect oper implement procedur as base type indic therefor nonblock runtim call might dispatch entri block barrier would make call illeg occur within protect action reason overrid procedur entri allow extens protect type discuss section adaspecif inherit anomali might aris mixin inherit use avoid provid addit function gener new gener barrier modifi entri alon suffici avoid introduct new adaspecif inherit anomali gener mixin class must defin synchron complet class result combin mixin class priori unknown base class entri barrier modifi introduc allow mixin class impos synchron constraint unknown set inherit oper howev also necessari way mixin class adapt synchron addit primit oper synchron constraint impos actual base type gener mixin instanti base type creat new result type must possibl parametris mixin synchron base upon base type order obtain correct synchron new result type parametris could obtain still topic ongo research interact tag type far discuss focus protect type extend section consid interact tag type protect tag type consid follow defin simpl buffer packag simple_buff type data_t tag privat procedur write m procedur read m privat type data_t tag record buffer use safe sequenti environ make prewritten buffer safe concurr access requir encapsul protect type follow illustr easili achiev protect type buffer tag procedur write procedur read x integ privat buffer access protect interfac cours buffer protect type extend follow dispatch buffer type b access bufferclass new altern simpl bufferdata made protect encapsul follow protect type buffer tag procedur write m procedur read m privat would allow buffer access directli without protect overhead situat dictat safe so combin extens protect type classwid tag type allow even power paradigm consid protect type buffer tag procedur write m simple_bufferdata_tclass procedur read m single_data_tclass privat here protect type tag type easili extend program arrang dispatch buffer within writeread routin further use access discrimin data encapsul protect concurr use type ad access simple_bufferdata_tclass protect type tag normal discrimin procedur write procedur read x integ privat type b access bufferclass new buffernew simple_bufferdata_t here b dispatch correct buffer writeread dispatch correct data encapsul exampl section present two exampl illustr principl discuss paper assum extern call dispatch postprocess parent call check parent barrier child access parent state signal concurr program signal often use inform task event occur signal often differ form transient persist signal wake singl task wake task section illustr abstract built use extens protect type consid first abstract definit signal packag signal protect type signal abstract procedur send entri wait abstract privat signal_arriv type all_sign access signalclass packag bodi signal protect bodi signal abstract procedur send begin signal_arriv true creat persist signal signal use signal packag persistent_sign protect type persistent_sign new signal entri wait privat entri wait signal_arriv packag bodi persistent_sign protect bodi type persistent_sign entri wait signal_arriv begin signal_arriv fals creat transient signal signal use signal packag transient_sign protect type transient_sign new signal procedur send entri wait privat entri wait signal_arriv packag bodi transient_sign protect bodi type transient_sign procedur send begin return entri wait signal_arriv begin signal_arriv fals creat signal releas task type base_sign new protect signal packag release_all_sign protect type release_all_sign new base_sign entri wait privat entri wait true packag bodi release_all_sign protect bodi release_all_sign entri wait true begin waitcount return base_signalwait now cours my_sign all_sign dispatch appropri signal handler advanc resourc control resourc alloc fundament problem aspect concurr pro gram consider exercis bloom criteria see section form appropri basi assess synchronis mechan concurr languag ada consid problem construct resourc control alloc resourc group client agent number instanc resourc number bound content possibl must cater design program mitchel well propos follow resourc control problem benchmark concurr objectori program languag implement resourc control oper ffl alloc alloc one resourc ffl dealloc dealloc resourc which thu becom avail alloc ffl hold inhibit alloc call ffl resum allow alloc again follow constraint oper alloc accept resourc avail control held synchron local state histori dealloc accept resourc alloc synchron local state call hold must servic call alloc syn chroniz type request call resum accept control held synchron histori inform ada deontic logic oper histori inform express directli barrier howev possibl use local state variabl record execut histori follow solut simplifi present model resourc counter indic number free resourc requir interpret mean except rais attempt made dealloc resourc yet alloc packag rsc_control max_resources_avail constant natur exampl no_resources_alloc rais dealloc protect type simple_resource_control tag entri alloc procedur dealloc entri hold entri resum privat entri alloc free lock req entri hold lock entri resum lock req bodi packag simpli keep track resourc taken freed set reset lock variabl packag bodi rsc_control protect bodi simple_resource_control entri alloc free lock begin free free alloc resourc taken procedur dealloc begin rais no_resources_alloc free return resourc taken taken entri hold lock begin lock true entri resum lock begin lock fals rsc_control mitchel well extend problem consid impact inherit extend resourc control add method alloc n take integ paramet n alloc n resourc extens subject follow addit requir call alloc n accept least avail resourc call dealloc must servic call alloc alloc n addit constraint call must servic fifo within prioriti fashion ignor here mitchel well also implement thi ada would done pragma note specif flaw implement shown mitchel well also exhibit flaw dealloc call resourc alloc resourc control deadlock servic call dealloc alloc alloc n implemen tation correct implicitli call dealloc resourc alloc view error except rais requir implement requeu wait n enough resourc avail requir implicitli fulfil call dealloc never queu sinc dealloc implement procedur use rsc_control packag advanced_control protect type advanced_resource_control new simple_resource_control entri allocate_n n natur procedur dealloc adaspecif anomali barrier cannot access paramet must also overrid method set chang see below privat entri allocate_n free lock req note ada allow access paramet barrier pure effici reason case must ada alway impl ment use intern suspens method statement everyth necessari overhead ada implement equival access paramet barrier indic two wait_for_n entri queue one current shall use two queue use one queue use tri satisfi request request cannot satisfi requeu other then role two queue swap avoid problem call task differ prioriti chang someth dealloc need correct implement allocate_n wait_for_n reset outstand call routin servic actual encod histori inform wait_for_n accept call dealloc entri wait_for_n for queue boolean n natur entri wait_for_n for queue boolean lock holdcount privat entri use allocate_n requeu less n resourc current avail packag bodi advanced_control protect bodi advanced_resource_control procedur dealloc overridden account new histori inform encod need access paramet barrier allocate_n begin chang true entri allocate_n n natur free lock begin free n free free n taken els requeu wait_for_ncurrent_queu entri wait_for_n for queue booleann natur lock holdcount chang begin current_queu current_queu chang fals free n free free n taken els requeu wait_for_nnot queue conclus paper argu ada s model concurr well integr objectori model focuss issu make protect type extens yet avoid pitfal inherit anomali approach adopt introduc notion tag protect type underli philosophi normal tag type although requir extens protect type easili articu late mani potenti solut paper explor major issu and appropri made concret propos ada extrem express languag mani orthogon featur paper shown introduct extens protect type undermin orthogon propos fit well limit privat type gener normal tag type work present here howev without difficulti major one associ overridden entri fundament principl objectori program child object build upon function provid parent child call parent access function therefor extend it ada call entri potenti suspend oper allow within protect object henc overrid entri give conflict objectori protect type model furthermor ada allow entri requeu call anoth entri requeu entri servic control return entri issu requeu request consequ parent entri issu requeu control never return child caus conflict objectori program model child allow undertak postprocess parent call paper discuss conflict detail propos rang potenti compromis solut ada import languag intern standard objectori realtim distribut program import continu evolv paper tri contribut grow debat best fulli integr protect type model ada objectori model clear introduc extens protect type larg chang ada one accept next major revis languag mani complic come abil overrid entri one possibl major simplif propos made would allow facil entri would consid final use java terminolog simplif might lead earli transit path current ada fulli integr version acknowledg author grate acknowledg contribut oliv kiddl kristina lundqvist idea discuss paper also would like acknowledg particip th intern workshop realtim ada issu gave us feedback initi idea r integr inherit synchronis adax evalu synchronis mechan structur multiprogram concurr ada toward method objectori concurr program ming parel objectori program languag inherit synchron constraint cocur rent objectori program languag lineariz correct criterion concurr object extend protect type concurr program java behavior notion subtyp dragoon adabas object orient languag concurr analysi inherit anomali objectori concurr program languag systemat concurr objectori program extend dispatch task commun mechan classic program languag design synchron concurr object orient languag java thread program languag oberon parallel objectori languag survey concurr program concurr malltalk tr objectori concurr program abcl concurr program concurr smalltalk program languag oberon lineariz correct condit concurr object systemat concurr objectori program toward method objectori concurr program introduc concurr sequenti languag analysi inherit anomali objectori concurr program languag integr inherit synchron adax behavior notion subtyp concurr ada java thread objectori softwar construct nd ed extens protect type concurr distribut objectori program classic program languag design synchron concurr object orient languag extend dispatch task commun mechan monitor structur multiprogram parallel objectori languag inherit synchron constraint concurr objectori program languag evalu synchron mechan ctr rodrigo garca garca alfr strohmeier experi report implement ept gnat acm sigada ada letter vxxii n decemb albert m k cheng jame ra implement prioriti ceil protocol ada acm sigada ada letter vxxvii n p april knut h pedersen constantino constantinid aspectada aspect orient program ada acm sigada ada letter vxxv n p decemb gustaf naeser kristina lundqvist lar asplund tempor skeleton verifi time acm sigada ada letter vxxv n p decemb aaron w keen tingjian ge justin t mari ronald a olsson jr flexibl distribut program extend java acm transact program languag system topla v n p may