t jone optim bindingtim improv strength program special a jone optim tell us program special strong enough remov entir level selfinterpret show jone optim origin aim futamura project play import role bindingtim improv main result show that regardless bindingtim improv appli sourc program matter extens special jonesoptim strictli weaker special jone optim view bindingtim improv gener extens selfinterpret connect result previou work interpret approach b introduct bindingtim improv semanticspreserv transform appli sourc program prior program special instead special origin program modifi program special goal produc residu program better sens one produc origin program classic exampl bindingtim improv naiv pattern matcher oin partial evalu produc special pattern matcher ecient gener knuth morri an oin partial evalu cannot achiev optim without suitabl bindingtim improv wellknown two program function equival may special dierent bindingtim improv lead faster residu program improv flow static data make special termin often dynam static comput numer bindingtim improv describ literatur eg routin use oin onlin special main advantag requir user modifi special order overcom limit special method henc handi mani practic situat surprisingli sever question rais bindingtim improv program limit bindingtim improv condit modif trigger desir special ef fect good luck naiv pattern matcher may rewritten lead oin partial evalu perform kmpoptim bindingtim improv found problem special paper answer relat question conceptu level reli particular special method technic detail interest statement valid special identifi condit figur show structur special system employ bindingtim improv preprocessor bindingtim improv bti take program p divis sd classifi ps paramet static dynam return function equival program p program special respect static data x special spec special bindingtim improv take divis sd input static special system spec figur bindingtim improv preprocessor program special data x avail special flow transform common virtual special system usual special automat program transform bindingtim improv often done hand investig matter step perform result paper extend previou work jone optim interpret approach see jone optim play key role power bindingtim improv and togeth static express reduct establish certain kind nontrivi among other precis answer old question whether oin partial evalu power onlin partial evalu paper organ follow review standard definit interpret special sect present two main ingredi work jone optim sect improv sect main result proven sect addit theorem present sect connect interpret approach establish sect opportun optim construct discuss sect conclud relat work sect challeng futur work sect assum reader familiar partial evalu ation eg present part ii preliminari section review standard definit interpret special notat adapt use divis sd classifi paramet program static dynam assum alway deal univers program languag notat program text p written languag l let denot applic lprogram p input when index l unspecifi assum languag l intend multipl argument written list notat strict argument equal program applic shall alway mean strong comput equival either side impli special use oin partial evalu equat defin equal side undefin program input output drawn common data domain includ program text conveni deal program accept program data input a suitabl choic set list known lisp defin program domain leav program languag unspecifi element data domain evalu themselv program appli enclos defin program use abstract express need translat correspond program languag denot p q p translat alway possibl l univers program languag interpret special follow standard definit interpret special definit interpret lprogram int int definit selfinterpret lprogram sint sint selfinterpret l i sint llinterpret definit special lprogram spec spec special l ip p x simplic assum program special two argument first argument static even though make use divis sd definit keep explicit for reason explain special need total definit allow spec diverg p sd x diverg x practic special often sacrific termin behav ior discuss termin issu see special trivial residu program produc simpl instanti sourc program definit trivial special lspecial spec triv spec trivial realist special evalu static express sourc program express static depend known data and thu precomput special time defin special case static express reduct sucient purpos definit run time taken sect definit run time program data dn let p d dn denot run time definit static express reduct special spec spec static express reduct q q p measur run time time semant eg number elementari comput step definit tell us that term residualprogram ecienc dierenc special program q respect valu special composit p q q respect valu x impli special contain least interpret a univers program evalu static applic here definit p special static express reduct nontrivi definit impli power perform univers comput special im plement includ onlin oin partial evalu tri evalu mani static express possibl improv ecienc residu program satisfi static express reduct properti given abov jone optim translat program special interpret import entir interpret overhead re move let us look problem close explain definit jone optim translat special let p n program let intn n linterpret let spec special l st futamura project defin use def function equival q p note program p written languag n program q written languag l n toltransl achiev special n linterpret intn respect p say q target program sourc program p translat alway perform consid trivial special first argument intn instanti p result trivial target program clearli translat expect target program ineci contain entir interpret natur goal therefor produc target program ecient sourc program unfortun cannot expect special produc ecient target program interpret nontrivi languag special exist could make maxim use static input p program jonesoptim special special said strong enough complet remov interpret overhead selfint preter definit adapt make use st futamura project definit jone optim let sint sint self interpret special spec spec jonesoptim sint i joptspec sint special spec said jonesoptim exist least one selfinterpret sint that sourc program p target program p least ecient input sourc program p tell us spec remov entir layer selfinterpret case selfinterpret special interest easi judg extent interpret overhead remov compar sourc target program written languag particular program p p ident safe conclud goal achiev also explain limit structur residu program inherit structur bound sourc program best observ special selfinterpret eg ariti function definit residu program easi requir jone optim alway easi satisfi it instanc partial evalu firstord function languag algebra data type combin sever transform method necessari constant fold unfold polyvari special partial static valu constructor specializa tion type special jone optim first proven lambdamix see also first implement jonesoptim special oin partial evalu lisplik languag earli oin partial evalu similar languag util partial static structur produc near ident map mani special known whether jonesoptim not partial evalu fclmix imposs write selfinterpret make jone optim recent work jone optim concern tagelimin special selfinterpret strongli type languag note definit jone optim satisfi simpl construct els mysint fix selfinterpret want myspec jonesoptim spec triv trivial special def special myspec return last argument x unchang first argument p equal mysint otherwis myspec perform trivial specializa tion clearli special use practic formal joptmyspec mysint final show jonesoptim special static express reduct exist fact play import role next section properti satisfi simpl construct myspec stat case p case implement pattern match program p consist composit two arbitrari program p decompos q q q special respect result evalu sint selfinterpret otherwis p special respect x special jonesoptim mysint express reduct properti def realist shall concern technic detail pars lprogram p jonesoptim special instanc also satisfi properti static express reduct bindingtim improv bindingtim improv semanticspreserv transform appli sourc program special aim produc residu program better sens produc origin sourc program numer bindingtim improv describ literatur eg formal bindingtim improv program take program p divis ps argument static dynam transform p function equival program p bindingtim improv perform transform independ static valu avail special definit bindingtim improv lprogram bti bti bindingtim improv l use def follow function equival residu program r r produc directli special p special bindingtim improv version p practic expect and hope program r better sens program r exampl bindingtim improv lead faster residu program improv flow static inform special time import note bindingtim improv cannot precomput residu program sinc static valu make tabl contain possibl residu program sinc gener special sourc program allow infinit number dierent residu program compar translat translat cannot precomput result sourc program store them say tabl target program sinc gener infinit number dierent result term bindingtim improv origin coin context oin partial evalu improv flow static inform eas transform routin use special method surpris sinc exist special method could make maxim use avail inform case use term bindingtim improv semanticspreserv pretransform regardless particular special method note def requir sourc program transform ident transform correct but trivial bindingtim improv cours bindingtim improv use must perform nontrivi transform least program oth erwis residu program r r alway ident jonesoptimalitybindingtim improv previou section two dierent stream idea present bindingtim improv jone optim special program relat put idea togeth present two main result suffici condit first theorem tell us everi jonesoptim special spec exist bindingtim improv allow special achiev residualprogram e cienci special jone optim su cient condit proof make use gener construct bti theorem jone optim sucient special reduct follow hold proof proceed two step let sint selfinterpret spec jone optim special spec defin bindingtim improv z two stage q bindingtim improv depend sint spec program p given program p divis sd program bti produc new program perform ps comput two stage first spec special p respect x sint evalu residu program remain input def follow new program function equival p accord def bti bindingtim improv sinc p p x consid rh implic thm spec let bti bindingtim improv defin let p program let x data bindingtim improv program obtain residu program r special p respect x reduc static express sinc p form suit def rewrit obtain program r evalu applic spec obtain recal rh implic r result special sint respect r spec program r fast r accord def special joptspec sint conclud r least fast r sinc y relat hold p x prove theorem necessari condit second theorem tell us special spec jonesoptim cannot alway reach residualprogram ecienc anoth special spec jone optim necessari condit theorem jone optim necessari special follow hold proof assum rh implic hold choos sint joptspec sint special exist nontrivi program languag eg myspec sect let bti bindingtim improv satisfi rh implic respect spec defin sint sinc bti bindingtim improv sint self sint also selfinterpret rh implic let p sint let x program q let data sinc joptspec sint combin realiz relat hold q thu conclud joptspec sint prove theorem second theorem impli special jonesoptim cannot benefit bindingtim im provement limit achiev bindingtim improv spec jonesoptim observ proof thm rh implic weaken instead quantif spec spec need quantif spec spec remark literatur jone optim often defin use r y assumpt follow directli rh thm must reduc static express spec doe discuss combin theorem conclud that term residualprogram ecienc special jonesoptim strictli weaker special jonesoptim question whether oin partial evalu power onlin partial evalu answer precis oin partial evalu static express reduct jonesoptim achiev residualprogram ecienc onlin partial evalu use suitabl bindingtim im prover bindingtim improv depend partial evalu sourc program jone optim import build special work well futamura pro jection previous found intuit would good properti theorem give formal statu term optim name criterion result also support observ special weak cannot overcom inherit limit best observ special selfinterpret which amount test whether special jonesoptim way test strength special see whether deriv certain wellknown ecient program naiv ineci program one popular test see whether special gener naiv pattern matcher fix pattern ecient pattern matcher make jone optim stand comparison test jonesoptim special static express reduct guarante pass test suitabl bindingtim improv thm special may success pass number test long jonesoptim strength limit way thm even though construct bindingtim im prover use proof thm suggest sourc program p transform new p deep transform may necessari case extent sourc program need transform practic depend desir optim actual power special spec realist bindingtim improv need transform sourc program robust section present two result regard jone opti maliti establish certain kind nontrivi jonesoptim special static express reduct particular tell us infinit number selfinterpret jonesoptim special static express reduct also jonesoptim theorem jone optim singular let spec two jonesoptim special spec reduc static express let sint sint sint two selfinterpret joptspec sint joptspec sint exist selfinterpret sint sint differ beyond renam sint sint proof proof use construct combin two selfinterpret special new selfinterpret without break jone optim defin selfint preter sint sint new selfinterpret sint dierent beyond renam selfinterpret sint sint sinc sint contain program show joptspec sint examin spec special sint sinc spec reduc static express sinc sint form suit def conclud relat hold p desir properti joptspec sint prove theorem first observ spec more jonesoptim sint spec sint faster p turn faster p surpris sinc special usual idempot repeatedli appli special program lead opti mizat known area compil construct optim may enabl optim also underlin realist choos time condit def alreadi discuss sect second special case thm let spec sint conclud repeatedli appli theorem everi jonesoptim special static express reduct exist infinit number selfinterpret special also jone optim state formal follow theorem theorem jone optim robust let spec spec special static express reduct let sint sint selfinterpret joptspec sint exist infinit number selfinterpret sint sint pairwis dierent beyond renam joptspec sint exist infinit number special spec spec pairwis dierent beyond renam joptspec sint proof let copi program defin number program copi i copi copi j dierent beyond renam i j defin number program sint i sint sint selfinterpret selfinterpret dierent beyond renam sinc contain differ copi program sint form use def conclud joptspec sint sinc defin number program spec i spec special special dier ent beyond renam sinc contain dierent copi program conclud joptspec sint sinc prove theorem remark first item also proven use construct proof thm requir static express reduct theorem hint certain kind nontrivi jone optim special also suggest thm static express reduct sure jone optim singular special infinit number selfinterpret jonesoptim special static express reduct said robust respect certain nontrivi modif selfinterpret eectiv exclud jone optim special myspec defin sect may kind fair sought earlier work three techniqu bindingtim improv program section establish connect three known techniqu bindingtim improv fig ure use standalon bindingtim improv bti c previou section stack sourc program p instrument selfinterpret a b show thm thm cover two new case minor adapt three techniqu produc residu program thu equal power respect bindingtim improv consid follow fragment thm thm bindingtim improv version p special respect x observ bti function translatorif disregard extra argument sd wellknown gener extens interpret transla tor sinc bindingtim improv function ltol translat gener extens self interpret l instead bindingtim improv p bti special suitabl selfinterpret sint respect p two way produc residu program special selfinterpret either directli special project a increment futamura project b examin two case increment special let bti bindingtim improv suppos spec special sint selfinterpret use equal obtain new set equat thu everi bindingtim improv perform transl way interpret way exampl latter case polyvari expans sourc program special suitabl self interpret appli bindingtim monovari oin special modifi program overal eect transform bindingtim polyvari oin special even though bindingtim mono variant oin special use produc residu program similarli known optim translat gener suitabl interpret techniqu also use selfinterpret improv special program theorem carri interpret case provid replac rh implic quantif quantif spec spec sint use instead direct special two step also carri one step notat conveni let us first redefin format selfinterpret special make easier accommod program two three argument selfinterpret sint interpret program two argument defin special spec special program three everi bti exist pair spec sint vice versa prop appendix a argument defin program q special respect one static argument a respect two static argu ment b residu program take remain argument input note case dierent divis use spec two step carri one step let q selfinterpret sint defin abov let twoargument program p let b c argument x respect p special respect x via sint use r residu program p follow let bti bindingtim improv let spec special suppos spec special sint selfinterpret equat st special project selfinterpret instead interpret special program via interpret also known interpret approach exampl gener kmpstyle pattern matcher naiv pattern matcher insert instrument selfinterpret naiv pattern matcher oin partial evalu similix mention sect oin partial evalu cannot achiev optim special naiv matcher via instrument selfinterpret job anoth exampl simul onlin partial evalu oin partial evalu bootstrap program transform note transform optim anoth level special spec respect sint yield new special intern techniqu self interpret new special know nd special project result gener optim special report elsewher eg again main theorem appli case replac quantif bti bti sint sint rh implic summari three techniqu bindingtim improv program summar fig produc residu program and thu equal power respect bindingtim improv program techniqu prefer practic depend applic hand exist exampl applic literatur case result section shed new light relat bindingtim improv interpret approach two main theorem cover three case everi pair spec bti exist pair spec sint vice versa prop appendix a direct special a one step st special project increment special b two step st futamura project c three step nd futamura project figur three techniqu bindingtim improv program add step gener bindingtim improv selfinterpret obtain nd futamura project detail formal reason due definit special spec argument bti reorder optimizingthetheoreticalcon proof thm make use gener bindingtim improv mani case certain fragment relev bindingtim improv program particular special spec need incorpor bindingtim improv entir special here spec remaind section point possibl optim gener construct program special program composit special observ bindingtim improv produc bti contain special whose argument fix p make program structur p much gener usual compon spec need special p improv construct replac spec gener extens gen p p program specifi gener extens gen p gener ps residu program use follow program instead z composit x q composit notic fix composit sint gen p intermedi data structur residu program produc gen p consum sint method program composit may fuse two program elimin intermedi data structur code gener pars redund oper interest examin whether known bindingtim improv justifi start gener construct whether new bindingtim improv deriv gener construct spec repres desir level special let us illustr exampl suppos onp onlin partial evalu ope oin partial evalu reduc static express jonesoptim selfinterpret sint special accord thm r y r y two residu program produc bindingtim improv defin bindingtim improv p bti perform r produc ope least good one r produc onp deriv use bindingtim im prover bti program special program com posit obtain automat one bindingtim improv program publish literatur eg special bti respect sourc program eg naiv pattern matcher anoth challeng question whether bindingtim improv specifi combin atom bindingtim improv relat combin semant tower nonstandard interpret relat work first version optim appear problem special call strong enough program p program essenti program definit optim use paper appear first p see also sect sinc power special judg mani differ way use term jone optim propos work focu problem selfappl none consid role jonesoptim special bindingtim improv also said special weak cannot overcom inherit limit best observ special self interpret result underlin argument perspect bindingtim improv term bindingtim improv origin coin context oin partial evalu sourcelevel transform program prior special routin use connect special method bindingtim improv rang rearrang express eg use associ arithmet oper transform requir ingenu eg transform naiv pattern matcher transform incorpor fragment special collect bindingtim improv oin partial evalu found sect chapter actual power bindingtim improv investig work idea control properti residu program special suitabl interpret use perform deforest unificationbas inform propag bindingtim polyvari special transform oin partial evalu appar dierent stream work connect bindingtim improv relat work shown that without use bindingtim improv oin partial evalu maxim polyvari bindingtim analysi function equival onlin partial evalu partial evalu base constant propag paper show oin partial evalu simul onlin partial evalu suitabl bindingtim improv provid oin partial evalu jonesoptim conclus anecdot evid suggest bindingtim improv program use inexpens method overcom limit special without modifi special itself pretransform often ad hoc appli improv special program know theoret limit condit method are power pretransform be result show one alway overcom limit jonesoptim special static express reduct use suitabl bindingtim improv ment alway case special jonesoptim thu regardless bindingtim improv perform sourc program matter extens special jone optim said strictli weaker special jonesoptim also answer question whether oin partial evalu power onlin partial evalu jone optim origin formul assess qualiti special translat program special interpret result give formal statu term optim name criterion previous found intuit would good properti inde propos renam optim special izat jonesoptim special precis felt wrong impli special better jonesoptim one paper show way implic inde true proof make use construct bindingtim improv work special construct sucient theoret purpos practic it incorpor entir special practic special method produc residu eect connect particular special evidenc numer bindingtim improv given literatur howev univers construct may provid new insight natur bindingtim improv instanc interest see whether nontrivi bindingtim improv eg justifi univers construc tion whether new pretransform deriv where special incorpor univers construct repres desir special strength eventu may lead better understand design reason bindingtim improv result impli special jonesoptim cannot benefit bindingtim improv ment exampl seem kmp test pass oin partial evalu jone optim lead question practic limit special jonesoptim work need identifi caus eect concret level awar onlin partial evalu shown jone optim question answer posit alreadi done oin partial evalu also much practic experi build jonesoptim special realist program languag in stanc work need retyp transform strongli type languag make transform standard program special truli jonesoptim acknowledg comment sergei abramov kenichi asai mikhail buli onkov niel christensen yukiyoshi kameyama siaucheng khoo eijiro sumii earlier version paper greatli appreci special thank due anonym review thorough care read submit paper provid mani valuabl comment preliminari version paper present second asian workshop program languag system daejeon south korea r combin semant nonstandard interpret hierarchi abstract instanti stringmatch program similix manual extract polyvari bind time analysi polyvari special equival onlin partial evalu pattern match string better support static data flow partial comput principl partial evalu comput process approach compilercompil gener partial comput gener special mechan metasystem hierarchi program transform gener optim special gener transform deforest supercompil compil gener partial evalu case studi partial evalu challeng problem partial evalu mix comput partial evalu program gener partial evalu automat program gener gener compil lazi languag partial evalu jonesoptim special strongli type languag partial static structur selfapplic partial evalu evolut partial evalu remov inherit limit structur selfapplic partial evalu ml pattern match compil partial evalu mechan proof optim partial evalu posit supercompil bootstrap higherord program transform interpret realist compil partial evalu tag elimin jonesoptim gener higherord onlin partial evalu polyvari expans compil gener tr partial evalu myampersandohgrcomplet algebra specif structur selfapplic partial evalu partial evalu pattern match string partial evalu selfappl type better support static data flow gener compil lazi languag partial evalu partial evalu automat program gener extract polyvari bind time analysi polyvari special realist compil partial evalu bootstrap higherord program transform interpret program gener termin bindingtim analysi tag elimin jonesoptim jonesoptim special strongli type languag polyvari expans compil gener combin semant nonstandard interpret hierarchi mechan metasystem hierarchi program transform evolut partial evalu mk pattern match compil partial evalu ctr niel h christensen robert glck offlin partial evalu accur onlin partial evalu acm transact program languag system topla v n p januari