t minimum achiev util faulttoler process period task a abstractth rate monoton schedul rm polici wide accept schedul strategi realtim system due strong theoret foundat featur attract practic use period task set n task deadlin end task period guarante feasibl schedul singl processor long util factor task set nn converg larg n analyz schedul set period task schedul rm polici suscept singl fault recoveri action reexecut uncomplet task prioriti rm polici maintain even recoveri condit guarante task miss singl deadlin even presenc fault util factor processor exceed thu minimum achiev util permit recoveri fault expir deadlin task bound better trivial bound would obtain comput time doubl provid reexecut rm analysi result provid schedul guarante toler varieti intermitt transient hardwar softwar fault handl simpli reexecut addit demonstr perman fault toler effici maintain common spare among set processor independ execut period task b introduct realm realtim comput frequent encount system task requir execut period applic requir common often found in exampl process control space applic avion other even extern event trigger task period mani realtim system sampl occurr event period execut associ task time slot reserv them sampl rate depend expect frequenc extern event reason aperiod sporad task execut period manner period execut well understood predict varieti schedul polici period realtim system studi schedul polici defin optim schedul feasibl set task polici also same system call fixedprior system task fix prioriti prioriti chang run time rate monoton schedul rm proven optim schedul polici schedul set fix prioriti task uniprocessor earliestdeadlinefirst edf optim schedul polici variabl prioriti system note prioriti task differ critic former measur assign task schedul polici facilit schedul wherea latter measur import task defin applic rm wide use practic easili implement preemptiv polici prioriti task assign increas order period task particular prioriti preempt lower prioriti task liu layland prove long util factor task set consist n task less n n gamma task set guarante feasibl schedul uniprocessor bound approach n goe infin howev may exist task set util factor bound still may feasibl schedul stochast analysi breakdown util factor randomli gener task set present problem schedul period task multiprocessor consid easi demonstr neither rm edf algorithm optim schedul set period task multiprocessor system among fix variabl prioriti algorithm respect fact schedul polici proven optim multiprocessor system anoth issu realtim comput current gain increas attent research fault toler comput introduc great extent critic applic relianc place reduc human intervent minimum situat demand hard realtim process merg catastroph consequ failur difficult imagin fault toler must provid respons system must perform comput success meet deadlin even presenc fault indispens mani applic paper contribut evolv framework design implement respons system goal paper investig issu fault toler system realtim period task employ rate monoton schedul previou work usual address softwar fault task primari altern code offlin schedul strategi consid period task period particular task integr multipl next lower task period altern schedul rm polici first effort made includ maximum number primari execut schedul similar problem schedul altern version program call ghost consid dynam program use perform schedul attempt made minim cost function load balanc scheme present period task set schedul rm neighbor faulti processor ring take task eventu distribut processor howev consider miss deadlin due overload caus task migrat respons fault paper address schedul criterion set period task faulttoler process specif prove minimum achiev util set period task execut environ suscept occurr singl fault recoveri action recomput partial execut task result guarante task meet deadlin even presenc fault util factor task set processor less class fault toler includ intermitt transient hardwar softwar fault addit perman crash incorrect comput fault also handl provid spare perform recoveri subsequ execut task set paper organ follow section provid background explain problem declar assumpt follow section present proof assert minimum achiev util section address practic implement issu conclus given final section background problem statement assumpt mention introduct rm strong theoret foundat wide use practic due simplic rate monoton schedul polici assign prioriti task increas order period consid set n task task describ tupl execut time task period r releas time ie time first invoc task occur thu ng assum task label manner task expect complet comput prior end period thu j th instanc j task readi execut time r deadlin complet assum deal hard realtim system aim meet deadlin condit oppos soft realtim system deadlin may miss aim reduc delay paper explicitli mention r s assum zero execut task preemptiv ie execut task i higher prioriti task k readi execut comput task interrupt remain suspend task k complet execut task continu state suspend provid task higher prioriti wait execut usual assum time swap task neglig account comput time note definit preemption recurs ie task k interrupt task i interrupt anoth task still higher prioriti rm fix prioriti polici sinc prioriti task remain static chang cours execut task prioriti assign increas order task period task smallest period assign highest prioriti task largest period lowest call arriv time task instant readi execut ie deadlin next arriv task departur time task defin time instant task complet execut thu arriv time j th instanc task r departur time cannot defin easili depend paramet higher prioriti task util factor u task set defin singl processor system task set said fulli util processor schedul algorithm task set feasibl schedul use algorithm increas caus schedul infeas least upper bound util factor minimum util factor possibl task set fulli util processor also call minimum achiev util task set util factor less minimum achiev util guarante feasibl schedul task set n task minimum achiev util n n gamma n minimum achiev util converg ln approxim fault classif discuss fault toler necessari consid issu fault assumpt signific impact design system crash fault model processor either oper correctli or fault occur respond event intern extern incorrect comput fault assumpt consid processor may fail produc correct result respons correct input issu relat fault diagnosi consensu faulttoler process reader refer addit fault also classifi perman intermitt transient perman hard fault erron state continu stabl intermitt fault occur occasion due unstabl natur hardwar transient fault result temporari environment condit perman fault toler provid spare take task primari processor fault occur intermitt transient fault toler repeat comput analysi problem gener schedul problem concern alloc share resourc multipl process need resourc simultan alloc perform attempt achiev certain prespecifi goal tradit comput goal usual minim total time increas respons time request howev realtim system goal simpli alloc resourc manner deadlin associ task met paper deal schedul task execut resourc processor hard realtim system schedul task guarante complet deadlin realtim system use critic applic necessari system surviv spite fault may aris system unlik nonrealtim system occurr fault subsequ recoveri may permit caus delay imper result comput realtim system meet deadlin even presenc fault thu notion guarante feasibl schedul extend cover random event fault occurr challeng endeavor address nevertheless paper consid fault toler strategi set period task execut rm polici guarante task miss even singl deadlin due occurr fault random moment subject fault assumpt explicitli state therein maintain prioriti rm polici one consid introduc fault toler comput host issu need consid addit alreadi exist mean provid fault toler introduc redund system select appropri level time andor space redund driven requir applic redund provid creat replica level comput usual task level realtim system time redund provid reexecut task multipl number time origin execut reexecut perform singl processor differ processor choic depend fault model assumpt realtim system time redund desir choic provid suffici laxiti deadlin enough spare capac task miss deadlin allow maximum util avail resourc howev deadlin stringent littl laxiti avail space redund choic thu ideal design one effect resolv tradeoff two choic minimum cost overhead incur task guarante meet deadlin fault assumpt spacetim tradeoff fundament design respons comput system result present optim tradeoff provid schedul guarante singl fault environ period task singl fault reexecut task recoveri analyz follow scenario ffl set task execut singl processor task schedul rm polici ffl task independ ffl fault may occur instant ffl interv success fault greater largest period task set ffl fault detect next occurr departur task processor exampl lower prioriti task execut occurr fault time later anoth higher prioriti task suppos preempt first task fault detect higher prioriti task expect depart normal execut ffl recoveri action reexecut partial execut task instant fault detect includ current execut task preempt task ffl task requir meet deadlin even reexecut due occurr fault ffl prioriti rm polici maintain even recoveri maintain prioriti task import sinc rm fix prioriti schedul polici prioriti assign system design time approach simplifi design process design worri assign separ prioriti recoveri analyz effect chang prioriti schedul task set one note stage place restrict kind fault toler architectur system long condit satisfi design result paper valid exampl one consid hardwar perman crash fault recoveri subsequ comput would perform a regular execut fault b primari processor fault occur prior time c spare processor figur feasibl schedul presenc fault spare processor hand softwar fault occur recoveri possibl primari processor itself incorrect comput fault handl fault detect perhap consist check task expect depart addit recoveri program task need one normal execut long comput time less equal comput time primari code two exampl shown figur consid task set consist two task period exampl assum crash fault processor figur processor state function time shown regular execut figur a observ schedul feasibl fault occur figur b c show state processor spare respect fault occur prior time instant fault occur task could complet restart spare meet deadlin time figur a show execut profil two task whose period respect howev exampl though schedul feasibl fault occur true fault caus recoveri action taken arriv task time preempt task fault occur prior complet time spare restart execut task start task higher prioriti task task complet time manag meet deadlin time reexecut task start time preempt time arriv next instanc task task miss deadlin time seem obviou exampl certain amount time redund provid recoveri rm schedul criteria u suffici trivial a regular execut fault b primari processor fault occur prior time c spare processor figur infeas schedul presenc fault solut reserv enough space task event fault enough spare capac term time task reexecut still meet deadlin sinc worst possibl time fault occur prior complet task amount extra time devot task recoveri addit c thu rate monoton analysi schedul entir task set comput time task assum c mean that gener case effect minimum achiev util processor ie half howev situat pessimist appear prove follow section minimum achiev util guarante enough time redund complet recoveri deadlin thu long util factor task set processor less equal task set guarante feasibl schedul presenc singl fault motiv one popular tradit approach design faulttoler system use n modularredund nmr techniqu everi processor provid extra spare spare may hot warm cold realtim system hot spare prefer choic time wast perform recoveri spare said hot synchron perform comput primari processor take primari processor fail fault model incorrect comput byzantin fault may distinct primari spare perform comput vote result mask faulti result assum crash failstop model nmr requir processor duplic toler singl fault number processor faulttoler system number processor origin system system call duplex system toler one fault primari spare fault long one fault affect particular primari spare achiev space overhead equal size origin system ie doubl space resourc space overhead duplex system high mani applic usual desir singl spare group processor processor fail spare substitut place wherea provid singl spare simpl feat nonrealtim system ensur recoveri perform within deadlin easi contribut paper make easi guarante recoveri limit util factor processor u total util factor larg set task number processor need system singl spare du e assum crash fault even distribut util factor like significantli less du e duplex system interestingli trivial solut ensur recoveri doubl comput time requir requir du e nearli requir duplex system addit toler hardwar crash fault major applic result toward toler softwar fault deal greater detail section determin minimum achiev util prove minimum achiev util present definit term use proof recoveri defin reexecut partial execut task prioriti rm maintain thu recoveri lower prioriti task higher prioriti task arriv higher prioriti task preempt recoveri lower prioriti task addit fault affect multipl task higher prioriti task perform recoveri action first schedul said feasibl set task task set guarante schedul rate monoton algorithm ie task meet deadlin even recoveri perform due singl fault occur arbitrari instant time set task said fulli util processor task set feasibl schedul increas comput time task set caus schedul becom infeas minimum achiev util minimum util factor everi possibl set task fulli util processor defin critic instant task instant arriv task largest respons time presenc fault schedul set task fulli util processor least one critic instant task respons time period task shall call time interv arriv deadlin task critic period fault occur prior complet task creat maximum delay task lower prioriti task interrupt it henc need examin effect fault instant task complet consid number case lead proof theorem minimum achiev util case task set one task consid task set compris singl task c case releas time matter observ minimum achiev util task set one task proof obviou sinc c cannot exceed c equal valu x occur instant kt a b recoveri task recoveri task recoveri task figur schedul two task period suffici time reexecut task still meet deadlin processor fulli util c import note even task set one task comput time task cannot exceed half valu period ie c n number task set case task set two task begin analysi minimum achiev util case let us consid issu releas time tradit rm analysi worst delay task observ arriv simultan task first arriv task feasibl schedul subsequ arriv also meet deadlin one consid feasibl condit simultan arriv task necessarili true one consid possibl fault exampl consid task set f g releas time zero consid first arriv would appear task set feasibl schedul processor fulli util shown figur a task releas simultan sinc task higher prioriti start execut depart begin fault occur prior complet task time instant restart perform recoveri task arriv time preempt recoveri recoveri complet time next arriv task occur howev fault occur time instant schedul infeas shown figur b task arriv time preempt task arriv time fault occur prior complet task time task reexecut task recov time time instant recoveri task begin howev next arriv task occur time preempt recoveri task caus miss deadlin time unit time avail task recoveri time interv wherea comput time thu correct valu c fulli util processor c henc analysi consid possibl valu releas time consid set two task arbitrari releas time first consid case t next consid variou subcas case a theorem minimum achiev util set two task satisfi condit proof first prove long util factor less equal feasibl schedul guarante task set give particular instanc processor fulli util util factor observ clear c within interv r dt t e arriv task worst possibl scenario task complet preempt arriv task fault occur prior complet task case task need execut again task meet deadlin sinc c task meet deadlin follow condit ie tradit rm analysi feasibl condit dt t faulttoler system task execut worst case scenario occurr singl fault assum util factor task set less equal ie therefor thu feasibl condit given equat guarante equat satisfi thu task set satisfi condit theorem guarante feasibl schedul util factor less equal a b c figur model subsequ arriv task consid case c two case processor fulli util sinc increas c first case c second case caus schedul becom infeas case util factor also prove long util factor less equal task feasibl schedul henc t minimum achiev util case b take follow approach proof proof first show instanc task model arriv first instanc valu releas time r r prove first instanc feasibl schedul possibl valu releas time long util factor less equal ie prove minimum achiev util among task set fulli util processor first instanc also without loss gener assum one r r zero consid figur interest feasibl meet deadlin time instant th instanc task arriv time instant r kt consid variou case r ffl r shown figur a th instanc task model first instanc task task set g possibl fault execut j th instanc task affect schedul th instanc task ffl r shown figur b c th instanc task model first instanc task task set appendix consid possibl case releas time period task case present valu task comput time fulli util processor first instanc task case prove processor fulli util first instanc task util factor greater theorem minimum achiev util set two task satisfi condit t proof shown subsequ instanc two task first instanc model first instanc releas time prove lemma appendix possibl valu releas time processor fulli util first instanc util factor greater equal henc minimum achiev util set two task satisfi condit case task set n task consid set n task whose util prove induct minimum achiev util set n task let us assum minimum achiev util set task prove also true set n task consid set first n gamma task whose util set n ngamma feasibl schedul u becaus thu need consid case u sinc u feasibl schedul assumpt thu need consid feasibl schedul task n case a theorem minimum achiev util set n task satisfi condit assum minimum achiev util set task case set two task follow condit repres worst possibl scenario satisfi correspond task set feasibl schedul note revers true ie task set may satisfi follow condit still feasibl schedul ie assum u n therefor thu condit equat guarante whenev thu sum also nonneg equat satisfi task set guarante feasibl schedul thu set n task minimum achiev util n t case b consid two subcas follow lemma assum set task n fulli util processor note set ngamma fulli util processor sinc u add task n set ngamma increment comput time till processor fulli util valu comput time c n henc task n least one critic period occurr fault subsequ recoveri caus task deadlin two possibl case worst case instant occurr fault prior complet task n case recoveri sole reexecut task n or worst case instant occurr fault prior complet task former case fraction time processor spend execut task critic period task n x dt n t e latter case fraction time processor spend normal execut recoveri task critic period task n here lemma minimum achiev util set n task satisfi condit e assum minimum achiev util set task construct set task follow util factor u set n ie u consid fault prior complet task c interv critic interv set n time complet task thu last task miss deadlin set infeas schedul sinc assum minimum achiev util set task util factor must exceed howev u u n thu minimum achiev util everi set n task satisfi condit lemma prove everi set n task fulli util processor satisfi condit lemma convert anoth set task infeas schedul exampl consid set three task g task set fulli util processor task set construct set g set infeas schedul fault occur time prior complet task time instant enough spare time recov lemma minimum achiev util set n task satisfi condit assum minimum achiev util set task assum set task n fulli util processor sinc set ngamma fulli util processor increment comput time task ngamma ngamma util factor let increas delta let new set util factor u delta easi observ c n delta sinc task lowest prioriti task set reduct comput time delta c free least delta amount time task n interrupt task amount delta reduct delta also free extra delta recoveri thu we prove follow theorem gener case theorem set n task minimum achiev util proof theorem lemma prove minimum achiev util set n task provid minimum achiev util set task addit theorem true one task shown observ also proven true set two task theorem henc induct true n implement issu toler hardwar crash fault consid distribut system common spare spare idl monitor state processor complet instanc task processor send messag spare indic task success complet spare maintain list task system processor execut inform either provid lookup tabl complet time task complet time easili comput onthefli let ccomm maximum commun latenc network task suppos complet time c spare expect confirm time case messag receiv processor declar faulti spare take faulti processor task set initi recoveri rate monoton analysi task set processor commun time overhead reconfigur assum includ comput time task so task comput requir c c use analysi techniqu assum commun delay finit bound unreason assumpt practic applic also requir execut code task access spare discuss section space overhead guarante deadlin presenc singl fault duplex system due processor howev number processor need system singl spare recoveri due u total util factor task set assum task set partit util factor evenli distribut tabl show number processor requir scheme differ valu util factor observ provid common spare significantli reduc size system effect pronounc larg valu util factor tabl number processor system comput time doubl rm analysi duplex system system common spare recoveri differ valu util factor u doubl comput duplex system common spare time rm analysi recoveri l u l u l u toler incorrect comput fault caus hardwar fault tripl modular redund tmr system requir toler incorrect comput fault duplex system detect presenc incorrect comput fault result two processor agre third processor requir major result assum correct similar techniqu describ use toler singl incorrect comput fault rather tmr system duplex system spare use case duplex pair detect error spare use perform recoveri number processor requir tmr system due wherea number processor requir duplex spare recoveri due again u total util factor entir task set number processor requir scheme shown tabl notic duplex spare requir less space overhead compar tmr system howev benefit larg observ crash fault toler softwar fault intermitt transient hardwar fault believ greatest applic result paper would toward toler softwar fault intermitt transient hardwar fault space hostil industri applic outsid environ condit alpha particl electrostat interfer etc caus transient error addit softwar fault stack overflow oper system etc best handl reexecut limit util factor processor guarante recoveri perform within deadlin even though consid reexecut partial execut task necessari fault affect singl task task reexecut meet deadlin confid reexecut caus task miss deadlin addit recoveri code need tabl number processor tmr system duplex system common spare recoveri differ valu util factor u tmr duplex system system common spare l u l u primari code especi true softwar fault altern program desir long time execut recoveri program less equal execut time primari program certain deadlin met toler multipl fault multipl fault toler analysi long interv success fault larger largest period task set assumpt unlimit transient fault toler k perman crash fault toler provid k spare limit util factor processor certain task set k nmr system yield lesser space overhead greater fault coverag would easier implement case u util factor entir task set assum task set partit util factor evenli distribut exampl total util use two processor wherea approach would requir three processor gener case provid k common spare would result lesser overhead conclus provid theoret foundat faulttoler process period realtim task schedul rate monoton schedul polici scenario recoveri fault involv restart partial execut task maintain prioriti level rm pol ici show minimum achiev util processor result guarante task meet deadlin even presenc fault util factor processor restrict bound much better maximum util factor would obtain comput time task naiv doubl rm analysi provid recoveri time result provid framework toler transient intermitt hardwar softwar fault reexecut prefer recoveri techniqu addit result applic toler perman crash incorrect comput fault spare must employ replac faulti processor system show space redund achiev maintain common pool spare is case less nmr system contribut paper form import compon evolut respons system concept provid guarante meet deadlin system spite occurr fault integr design faulttoler realtim system critic applic provid simpl criterion ensur feasibl meet deadlin presenc singl fault consider reduc complex encount design lead safer depend use realtim system critic applic r schedul algorithm multiprogram hard realtim environ the rate monoton schedul algorithm exact character averag case behavior on realtim schedul problem schedul period occur task multipl proce sor a note preemptiv schedul period realtim task respons system challeng nineti a faulttoler schedul problem on schedul task quick recoveri failur the diffus model base task remap distribut realtim system the consensu problem faulttoler com pute theori practic reliabl system design tr ctr rodrigo m santo jorg santo javier d orozco least upper bound fault toler realtim system journal system softwar v n p octob sylvain lauzac rami melhem daniel moss improv ratemonoton admiss control applic ieee transact comput v n p march sasikumar punnekkat alan burn robert davi analysi checkpoint realtim system realtim system v n p jan frank liberato rami melhem daniel moss toler multipl transient fault aperiod task hard realtim system ieee transact comput v n p septemb tarek f abdelzah vivek sharma chenyang lu util bound aperiod task prioriti driven schedul ieee transact comput v n p march