t theori applic invert function fold a paper devot proof applic generalis theorem due bird de moor gave condit total function express relat fold theorem illustr three problem deal construct tree variou properti generalis give condit invers partial function express relat hylomorph proof make use doornbo backhous theori wellfounded reduct possibl applic generalis theorem discuss b introduct purpos paper describ one techniqu invert function bother invers function reader might ask reason mani problem comput specifi term comput invers easili construct function inde compress best specifi invers decompress pars invers print on applic invers sometim aris unexpect situat illustr thi discuss three problem solv instanc sinlg techniqu first problem breadthfirst label breadthfirst label tree respect given list augment node tree valu list breadthfirst order figur show result breadthfirst label tree node infinit list everybodi know breadthfirst travers close relat problem ecient breadthfirst label wide understood would one specifi problem invers us call type binari tree tree assum preprint submit elsevi scienc may a f l fig breadthfirst label tree left hand function bft tree list a breadthfirst travers ziptre tree tree b tree zip togeth two tree shape perform breadthfirst label given tree list x want zip anoth tree u what then tree u satisfi firstli must right shape condit enforc ziptre secondli breadthfirst travers must prefix given list x thu come follow specif bft look flow inform specif function bft appear lefthand side mean wish data go backward them let us denot invers function f f pronounc the convers f briefli f wok formal definit f delay section now let us say f nondeterminist yield x f rewrit specif pipelin right left result follow equival pointfre specif fst cat nondeterminist split input list two therefor fst cat take arbitrari prefix input list invers bft give us tree whose breadthfirst travers match prefix tree zip input exampl invers aris unexpectedli specif concis is one deriv algorithm it answer among two exampl present paper second problem given list tree task combin singl tree retain lefttoright order subtre make height result tree small possibl figur illustr one tree height given subtre height fig tree height built tree height actual content subtre import think simpli number repres height third problem classic one wellknown given preorder inord travers intern label binari tree tree reconstruct uniqu contain duplic element challeng deriv linear time algorithm thi three problem involv build or rebuild tree kind specifi term convers oper flatten tree list valu function programm awar flatten structur usual perform fold oper consequ build structur usual perform convers oper unfold howev reason convers oper necessarili involv unfold converseofafunct theorem paper devot give us condit invers function written fold follow section show theorem appli deriv solut problem function programm make use hand law theorem transform specif optimis code converseofafunct theorem anoth use tool worth ad function programm arsen joint use fold fusion theorem turn recur pattern program deriv final present prove generalis theorem allow one write invers partial function hylomorph theori convers function relat framework necess calculu relat program section present enough notat describ main idea concept introduc section relat settheoret speak relat r b set pair a b type b type b convers relat defin flip pair is b a r a b r composit r c defin c a r convers contravari respect composit r type a relat id defin id omit subscript clear context relat r b call simpl r r id is everi valu map one valu b word r partial function relat r call entir id r r is everi valu map least one valu b relat total function simpl entir paper write type function b partial function b relat b relat call coreflex subset id use coreflex model predic oper convert booleanvalu function coreflex a a p p conveni let a a p p yield fals domain p perform two consecut test one stronger other stronger one absorb weaker one p q a p given relat r b coreflex dom r determin domain r defin a a dom r b altern dom set intersect follow dom r r r coreflex ran r determin rang relat defin ran write pointwis style relat introduc choic oper express x nondeterminist yield either x exampl follow relat prefix map list one prefix prefix list list step list list step step fold choos either con current item prefix sublist return empti sequenc prefix everi list rigor semant reader refer fold datatyp come fold function list haskel prelud function list b well known slight variat nonempti list defin tipvalu binari tree follow datatyp data tree fold function defin as fold instanc gener definit regular datatyp defin fixedpoint base functor f say isomorph datatyp often parameteris case f type fa ta ta exampl conslist arbitrari fixedpoint fa denot type write fa x instead fa x think f bifunctor exampl base functor nonempti list tree fa x given base functor f datatyp function f type fa b catamorph f f uniqu function satisfi f dierent fold special case f f instanti dierent base func tor except haskel usual divid f sever function constant correspond oper particular operand coproduct base functor functor relat take function function monoton relat inclus call relat switch functor relat theori extend relat well catamorph r f r relat type fa b b type fuller account relat theori relat catamorph reader refer converseofafunct theorem converseofafunct theorem introduc tell us write invers function fold read theorem convers function f base functor t r fa b b surject f r f ff specialis theorem function list read follow jointli surject mean base base aa ran step satisfi f step x similarli invert total function f nonempti list theorem state base b step b b jointli surject that is ran base aa ran step f base a a postpon proof theorem section fact gener result prove now let us see applic rebuild tree travers well known that given inord preorder travers binari tree whose label distinct one reconstruct tree uniqu problem record section exercis exercis knuth briefli describ done comment would interest exercis write program task inde becom classic problem tackl studi program invers deriv linear time algorithm van de snepscheut note one class solut attempt invert iter algorithm class deliv recurs algorithm section see theorem help deriv function program solv problem inter estingli although start recurs specif theorem deliv algorithm fall first categori defin follow datatyp intern label binari tree fold function foldtre data tree inord preorder travers tree defin term foldtre inf x pre pre x assum predic distinct yield true tree whose valu node distinct aim construct distinctfork preorder inord fork f g fig ad new node tree tri appli theorem construct convers function relat fold howev due type fork preorder inord appar cannot fold recurs datatyp instead defin rebuild rebuild relat inord construct tree whose inord travers meet given list coreflex x preorder pick one whose preorder travers list x appar fork preorder rebuild furthermor predic distinct enforc constrain x must contain duplic element aim thu deriv rebuild x deriv proce two part invert inord fold list fuse x preorder result fold build tree fold accord theorem order invert inord need tree zero relat add tree tree jointli surject satisfi inord inord add x look second equat say tree x whose inord travers as relat add must abl creat new tree x order travers as one way illustr figur divid left spine x two part move lower part one level attach end facilit oper introduc altern spine represent tree repres list valu subtre along left spine type spine list exampl tree left figur repres list b function roll convert spine back singl tree fact isomorph spine tree a roll spine tree join u a advantag represent trace spine upward leftmost leaf rather downward root see end next section necessari ecient algorithm function inord roll flatten spine tree task invert fold need spine tree zero spine relat add spine spine satisfi inord roll inord roll add easi choic zero would add claim follow definit satisfi add spine spine add us a roll vs ws vs ws us nondeterminist pattern definit add divid list us two part indic add relat exampl tree right figur result cut spine middl yield a roll b show add satisfi need follow fact whose proof left dilig reader inord proof goe sinc concat map distribut concat map con id inord ws definit concat map concat map con id inord a roll vs ws inord roll a roll vs ws also dicult see add jointli surject nonnul tree result add therefor conclud inord roll enforc preorder invert inord roll start deriv rebuild x roll isomorph convers contravari invert inord roll last section let haspreord except introduct roll deriv far mostli mechan roll haspreord x partial function easili implement haskel howev add still relat fuse haspreord x fold therebi refin add partial function whole express implement unfortun haspreord x rather strong condit enforc possibl maintain invari within fold applic add obvious ad new element tree new tree certainli dierent preorder travers invent someth weaker fuse fold defin preorderf preorder travers forest preorder look figur again preorder travers tree lefthand side e c b preorderf t u v w is go along left spine travers subtre upward gener given spine tree us preorder travers revers map fst uspreorderf map snd us call part prefix sux travers look tree righthand side preorder travers e a c b preorderf t u v w dicult see add node spine tree us sux preorder travers chang new node alway insert prefix insight split haspreord two part haspreord list spine bool haspreord x us prefixok x us suxok x us suxok x us preorderf map snd us issuxof x prefixok x us revers map fst us remov tail x defin by express x issuxof yield true x sux use boldfac font indic infix oper and bind looser function applic plan fuse suxok x fold leav prefixok x outsid slight problem howev invari suxok x prevent fold gener say leftist tree null along spine sinc empti list inde sux list tree may bound reject later look righthand side figur assum know preorder travers tree want preorderf t u v w tree figur although satisfi suxok x bound wrong next immedi symbol stand way c way chang order afterward thu find proper locat insert new node shall aggress consum much sux x possibl follow predic lookahead x ensur construct tree next immedi symbol x consum lookahead list spine bool lookahead x us length us map fst us last x appar lookahead x compat haspreord x use suxok x lookahead x invari defin ok x us suxok x us lookhead x us deriv continu rebuild x as begin section sinc haspreord x us prefixok x us ok x us fold fusion assum nodup x roll prefixok x foldr add x fold fusion theorem use last step wellknown see exampl chapter justifi fusion step shown x contain duplic element follow fusion condit hold ok x add add defin by tree spine list v v b us word function trace left spine upward consum valu spine match tail x tri roll much possibl ad end spine readi final optimis avoid comput x preorderf map snd us scratch time appli tupl transform see exampl chapter fold return pair haskel implement shown figur fold rebuild return pair first compon tree second compon list repres x preorderf map snd us sinc list consum end repres revers function rollpf implement roll prefixok x data tree null node tree a tree a deriv showeq rebuild eq a a tree rebuild add v v buu bx b rollpf eq atre aa tree b fig rebuild tree travers via fold b c e f b c e f b e f b e f b e f b c e f fig build tree preorder preorder travers tree spine print boldfac font figur show exampl algorithm action part boldfac font indic preorderf map snd us notic preorder travers tree spine alway form sux given list a b c e f actual reinvent algorithm propos function style first step transform recurs definit fork preorder inord iter introduc stack eect achiev introduc spine represent build tree given preorder hold on reader might complain deriv work becaus luck choos correct order start preorder now would invert preorder enforc result fold constraint tree built must given inord travers still work fact doe result new complic algorithm therefor go sketch outlin develop first seek invert preorder problem turn make sens work forest rather tree abbrevi list tree a forest a recal preorderf forest list defin preorderf concat map preorder reader easili verifi preorderf invert below preorderf step a us us us node helper function tip lbr rbr respect creat tip tree tree left branch tree right branch defin by lbr a rbr a word step extend forest one four possibl way applica ble ad new tip tree extend leftmost tree forest make leftsubtre rightsubtre combin two leftmost tree next step find rule decid four oper perform ad new valu forest need invent invari enforc bodi fold begin with reason preorder some trivial manipul b c e f b c e f b c e f b c e f b c e f b c e f fig build tree preorder inord travers construct subtre print boldfac font skip subsequ subtre underlin optimis code figur pair subtre thu type aforest again condit inord strong maintain luckili turn weaker constraint do issubseqof x subsequ x is requir construct forest inord travers tree shall alway form segment x correct order figur demonstr process construct tree figur time notic inord travers construct forest alway form subsequ given list b c a e f pencilandpap work dicult work rule extend forest maintain invari howev rule consist total eight case rel complic compar simpler algorithm section owe fact four possibl oper choos from section two either go upward one node along spine stop attach new node reason present result program implement algorithm present figur tree forest annot extra inform avoid recomput repres type aforest optimis program run linear time bigger constant overhead section rbr lbr type aforest tree a a rebuild eq a a tree rebuild fst unwrap snd foldr add revers x add eq aaforest a aaforest a add xux newtre xu add xux tu isnext x tail x rbr t us newtre xu add xuxtbbsu isnext x tail x rbr t bbsu newtre xu join t join t us join tb us lbr t bsu newtre isnext fals isnext bb b locat x locat locat bx locat by x fig anoth way rebuild tree travers via fold build tree minimum height next consid second problem build tree minimum height lineartim algorithm problem propos demonstr similar algorithm deriv start give formal specif problem defin tipvalu binari tree follow datatyp data tree function flatten take tree return tip lefttoright order written fold flatten tree list wrap item singleton list foldtre fold function tree defin section given tipvalu binari tree whose tip valu repres height tree function comput height combin tree also defin fold obviou way height tree int int ht return larger two argument problem thu find among tree flatten given list one height yield minim valu specif need consid possibl result need power transpos oper also call breadth function power transpos oper convert relat r b function a set ra contain valu b map extract valu set need relat min set a defin definit use connect preorder mean order reflex transit compar everyth correct type relat min gener function preorder necessarili antisymmetr problem defin comparison height two tree problem specifi as fig ad new node tipvalu binari tree similar last problem deriv also proce two step invert flatten relat fold fuse someth fold elimin nondetermin function flatten invert way similar section also help switch spine represent defin follow type spine tree repres list subtre along spine togeth leftmost leaf convers spine tree ordinari represent perform by roll spine tree sinc rang flatten set nonempti list seek invert foldrn fold nonempti list theorem say flatten roll foldrn add one relat add one satisfi flatten roll one flatten roll add b figur illustr idea claim follow definit satisfi requir one add b ys proof similar section left reader exercis invert flatten get furthermor roll factor xs ys roll xs roll ys ie counterpart defin spine tree sinc relat add choic given spine tree length n specif gener exponenti number tree elimin nondetermin add therebi improv ecienc make use follow greedi theorem present special case gener version prove theorem the greedi theorem for nonempti list let base two relat step monoton connect preorder is inform monoton condit mean wors partial solut stage fold alway give wors result condit hold stage fold need retain one best result comput far thu min get promot foldrn add satisfi monoton condit respect could appli greedi theorem howev true tree smallest height alway remain smallest extend add fortun add monoton stronger order defin height a word height return list height along left spine start root relat add monoton defin by lexicograph order sequenc choic make sens ensur monoton need optimis whole tree also subtre left spine proof add monoton howev quit involv present here reader refer detail discuss type bmh int tree int int one minadd int spinei spinei minadd minsplit x minsplit x yx height height x height bin xa y ht b ht roll spinei tree int int roll fig code build tree minimum height appli greedi theorem get sinc one function min one one analysi optimis min add let b x x x n spine tree insert valu a shown order construct best tree order need actual check n possibl alway break list x x i smallest index height x i height roll b x x x height x i also omit detail refer interest reader code shown figur first problem annot tree height avoid recomput algorithm also linear number node tree breadthfirst label breadthfirst label tree respect given list label node tree breadthfirst order use valu list jone gibbon propos neat solut problem base clever use cyclic data structur problem recent revisit okasaki go show okasaki algorithm deriv use convers ofafunct theorem let us go specif finer detail recal data structur intern extern label binari tree data tree queuebas algorithm breadthfirst travers wellknown list typeforest list tree bftf forest list bftf bin x perform label use follow partial function ziptre ziptre tree tree b tree ziptre tip a tip ziptre bin x y bin b u breadthfirst label tree x seen zip x anoth tree breadthfirst travers prefix given list as bfl equival bfl prefix x complet specif relat prefix nondeterminist map list one finit prefix prefix pass bft yet nondeterminist map tree whose breadthfirst travers equal chosen prefix import ziptre partial function yield valu given two tree exactli shape therefor tree compos bft prefix zip input tree correct size shape partial function ziptre play role filter sinc breadthfirst travers algorithm natur defin term queue tree or forest rather singl tree reason tri invert bftf rather bft problem rephras term bfl zipforest bftf prefix x zipforest forest forest b forest ab simpl extens ziptre forest which like ziptre partial function zipforest zipforest zipforest xs ys decis focu bftf made rest mechan invert bftf find base step bftf step valu base deriv step dicult either start gener case assum structur xs definit bftf bftf tip xs therefor step xs might contain tip xs one possibl valu choic alon make step jointli surject sinc cannot gener forest nontip tree head therefor consid case xs contain two tree definit bftf bftf bin x xs therefor defin step be step forest forest step sinc forest either begin tip tree begin nontip tree empti step jointli surject convers bftf thu construct know bftf list forest fold fuse zipforest bftf fold zipforest bftf revzip f tip b ts revzip f bin b ys x express zipforest bftf type list forest b forest ab consid zipforest bftf x x list label constructor build x replac revzip stop yield relat map unlabel forest label forest pattern match error invok stop x short revzip x long appli fold fusion fuse zipforest bftf prefix eect add anoth case revzip is revzip f cut list label forest consum earlier list still list label cannot short result code shown figur made linear use implement dequ support constanttim addit delet input output revzip clariti leav is noth adapt okasaki algorithm list paper okasaki rais question peopl come algorithm instead appeal complic approach answer know converseofafunct theorem generalis converseofafunct theorem aim section prove follow generalis theorem hylomorph theorem generalis converseofafunct theorem let b simpl relat exist relat r fc b b simpl relat fc i dom data tree tip bin tree a tree a deriv show stop revzip f revzip f tip ts revzip f bin b u v last init ys last ys fig code breadthfirst label word theorem give condit convers simpl relat express hylomorph relationship theorem well notion need establish connect given section new ingredi theorem fwellfounded notion wellfounded admit induct great import comput scienc doornbo gave care analysi relationship two notion propos sever dierent generalis them notion fwellfounded defin page relat r fwellfound if relat equat uniqu solut x give proof theorem take convers side aim prove given condit know hylomorph t f r f characteris least solut x equat assumpt iii r fwellfound know t f r f fact uniqu solut show also solut proof goe assumpt i sinc ran r r r by assumpt assumpt i sinc dom s by assumpt sinc fs simpl theorem thu prove wellfounded reduct proof theorem make use fwellfounded guarante uniqu solut practic propos howev stronger properti need reason fwellfounded alon guarante termin view hyloequ lefttoright rewrit rule evalu nondetermin demon counterexampl take consid relat f id f a a recurs program termin strict second compon input pair yet f id fwellfound shown section howev termin guarante freduct relat notion freduct introduc section one way generalis notion admit induct arbitrari datatyp said f reduct coreflex c id monotyp factor oper defin galoi connect r d c due page intuit behind monotyp factor reader refer relat r coreflex c properti translat pointlevel aid understand word r freduct use induct proof follow way may conclud properti c univers true show satisfi c given rpredecessor fstructur contain element satisfi c sever properti concern freduct handi purpos follow fact respect theorem theorem theorem fact freduct impli fwellfounded fact freduct fs simpl fact f freduct sinc freduct guarante termin and accord fact stronger fwellfounded fwellfounded requir theorem alway strengthen freduct practic question construct freduct relat discuss depth yet talk relationship theorem theorem begin with note follow lemma lemma theorem follow special instanc theorem take entir relat well simpl one is function entir relat one dom translat requir r surject relat condit iii r freduct is accord lemma fact howev fact say f inde freduct sinc f obtain conclus theorem proof lemma simpli extract proof theorem complet given below r sinc dom r hand written concis r stand least fixedpoint oper sinc dom s sinc r fs applic generalis theorem theorem potenti power sinc allow functor f determin pattern recurs independ input output type much wider class algorithm thu cover one applic found theorem prove loop implement invers function loop specifi relat relat initialis loop r serv loop bodi domain repres termin condit therefor ought disjoint domain r given relat r reflex transit closur r smallest reflex transit relat contain r gener defin least fixedpoint key observ closur also written hylomorph base functor definit closur unfold phase wrap input valu inl wrap indefinit number inr s fold phase replac inl inr r exact number iter perform determin termin test given function f let us instanti theorem discov condit f sinc dom instanti ran s is r shall jointli surject condit ii divid two part shunt function side get look familiar enough think f invari first half say initi valu satisfi invari second half say given input satisfi invari loop bodi r maintain invari condit iii requir s r fwellfound intuit speak want r decreas loop variabl sens assum wish prove r correctli implement specif x shown next two section occas x quit natur factor f f need check three condit abov string edit problem string edit problem chapter typic exampl dynam program recent drawn much attent due applic dna sequenc match simplest form given two string one sourc one target avail command imagin cursor posit left sourc string assum follow command in c insert charact c current posit del c delet charact c current posit cpi c skip current charact c move cursor one posit right task find shortest sequenc command transform sourc string target string complic variat might given command weight may vari repres three command datatyp op data in char del char cpi char specifi problem one might attempt construct relat take pair string return arbitrari sequenc command relat string fact easier construct invers function exec execut sequenc command start pair empti string yield two string step exec function start two empti string tri reconstruct origin sourc target string in oper extra charact ad target string del oper treat statement sourc string extra charact cpi command view say two string common charact current posit convers exec hand take two string yield sequenc command reduc pair empti string thu show command transform one string anoth string edit problem thu defin by section bird de moor deriv specif dynam program algorithm use dynam program theorem convers fold yet other prefer describ exec iter process is claim exec start move in last init x del last x init x init cpi last x last x last y loop start two string empti list command nondeterminist loop bodi move tri recov last command might tri possibl command iter repeat string becom empti notic move defin partial relat yield valu x empti view taken curti specif written term min r loop theori readi transform dynam program algorithm certain condit satisfi go problem solv use develop the ori instead bridg gap two view exec word know claim exec discuss open section mind generalis exec execwith function execwith type stringstringlist op stringstr defin by execwith replac constant definit exec given argument y task show execwith one may also think invent propos execwith loop invari check whether invari work invari say that denot input pair string x y intermedi valu point comput move start execut command op check condit one one condit i hold start move jointli surject condit ii requir execwith start id execwith move execwith first one trivial hold second inclus hold move undo last step execut thu domain lefthand side restrict tripl one two string empti execut still yield result condit iii move wellfound alway reduc length first two compon tripl therefor conclud execwith start build tree combin pair recal follow datatyp leafvalu binari tree data tree ye introduc yet anoth approach build tree list major paper focus invert flatten fold yet anoth altern way build tree list start list tip keep combin adjac tree one left process characteris join aim is cours show flatten propos invari loop iter forest alway flatten given list check flattenf inde map tip join jointli surject former cover list tip tree latter cover rest need verifi that concat map flatten map tip id concat map flatten join concat map flatten first inclus obvious hold second hold join restrict domain lefthand side list least two tree aect result return final join wellfound reduc length forest follow flattenf consequ flatten one might relat small exercis merg sort two way implement merg sort one implement hylomorph unfold phase expand tree fold phase perform merg node implement loop start map wrap convert input list singleton list iter merg adjac list one list left first said topdown second bottomup similar reason convert former latter howev addit distribut properti list merg need proof similar problem treat topdown algorithm also transform bottomup one conclus relat work idea program invers trace back dijkstra howev given import invers specif techniqu rel paper devot topic have deal program invers context imper program refin calculu program invert run backward challeng part encount branch loop classic exampl construct binari tree given inord preorder travers invers function program receiv even less attent publish result eg base composit approach essenti imper counterpart h defin f g invers f g recurs construct reach primit whose invers predefin rather controlori view complement dataori view paper generalis function arrow consid polytyp oper datatyp ensur oper invers carri thing revers order such map left map right alway construct pair eort also made autom process paper also contain detail bibliographi converseofafunct theorem howev take noncomposit approach invert function invert function matter defin properti satisfi appli convers ofafunct theorem three exampl invert function usual nondeterminist fold make use often compos function act filter fold fusion theorem appli fuse filter fold remov nondetermin refin specif implement function pattern deriv turn use solv mani problem techniqu new similar techniqu adopt in exam ple howev best knowledg de moor first present techniqu theorem suggest wider rang applic problem dealt preced pars lead deriv floyd algorithm therefor coincid algorithm develop section resembl pars author believ possibl although tiresom task deriv shiftreduc pars algorithm generalis reason section also point problem build tree minimum height seen special case knuth generalis shortest path problem problem address wa given contextfre grammar cost function pars tree construct word pars tree whose cost minimum given list number construct ambigu grammar whose word list possibl pars tree includ binari tree cost pars tree would simpli height knuth algorithm thu appli find best pars yield minimum height would interest investig whether linear time algorithm section optimis special case relat other one natur question wide theorem appli word determin whether converseofafunct theorem appli particular function part answer given convers function written fold function must unfold necessari sucient condit function unfold given thu use test appli converseofa function theorem one possibl reason invert imper program often talk could theori nondetermin context refin calculu establish instanc dijkstra guard command languag extend includ angel choic well demon choic shown invers demon program angel correspond theori relat still develop interest see would benefit research invers relat fulli exploit gener theorem potenti use sinc allow functor f determin pattern recurs independ input output type much wider class algorithm thu cover appli theorem simpl case fa x verifi loopbas algorithm author enthusiast see exampl gener theorem necessari acknowledg thank due member algebra program group oxford univers comput laboratori oeg de moor interest encourag comment throughout develop paper roland backhous kindli point relat henk doorn boss work advantag base theorem freduct author would also like thank anonym refere detail use advic r univers resolv algorithm invers comput function languag statement invers strongest postcondit relat catamorph element relat theori datatyp build tree minimum height algebra program algebra method optim problem program invers fun introduct algorithm relat approach optim problem program invers reduct argument program construct reduct scienc comput program function fold unfold scienc program inord travers binari tree invers synthesi function invers construct tournament represent exercis pointwis relat program construct list homomorph via tupl fusion compact print pars data convers program relat program gener dijkstra algorithm art comput program volum invers applic program relat program simpl e binari multirel run program backward logic invers imper comput inord travers binari heap invers optim time space invers recurs tree travers program invers refin calculu tr inord travers binari tree invers program invers refin calculu program invers synthesi function invers statement invers strongest postcondit realtim dequ multihead ture machin pure function program reduct algebra program synthesi function transform constraint poster art comput program volum rd ed breadthfirst number scienc program introduct algorithm data convers program compact print pars construct list homomorph tupl fusion invit talk element relat theori datatyp inord travers binari heap invers optim time space induct recurs datatyp univers resolv algorithm construct tournament represent algebra method optim problem invers recurs tree travers function pearl ctr kiminori matsuzaki hideya iwasaki kento emoto zhenjiang hu librari construct skeleton sequenti style parallel program proceed st intern confer scalabl inform system pe may june hong kong