t random fulli dynam graph algorithm polylogarithm time per oper a paper solv longstand open problem fulli dynam algorithm present first fulli dynam algorithm maintain connect bipartit approxim minimum span tree polylogarithm time per edg insert delet algorithm design use new dynam techniqu combin novel graph decomposit random lasvega type random algorithm use simpl data structur small constant factorlet n denot number node graph sequenc ohgrm oper number edg initi graph expect time p updat op log n througout paper logarithm base connect bipartit worstcas time one queri olog nlog log n kedg wit problem doe remov k given edg disconnect graph expect time p updat op log n expect time q queri oqk log n given graph k differ weight minimum span tree maintain sequenc p updat expect time opk log n impli algorithm maintain egrapproxim minimum span tree expect time op log n loguegr p updat weight edg u b introduct mani area comput scienc graph algorithm play import role problem model graph solv comput properti graph underli problem instanc chang increment algorithm need quickli comput properti modifi graph algorithm make use previou solut and thu solv problem faster recomput scratch call fulli dynam graph algorithm precis fulli dynam graph algorithm data structur support follow three oper insert edg e delet edg e test graph fulfil certain properti e g two given vertic connect depart comput scienc cornel univers ithaca ny email mhrcscornelledu author maiden name monika h rauch research support nsf career award depart comput scienc univers victoria victoria bc email valcsruvicca research support nserc grant throughout paper logarithm base previou work recent year lot work done fulli dynam algorithm see connectivityrel work undirect graph also larg bodi work restrict class graph insertionsonli algorithm current best time bound fulli dynam algorithm undirect nnode graph are o n per updat minimum span forest o n per updat o per queri connect o log n per updat olog n per queri cycleequival doe remov given edg disconnect graph o n per updat o per queri bipartit is graph bipartit lower bound cell probe model ofomegagamma n log log n amort time per oper problem appli random algorithm shown averag updat time a variant of connect bipartit algorithm on m log n edg use updat chosen uniformli given edg set thu dens graph averag perform nearli match lower bound planar graph fulli dynam algorithm minimum span forest connect given close lower bound take time olog n per delet olog n per insert queri howev constant factor algorithm quit larg thu follow question pose open question properti maintain dynam polylogarithm time gener constant factor fulli dynam algorithm small effici implement possibl new result paper give posit answer question present new techniqu design fulli dynam algorithm polylogarithm time per oper appli techniqu fulli dynam connect bipartit fflapproxim minimum span tree cycleequival problem result algorithm lasvega type random algorithm use simpl data structur small constant factor sequenc omegagamma number edg initi graph follow amort expect updat time worstcas queri time achiev connect updat time olog n queri time olog n log log n bipartit updat time olog n queri time o minimum span tree graph k differ weight updat time ok log n immedi consequ result achiev faster fulli dynam algorithm follow problem algorithm maintain fflapproxim minimum span tree expect time op log n log uffl p updat weight edg u algorithm kedg wit problem doe remov given k edg disconnect graph updat time olog n amort expect queri time ok log n note cycleequival equival edg wit problem fulli dynam algorithm maintain maxim span forest decomposit order k graph time ok log n per updat keep k fulli dynam connect data structur maxim span forest decomposit order k decomposit graph k edgedisjoint span forest f f maxim span forest g maxim span forest decomposit interest sinc f graph okn edg kedg connect compon g addit use data structur present simpl determinist algorithm maintain minimum span tree connect fulli dynam amort time per updat minimum span tree algorithm o log n improv o log n use sparsif techniqu amort time per updat connect algorithm o log n even though algorithm improv run time best known algorithm interest sinc present complet differ approach previou algorithm use simpl data structur addit connect algorithm first fulli dynam algorithm use sparsif techniqu achiev run time less m main idea new techniqu combin novel decomposit graph random edg graph partit olog n level edg highlyconnect part graph where cut dens lower level loos connect part where cut spars level i span forest maintain graph whose edg level below tree edg delet level i sampl edg level high probabl either find edg reconnect two subtre cut defin delet edg spars level i case found replac edg fast case copi edg cut level recurs level knowledg previou use random fulli dynam algorithm montecarlo type approxim algorithm minimum cut paper structur follow section give fulli dynam connect algorithm section present result kweight minimum span tree fflapproxim minimum span tree bipartit section contain determinist algorithm random connect algorithm deletionsonli connect algorithm definit notat let e jv m use convent element v refer vertic let l edg g partit l level l i keep forest f tree edg f span forest v l span tree g edg e n f refer nontre edg span tree level tree f nontre edg incid vertic store data structur describ detail below weight denot wt number nontre edg incid span tree edg whose endpoint lie span tree count twice size denot st number vertic tree smaller anoth tree size greater other say level level algorithm initi edg e comput f span tree g edg e delet remov e graph contain it e tree edg let level e e call replace i let level tree contain edg e let two subtre result delet e st ffl sampl sampl c log nontre edg e incid vertic appropri constant c edg endpoint pick probabl wt edg one endpoint pick probabl wt case replac edg found one sampl edg connect add f j j i ffl case sampl unsuccess none sampl edg connect search edg incid determin g choos one element add f j j i remov element e insert add one newli insert edg f j j i l proof correct first show edg contain il e ie replace l call case occur edg insert e l use fact argu replac edg exist found number edg ever e lemma smaller tree level i proof proof follow tree split two tree endpoint edg contain smaller tree size tree contain endpoint halv thu cours algorithm endpoint edg inci dent smaller tree log n time given level and tree level i lemma i mc igamma proof show lemma induct clearli hold assum hold sum smaller tree p log n edg ad e corollari p total number edg ever level impli total number edg e greater mc choos c observ edg never move higher level level less log n edg give follow corollari corollari contain e l follow relationship use run time analysi also evid corollari p theorem f span forest v proof initi true sinc comput f span tree consid first time fail tree edg e delet replac edg exist found corollari replac edg lie let minimum level replac edg exist let e e k claim k assum not let fr sg replac edg level i sinc r connect path r f sinc e f k e path henc sg replac edg e thu k delete i call either replac edg found sampl everi edg incid examin claim everi replac edg fr sg incid suppos not assumpt path r ji f j path includ e either r includ e fr sg form cycl f gamma e contradict assumpt fr sg replac edg euler tour data structur subsect present data structur use implement algorithm previou section effici encod arbitrari tree n vertic use sequenc symbol gener follow root tree arbitrari vertex call et root et defin follow visit x child c x visit x edg visit twice everi degre vertex time except root visit time time vertex u encount call occurr vertex denot u new encod tree result split join previous encod tree easili gener let et t sequenc repres arbitrari tree procedur modifi encod delet edg fa bg let two tree result encount two travers fa bg thu et t given interv et t splice et t sequenc chang root r s let occurr s splice first part sequenc end occurr remov first occurr o r tack end sequenc begin add new occurr end join two root tree edg e let given occurr creat new occurr splice sequenc et t immedi sequenc et t store balanc search tree degre b height olog n log b one may insert interv splice interv time ob log n log b maintain balanc tree determin two element tree one element preced order time olog nb asid list array data structur use connect algorithm tree repres sequenc store balanc bari search tree next describ data structur data structur two option store nontre edg first simpler explain here second shave factor log log n updat time reduc cost sampl describ last subsect section span tree level l occurr et t store node balanc binari search tree call etttre tree last level l et t store balanc log nari search tree note nontre edg level vertex arbitrarili choos one occurr activ occurr u activ occurr vertex v keep unord list nontre edg level incid v store array node ettre contain number nontre edg number activ occurr store subtre thu root et t contain weight size addit store g f use adjac list keep array list ffl vertex level pointer vertex activ occurr level ffl tree edg level k e f k pointer four or three endpoint leaf occurr associ travers f k ffl nontre edg pointer locat two list nontre edg contain edg revers pointer ffl level i list contain pointer root etttre span tree level i root pointer back list ffl level i list tree edg e edg pointer back posit list implement use data structur describ abov follow oper execut span tree level let span tree level i ffl treex i return pointer et t span tree level contain vertex x ffl nontre edgest return list nontre edg store et t edg return twice randomli select nontre edg e least one endpoint edg endpoint pick probabl wt edg exactli one endpoint pick probabl wt test exactli one endpoint so return edg ffl insert treee i join e two tree level i contain endpoint e ffl delet treee i remov e tree level contain it ffl insert nontree i insert nontre edg e e ffl delet nontree delet nontre edg e follow run time achiev use binari search tree tree sampletest insert non tree delet non tree delet tree insert tree olog n nontre edgest om log n number move edg last level l log nari tree use run time delet tree insert tree increas olog n log log n run time tree reduc olog n log log n describ implement detail oper treexi follow pointer activ occurr x level i travers path et t tree activ occurr root return pointer root nontre edgest travers node et t output everi nonempti list nontre edg encount node let level tree pick random number j wt find j th nontre edg fu vg store et t treeu l treev l return edg insert treeei determin activ occurr endpoint e level follow procedur join two root tree abov updat pointer root new tree list tree edg level i delet treeei let vg determin four occurr associ travers e tree level contain e delet e it follow procedur abov updat pointer root new tree list tree edg if necessari activ occurr u v insert nontreeei determin activ occurr endpoint e level add e list edg store them delet nontree follow pointer two locat e list nontre edg remov e use function delet algorithm implement follow initi data structur given graph g comput span forest g comput et t forest select activ occurr set pointer describ abov initi set tree level insert nontre edg appropri activ occurr level comput number nontre edg subtre node answer queri are x connect test treex updat data structur delet edg efuvg e e delet treee e tree edg execut delet nontree repeat time case replac edg e found delet nontree case sampl unsuccess edg fu vg nontre treeu l treev l add fu vg s fedg exactli one endpoint g g case jsj wt c log n select one e case choos one edg e remov everi edg e delet non treee insert nontree case analysi run time show amort cost per delet olog n delet case replac edg found olog n insert tree oper execut cost olog n addit case sampl success cost sampletest olog n repeat olog n time total olog n case sampl success wt refer execut nontre test edg cost gather test nontre edg first oper cost olog n per nontre edg second olog n log log n per nontre edg total cost owt log n three possibl case case jsj wt c log n wt cost gather test delet oper otherwis probabl subcas occur total cost case owt log n thu contribut expect cost olog n per oper case jsj wt c log n delet nontre insert nontre tree cost olog n total cost owt log n case treeu i treev i reconnect note edg incid smaller tree gather test thu cours algorithm cost incur case level o sum taken smaller tree level i lemma p corollari p give total cost om log n fulli dynam connect algorithm algorithm next also consid insert edg fu vg insert g add fu vg e l u v previous connect g ie treeu l treev l add fu vg f l let number level l log ne rebuild data structur execut period rebuild level i done move edgesi oper move tree nontre edg e j also j i tree edg e j insert f k rebuild level i contain edg f ie span tree level j span connect compon g insert increment i number insert modular log ne sinc start algorithm let j greatest integ k k ji edg insert rebuild level l execut repres binari counter whose bit b b signific bit rebuild level occur time th bit flip proof correct proof correct one deletionsonli case except must set valu l log ne alter argument show edg contain defin iperiod period begin right rebuild level j i start algorithm end right next rebuild level j i ie iperiod start right flip bit j i start algorithm end next flip note two type iperiod a begin immedi rebuild level edg e move e j flip b begin immedi rebuild level i ie edg move e b flip easi see iperiod consist two part one type iperiod follow one sinc flip bit b j must follow flip b second bit b j flip theorem let number edg e iperiod proof proof analog lemma have lemma smaller tree level search two consecut rebuild level bound note may restrict attent edg move one iperiod sinc e empti start i period thu edg e either pass e one iperiod move singl rebuild level i empti start iperiod edg move e rebuild level pass e igamma e e igamma type iperiod ie first part iperiod insert g type iperiod h igamma maximum number edg pass e igamma e singl ie iperiod follow b iperiod b number edg insert g singl iperiod number edg insert g iperiod lgammaigamma bound h use lemma bound p sum smaller tree search level proof lemma bound h choos substitut h b yield choos log ne note n induct proof show impli l edg never pass l have corollari log ne edg e contain e l analysi run time analyz run time note analysi case case abov affect rebuild howev bound cost incur insert ie cost oper move edg case argument om log n edg gather test use nontre edg tree level cours algorithm must modifi cost ie cost execut move edgesi cost move tree edg nontre edg cost updat f k analyz first part note move edg e cost olog n per edg number edg move greater p thu cost incur cost insert one tree edg given level olog n per edg tree edg ad level sinc tree edg never pass up thu cost may charg edg total cost olog n per edg analyz cost insert sinc start algorithm rebuild occur level lower analysi level deletionsonli argument hold is cost incur level bound om log nc number edg initi graph appli lemma conclud cost gather test edg smaller tree level iperiod oa log n log l note sinc o edg e l given time sinc cost olog n per edg gather test total cost instanc gather test level olog n use potenti function argument charg cost insert new insert contribut c log n token toward bank account level total thetalog n token sinc iperiod occur everi n insert token contribut insert pay on log n cost gather test level iperiod on log n cost move edgesi incur iperiod improv section present simpl trick reduc cost test nontre edg incid smaller tree o per edg total cost gather test edg incid o per edg constant time gather test note abov sinc nontre edg incid ettre avail list time need retriev edg o per edg one also test nontre edg o time ie determin set nontre edg contain one endpoint run list three time edg list initi entri n theta n array use entri count number time edg appear list travers list add edg whose count one constant queri test time deletionsonli algorithm note determin whether two vertic j compon ie treej speed o deletionsonli algorithm compon split replace l call replac edg found case label node smaller compon new label cost proport size cours algorithm cost on log n sinc node appear smaller compon log n time label improv affect asymptot run time random connect algorithm domin cost random sampl howev use determinist algorithm present later paper random algorithm dynam graph problem section show dynam graph problem polylogarithm expect updat time reduc problem connect give altern algorithm maintain minimum span tree kweight minimum span tree algorithm kweight minimum span tree problem maintain minimum span forest dynam graph k differ edgeweight given time e initi graph comput minimum span forest f g defin sequenc subgraph g fedg weight rank ig f initi l k distinct edgeweight call extra span forest g maintain connect algorithm forest f also store dynam tree subgraph order weight edgeset store balanc binari tree insert edg fu vg g determin u v connect f so find maximum cost edg e path u v f weight e greater weight fu vg replac e f fu vg u v previous connect add fu vg f otherwis add fu vg e j j rank weight fu vg fu vg edg weight g creat new subgraph ad fu vg extra insert order g updat e reflect chang f delet edg fu vg g delet fu vg graph contain it updat f fu vg f tree f divid two compon find minimum u v connect g use binari search list subgraph now search path u v span forest g find edg cross cut use binari let x midpoint path recurs portion path u x u x connect f els recurs path x v correct edg fu vg insert cost less cost maximum cost edg tree path u v minimum span forest f unchang cost fu vg less cost maximum cost edg e tree path u v replac e fu vg decreas cost minimum span tree maximum possibl amount give thu minimum span tree g fu vg analysi run time algorithm determin f chang updat data structur insert maximum cost edg tree path u v determin time olog n use dynam tree data structur f delet take time olog n log log n find minimum u v connect g sinc connect queri level take time olog n log log n midpoint tree path u v g determin time olog n use dynam tree data structur span tree g algorithm recurs log n time determin replac edg fu vg total olog n insert delet fu vg e rank weight fu vg take amort expect time olog n f chang one addit insert delet execut everi e j updat constant number oper dynam tree f span tree everi e j cost olog n thu amort expect updat time ok log n fflapproxim minimum span tree algorithm given graph weight u fflapproxim minimum span tree span tree whose weight within factor ffl weight optim problem maintain ffl approxim easili seen reduc kweight mst problem weight rank fall interv yield algorithm amort cost olog n log uffl log log n bipartit algorithm bipartit graph problem answer queri is g bipartit o time g dynam graph reduc problem weight minimum span tree problem use fact graph g bipartit iff given span forest f g nontre edg form even cycl f call edg even edg remain edg odd also use fact edg e f replac even edg set even edg preserv let c cut f induc remov e e replac odd edg nontre edg e cross c pariti e chang replac edg odd replac edg exist even replac edg thu pariti even edg never chang f store dynam tree algorithm is gener span forest f initi graph g tree even nontre edg weight odd edg weight edg weight graph bipartit edg insert determin odd even use dynam tree data structur f give weight accordingli edg delet tree edg replac odd edg becaus weight replac remov odd edg find next replac remov that etc replac relabel replac edg even add back g correct edg insert algorithm determin even odd edg delet replac even edg possibl affect pariti remain edg even replac edg exist odd replac edg pariti everi edg cut chang howev sinc even edg exist cut suffic make odd edg even edg analysi run time even edg never becom odd thu weight edg chang onc show insert edg caus edg ad data structur weight weight delet edg lead remov edg data structur thu amort expect updat time olog n determinist minimum span tree algorithm section present fulli dynam determinist minimum span tree algorithm amort time o log n per oper current number edg g note techniqu sparsif appli top algorithm yield algorithm o log n amort time per oper deletionsonli minimum span tree algorithm data structur use similar random connnect algo rithm instead random sampl alway exhaust search edg incid smaller compon edg store p level accord weight move level deletionsonli data structur kept old edg newli insert edg kept separ level period rebuild execut deletionsonli data structur revis includ newli insert edg e jv m rank edg weight edg g partit l level l e l contain edg rank j m comput minimum span forest f g i keep forest f tree edg f minimum span forest v note f n f algorithm updat data structur delet edg efuvg e tree edg delet nontree e tree edg e delet treee replaceu v i els gather test nontre edg incid case replac edg found let e minimum weight replac edg case replac edg found implement analysi run time use data structur random algorithm store nontre edg e appropri ettre level i ettre store binari tree nontre edg store ntlist gather test edg incid may done wt time see improv section abov tree edg delet replac edg sought total cost gather test nontre edg given level charg delet replac edg found level not consid latter case first becom new compon f cost gather test edg incid owt given level log n see lemma level total cost om log n cost gather test level replac edg found greater cost gather test everi edg level o m addit tree edg p insert tree oper execut per level total cost o log n cost delet nontre olog n cost thu o log n per edg delet plu total cost om log n cours algorithm fulli dynam minimum span tree algorithm algorithm partial rebuild data structur execut p number edg graph last rebuild initi rebuild edg refer old edg and still g store deletionsonli data structur describ abov newli insert edg store separ set e l f l minimum span tree consist old edg ie gv f minimum span tree gv e ie old new edg store f dynam tree data structur e l keep list edg order rank rebuild number updat insert delet sinc last rebuild start algorithm reach p reset current number edg graph insert edg e l appropri e l redistribut old edg among l e contain edg rank j i gamma p edg old edg tree edg level move level add edg level remov edg level delet edg e g e old tree edg updat deletionsonli data structur e belong f stop otherwis delet vg f find minimum cost edg e exactli one endpoint e l add f smallercost edg e replac edg delet data structur if exist insert edg e g add edg e l test replac edg f is use dynam tree find heaviest edg path es endpoint path determin e lighter ye modifi f accordingli analysi run time cost edg insert olog n sinc consist constant number oper dynam tree data structur cost edg delet may includ cost updat dynam tree data structur olog n cost test edg e l o log n cost updat deletionsonli data structur show bound latter cost involv deletionsonli data structur rebuild given analysi section o p per delet tree edg plu overal cost om log n rebuild o log n per updat oper bound next cost rebuild first discuss ad edg appropri level discuss rebalanc size level determin appropri level edg take time olog n use binari search move nontre edg e l e l cost olog n per edg total o move tree edg e l e requir insert edg level j cost o per edg total om log n edg e l never move one level rebalanc ie either e cost olog n per tree nontre edg thu time rebuild om log n cost rebuild amort p occur o p number edg current graph oper occur sinc cost algorithm per edg delet insert o log n determinist connect algorithm minimum span tree algorithm easili convert algorithm connect run time section give altern connect algorithm o log n amort updat time without use sparsif data structur use similar use previous present algorithm two import dif ferenc previou algorithm edg partit level here level contain p edg level ad need is initi level edg creat new edg insert highest level contain less p edg newli creat empti highest level otherwis data structur whole never rebuilt new level ad one time edg level delet level discard use term level denot ith nonempti level previou algorithm edg move level f defin befor i keep forest f tree edg f span forest v here f store relax version ettre call rettre unlik ettre use previou algorithm rettre follow properti edg level delet replac edg found level j i j rettre level updat allow us keep larger number level rettre data structur let span tree level let ct tree creat contract everi span tree level one node node ct call big node thu edg ct belong f retttre consist ettre sequenc et ct list edg activ occurr vertex replac ffl list nodesa vertic g contract form a follow first vertic incid edg e vertic vertex v g nodesa keep list edg f incid v list nontre edg incid v number nontre edg incid v pointer a ffl number edg incid vertic nodesa addit keep order list nonempti level store doubli link list l and nonempti level array whose jth entri pointer locat vertex j nodeslist level contain j oper rettre defin ettre omiss sampletest addit two oper defin below ffl big nodeu i return big node level contain vertex u oper assum e delet edg f whose endpoint still contain big node level let span tree level contain endpoint e smaller two tree split two big node repres implement big nodeu i follow pointer level i vertex u nodeslist level contain u pointer big node contain u call big node domin cost find level l take time olog n implement split big smaller two subtre let vg travers et ct level determin set u vertic g use big one node u determin big node repres node u remov node u nodesa creat new node b add node u new order nodesb list updat number edg incid node nodesa nodesb accordingli call split big node take time proport number vertic plu olog n call big node implement ettre oper need modifi slightli run time olog n is insert nontreet e delet nontree endpoint e may move begin end nodeslist contain it implement treex i nontre edgest insert treee i delet treee i unchang except constant number call big node algorithm updat data structur delet edg efuvg e tree edg execut delet nontree e tree edg level i delet treee i call replaceu v i gather test nontre edg incid case replac edg e found delet nontree insert treee case replac edg found let j next lowest nonempti level i split big node j replaceu v j updat data structur insert edg efuvg number edg level p build data structur new level reset l new level u connect call insert nontree treeu l els insert treee l implement analysi run time gather test nontre edg store nontre edg ntlist see section gather test edg incid may done time owt number nontre edg incid show amort time per updat oper o log n sinc build data structur new level take time on occur everi p n insert total time insert charg on n insert next show total cost delet om log n number edg initi graph k total number updat oper search replac edg take time owt separ consid cost search last level search occur and either termin success discontinu level cost level search occur total cost search delet last level p per search om log n total cost search level replac edg found o sum creat level appli lemma total cost om log n cost split big node charg node total cost n log n per level sinc om n level creat whole cours algorithm total cost split big node om log n thu cost updat oper amort updat o log n acknowledg thank david albert comment present r averag case analysi dynam graph algo rithm main tenanc minimum span forest dynam planar graph improv sparsif sparsif techniqu speed dynam graph algorithm separ base sparsif dynam planar graph algorithm an onlin edgedelet problem data structur onlin updat minimum span tree ambival data structur dynam edgeconnect k smallest span tree lower bound fulli dynam connect problem graph fulli dynam algorithm edg connect fulli dynam cycleequival graph approxim minimum cut insert spars certif dynam biconnect graph use random sparsif approxim minimum cut linear time algorithm find spars kconnect span subgraph kconnect graph fulli dynam biconnect graph improv data structur fulli dynam biconnect graph a data structur dynam tree on find updat span tree shortest path tr data structur dynam tree amort analysi algorithm set union backtrack mainten minimum span forest dynam plane graph fulli dynam algorithm edg connect complex model increment comput separ base sparsif i ambival data structur dynam edgeconnect iki smallest span tree sparsificationmyampersandmdasha techniqu speed dynam graph algorithm polylogarithm determinist fullydynam algorithm connect minimum span tree edg biconnect sampl provid bound onlin edgedelet problem improv data structur fulli dynam biconnect certif fast algorithm biconnect fullydynam graph ctr mihai ptracu erik d demain lower bound dynam connect proceed thirtysixth annual acm symposium theori comput june chicago il usa david eppstein dynam gener topolog embed graph proceed fourteenth annual acmsiam symposium discret algorithm januari baltimor maryland glencora borradail philip klein n log n algorithm maximum stflow direct planar graph proceed seventeenth annual acmsiam symposium discret algorithm p januari miami florida robert e tarjan renato f werneck selfadjust top tree proceed sixteenth annual acmsiam symposium discret algorithm januari vancouv british columbia umut a acar guy e blelloch robert harper jorg l vitt leung maverick woo dynam static algorithm applic dynam tree histori independ proceed fifteenth annual acmsiam symposium discret algorithm januari new orlean louisiana camil demetrescu giusepp f italiano algorithm techniqu maintain shortest rout dynam network electron note theoret comput scienc entc v n p april david r karger minimum cut nearlinear time journal acm jacm v n p jan timothi m chan dynam subgraph connect geometr applic proceed thiryfourth annual acm symposium theori comput may montreal quebec canada jacob holm kristian de lichtenberg mikkel thorup polylogarithm determinist fullydynam algorithm connect minimum span tree edg biconnect journal acm jacm v n p juli mikkel thorup worstcas updat time fullydynam allpair shortest path proceed thirtyseventh annual acm symposium theori comput may baltimor md usa eran eyal dan halperin dynam mainten molecular surfac conform chang proceed twentyfirst annual symposium comput geometri june pisa itali camil demetrescu giusepp f italiano fulli dynam pair shortest path real edg weight journal comput system scienc v n p august