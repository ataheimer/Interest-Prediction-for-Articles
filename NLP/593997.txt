t skeleton tree effici decod huffman encod text a new data structur investig allow fast decod text encod canon huffman code storag requir much lower convent huffman tree olog n tree depth olog n decod faster part bitcomparison necessari decod may save empir result larg reallif distribut show reduct number bit oper basic idea gener yield save b introduct import use data compress inform retriev ir system today wellestablish mani author comment larg fulltext ir system inde voraci consum storag space realtiv size raw textual databas text kept also variou auxiliari file like dictionari concord usual adjoin system make retriev process effici moreov certain data structur decod tabl tree resid ram larg system requir power machin therefor quit natur effort made compress text necessari file therebi reduc demand storag ram equival fix machin given resourc effect increas size data base still handl effici popular compress method base work lempel ziv adapt method alway suitabl ir applic context fulltext retriev larg number small passag access simultan eg produc kwic keywordincontext index respons submit queri text fragment decod regardless exact locat adapt code method use would forc us start decod begin text logic block contain retriev passag would either decod much need may impli increas process time prepar priori smaller block would cost us compress effici case advantag use adapt method often yield better compress static one may lost huffman code still one best known popular static data compress method certain applic data transmiss commun channel code decod ought fast applic like ir scenario focu paper compress decompress symmetr task compress done onc build system wherea decompress need process everi queri directli affect respons time thu special interest fast decod techniqu see eg data structur need decod huffman encod file a huffman tree lookup tabl gener consid neglig overhead rel larg text howev text larg huffman code appli connect markov model requir huffman forest may becom storag problem moreov alphabet encod necessarili small may eg consist differ word text huffman tree thousand even million node uncommon tri paper reduc necessari intern memori space devis effici way encod tree addit new suggest data structur also allow speedup decompress process reduc number necessari bit comparison manipul individu bit inde main caus slow decod huffman encod text method base larg tabl construct preprocess stage suggest help entir decod process perform use byte orient command see also howev intern memori requir storag tabl may larg anoth possibl avoid access individu bit use ari instead optim binari huffman code obvious reduc compress effici de moura et al report degrad signific next section recal necessari definit canon huffman tree use below section present new suggest data structur includ experiment result section main idea extend yield yet smaller tree even faster decod canon huffman code figur canon huffman code given probabl distribut might quit larg number differ huffman tree sinc interchang left right subtre intern node result differ tree whenev two subtre differ structur weight averag path length affect interchang often also optim tree cannot obtain via huffman algorithm one may thu choos one tree addit properti prefer choic mani applic canon tree defin schwartz kallick recommend mani other see eg denot p assum length bit codeword assign huffman procedur element probabl depth leaf correspond p huffman tree tree call canon if scan leav left right appear nondecreas order depth or equival nonincreas order idea huffman algorithm use gener length f g codeword rather codeword themselv latter easili obtain follow ith codeword consist first bit immedi right binari point infinit binari expans mani properti canon code mention follow use run exampl paper consid probabl distribut impli zipf law defin weight nth harmon number law believ govern distribut common word larg natur languag text canon code repres string hn call sourc k denot below length longest codeword the depth tree n number codeword length k sourc correspond zipf distribut i code depict figur shall assum eas descript sourc hole ie three integ true mani reallif distribut particular exampl below hand distribut one alphabet use compress set spars bitmap techniqu suggest herein easili adapt gener case use vector succi give codeword length i next larger codeword length j make exposit clearer shall suppress refer succi sinc distribut without hole one properti canon code set codeword length compris binari represent consecut integ exampl case codeword length bit binari integ rang fact exploit enabl effici decod rel small overhead codeword bit detect one get rel index within sequenc codeword length simpl subtract follow inform thu need let length shortest codeword let basei integ valu first codeword length i denot standard sbit binari represent integ k with lead zero necessari jth codeword length i let seqi sequenti index first codeword length i suppos detect codeword w length iw integ valu binari string w ie rel index w within block codeword length thu seq rel index w within full list codeword rewritten iw gamma diff thu one need list integ diff tabl give valu n basei seqi diffi exampl tabl decod valu canon huffman code zipf suggest next section new represent canon huffman code spaceeffici may also speed decod process permit time decod singl bit one iter skeleton tree fast decod follow small exampl use data abov show save possibl suppos decod detect next codeword start inform enough decid follow codeword ought length bit thu abl detect first bit codeword read follow bit block without check bit end codeword reach goal construct effici datastructur permit similar decis soon possibl fourth bit earliest possibl exampl sinc also codeword length start decod sktree suggest solut binari tree call sktree for skeletontre structur induc underli huffman tree gener significantli fewer node tree travers like regular huffman tree is start pointer root tree anoth pointer first bit encod binari sequenc sequenc scan read zero resp proceed left right child current node regular huffman tree leav correspond full codeword scan decod algorithm output correspond item reset treepoint root proce scan binari string case howev visit tree depth necessari identifi length current codeword leav sktree contain length correspond codeword f tree pointer gamma root start length string f string els tree pointer gamma right tree pointer valu tree pointer f codeword string start output tree pointer gamma root start els figur decod procedur use sktree formal decod process use sktree depict figur variabl start point index bit begin current codeword encod string store vector string node sktree consist three field left right pointer null node leaf valuefield zero intern node contain length bit current codeword node leaf actual implement use fact intern node either zero two children store valuefield rightfield space serv flag use right pointer procedur also use two tabl tabl give jth element in nonincreas order frequenc encod alphabet diff i defin abov vari k length shortest length longest codeword procedur pass one level tree one accord bit encod string leaf reach rest current codeword read one oper note bit input vector individu scan yield possibl time save figur sktree zipf distribut figur show sktree correspond zipf distribut tree tilt ffi left right children indic arrow point to right frame leav correspond last codeword indic length sktree exampl consist node oppos node origin huffman tree idea similar sktree base tabl rather tree suggest moffat turpin instead identifi root subtre codeword depth essenti form complet tree fix depth less depth code tree by extend shorter branch examin code tree node depth determin minimum codeword length subsidiari subtre find length codeword fixeds window compress bitstream consid binari valu compar leftjustifi base valu sequenc hardcod cascad ifstat comparison equival transit left right child sktree replac bit comparison equival byte word base comparison reminisc mechan suggest construct sktree travers standard canon huffman tree decod given codeword one may stop soon one get root full subtre depth h h ie subtre depth h h leav sinc stage known exactli h bit need complet codeword one way look sktree therefor standard huffman tree full subtre depth h prune direct much effici construct follow onetoon correspond codeword path root leav huffman tree extend defin binari string path p s induc tree given root r path consist e e r left resp right child r exampl figur p consist four node repres bullet top line skeleton sktree consist path correspond last codeword everi length let codeword denot l are exampl etc idea p l serv demarc line node left resp right p l ie left resp right child one node p l correspond prefix codeword length first approxim construct procedur thu take tree obtain there clearli need includ longest codeword l k alway string k s adjoin miss children turn complet tree intern node left right child label new leaf set equal label closest leaf follow inord travers word creat path l one first follow node alreadi exist tree one branch creat new node label miss right child node path label base assumpt hole miss left children new node path label i closer look impli follow refin suppos codeword l zero rightmost posit ie l string ff length gamma first codeword length follow get ith bit one decid length current codeword l termin string s l jfij first codeword length length codeword deduc alreadi read bit follow fi follow one alway need full string l sktree prefix includ rightmost zero let l prefix revis version procedur start tree obtain node tree depict bullet figur path p l leaf tree left child leaf new termin node repres figur box contain number i addit leav fill explain abov space complex evalu size sktree count number node ad path p l k sinc codeword canon code order correspond frequenc also alphabet sort suffic compar l l igamma let empti string m let fli longest common prefix l l string exampl number node sktree given by sinc summat alon number intern node the bullet figur maximum function come prevent extrem case differ might neg exampl l longest common prefix sinc consid bit includ rightmost zero l case inde new node ad p l immedi bound number node sktree ominn k sinc one hand hand cannot exceed number node underli huffman tree n gamma get tighter bound consid node upper level sktree belong full binari tree f leav root sktree depth f e leav level gamma tree f part sktree path p l must overlap account node f separ k gamma node f k gamma disjoint path it path p l extend f log yield bound number node sktree save worst case eg one codeword length except longest alway least two gener depth huffman tree omegagamma n save might signific tree optim skew distribut mani applic like distribut charact charact pair word natur languag depth huffman tree olog n larg n even constant c depth c log n must quit small suppos huffman tree leaf depth d theorem probabl element correspond leaf f j jth fibonacci number get exercis golden ratio thu c log n give numer exampl section one huffman tree correspond differ word english leav probabl tree size leaf level log n less theta gamma mean word occur everi billion word exist rare word put lower limit size text case must larg enough fill cdrom distribut given tabl experi below ratio depth huffman tree log n even origin huffman tree would deeper sometim conveni impos upper limit olog n depth often impli neglig loss compress effici case given logarithm bound depth size sktree log n log time complex decod base standard huffman tree averag number comparison per codeword sum taken leav i depth tree time probabl get i similar sum hold sktree differ leaf correspond singl element sever consecut codeword length let w prefix codeword correspond leaf sktree label denot codeword correspond leaf sktree correspond use notat section indic rang diff averag number comparison per codeword use sktree thu evalu as ifleav sktreeg w binari string correspond leaf i depth tree shortcut labe probj probabl element index j approxim assum probabl element level tree gammai correspond dyadic probabl distribut probabl integr power cannot great differ actual probabl distribut dyadic one sinc yield huffman tree see bound distanc distribut given model eqn becom ifleav sktreeg similar sum taken leav origin huffman tree give averag codeword length dyadic distribut therefor larg save whenev number node sktree much smaller underli full huffman tree experiment result test effect use sktree follow reallif distribut use data french collect tresor de la langu francais databas mb french languag text million word th th centuri english sourc mb million word wall street journal hebrew part responsa retriev project mb hebrew arama text million word written past ten centuri first set alphabet consist bigram three languag the sourc english distribut next set element encod differ word yield larg alphabet final set contain distribut trigram french complet zipf distribut use exampl also ad total averag number averag rel sourc k number codeword node number save element length sktree comparison comparison bigram french hebrew english word french hebrew trigram french tabl time space requir reallif distribut tabl display result first three column give statist variou distribut depth k huffman tree size n encod alphabet weight averag length codeword measur bit equal averag number comparison standard huffman tree use next two column bring number node sktree given eqn averag number comparison per codeword decod base sktree given eqn final column show rel save number comparison measur percent see larg distribut roughli half comparison may save note save spite fact highprob symbol short codeword rel bit common weight averag take account bit save shorter codeword save multipli higher probabl bit save longer codeword even probabl small larg number cumul effect note also cost store sktree sever percent cost full huffman tree reduc sktree wish explor might gain prune sktree intern node one would thu get leav yet possibl deduc length current codeword partial inform alreadi avail exampl figur bit alreadi process correspond intern node rightmost upper corner know alreadi length current codeword either therefor need one comparison know exact length concaten follow seven bit three alreadi process get bit string w binari valu w smaller base next codeword must length otherwis length use origin sktree explain previou section would least one comparison possibl even more eg bit would perform four comparison still know length reflect lead idea reduc sktree obtain sktree prune branch one hand reduc tree obvious smaller other saw may also decreas number comparison formal defin node v sktree two valu lowerv upperv by v leaf lowerv v intern node lowerv lowerleftv is node v codeword correspond leav subtre root v length interv lowerv upperv term earlier notat defin reduc sktree smallest subtre sktree leav w correspond rang two consecut codeword length ie figur reduc sktree zipf distribut figur reduc sktree obtain sktree figur leav also indic bullet correspond rang underneath recal origin huffman tree node sktree reduc sktree left note leav origin sktree delet also entir subtre node correspond part p l overlap p l eqn sinc seek minim tree path node highest tree need kept rest branch offspr prune gener view regular reduc sktree would follow consid full canon huffman tree assign node valu lower upper delet node start leaf proceed parent node get smallest tree everi leaf w satisfi lowerw upperw ie correspond codeword length sktree process continu node delet codeword correspond new leav length i get reduc sktree henceforth adopt notat sk tree sk tree origin reduc sktree respect subscript refer maxim size set codewordlength associ leav tree cannot use equal eqn would impos rang exactli two codeword length leaf sk tree exampl figur leav equal last element codeword block correspond sk tree figur exampl sk tree special leav eqn exampl leav may exist parent node correspond alreadi rang codeword length case origin leaf sk tree must kept let us call leav sk tree special leav exampl distribut abov special leav exist distribut hebrew bigram first element sourc h left part figur last codeword l codeword length list right part figur correspond section sk tree special leav w indic rectangl contain valu lowerw which equal upperw leav depict bullet abov exampl see codeword length prefix parent node correspond leaf associ prefix may extend codeword length similarli prefix impli codeword length prefix codeword length decod procedur sk tree similar sk tree given figur ifblock replac one figur use f lag field leaf w f otherwis valu field w store lowerw w leaf w intern node valu tree pointer f len gamma valu tree pointer codeword string start f lag tree f codeword string start len output tree pointer gamma root start figur decod use sk tree leaf w reach current codeword initi length lowerw correct set w special leaf next codeword inde length lowerw w special leaf f lagw check append zero right end codeword get integ valu larger equal first codeword length lowerw so updat current codeword includ also follow bit construct sk tree similar underli sk tree consid path node node appear least two differ path intern node sk tree leav ad fill miss left right children may special leav space complex sk tree note principl sever special leav may eman singl branch p l leav upper bound number node ominn k sk tree practic special leav rare appear particular case p l contain either p l former case special leav right children node p l latter left children exampl refer tree figur l prefix l gener special leaf right child wherea l contain l prefix gener special leav left children given huffman tree special leav associ sk tree case exampl besid one figur number node clearli exactli one leaf rang sk tree complet tree ie intern node exactli two children size sk tree earlier exampl distribut list tabl seen even huge huffman tree hundr thousand node size reduc sever ten reduct even rel size sk tree number save averag save sourc node rel number rel sk tree sk tree comparison sk tree english bigram french hebrew english word french hebrew trigram french tabl time space requir sk tree evalu averag number comparison take sum similar eqn leav sk tree special leav formula eqn appli other let w prefix correspond codeword assum leaf label jwj codeword correspond leaf sk tree w first length follow one length exact cutoff point import codeword correspond consecut indic rang iw probabl codeword multipli number necessari comparison detect them jwj sinc need addit comparison decid length yield use notat eqn follow formula ifleav sktreeg tabl give result averag exampl reallif exampl give reduct rel regular huffman decod algorithm rel algorithm use sk tree final remark prune skeleton tree turn profit term time space climb even higher defin sk tree accordingli associ valu ranges node v sk tree give size set correspond codeword length leav sk tree ranges sk tree ranges consid path start leaf move parent pointer toward root ranges valu node path form nondecreas sequenc first valu follow possibl sever s etc fix path last node valu if exist new leaf yield sk tree similarli proceed even last node valu would yield sk tree etc howev save incur pass sk tree sk tree caus fact sever consecut node path ranges valu new leav sever level higher accordingli sever comparison could save parent node node ranges valu also ranges valu child parent node must ranges valu mean special leaf argu earlier case rare therefor whenev special leaf involv pass lowest node ranges valu lowest node ranges valu would let us climb one level save one comparison hand need addit comparison within rang valu case noth gain cours price two addit comparison could process use binari search rang size gener need r addit comparison reach leaf sk r tree push idea extrem would skeletontre all would find correct length codeword use sequenc binari search step list first or last codeword everi codeword length suggest standard binari search search code maxim codeword length k take exactli dlog ke comparison would exampl distribut note averag number comparison sk tree threshold exampl tabl correspond valu tabl therefor seem necessarili worthwhil pass sk tree moffat turpin suggest use bias binari search sinc probabl distribut codeword length skew first bit code word approach linear search skeletontre introduc paper conveni data structur perform similar search effici r huffman code dead ziff d perl y fast search compress text allow error responsa retriev project alway want know afraid ask rabinowitz j moor e inform retriev method construct minimum redund code nemetz t art comput program applic inform diverg huffman code implement minimum redund prefix code text compress dynam document databas kallick b fast decod huffman code psychobiolog languag univers algorithm sequenti data compress compress individu sequenc via variabler code ad compress fulltext retriev system tr ctr dana shapira ajay daptardar adapt knuthmorrispratt algorithm pattern match huffman encod text inform process manag intern journal v n p march