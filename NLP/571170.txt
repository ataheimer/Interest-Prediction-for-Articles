t use heap elimin stack access a valu variabl often given field heap cell frequent program pick valu sever variabl differ field heap cell keep variabl stack frame access origin locat heap instead reduc number load store stack cost introduc smaller number load heap present algorithm find optim set variabl access via heap cell instead stack slot transform code program accordingli implement optim mercuri compil measur show reduc program runtim time reduc program size optim straightforward appli mercuri languag immut data structur adapt languag destruct assign would requir compil perform mutabl analysi b introduct compil tri keep valu variabl per hap virtual regist whenev possibl howev procedur call in gener case modifi content permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ppdp octob pittsburgh pennsylvania usa regist standard solut problem alloc slot stack frame everi variabl live call copi variabl stack call paper investig possibl avoid alloc associ copi exploit fact variabl valu must save may alreadi avail memori locat cannot updat call suppos obtain valu variabl eld immut cell heap point variabl b from on assum cell immut unless specic say otherwis allow us avoid store stack provid nd locat heap everywher need to case procedur singl assign languag procedur imper languag express singleassign form place later procedur refer a store valu b instead valu stack may look promis worst case requir number stack slot one number store stack call one addit instruct load b stack place later procedur want access a howev may happen program need b call case need stack slot store instruct stack slot anyway access via b need addit store may also happen everi basic block program access also access b case access via b requir addit load either thing happen access via b elimin one stack slot one store oper stack slot use denit rst call denit access via b also save load cell would need store stack slot overal access via b may better store stack slot cours may two call procedur access b case access via b incur cost addit load howev often happen two call procedur access variabl point cell eg b access one variabl whose valu came eld cell singl load b give us access cost load b need divid among mean cost access instead store stack slot depend variabl reachabl b access via b inde may happen access via b worthwhil access via b worthwhil access via b worthwhil interdepend decis need make dierent variabl reachabl cell sig nicantli complic task nding optim partit variabl store cell stack slot access via cell compar partit variabl store stack slot optim partit may reduc total number stack access load store perform program may reduc number stack slot requir may both cours may also neither optim guarante speedup tri partit obviou algorithm comput best partit unfortun algorithm feasibl cell contain dozen eld requir tri million partit paper describ much ecient algorithm base maxim match bipartit graph implement algorithm mercuri compil experi show give real benet real program eg mercuri compil itself next section give brief introduct mercuri concentr featur relev optim section give work exampl explain techniqu section dene condit applic optim show collect inform need implement opti mizat section give algorithm comput optim partit section explain sourcetosourc transform use exploit optim partit section give result preliminari experiment evalu optim mercuri assum familiar basic concept logic pro gram prolog syntax also mercuri syntax mercuri pure declar logic program languag design construct larg reliabl ecient softwar system team programm mercuri syntax similar syntax prolog mercuri also strong modul type mode determin system catch larg fraction programm error enabl compil gener fast code main featur mercuri relev paper follow everi predic one mode say everi argument whether input output the mode system sophist that matter paper call mode predic procedur mode system insist abl nd compil time state instanti everi variabl everi point everi procedur abl reorder conjunct goal use valu variabl come goal gener valu variabl cannot perform either task reject program mercuri associ everi procedur determin express upper lower bound number solut procedur have procedur guarante exactli one solut determin det procedur may one solut one set input zero solut input determin semidet procedur may number solut determin nondet denit predic mercuri bodi made atom conjunct negat disjunct if thenels simplifi algorithm compil convert bodi claus form atom appear b distinct variabl mode analysi compil classi unica tion one type copi one b input output test input deconstruct b input output construct input b output complex unic otherwis use respect notat b a b a b a indic mode unic paper shall mainli concern de construct deconstruct b whether princip functor b f previous establish and n assign eld cell point b variou note eld variabl use later in particular anonym variabl compil access eld compil also detect disjunct disjunct deconstruct input variabl dierent function symbol disjunct valu variabl entri disjunct determin di junct ani succeed other cannot succeed tri unifi variabl function symbol bound to compil convert disjunct switch they resembl switch construct c mercuri compil sever backend translat mercuri dierent target languag backend work paper compil origin backend translat mercuri low level c code backend use execut algorithm describ execut algorithm use virtual machin whose data structur consist heap two stack set gener purpos regist use argument pass set special purpos regist heap stack pointer differ two stack irrelev purpos paper mercuri compil respons paramet pass ing stack frame manag heap alloc control ow includ manag backtrack almost everi aspect execut signic task leav c compil instruct select instruct schedul regist alloc within basic block eect use c compil high level optim assembl besid achiev portabl approach allow mercuri compil perform optim exploit semant properti mercuri program such immut ground term cannot convey c compil mercuri compil assum everi call clobber everi virtual machin regist everi call site ush live variabl slot current procedur switch a empti load k v l r store k v k v l r compareresult k k b switch result load k v l load k v r load v k l r load k v r load k v l switch a empti load k store k v compareresult k k b switch result load k v t l bc load t k ce v ce r ce load v t k be l be r load k v t r bd updat bd k v r d load t k de v de l de a b figur updat predic origin form a modi transform b stack frame similarli start nondeterminist di junction ush stack variabl live start second later disjunct sinc start disjunct reach backtrack long execut clobber virtual machin reg ister ifthenels treat similarli the els branch correspond second disjunct situat mercuri execut algorithm requir live variabl ush stack mercuri compil therefor pass gure out ush point variabl need ush stack point variabl need exist stack simultan need store dierent stack slot one may abl use stack slot store dierent variabl dierent ush point compil use standard graph colour approach see eg assign variabl stack slot motiv exampl consid mercuri predic illustr figur a updat binari search tree t contain keyvalu pair new version tree t map key k valu v text symbol comment predic predic search updat variou kind fairli import mani mercuri program declar natur mercuri encourag programm use repres dictionari instead array which must updat destruct origin form predic variabl k v l r whose valu produc deconstruct live call compar immedi follow deconstruc tion compil therefor alloc stack slot variabl save valu stack slot call save valu variabl requir load regist rst origin locat memori cell point t k v also live call alreadi put regist updat caller execut follow one three path compar re turn k k equal execut take second arm switch code use k v l r input four variabl must load stack slot k less k execut take rst arm switch contain call make call requir l k v load regist stack slot call return l regist call need load regist k v r third arm switch analog rst ad comment indic variabl code store stack variabl load stack heap count load store variabl involv deconstruct the cell variabl eld variabl kvlr requir make valu variabl avail along path execut involv deconstruct execut take rst arm switch result execut four load four store involv variabl program point b three load b c three load c e total ten load four store execut take third arm switch result similar reason also execut total ten load four store execut take second arm switch result execut four load four store b three load b e total seven load four store key idea paper realiz load store b signic cost avoid cost will insert clone deconstruct later procedur bodi clone incur extra cost load t long choos perform transform initi save least big extra cost path execut achiev speedup figur b show predic transfor mation clone origin deconstruct one region rst use eld variabl execut take rst arm switch result transform predic execut one load one store b two load b c load stack slot regist load l bc cell point to four load c e load stack slot regist load k bc v bc r bc cell point to total seven load one store execut take third arm switch result analysi analog total cost seven load one store execut take second arm switch result execut one load one store b four load b e total load one store overal transform reduc cost path rst third arm ten load four store seven load one store cost path second arm seven load four store load one store transform also reduc number stack slot requir origin code need six stack slot variabl one kvkvlr transform code need three stack slot vari abl one kvt sourc speedup ad one two extra load path execut replac four load four load b one load one store extra cost alway form extra load cell variabl t rst stack ush deconstruct possibl case extra store cell variabl stack ush save alway form elimin store eld variabl stack ush elimin load eld variabl need stack ush case must keep load k elimin load well store v l r reason reduct stack slot requir save stack preserv valu eld variabl ts heap cell across call sinc number eld variabl cell greater one use one stack slot save valu one variabl across call detect opportun optim describ algorithm perform transform shown exampl abov need introduc background inform denit bodi mercuri procedur goal goal may atom goal compound goal atom goal may unic builtin oper eg arithmet call for purpos paper distinct rst order call higher order call method call compound goal may conjunct disjunct switch ifthenels negat existenti quanti er rest paper restrict attent rst four compound goal type algorithm treat negat special case ifthenels notgoal equival goal fail true treat existenti quanti goal goal itself call di junction switch ifthenels branch control structur branch goal denit ush point point bodi procedur code gener requir store variabl stack slot regist mercuri four kind ush point execut reach call code gener must ush variabl live call stack like compil mercuri compil assum call clobber regist execut reach start ifthenels code gener must ush variabl live start els case els case reach regist may clobber eg call insid condit code gener must ush variabl stack otherwis ush variabl regist well stack slot execut reach start disjunct code gener must ush variabl live start second disjunct later disjunct nonrst disjunct reach via deep backtrack ie failur call insid previou disjunct failur goal follow disjunct whole code gener must ush variabl stack otherwis ush variabl regist well stack slot execut reach end branch control structur code gener must store variabl live afterward specic stack slot specic regist exact locat determin prepass code gener ensur branch leav variabl place denit anchor one follow start procedur bodi call site start branch control structur end condit ifthenels end branch control structur end procedur bodi ush point anchor anchor ush point exampl figur a program point abcd e which repres start outer switch call compar two call updat end inner switch respect anchor also ush point code fragment also contain two anchor start inner switch end outer switch exampl distinguish two anchor program point b e denit interv sequenc atom goal delimit leftright pair anchor satisfi properti forward execut start left anchor continu without encount failur which would initi backtrack ie backward execut next anchor reach right anchor pair consid call part atom goal interv call site right anchor interv left anchor denit segment maxim sequenc one interv right anchor interv sequenc except last left anchor interv follow sequenc sequenc must also satisfi properti execut get left anchor rst interv right anchor last interv without code gener throw away current record valu live variabl segment contain one interv howev right anchor interv start ifthenels interv ifthenels interv start condit belong segment right anchor interv start disjunct interv disjunct interv start rst disjunct belong segment right anchor interv start switch interv disjunct interv start arm switch belong segment interv whose right anchor start switch interv part one segment exampl figur a ab bc ce be bd de segment empti interv contain atom goal end call compar start follow switch part segment start b transform algorithm three phase rst phase nd interv procedur bodi interv record left right anchor set variabl need input interv includ input atom goal interv and interv whose right anchor start switch variabl switch on set variabl need segment s denot varss union set variabl need compon interv segment s also record interv leftmost anchor segment interv belong second phase travers procedur bodi backward look deconstruct b fa an call eld vari abl oppos b cell variabl nd deconstruct tri nd eld variabl avoid store stack slot load heap cell point cell variabl instead wherev need access eld variabl via cell variabl follow condit hold memori cell point cell variabl must immut isnt valu eld cell may chang origin deconstruct copi deconstruct transform insert elsewher procedur bodi mercuri cell mutabl instanti state cell variabl point deconstruct state pointer cell live point so compil may choos destruct updat cell program point valu eld variabl need as input atom goal live variabl ush output argument procedur whole must within eectiv scope deconstruct consid variabl follow program fa b rxaz need determin singl locat a use r henc must store stack slot everi interv need valu eld variabl valu cell variabl must reachabl time execut reach deconstruct consid variabl follow program fab qxab rxa sxyaz access indirectli y need add load segment q r q succeed multipl time load execut per success guarante compens remov store call q valu eld variabl requir segment deconstruct otherwis point investig whether would worthwhil access via cell variabl segment deconstruct four condit hold least eld variabl these form set candid eld variabl partit set candid two subset access via cell vari abl nevertheless store access via stack slot thi rst nd set maxim path execut take procedur bodi point deconstruct point deconstruct goe scope denit path sequenc segment start segment contain deconstruct segment follow segment j a left anchor rst interv segment j right anchor last interv segment i b execut resum left anchor rst interv segment j backtrack initi within segment i path maxim contain within anoth path maxim path disjunct includ maxim path rst disjunct maxim path second disjunct maxim path third etc maxim path ifthenels either maxim path condit follow maxim path part maxim path condit follow maxim path els part maxim path switch maxim path one arm switch program figur a maxim path abbcc abb abbdd sinc backtrack switch maxim path start given deconstruct nonempti set candid eld variabl invok algorithm describ next section partit candid variabl set that point view execut take particular maxim path procedur bodi better access via cell variabl set better store stack slot decid variabl load cell introduct maxim match algorithm use decid variabl load cell make use maxim match algorithm bipartit graph section introduc terminolog exampl denit bipartit graph g made two disjoint set vertic b c edg e applic set vertic repres benet cost match bipartit graph g set edg e vertex occur maxim match g match match g jm j jm j ecient algorithm maxim match bipartit graph base search augment path denit given bipartit graph g match altern path path whose edg altern e dene set reachableu m set node reachabl u altern path given bipartit graph g match augment path p altern path rst last vertic free ie occur given bipartit graph g match augment path p match jm cost benefit figur stack optim graph program figur togeth maxim match import properti maxim match relationship augment path properti match g maxim exist augment path p g straightforward algorithm bipartit maxim match base search augment path use breadthrst search oju j jej sophist algorithm o exampl figur show bipartit graph match illustr solid arc match g exampl altern path loadt dene edg fstorek loadt storek storet g augment path endpoint match inde match maxim match minim stack oper aim nd deconstruct unic b an set variabl involv store stack order minim number stack oper requir let f ang candid eld variabl maxim path deconstruct assum given list segment function determin variabl whose valu requir program segment i determin maxim path independ set variabl requir stack slot denit cost must incur access candid variabl f via cell variabl b instead via stack are loadb i need add load b everi segment storeb need add store b rst seg ment b live initi segment call set costf benet gain access candid variabl f via cell variabl b instead via stack are b live initi segment even origin program would need store b stack store extra cost incur access eld variabl via b storef store f initi segment loadf avoid load f initi segment call set benefitf use model total cost benet choos access given subset v f via cell variabl instead store stack total set cost incur choos access given subset v f via cell variabl instead store stack costv total benet choic benefitv note that benet f independ cost not sinc cost load b given segment incur onc even use access one candid variabl therefor cannot decid candid variabl individu whether store stack access via cell variabl must consid set candid time need ecient algorithm nding set v f benefitv greater equal costv time assum cost load store oper equal discuss relax assumpt section henc search set v f two choic v v prefer v sinc requir fewer stack slot algorithm reduc stack optim problem maxim match problem bipartit graph ecient algorithm known denit stack optim graph deconstruct given bipartit graph g whose vertex set ff benefitf dene costfg node graph repres load store instruc tion edg repres benet one gain one will incur given set cost diagram cost node top benet node bottom exampl consid program shown figur a default compil requir load store deconstruct treekvlr singl maxim path the entir procedur eld variabl candid segment anchor end call var inform given by cost benet eld variabl given cost benet k fstoret loadt fstorekg loadt loadt g note sinc requir deconstruct cost candid sinc candid requir initi segment load benet stack optim graph deconstruct shown figur algorithm start nding maxim match stack optim graph figur show edg maxim match solid line mark unmatch cost node node reachabl node use altern path respect cost node mark repres cost paid for correspond benet benet node mark benet equal outweigh correspond cost algorithm partit candid whose benet includ mark node whose benet includ mark node result v variabl want access via cell variabl latter set fact benet node candid variabl either mark unmark consequ follow lemma lemma let g stack optim graph adjac subset c maxim match g let mg match node c let m node reachabl altern path unmatch node c b b r proof suppos contrari wlog b r altern path c mc b henc altern path c a sinc c mc rst edg path cannot sinc path must even number edg last edg must b also adjac a extend altern path c reach b contradict altern sinc altern path c a mean path c must use edg henc altern path c b contradict exampl figur show stack optim graph program figur a togeth maxim match mark with m node reachabl altern path start unmatch node c in case node floadt g figur mark node loadt storek loadt set v dene match set candid variabl whose benet node unmark case g result optim program shown figur c requir load store note access eld variabl cell result program figur b requir load store show choic v wors default access everi candid stack slot choic optim theorem let g stack optim graph maxim match g let load k v l r store k v l r dodgyk v l r load l r load k v checkk v c load k checkk c c load k checkk c c load k v l r store dodgyk v l r load t l r load t k v checkk v c load t k checkk c c load t k checkk c c store t k dodgyk v l r load t l r load k t v checkk v c load k checkk c c load k checkk c c a b c figur a origin arbitrari program b transform program maxim stack space save c optim transform program match node c unmatch node c let maxim proof let node c rc match otherwis would mc must match node rb suppos contrari c match b rb altern path c mc b end unmatch edg sinc start unmatch edg c b henc extend path use match edg b c henc c r contradict impli b rb otherwis would augment path c mc b sinc node rb either match node rc unmatch denit benefitv rb sinc v contain exactli f benefitf show costv rc costv node c adjac node benefitv rb sinc node rc match node rb must adjac node rb thu rc costv suppos contrari node c rc adjac b rb c rc henc altern path c mc c end edg altern path extend b sinc b c henc b r contradict thu rc netv jmbj consid set variabl v f let mb denit node unmatch match node costv henc jmc j jmb j also clearli mb mb sinc node mb unmatch netv netv merg result differ maxim path exampl program figur a maxim path follow treekvlr abbcc abbdd abb stack optim graph maxim path shown figur none maxim match leav unmatch cost node v get result along maxim path therefor access variabl fk v l rg via along everi maxim path result optim program shown figur b howev gener may comput dierent set v along dierent maxim path valu v comput along given maxim path includ given eld variabl access eld variabl via heap cell along maxim path may lead slowdown execut take maxim path access eld variabl via cell maxim path via stack slot maxim path make sens need store eld variabl stack slot rst interv use maxim path access via stack slot gain noth may lose someth access via cell along maxim path sinc tri make sure optim never slow program rst harm therefor access eld variabl via cell maxim path prefer access eld variabl via cell ie eld variabl set v comput maxim path valu v comput along given maxim path guarante access variabl v via cell instead via stack slot slow program down howev similar guarante subset access subset variabl v via cell instead via stack slot slow program down would therefor good idea simpli take intersect loadl storel loadr storer storek loadv storev cost benefit loadl storel loadr storer storek loadv storev cost benefit loadl storel loadr storer storek loadv storev cost benefit figur stack optim graph maxim path abbcc abbdd abb program figur a set v comput along dierent maxim path access variabl intersect via cell instead restrict candid set remov variabl in tersect restart analysi begin new candid set keep get set v maxim path time restart analysi remov least one variabl candid set size initi candid set thu put upper bound number time need perform analysi cost oper now assum load store cost same reason close truth whole truth optim deal two kind store four kind load kind store deal store eld variabl stack store cell variabl stack kind load deal load eld variabl regist store stack in initi segment load cell variabl stack regist in later segment use regist base load eld variabl cell load eld variabl cell load variabl stack slot transform add type load possibl type store remov type store possibl type load side eect also turn type load type load store involv either side ledger go current stack frame mean like cach hit type load cluster mean also like cach hit exampl unic deconstruct cell argument machin cach block contain four word type load requir load argument cell regist two cach miss type load occur one per cell per segment cluster all therefor much like cach miss type load also like cach load load type typic follow within instruct store load valu load type typic follow within instruct load type use load valu cell address optim turn type load type load so noth chang distanc load instruct next instruct need load valu type store properti valu store like access next in struction make pipelin stall data hazard unlik type load hand signic chanc caus data hazard result stall chanc cost result stall depend other independ instruct schedul by compil hardwar execut load rst instruct use load valu mean probabl cost and thu averag cost stall depend program input data sinc rel cost dierent type load store depend averag number length cach miss stall gener rel cost programdepend lesser extent datadepend well therefor extend optim four paramet give rel cost type load type store the cost paramet load also suppos account associ cost turn type load type load paramet form small integ extens consist replic node stack optim graph c time c cost paramet type oper repres node replica given origin node connect accord lemma retain properti copi node either mark not henc set v remain well dene theorem continu hold howev match algorithm gener solut whose net eect eg addit n type cell variabl load remov type eld variabl store arloadcost f ieldv arstorecost experi set cellv arloadcost three paramet cellv arstorecost f ieldv arloadcost f ieldv arstorecost transform code determin set v eld variabl access cell variabl deconstruct transform program ad clone deconstruct perform forward travers procedur bodi start deconstruct appli current substitut go initi current substitut ident substitut reach begin segment v varsi add clone decon struction eld variabl f replac new variabl f construct substitut eect replac variabl access cell copi clone deconstruct remain new variabl clone deconstruct never use proceed appli substitut reach end segment exampl program given figur a rg travers forward decon struction reach segment segment follow call dodgi sinc var v empti add clone deconstruct fk v construct substitut g continu travers appli substitut balancedl r replac balancedl r note k v never use reach end segment start segment insert new clone deconstruct construct new current substitut g process later segment similar segment share interv which must interv end start switch transform insert clone unic uniqu anchor start segment figur a would mean insert singl clone deconstruct immedi call compar instead three clone deconstruct start three switch arm show figur b howev mercuri code gener load variabl cell need to code gener transform therefor exactli eect code figur b optim extend straightforward manner case cell variabl b eld variabl anoth deconstruct eg c gbbbk simpli appli optim rst deconstruct b faan appli optim c achiev desir eect implement optim two pass procedur bodi rst pass backward travers build data structur describ interv segment goe along reach deconstruct unic use data structur nd candid variabl appli match algorithm nd candid access via cell vari abl updat data structur ect result associ transform would be appli transform yet instead transform requir optimiz deconstruct perform second forward travers procedur perform evalu implement optim describ paper melbourn mercuri compil initi test found necessari add two tune paramet onepath node ratio threshhold valu opr accept result match algorithm given path ratio number benet node number cost node comput match least opr allpath node ratio threshhold valu apr accept result match algorithm ratio total number benet node total number cost node path least apr accept result match algorithm must pass threshold fail one threshold algorithm use cell access path eld variabl store eld variabl stack exampl consid program figur contain one path whose match shown figur ratio unmark benet node unmark cost node which correspond benet cost access opr optim reject store stack slot sinc one path allpath ratio same exampl program figur a three path abbcc abdbd abb match shown figur ratio unmark benet node unmark cost node abbcc abdbd ratio abb onepath node threshold reject transform lead code figur b unless opr three path share benet node share one cost node one look path benet node cost node ratio henc allpath node threshold reject transform apr increas onepath node ratio threshhold beyond kind eect increas number node alloc cell variabl load store rel number node alloc eld variabl load store advantag set threshhold say signicantli cheaper compil time run match algorithm graph copi cost node four copi benet node allpath node ratio threshhold pose dierent test onepath node ratio threshhold dierent path share benet the elimin eld variabl store mayb load princip compon cost the insert cell variabl load segment control impact optim execut size allpath node ratio threshhold use control impact optim execut size oper number node set paramet virtual guarante optim increas size execut cost oper node benet opera tion set paramet virtual guarante applic transform strictli decreas size execut one cannot make concret guarante c compil mercuri compil nal say execut size two reason found threshold nec essari first impact pipelin eect cach program line opt opt opt opt opt mmc compress ray tabl perform evalu eect discuss section vari depend circumst sometim variat make transform program faster origin sometim make slower threshold allow us lter applic transform highest chanc slow program leav applic like yield speedup second even origin program transform program perform respect cach pipelin eect reason prefer origin program reason concern happen cell variabl becom dead eld variabl still aliv origin program garbag collector may abl reclaim storag occupi cell dead eld variabl sinc may live root point them transform program reclam possibl live root reachabl cell variabl whose lifetim transform artici extend therefor test test program sever set paramet valu unfortun whole paramet space big search even close exhaust realli feasibl due space limit cannot present result paramet set howev four chosen repres result have comment make still true one look result date four set paramet valu cost cell variabl load set three oper cost one sinc preliminari investig suggest roughli right set dier valu one path allpath node ratio threshhold four combin paramet valu report onepathallpath test program follow mmc test case melbourn mercuri compil compil six largest modul code compress mercuri version compress benchmark specint suit next two entri involv group entri recent icfp program contest entri ray tracer gener ppm le structur descript scene entri sourcetosourc compress program hypothet markup languag nuc mercuri version pseudoknot benchmark execut time ray ray trace program gener pictur helix dodecahedron benchmark machin dell pc mhz pentium iv mb linux tabl show result rst column identi benchmark program second give size sourc line code measur word count program wc third column give time taken program compil without stack slot optim follow four group two column give time take compil stack slot optim indic set paramet valu ratio time unoptim time time deriv execut benchmark program eight time discard highest lowest time averag remain time tabl show wide rang behavior compress optim eect compress simpli contain kind code optim appli to two program icfp ray stack slot optim consist give speedup icfp stack slot optim consist give slowdown around nuc stack slot optim give speedup bit set paramet valu slowdown bit set paramet valu clearli indic transform perform stack slot optim beneci other harm dierent paramet valu admit dierent proport two kind gener rais threshold reduc probabl slowdown also reduc amount speedup avail one cannot guarante given threshold valu exclud undesir applic transform without also guarante also exclud desir one icfp paramet valu explor which rang admit mani wrong kind use paramet valu use higher cost cell load store may yield speedup icfp also mmc stack slot optim achiev speedup rang one consid one expect program spend much time stack access it also alloc memori cell in make decis perform call return arithmet collect garbag result show elimin mayb one quarter stack access result look impress interestingli previou benchmark run which may typic slightli earlier version compil yield somewhat smaller speedup around still pretti good result think reason largest complex program benchmark suit give far best result also far program make use complex data structur small program tend use rel simpl data structur code travers complex data structur also complex therefor big therefor reason believ perform stack slot optim larg program like resembl behavior mmc benchmark program howev fact stack slot optim sometim lead slowdown mean may good idea compil turn automat probabl better let programm test eect benchmark also show stack slot optim usual reduc size execut usual case increas tini amount less nice given mani optim improv speed cost addit memori enabl stack slot optim slow compil slightli case seen impact compil time rang case seen go seen higher that also look eect optim size stack frame test version mercuri compil predic whose implement need stack frame paramet valu explor stack slot optim abl reduc size stack frame predic also reduc averag size stack frame averag predic word word oddli enough optim lead trivial reduct less stack space requir execut compil point compil requir maximum stack space virtual frame stack predic whose stack frame size aect optim conclus relat work optim describ replac number stack access equival smaller number heap access mani case optim reduc number memori access requir execut pro gram optim also reduc size pro cedur stack frame improv local make cach eectiv optim lead signific perform improv program manipul complex data structur default usag optim need conserv order avoid slowdown paramet valu would appear suitabl thi gain maximum benet optim programm may need explor paramet space sinc conserv threshhold restrict benet optim optim dene somewhat similar remateri regist alloc eg sometim easier recomput valu variabl keep regist remateri optim eectiv split lifetim variabl order reduc pressur regist stack slot key dier enc remateri variabl independ variabl wherea complex problem aris interdepend choic stack slot fact mercuri compil long optim took variabl denit form b f f constant clone segment b need order avoid store b stack substitut dierent variabl b segment unlik optim present paper optim requir analysi all also somewhat relat partial dead code elimin save load initi segment eectiv result sink calcul eld variabl point later program code restrict candid eld variabl ensur sink add overhead worth discuss optim appli languag optim applic prolog even without mode inform sinc even though rst occurr unic may neither construct deconstruct execut copi ad algorithm deconstruct good prolog compil take advantag inform execut ecient cours without inform determin optim danger simpli assum code determinist reason quit larg proport prolog code unfortun advantag like visibl wambas compil sinc regist wam memori strict function languag ml optim straightforwardli applic sinc mode inform syntact avail code alway determinist optim avail next major releas mercuri system also avail releaseoftheday mercuri system httpwwwcsmuozaumercuri near futur r regist alloc spill via graph color david je bernhard ste execut algorithm mercuri tr remateri partial dead code elimin regist alloc myampersandamp spill via graph color