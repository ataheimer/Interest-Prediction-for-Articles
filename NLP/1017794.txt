t methodolog gener verifi combinatori circuit a highlevel program languag offer signific express provid littl guarante resourc use resourcebound languag hardwaredescript languag provid strong guarante runtim behavior comput often lack mechan allow programm write structur modular reusabl program overcom basic tension languag design recent work advoc use resourceawar program rap languag take account natur distinct develop platform deploy platform resourceconstrain softwarethi paper investig use rap languag gener combinatori circuit key challeng encount rap approach safe admit mechan express posteriori postgener optim paper propos studi use abstract interpret overcom problem approach illustr use indepth analysi fast fourier transform fft gener comput compar gener fftw b introduct hardwar descript languag primarili concern resourc use except highend applic verifi support nsf itr put multistag annot work permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee septemb pisa itali correct hardwar system prohibit expen sive contrast softwar languag primarili concern issu express safeti clariti maintain softwar languag provid abstract mechan higherord function polymorph gener recurs abstract mechan make design maintain reusabl also keep program close mathemat definit algorithm implement help ensur correct hardwar descript languag vhdl verilog provid limit support abstract mechan grow interest reconfigur hardwar invit us consid integr hardwar softwar world consid verif techniqu one world use appli other current program reconfigur hardwar hard first softwar develop typic train design circuit second specifi circuit hand tediou error prone difficult maintain challeng integr hardwar softwar world summar key question get raw perform hardwar without give express clariti softwar gener manifest interfac recent work resourceawar program rap context softwar gener suggest promis approach hardwar verif rather verifi circuit case bycas basi propos circuit design express gener specif automat gener whole famili cir cuit technic novelti approach gener specif verifi guarante gener circuit correct approach naivelygener circuit correct construct effici circuit correct produc systemat verifi improv correct naiv gener verifi naiv gener verifi posteriori postgener optim fix result gener verif point view mean replac problem verifi transform one verifi modif one program gener classic exampl gener one use selesnick burru produc fast fourier transform fft circuit primenumb size extens survey found frigo account fftw system write use program gener howev challeng cf one challeng manifest interfac gener hard express tradit type system exampl string algebra datatyp pars tree even graph use repres gener program would allow us express manifest interfac type as circuit type choos repres circuit with soon start compos gener exampl want build circuit comput fft perform multipli cation comput invers fft run prob lem type circuit provid static guarante consist wellformed composit circuit illustr assum given two trivial gener take input produc andgat invert meaningless composit aris write connect oper infix oper type circuit circuit circuit wire output first circuit input second circuit problem second circuit one input two type system prevent error circuit type circuit gener desir circuit type express possibl time express valu circuitrealiz exampl programm might want use abstract list or dynam data structur describ circuit need know earli possibl develop process use realiz use finit memori resourceawar program resourceawar program rap languag design address problem describ provid highli express untyp substrat support featur dynam datastructur modul object higherord function allow programm express stage distinct comput develop platform comput deploy platform conveni notat static type safeti ensur use multistag program msp construct use advanc static type system ensur comput intend execut resourcebound platform inde resourcebound combin three ingredi allow programm use sophist abstract mechan program static guarante gener resourcebound program exampl rather use one concret type repres circuit rap languag provid abstract datatyp parameter inform gener code type two trivial gener would be type connect oper would refin code code code gener type variabl must alway instanti consist extra inform type system reject bad declar type variabl cannot instanti output inv which bool input which boolbool note type function similar type standard mathemat function composit oper addit ensur gener program well type rap languag also ensur gener program satisfi variou notion resourc constraint cf problem ensur gener program welltyp resourcebound gener code type rap languag must remain abstract provid construct travers valu type jeopard sound decid static type complic reason correct program written languag time abl look insid code mean posteriori optim cannot express within languag optim still implement standalon sourcetosourc transform outsid languag invalid safeti resourcebounded guarante distinguish two form posteriori optim gener one independ applic one specif applic gener optim gener welltest less like invalid guarante provid rap set domainspecif optim written programm particular applic less like test extens therefor problemat time system fftw make strong case practic import domainspecif optim therefor face technic problem implement domainspecif optim without lose benefit rap framework contribut paper propos use abstract interpret program gener avoid need posteriori optim allow us gener desir circuit without lose guarante provid rap languag benefit propos techniqu extend untyp set avoid gener larg circuit first place thu reduc overal runtim need gener accept code verif point view approach replac problem verifi sourcetosourc transform verifi correct finit set optim one specif program gener propos method abstract interpret carri four initi standard step build program gener implement inputoutput behavior express typesaf languag ocaml run exampl use fft fft step implement cooleytukey recurr comput fft verifi correct inputoutput behavior program use express languag implement fft step reduc make sure first textbook definit cooleytukey recurr transcrib correctli and second program correctli transform monad style monad transform welldefin mechaniz paper explain monad transform or style conveni use propos approach often necessari convert whole program monad style so transform done hand done need identifi relev comput stage program cf involv determin part comput done develop platform must left deploy platform add stage annot step stage construct hy gienic quasiquot ensur done semant transpar manner twolevel type system understand use quasiquot gener program cf ensur inconsist use first secondstag input rap type system goe ensur secondstag comput use featur resourc avail target platform sourc code result gener often concis minor variat result first step qualiti gener code satisfactori paper propos follow addit step use abstract interpret techniqu shift comput develop platform rather deploy platform step gener lead smaller effici circuit short term technolog reduc time effort need program reconfigur hardwar reconfigur hardwar potenti deliv signific perform improv comput intens applic do main exampl najjar et al report speedup time highlytun softwar implement rather perform numer intens kernel nativ softwar platform rest applic implement system offshor kernel fieldprogramm gate array fpga fieldprogramm hardwar wellsuit massivelyparallel implement comput express combinatori circuit longer term hope propos approach posit impact vlsi logic design verif relat work work build long tradit use function program languag describ hardwar circuit rubi lava hawk hml hydra reflect how ever none languag provid kind manifest interfac static type discuss abov hardwaredescript languag recogn need macro distinguish circuit descript circuit exampl sac singleassign arraybas languag sa cs facil improv c macro system provid neither express higherord languag manifest interfac static guarante deliv rap type system mckay singh use partial evalu an autom approach stage dynam special fpga special optim circuit use intension analysi program partial evalu system user chose two level abstract either treat tool black box case control gener process deleg tool treat tool white box case wellform correct guarante gener code void twolevel static type system allow programm safe gain full control gener process safl allow programm breakdown comput compon implement hardwar softwar safl firstord monomorph type languag whole comput must resourc bound thu rap point view whole safl comput perform deploy platform hardwarec similar safl use clike imper featur organ paper section give quick introduct basic stage explain basic approach context minim exampl though static type system metaocaml check type correct circuitrealiz code suffici present valid idea abstract interpret code gener section describ fast fourier transform express function languag stage section describ generationtim optim optim enabl abstract interpret gener code show effect techniqu compar number float point oper result naiv stage version fftw system section conclud abstract interpret power stage construct mechan distinguish comput stage program follow minim exampl illustr use construct metaocaml let rec power n n els x power n x ignor stage construct bracket escap e code standard definit function comput use defin special function x without stage last step simpli return function would invok power function everi time get invok valu x contrast stage version build function comput third power directli that is use multipl see stage construct work start last statement code abov wherea term fun x e x valu annot term fun x e not outer bracket contain escap express still need evalu bracket mean want construct futur stage comput escap mean want perform immedi comput build bracket comput multistag languag construct hint imper thu applic e must perform even though x still uninstanti symbol power ex ampl power perform immedi all repeat everi time new valu x bodi definit function power recurs applic power escap ensur immedi execut first stage evalu definit power first result fun x x x x wherea implement unstag definit power hardwar nontrivi stage one evalu program clearli circuitrealiz abstract give minim exampl abstract interpret gener use consid presenc multipl bodi power resort posteriori techniqu elimin unnecessari comput code gener requir make code data type less abstract disadvantag void equat reason principl comput insid bracket essenti reduc syntact quotat cf footnot equal importantli ensur static type safeti would necessit use higherord type cf abstract interpret allow us avoid problem still achiev essenti result first step appli abstract interpret identifi concret domain gener code type use pro gram would like look insid type gener implicit origin program second step design abstract domain provid us inform code valu exampl use one int code type split singl case concrete_cod two first indic inform code valu name liter second say addit inform code valu note term concret abstract may seem backward not abstract type approxim second stage valu concret type see abstract type contain inform origin type need present concret function convert abstract_cod concrete_cod let conc match c one c c next step lift oper concret type abstract type use work done first stage less work left second stage oper power function use multipl oper achiev desir effect defin correspond abstract oper follow match xy one one one one y x one x x y conc x conc y seen definit abstract_cod type make possibl directli express optim would requir inspect concrete_cod type wherea concret function express within languag abstract function would go way can not particular latter requir inspect valu abstract type code stage function express as let rec power n n one els x power n x evalu declar fun x conc power ani would yield precis desir result fun x x x x last multipl elimin simpl exampl abstract interpret gener code provid systemat safe approach achiev essenti result posteriori optim next two section show scale substanti exampl fft yield result compar produc fftw system stage fft fft find applic mani timecrit embed applica tion therefor import abl gener effici circuit it use fft run exampl paper section begin show fft implement pure function manner ocaml then metaocaml stage construct use express variant function special respect size input vector unstag fft implement basic cooleytukey recurr implement as let rec fft dir l listlength l els l merg dir two paramet be direct flag dir input vector l repres list input vector length one simpli return it otherwis split vector even odd compon eo recurs appli fft subvector merg result complex number auxiliari function complex number repres pair ocaml float oper complex addit implement follow let add ri r function split merg use defin fft implement follow let rec split l match l xyx let rec merg dir l let rec mg l l match l l xx yy zxa zyb _ function w comput power nth complex root uniti monad share avoid explos size gener code use monad librari share requir rewrit part fft program monad style explicit open recurs let fft dir f l listlength ret l els l bind f e fun bind f o fun ret merg dir y new paramet f use place recurs call fft dir bodi origin function return ret bind two standard monad oper get exactli function origin program would use monad librari ret ident function noop bind pass result first argument second one detail monad librari monad share beyond scope paper describ elsewher purpos paper reader view librari avoid code duplic gener exampl fft merg function need convert monad style stage fft stage fft respect size input vector add stage annot get stage fft function fft ms stage function take vector code valu denot delay element sinc oper split parametr element requir explicit stage merg function written monad style chang use stage version complex arithmet function name w s add s sub s mult the ret oper exactli ret oper use befor stage function achiev ad stage annot origin one exampl add function defin as let add_ ri r let merge_m dir l let rec mg l l match l l xx yy bind ret mult_ w_ dir n j y fun z bind ret add_ x zfun zx bind ret sub_ x zfun zy bind mg xs ys j fun ab ret zxa zyb _ ret bind mg l l ret a b fft function use stage monad version merg let fft_m dir f l listlength els l bind f e fun bind f o fun merge_m dir y use fft ms pass monad fix point oper sm result monad valu pass appropri monad run combin runm fun x run y_sm fft_m n follow focu qualiti code gener comput improv use abstract interpret gener code auxiliari function nonstandard run construct see allow metaocaml output c function code correspond stage definit special size input vector preliminari syntax nonstandard run construct current trxrun gcc gcc replac name differ backend compil icc f input vector size get follow output result translat c is int __fun_defdoubl x_ doubl doubl doubl doubl doubl doubl doubl doubl x_ return function __fun_def take array four complex num ber realiz array four pair doubl two floatingpoint number pair repres real imaginari part complex number respect function comput fft inplac exit function input array contain comput transform code repres fulli unfold complex fft comput sampl size singleassign straightlin code easili translat combinatori circuit what wrong gener code gener code point need domainspecif opti mizat suffer obviou problem includ repeat comput y_ y_ appear subexpress larger express statement x_x_ assign array element temporari temporari use onc also statement y_x_ kind statement perform unnecessari move trivial expens float point multipl factor roundoff error result unnecessari comput multipl e exact point fft contain factor exactli zero furthermor replac factor exact zero would lead cascad simplif aggress compil optim might elimin problem mani them ensur elimin requir knowledg fft algorithm note mean posteriori optim need follow illustr point show benefit focus write better gener rather fix result simpl gener abstract interpret fft use abstract interpret seri refin gener show problem identifi end last section address key featur modif extract inform secondstag or gener comput make avail first stage abstract domain want avoid code duplic want avoid trivial multipl addit therefor need two abstract domain stack one top other domain success refin float type use element vector produc fft first domain exp float code keep track whether code valu cheap duplic complic express tag exp simpl express a float liter exampl tag val second domain lit float float maybevalu allow us construct complex arithmet oper discrimin liter known gener time comput not comput valu unknown gener stage tag ani valu repres multipl known factor keep factor floatingpoint datatyp analog one discuss section carri inform code valu must stress inform fragment liter simpl variabl refer etc obtain look insid code fragment rather make note inform gener code fragment data avail us gener time never look insid code gener element type view sometim exact approxim futurestag valu note also abstract interpret respect gener code fragment abstract interpret section defin concret function two abstract domain defin abov val x x exp x x anyx x anyx exp mvconc x anyfactorx exp factor mvconc x function success forget inform result mvconc opaqu code valu inform valu gener stage forgotten function conc intern multipl factor comput yield maybevalu avoid code duplic trivial bind butterfli oper offer opportun avoid repeat comput oper repres follow code snippet appear merg ms abov bind ret mult_ w_ dir n j y fun z bind ret add_ x z fun zx bind ret sub_ x z fun zy multipl mult_ w_ dir n j y use subsequ add_ sub_ oper one might expect bind result valu z avoid repeat com putat inde case unstag program stage program multipl first line realli symbol z use two place comput duplic alreadi mention one techniqu avoid form code explos monad share butterfli problem point need concis control way name intermedi result gener avoid duplic express contain comput achiev defin variant monad return oper name argument name get duplic call variant retn defin appendix a retn oper singl valu must deal tupl maybevalu domain repres complex number therefor rais retn work valu type use function liftcm retn v defin appendix a allow us gener name bind exp variant avoid gener trivial bind for val variant result code merg oper shown let merge_mv dir l let rec mg l l match l l xx yy bind liftcm retn_v x fun x bind liftcm retn_v y fun bind liftcm retn_v fun z bind ret add_sv x z fun zx bind ret sub_sv x z fun zy bind mg xs ys j fun ab ret zxa zyb _ ret bind mg l l ret a b differ merg ms function two way first use liftcm retn v instead ret wherev opportun control name express second use complex arithmet oper viz add sv sub sv mult sv w sv work maybevalu domain rather float domain add sv oper simpl chang stage add oper add s let mv_add x let add_sv ri r mv_add r r mv_add i gener code result form replac merg ms merg mv fft ms function avoid duplic ex pression also avoid gener name trivial express avoid trivial oper case multipl function section replac code type abstract domain type must lift stage complex arithmet function abstract domain essenc mean studi oper defin differ case aris result use abstract interpret abstract multipl oper section made use ident x avoid redund comput gener code similarli use ident avoid unnecessari addit multipl fft code exampl addit function add defin abstract domain abstract code use ident x avoid gener unnecessari addit oper function lit variant allow us discrimin zero valu other thu perform case analysi given code fragment below let rec add_a n match n n x lit x similarli know valu pair factor use inform avoid gener unnecessari multipl use ident f x code fragment ani fxx fyy fy fxmv_add x y els case gener code addit mv_add x gener code multipl common fac tor rather carri factor along multipl factor gener need excerpt illustr inform known annot input fragment use set appropri annot output fragment again never examin gener code itself addit oper add individu valu use defin addit oper complex valu let add_ta r i r add_a r r add_a i i subtract sub ta multipl mul ta oper use abstract interpret avoid gener trivial oper code similarli defin avoid roundoff error factor fft algorithm root uniti order n n sampl size n known gener time comput factor then follow function w comput return result pair lit floatingpoint number repres one complex number let w_a dir exp dir pi jn dir expdir pi i exp dir pi i exp dir pi i j mod must odd cos_sign sin_sign els quadrant lit csh cos_sign quadrant lit csh sin_sign quadrant els float_of_int j pi float_of_int n lit co theta lit sin theta gener exact valu possibl eg co is exactli zero comput e i ensur real imaginari part ident due specif librari trigonometr function comput valu co is ident comput valu sin as result success refin code function merg defin as let merge_a dir l let rec mg l l match l l xx yy bind liftcm retn_va x fun x bind liftcm retn_va y fun bind liftcm retn_va mul_ta w_a dir n j y fun z bind ret add_ta x z fun zx bind ret sub_ta x z fun zy bind mg xs ys j fun ab ret zxa zyb _ ret bind mg l l stepwis refin earlier merg mv function involv chang oper new oper viz retn va abstract away sign factor perform name bind similar done retn v earlier mul ta add ta sub ta perform optim complex arithmet oper w gener exact float valu possibl chang fft function use merg instead merg mv effect abstract interpret code gener gener code use stage fft function describ gener code point fft yield follow code int __fun_defdoubl x_ doubl doubl doubl doubl doubl doubl return code contain fewer oper present abstract interpret problem point address fact code contain floatingpoint multipl all inspect gener code point complex fft show use floatingpoint multipl floatingpoint addit subtract exactli number oper code gener fftw tabl figur summar measur effect abstract interpret fft first column give size fft input vector second column give number floatingpoint multiplicationsaddit or subtract code result direct stage third column show number multiplicationsaddit code result use abstract interpret techniqu stage last column show number multiplicationsaddit code gener fftw variou problem size tabl indic gener fft circuit improv abstract interpret abstract interpret produc circuit almost float point oper fftw number fftw obtain codelet fftw codelet sampl size valu estim base valu smaller size gener fft algorithm size direct stage abst interp fftw figur number floatingpoint multiplicationsaddit fft transform differ sampl size conclus propos methodolog write gener produc famili effici combinatori circuit build top rap languag programm guarante gener program would welltyp circuitrealiz gener written express languag easier ascertain correct gener and turn correct full famili gener circuit illustr use stage memoiz abstract interpret make possibl refin gener seri small modif gener effici circuit key featur methodolog avoid ad construct intension analysi gener code ensur static welltyped resourc bounded guarante rap languag pre serv inabl travers gener code sever limit posteriori optim run exampl fft circuit show abstract interpret provid promis altern approach allow us keep nextstag datatyp abstract immedi goal futur work see optim perform fftw achiev use abstract interpret particular implement present perform obviou optim broadli interest develop monad librari support use abstract interpret resourceawar program acknowledg would like thank jason eckhardt stephan ellner roumen kaiabachev help comment r structur interpret comput program hardwar design haskel map singl assign program languag reconfigur system implement multistag languag use ast abstract interpret unifi lattic model static analysi program construct approxim fixpoint densiti advantag configur comput monad multistag program fast fourier transform compil reflect function languag hardwar design theorem prove type system bound space function inplac updat design arithmet circuit refin rubi embed microarchitectur design languag within haskel object caml seek solut configur comput hml languag highlevel design highfrequ circuit dynam specialis xc fpga partial evalu metaocaml compil notion comput monad integr formal method digit circuit design hydra oregon graduat institut technic report emir pasal higherlevel languag hardwar synthesi sound reduct semant untyp cbn multistag comput gentl introduct multistag program gener imper environ classifi verilog hardwar descript languag comprehend monad tr comprehend monad notion comput monad fast fourier transform compil embed microarchitectur design languag within haskel sound reduct semant untyp cbn mutlistag comput or theori metaml nontriv extend abstract map singl assign program languag reconfigur system abstract interpret verilog hardwar descript languag structur interpret comput program tagless stage interpret type languag environ classifi seek solut configur comput densiti advantag configur comput type system bound space function inplac updateextend abstract higherlevel languag hardwar synthesi dynam specialis xc fpga parial evalu design arithmet circuit refin rubi hardwarec languag hardwar design version multistag program highlevel languag abstract reconfigur comput implement multistag languag use ast gensym reflect ctr christoph a herrmann tobia langhamm combin partial evalu stage interpret implement domainspecif languag scienc comput program v n p septemb edwin bradi kevin hammond verifi stage interpret verifi compil proceed th intern confer gener program compon engin octob portland oregon usa kedar swadi walid taha oleg kiselyov emir pasal monad approach avoid code duplic stage memoiz function proceed acm sigplan symposium partial evalu semanticsbas program manipul januari charleston south carolina jacqu carett gaussian elimin case studi effici gener metaocaml scienc comput program v n p septemb albert cohen sbastien donadio mariajesu garzaran christoph herrmann oleg kiselyov david padua search program gener implement gener transform highperform comput scienc comput program v n p septemb