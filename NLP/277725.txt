t implement cilk multithread languag a fifth releas multithread languag cilk use provabl good worksteal schedul algorithm similar first system languag complet redesign runtim system complet reengin effici new implement aid clear strategi aros theoret analysi schedul algorithm concentr minim overhead contribut work even expens overhead contribut critic path although may seem counterintuit move overhead onto critic path workfirst principl led portabl cilk implement typic cost spawn parallel thread time cost c function call varieti contemporari machin mani cilk program run one processor virtual degrad compar equival c program paper describ workfirst principl exploit design cilk compil runtim system particular present cilk novel twoclon compil strategi dijkstralik mutualexclus protocol implement readi dequ worksteal schedul b introduct cilk multithread languag parallel program gener semant c introduc linguist construct parallel control origin cilk releas featur provabl effici random work steal schedul languag clumsi parallel expos by hand use explicit continu pass cilk languag implement research support part defens advanc research project agenc darpa grant n comput facil provid mit xola project thank gener equip donat sun microsystem appear proceed acm sigplan confer program languag design implement pldi montreal canada june latest cilk releas still use theoret effici schedul languag simplifi consider employ callreturn semant parallel featur linguist simpl inlet mechan nondeterminist control cilk design run effici contemporari symmetr multiprocessor smp featur hardwar support share memori code mani applic cilk includ socrat cilkchess chessplay program prize intern competit philosophi behind cilk develop make cilk languag true parallel extens c semant respect perform parallel comput cilk control construct allow program execut parallel cilk keyword parallel control elid cilk program howev syntact semant correct c program result call c elis or gener serial elis cilk program cilk faith extens c c elis cilk program correct implement semant program moreov one processor parallel cilk program scale down run nearli fast c elis unlik cilk cilk schedul identifi piec code cilk compil runtim system bear respons schedul obtain ef ficienc have cours attempt reduc schedul overhead overhead larger impact execut time other howev theoret understand cilk schedul algorithm allow us identifi optim common case accord abstract theori perform cilk comput character two quantiti work total time need execut comput serial criticalpath length execut time infinit number processor cilk provid instrument allow user measur two quantiti within cilk schedul identifi given cost contribut either work overhead criticalpath overhead much effici cilk deriv follow principl shall justifi section workfirst principl minim schedul overhead born work comput specif move overhead work onto critic path workfirst principl play import role design earlier cilk system cilk exploit principl extens workfirst principl inspir twoclon strategi compil cilk program cilkc compil sourcetosourc translat transform cilk sourc c postsourc make call cilk runtim librari c postsourc run gcc compil produc object code cilkc compil produc two clone everi cilk procedurea fast clone slow clone fast clone ident respect c elis cilk program execut common case serial semant suffic slow clone execut infrequ case parallel semant concomit bookkeep requir commun due schedul occur slow clone contribut criticalpath overhead work overhead workfirst principl also inspir dijkstralik sharedmemori mutualexclus protocol part runtim loadbalanc schedul cilk schedul use worksteal algorithm idl processor call thiev steal thread busi processor call vic tim cilk schedul guarante cost steal contribut criticalpath overhead work overhead nevertheless hard avoid mutualexclus cost incur potenti victim contribut work minim work overhead instead use lock cilk runtim system use dijkstralik protocol call protocol manag runtim dequ readi thread worksteal algorithm ad advantag protocol allow except signal work processor addit work overhead featur use cilk abort mechan remaind paper organ follow section overview basic featur cilk languag section justifi workfirst principl section describ twoclon strategi implement section present protocol section give empir evid cilk schedul effici final section present relat work offer conclus cilk languag section present brief overview cilk extens c support cilk for complet descript consult cilk manual key featur languag specif parallel synchroniza tion spawn sync keyword specif nondetermin use inlet abort includ stdlibh includ stdioh includ cilkh cilk int fib int n n return n els int x return cilk int main int argc char argv int n result printf result dn result return figur simpl cilk program comput nth fibonacci number parallel use bad algorithm basic cilk languag understood exampl figur show cilk program comput nth fibonacci number observ program would ordinari c program three keyword cilk spawn sync elid keyword cilk identifi fib cilk procedur parallel analog c function parallel creat keyword spawn preced invoc procedur semant spawn differ c function call parent continu execut parallel child instead wait child complet done c cilk schedul take respons schedul spawn procedur processor parallel comput cilk procedur cannot safe use valu return children execut sync statement sync statement local barrier global one as ex ampl use messagepass program fibonacci exampl sync statement requir statement return xy avoid anomali would occur x sum comput addit explicit synchron provid sync statement everi cilk procedur sync implicitli return thu ensur children termin doe ordinarili spawn procedur return return valu simpli store variabl parent frame program use ineffici algorithm run exponenti time although logarithmictim method known p program nevertheless provid good didact exampl cilk int fib int n int inlet void summer int result x result return n return n els summerspawn fib n summerspawn fib n return figur use inlet comput nth fibonnaci number occasion one would like incorpor return valu parent frame complex way cilk provid inlet featur purpos inspir part inlet featur tam inlet essenti c function intern cilk pro cedur normal syntax cilk spawn procedur must occur separ statement express except made rule spawn perform argument inlet call case procedur spawn return inlet invok meantim control parent procedur proce statement follow inlet call princi ple inlet take multipl spawn argument cilk restrict exactli one argument inlet may spawn argument must first argument necessari restrict easi program around figur illustr fib function might code use inlet inlet summer defin take return valu result add variabl x frame procedur spawn variabl fib avail within summer sinc intern function fib lock requir around access x summer cilk provid atom implicitli concern two updat might occur parallel atom impos updat might lost cilk provid implicit atom among thread procedur in stanc thread maxim sequenc instruct end spawn sync return either explicit implicit statement inlet preclud contain spawn sync statement thu oper atom singl thread implicit atom simplifi reason c elis cilk program inlet ansi c ansi c support intern c function cilk base gnu c technolog howev provid support concurr nondetermin without requir lock declar critic region like cilk provid syntact sugar produc certain commonli use inlet implicitli exampl statement x spawn fibn conceptu gener inlet similar one figur sometim procedur spawn parallel work later discov unnecessari specul work abort cilk use abort primit insid in let common use abort occur parallel search mani possibl search parallel soon solut found one search one wish abort current execut search soon possibl wast processor resourc abort statement execut insid inlet caus alreadyspawn children procedur termin consid use futur implicit synchro nizat well synchron specif variabl instead use simpl spawn sync statement realiz workfirst principl howev differ synchron mechan could impact criticalpath comput issu secondari concern consequ opt implement simplic also system support relax memoryconsist model explicit sync statement use ensur sideeffect previous spawn subprocedur occur addit control synchron provid sync cilk programm use explicit lock synchron access data provid mutual exclus atom data synchron overhead born work howev although striven minim overhead finegrain lock contemporari processor expens current investig incorpor atom cilk languag protocol issu involv lock avoid user level aid debug cilk program use lock develop tool call nond detect common synchron bug call data race workfirst principl section justifi workfirst principl state section show follow three assumpt first assum cilk schedul oper practic accord theoret analysi present sec ond assum common case ampl parallel slack exist is averag parallel cilk program exce number processor run suffici margin third assum as inde case everi cilk program c elis oneprocessor perform measur theoret analysi present cite two fundament lower bound fast cilk program run let us denot tp execut time given comput p processor then work comput criticalpath length comput work lower bound tp tp must hold p unit work execut singl step addit lower bound tp must hold sinc finit number processor cannot execut faster infinit cilk random worksteal schedul execut cilk comput p processor expect time assum ideal parallel comput equat resembl brent theorem optim within constant factor sinc tp lower bound call first term righthand side equat work term second term criticalpath term importantli commun cost due cilk schedul born criticalpath term schedul cost make overhead explicit defin criticalpath overhead smallest constant c second assumpt need justifi workfirst principl focus commoncas regim parallel program oper defin averag parallel correspond maximum possibl speedup applic obtain defin also parallel slack ratio pp assumpt parallel slack pp ae c mean number p processor much smaller averag parallel p assumpt follow tp ae ct henc inequ obtain linear speedup criticalpath overhead c littl effect perform suffici slack exist although determin much slack must exist ensur linear speedup whether substanti slack exist common applic matter opinion empiric suggest slack common case express cilk make easi code applic larg amount parallel modests problem mani applic exhibit averag parallel yield substanti slack contemporari smp even sandia nation laboratori intel paragon contain node socrat chess program code cilk ran linearspeedup regim icca world comput chess championship where place second field section describ dozen divers applic run processor smp abstract model execut time ignor reallif detail memoryhierarchi effect nonetheless quit accur consider parallel slack parallelisim applic increas problem size therebi ensur run well larg machin third assumpt behind workfirst principl everi cilk program c elis oneprocessor perform measur let us denot ts run time c elis then defin work overhead incorpor criticalpath work overhead inequ yield sinc assum parallel slack restat workfirst principl precis minim c even expens larger c c direct impact perform adopt workfirst principl may advers affect abil applic scale up howev criticalpath overhead c larg but shall see section criticalpath overhead reason small cilk mani applic code larg amount parallel workfirst principl pervad cilk implementa tion worksteal schedul guarante high probabl opt steal migrat attempt occur that is ot averag per processor cost born critic path consequ schedul cilk postpon much schedul cost possibl work stolen therebi remov contributor work overhead strategi amort cost steal attempt permeat virtual everi decis made design schedul cilk compil strategi section describ cilkc compil gener c postsourc cilk program dictat work first principl compil schedul design reduc work overhead much possibl strategi gener two clone procedurea fast clone slow clone fast clone oper much c elis littl support parallel slow clone full support parallel along concomit overhead first describ cilk schedul algorithm then describ compil translat cilk languag construct code fast slow clone procedur lastli describ runtim system link togeth action fast slow clone produc complet cilk implement lazi task creation cilk proce sor call worker maintain readi dequ doubli end queue readi procedur technic procedur instanc dequ two end head tail procedur ad remov worker oper local tail dequ treat much int fib int n fibfram f frame pointer return n int x live var c call return frame stolen return xy figur fast clone gener cilkc fib procedur figur code second spawn omit function alloc free inlin call runtim system fast memori alloc signatur fib sig contain descript fib procedur includ pointer slow clone push pop call oper schedul dequ describ detail section c treat call stack push pop spawn activ frame worker run work becom thief attempt steal procedur anoth worker call victim thief steal procedur head victim dequ opposit end victim work procedur spawn fast clone run whenev thief steal procedur howev procedur convert slow clone cilk schedul guarante number steal small suffici slack exist expect fast clone execut time thu workfirst principl reduc minim cost fast clone contribut heavili work overhead minim cost slow clone although desir goal less import sinc cost contribut less heavili work overhead criticalpath overhead minim cost fast clone exploit structur cilk schedul convert procedur slow clone stolen maintain invari fast clone never stolen further more none descend fast clone stolen either sinc strategi steal head readi dequ guarante parent stolen children shall see simpl fact allow mani optim perform fast clone describ cilkc compil gener post sourc c code fib procedur figur exampl postsourc fast clone fib given figur gener c code gener structur c elis addit statement line activ frame alloc fib initi cilk runtim system use activ frame repres procedur instanc use techniqu similar inlin alloc typic take cycl frame initi line store pointer static structur call signatur describ fib first spawn fib translat line line state fib procedur save activ frame save state includ program counter encod entri number live dirti vari abl then frame push runtim dequ line next call fib routin would c spawn statement compil directli c elis postsourc exploit optim capabl c compil includ abil pass argument receiv return valu regist rather memori fib return line check see whether parent procedur stolen ha return immedi dummi valu sinc ancestor stolen well c stack quickli unwind control return runtim system protocol check whether parent procedur stolen quit subtlew postpon discuss implement section parent procedur stolen continu execut line perform second spawn shown fast clone sync statement compil noop fast clone never children exe cute know compil time previous spawn procedur complet thu oper requir sync statement alway succe exam ple line figur translat sync statement empti statement final line fib dealloc activ frame return comput result parent procedur slow clone similar fast clone except provid support parallel execut procedur stolen control suspend two procedur thread is spawn sync point slow clone resum use goto statement restor program counter restor local variabl state activ frame spawn statement translat slow clone fast clone sync statement cilkc insert call runtim system check see whether procedur spawn children return although parallel book share memori sequenti consist memori fenc must insert line ensur surround write execut proper order setjmplongjmp facil c could use well unwind strategi simpler keep slow clone substanti contribut littl work overhead sinc slow clone rare execut separ fast clone slow clone also allow us compil inlet abort statement effici fast clone inlet call compil effici ordinari spawn exampl code inlet call figur compil similarli follow cilk code implicit inlet call x spawn fibn compil directli c elis abort statement compil noop sync statement doe execut fast clone children abort runtim system provid glue fast slow clone make whole system work includ protocol steal procedur return valu processor execut inlet abort comput subtre like cost protocol amort critic path overhead significantli affect run time suffici parallel slack exist portion steal protocol execut worker contribut work overhead howev therebi warrant care implement discuss protocol detail section work overhead spawn cilk read write fast clone read write fib exampl experiment quantifi work overhead section work overhead still remain im plement howev includ alloc free activ frame save state spawn push pop frame dequ check procedur stolen portion work overhead due fact cilk duplic work c compil perform section show overhead small although product cilk compil might abl elimin unnecessari work would like compromis portabl cilk precursor cilk took workfirst principl extrem cilk perform stackbas alloc activ frame sinc work overhead stack alloc smaller overhead heap alloca tion cactu stack semant cilk stack howev cilk manag virtualmemori map processor explicitli done work overhead cilk frame alloc littl increment stack pointer whenev stack pointer overflow page expens userlevel ensu cilk would modifi memori map unfortun operatingsystem mechan support oper slow un predict possibl page fault critic sec suppos procedur spawn two children b c two children refer object as activ frame b c see other frame tion led complic protocol even though overhead could charg criticalpath term practic becam larg criticalpath term contribut significantli run time therebi violat assumpt parallel slack oneprocessor execut program inde fast insuffici slack sometim result poor parallel perform cilk simplifi alloc activ frame simpli use heap common case frame alloc remov free list dealloc perform insert frame manag virtual memori requir except initi setup share memori heap alloc contribut slightli stack alloc work overhead save substanti critic path term downsid heap alloc potenti wast memori stack alloc due fragment care analysi rel merit stack heap base alloc support heap alloc see paper appel shao equal care analysi support stack alloc see thu although workfirst principl give gener understand overhead born experi cilk show larg enough criticalpath overhead tip scale point assumpt underli principl longer hold believ cilk work overhead nearli low possibl given goal gener portabl c output compil research abl reduc overhead even more howev expens portabl exampl lazi thread obtain effici expens implement call convent stack layout etc although could principl incorpor machinedepend techniqu compil feel cilk strike good balanc perform portabl also feel current overhead suffici low problem notabl minim overhead data synchron deserv attent implement worksteal section describ cilk worksteal mecha nism base dijkstralik sharedmemori mutualexclus protocol call the protocol accord workfirst principl protocol design minim work overhead exampl megahertz ultrasparc i fib program protocol run faster hardwar lock primit first present simplifi version protocol then discuss actual implement allow except signal addit overhead although runtim system requir effort port architectur compil requir chang whatsoev differ platform sever straightforward mechan might consid implement worksteal protocol exampl thief might interrupt worker demand attent victim strategi present problem two reason first mechan signal interrupt slow although interrupt would born critic path larg cost could threaten assumpt parallel slack ness second worker would necessarili incur overhead work term ensur could safe interrupt critic section altern send interrupt thiev could post steal request worker could period poll them again howev cost accru work overhead time poll techniqu known limit overhead poll requir support sophist compil workfirst principl suggest reason put substanti effort minim work overhead worksteal protocol sinc cilk design sharedmemori machin chose implement worksteal sharedmemori rather messagepass might otherwis appropri distributedmemori implement implement victim oper directli share memori victim readi dequ crucial issu resolv race condit aris thief tri steal frame victim attempt pop one simpl solut add lock dequ use rel heavyweight hardwar primit like compareandswap testand set whenev thief worker wish remov frame dequ first grab lock solut fundament problem interrupt poll mechan describ howev whenev worker pop frame pay heavi price grab lock contribut work overhead consequ adopt solut employ di jkstra protocol mutual exclus assum read write atom protocol use three atom share variabl t h e call protocol key idea action worker tail queue contribut work overhead action thiev head queue contribut criticalpath overhead therefor accord workfirst principl attempt move cost worker thief arbitr among differ thiev attempt steal victim use hardwar lock sinc overhead amort critic path resolv conflict worker sole thief hold lock howev use lightweight dijkstralik protocol contribut minim work overhead worker resort heavyweight hardwar lock encount actual conflict thief case charg overhead victim incur critic path rest section describ protocol t return failur return success thief return failur unlockl return success figur pseudocod simplifi version protocol left part figur show action perform victim right part show action thief none action besid read write assum atom exampl t implement detail first present simplifi protocol use two share variabl h design tail head dequ respect later extend protocol third variabl e allow except signal worker except mechan use implement cilk abort statement interestingli extens introduc addit work overhead pseudocod simplifi protocol shown figur assum share memori sequenti consist code assum readi dequ implement array frame head tail dequ determin two indic h store share memori visibl processor index point first unus element array h point first frame dequ indic grow head toward tail normal con dition h moreov dequ lock l implement atom hardwar primit os call worker use dequ stack see section spawn push frame onto tail dequ spawn pop frame unless frame stolen thief attempt steal frame head dequ one thief time may steal dequ sinc thief grab l first action seen code worker alter h wherea thief increment h alter t possibl interact thief vic share memori sequenti consist memori fenc must insert line workervictim code line thief code ensur instruct execut proper order b ha c thief figur three case readi dequ simplifi protocol shade entri indic presenc frame certain posit dequ head tail mark h occur thief increment h victim decrement t consequ alway safe worker append new frame end dequ worri action thief pop oper three case shown figur case a thief victim get frame dequ case b dequ contain one frame victim decrement without interfer thiev get frame similarli thief steal frame long victim tri obtain it thief victim tri grab frame howev protocol guarante least one discov h t thief discov h t restor h origin valu retreat victim discov h t restor origin valu restart protocol acquir l l acquir thief steal dequ victim pop frame without interfer if frame still there final case c dequ empti thief tri steal alway fail victim tri pop attempt fail control return cilk runtim system protocol cannot deadlock process hold one lock time argu protocol contribut littl work overhead push frame involv overhead beyond updat t common case worker succes pop frame pop protocol perform oper memori load memori store decr ment comparison predict condit branch moreov common case thief oper dequ h cach exclus worker expens oper worker grab lock l occur thief simultan tri steal frame pop sinc number steal attempt depend rel heavi cost victim grab l consid part criticalpath overhead c influenc work overhead c ran experi determin rel perform protocol versu straightforward protocol pop lock dequ access it megahertz ultrasparc i protocol faster simpl lock protocol machin memori model requir memori fenc instruct membar insert line pop pseudocod tri quantifi perform impact membar instruct experi execut time code without membar same megahertz pentium pro run linux gcc protocol faster lock protocol processor protocol spend half time memori fenc replac lock memori synchron protocol nonblock straightforward lock protocol consequ protocol less prone problem aris spin lock use extens exampl even worker suspend oper system execut pop infrequ lock protocol mean usual complet steal oper worker dequ recent work arora et al shown complet nonblock worksteal schedul im plement use idea lisiecki medina modifi cilk schedul make complet non block experi protocol greatli simplifi nonblock implement simplifi protocol extend support signal except worker figur index h play two role mark head dequ mark point worker cannot cross pop place dequ need same full protocol separ two function h two variabl h mark head dequ e mark point victim cannot cross except condit occur includ frame stolen also use except exampl set caus worker discov except next pop new protocol e replac h line workervictim moreov line workervictim replac call except handler determin type except stolen frame otherwis proper action perform thief code also modifi tri program size fib blockedmul notempmul strassen cilksort yqueen yknapsack heat theta figur perform exampl cilk program time second accur within serial program c elis cilk program except program star parallel program implement differ algorithm serial program program label dagger y nondeterminist thu run time one processor work perform comput program valu indic actual work comput processor run time one processor steal thief increment e noth steal restor e origin valu otherwis thief steal frame h increment h point view worker common case simplifi protocol compar two pointer e rather h t except mechan use implement abort cilk procedur execut abort instruct runtim system serial walk tree outstand descend procedur mark descend abort signal abort except processor work descend next pop abort procedur discov except notic abort return immedi conceiv procedur could run long time without execut pop discov abort made design decis accept possibl unlik scenario figur cycl like lost work overhead abandon protocol mechan solv minor problem benchmark section evalu perform cilk show applic work overhead c close indic cilk implement exploit workfirst principl effect present breakdown cilk work overhead c four machin final present experi show criticalpath overhead c reason small well figur show tabl perform measur taken cilk program sun enterpris smp megahertz ultrasparc processor kilobyt l cach kilobyt l data instruct cach run solari compil program gcc optim level o full descript program see cilk manual tabl show work cilk program critic path two deriv quantiti p c tabl also list run time processor speedup tt rel oneprocessor execut time speedup tst rel serial execut time program averag parallel p case quit larg rel number processor typic smp measur valid assumpt parallel slack impli work term domin inequ instanc theta matri ce notempmul run averag parallel yield adequ parallel slack sever hundr processor even larger machin one normal would run small problem notempmul well applic averag parallel grow problem size thu suffici parallel slack like exist even much larger machin long problem size scale appropri work overhead c percent larger program show design cilk faith implement workfirst principl two case work overhead larger cilksort choleski due fact chang serial algorithm obtain parallel algorithm thu comparison c elis exampl serial c algorithm sort inplac quicksort parallel algorithm cilksort requir addit temporari array add overhead beyond overhead cilk it self similarli parallel choleski factor use quadtre represent spars matrix induc work linkedlist represent use serial c algorithm final work overhead fib larg fib essenti work besid spawn procedur thu overhead good estim cost cilk spawn versu tradit c function call small overhead spawn one understand applic perform signific work spawn overhead cilk schedul bare notic compar nois measur mhz mip r ultra sparc mhz pentium pro alpha overhead protocol frame alloc state save ns ns ns ns figur breakdown overhead fib run one processor variou architectur overhead normal run time serial c elis three overhead save state procedur spawn alloc activ frame procedur protocol absolut time given perspawn run time c elis present breakdown cilk serial overhead c compon schedul overhead small program perform analysi fib program figur program unusu sensit schedul overhead contain littl actual comput give breakdown serial overhead three compon overhead save state spawn overhead alloc activ frame overhead protocol figur show breakdown cilk serial overhead fib four machin methodolog obtain number follow first take serial c fib program time execut then individu add code gener overhead time execut result program attribut addit time requir modifi program schedul code ad order verifi number time fib code cilk overhead ad the code shown figur compar result time sum individu overhead case two time differ less overhead vari across architectur overhead cilk typic time c run time spawnintens program overhead alpha machin particularli larg nativ c function call fast compar architectur statesav cost small fib four architectur write buffer hide latenc write requir also attempt measur criticalpath overhead c use synthet knari benchmark synthes comput artifici wide rang work criticalpath length figur show outcom mani experi figur plot measur normal normal machin size experiment data model work bound critic path bound figur normal speedup curv cilk horizont axi number p processor vertic axi speedup ttp data point normal divid tt graph also show speedup predict formula speedup ttp run machin size p run order plot differ comput graph normal machin size speedup divid valu averag parallel done run horizont posit plot datum invers slack pp thu normal machin size number processor equal averag parallel vertic posit plot datum ttp measur fraction maximum obtain speedup seen chart almost run bench mark observ tp tp t one except data point satisfi tp tp workfirst principl caus us move overhead critic path abil cilk applic scale significantli compromis conclus conclud paper examin relat work mohr et al introduc lazi task creation implement mult languag lazi task creation similar mani way lazi schedul techniqu mohr et al report work overhead around compar serial t scheme dialect mult base research confirm intuit behind method show work overhead close achiev cid languag like cilk use c base languag simpl preprocess compil convert parallel cid construct c cid design work distribut memori environ employ latencyhid mechan cilk could avoid we work distribut version cilk howev cilk cid recogn attract base parallel languag c leverag c compil technolog highperform code cilk faith extens c howev support simplifi notion c elis allow cilk exploit c compil technolog readili tam lazi thread also analyz mani overhead issu gener nonstrict languag set individu perform whole host mechan requir applic obtain good overal perform contrast cilk multithread languag provid execut model base work criticalpath length allow us focu implement effort use workfirst principl use principl guid concentr optim effort commoncas protocol code develop effici portabl implement cilk languag acknowledg grate thank contribut cilk develop includ bobbi blumof ien cheng dailey mingdong feng chri joerg bradley kuszmaul phil lisiecki alberto medina rob miller ask plaat bin song andi stark volker strumpen yuli zhou mani thank user provid us feedback suggest improv martin rinard suggest term workfirst r empir analyt studi stack versu heap cost languag closur thread schedul multiprogram multiprocessor execut multithread program ef ficient schedul multithread comput work steal parallel evalu gener arithmet express detect data race cilk program use lock introduct algorithm solut problem concurr program control poll effici stock hardwar effici detect determinaci race cilk program lazi thread implement fast parallel call bound multiprocess time anoma lie heap o stack time space effici thread without oper system support cilk system parallel multithread comput jr make multiprocessor comput correctli execut multiprocess program person commun garbag collect fast function function lisp funarg problem call environ prob lem parallel symbol comput cid vlsi support cactu stack orient memori organ bridg model parallel comput tr multilisp languag concurr symbol comput vlsi support cactu stack orient memori organ bridg model parallel comput introduct algorithm finegrain parallel minim hardwar support compilercontrol thread abstract machin poll effici stock hardwar wholeprogram optim time space effici thread cilk system parallel multithread comput lazi thread cilk execut multithread program effici effici detect determinaci race cilk program thread schedul multiprogram multiprocessor detect data race cilk program use lock parallel evalu gener arithmet express solut problem concurr program control lazi task creation parallel symbol comput cid garbag collect fast stack faster function function lisp funarg problem call environ problem ctr liang peng wengfai wong chungkwong yuen silkroad ii mix paradigm cluster comput rc_dag consist parallel comput v n p august matteo frigo fast fourier transform compil acm sigplan notic v n april kalyan s perumalla richard m fujimoto effici largescal processori parallel simul proceed th confer winter simul p decemb washington dc unit state doug lea java forkjoin framework proceed acm confer java grand p june san francisco california unit state christoph j hugh radek grzeszczuk eftychio sifaki daehyun kim sanjeev kumar andrew p sell jatin chhugani matthew holliman yenkuang chen physic simul anim visual effect parallel character chip multiprocessor acm sigarch comput architectur new v n may yaron shoham sivan toledo parallel random bestfirst minimax search artifici intellig v n p may philip cox simon gauvin andrew rauchaplin ad parallel visual data flow program proceed acm symposium softwar visual may st loui missouri voonye vee wenj hsu localitypreserv loadbalanc mechan synchron simul sharedmemori multiprocessor proceed fourteenth workshop parallel distribut simul p may bologna itali marcel van lohuizen gener approach parallel chart pars applic lingo proceed th annual meet associ comput linguist p juli toulous franc bryan chan tarek s abdelrahman runtim support automat parallel java program journal supercomput v n p april madanl musuvathi shaz qadeer iter context bound systemat test multithread program acm sigplan notic v n june gregori w price david k lowenth compar analysi finegrain thread packag journal parallel distribut comput v n p novemb kenjiro taura kunio tabata akinori yonezawa stackthreadsmp integr futur call standard acm sigplan notic v n p aug dorit naishlo joseph nuzman chauwen tseng uzi vishkin toward first vertic prototyp extrem finegrain parallel program approach proceed thirteenth annual acm symposium parallel algorithm architectur p juli crete island greec robert ennal simon peyton jone optimist evalu adapt evalu strategi nonstrict program acm sigplan notic v n p septemb radu rugina martin rinard pointer analysi multithread program acm sigplan notic v n p may john s danah ite angelina lee charl e leiserson program except jcilk scienc comput program v n p decemb matteo frigo fast fourier transform compil acm sigplan notic v n p may rezaul alam chowdhuri vijaya ramachandran cacheoblivi gaussian elimin paradigm theoret framework parallel experiment evalu proceed nineteenth annual acm symposium parallel algorithm architectur june san diego california usa kenjiro taura kenji kaneda toshio endo akinori yonezawa phoenix parallel program model accommod dynam joiningleav resourc acm sigplan notic v n octob sanjeev kumar christoph j hugh anthoni nguyen carbon architectur support finegrain parallel chip multiprocessor acm sigarch comput architectur new v n may lawrenc rauchwerg nanci m amato smartapp middlewar adapt applic reconfigur platform acm sigop oper system review v n april v a vasenin a n vodomerov formal model system autom program parallel program comput softwar v n p juli radu rugina martin rinard symbol bound analysi pointer array indic access memori region acm sigplan notic v n p may matteo frigo volker strumpen cach complex multithread cach oblivi algorithm proceed eighteenth annual acm symposium parallel algorithm architectur juli august cambridg massachusett usa guangien cheng mingdong feng charl e leiserson keith h randal andrew f stark detect data race cilk program use lock proceed tenth annual acm symposium parallel algorithm architectur p june juli puerto vallarta mexico polyvio pratikaki jaim spacco michael hick transpar proxi java futur acm sigplan notic v n octob nimar s arora robert d blumof c greg plaxton thread schedul multiprogram multiprocessor proceed tenth annual acm symposium parallel algorithm architectur p june juli puerto vallarta mexico michael a bender cynthia a phillip schedul dag asynchron processor proceed nineteenth annual acm symposium parallel algorithm architectur june san diego california usa matteo frigo fast fourier transform compil acm sigplan notic v n april girija j narlikar schedul thread low space requir good local proceed eleventh annual acm symposium parallel algorithm architectur p june saint malo franc michael a bender jeremi t fineman seth gilbert charl e leiserson onthefli mainten seriesparallel relationship forkjoin multithread program proceed sixteenth annual acm symposium parallel algorithm architectur june barcelona spain dror ironi gil shklarski sivan toledo parallel fulli recurs multifront spars choleski futur gener comput system v n p april charl r toll timothi r mcjunkin david j gorisch suboptim minimum cluster volum coverbas method measur fractal dimens ieee transact pattern analysi machin intellig v n p januari robert d blumof charl e leiserson schedul multithread comput work steal journal acm jacm v n p sept kunal agraw yuxiong wen jing hsu charl e leiserson adapt schedul parallel feedback proceed eleventh acm sigplan symposium principl practic parallel program march new york new york usa radu rugina martin c rinard symbol bound analysi pointer array indic access memori region acm transact program languag system topla v n p march kunal agraw yuxiong charl e leiserson adapt work steal parallel feedback proceed th acm sigplan symposium principl practic parallel program march san jose california usa radu rugina martin c rinard pointer analysi structur parallel program acm transact program languag system topla v n p januari girija j narlikar guy e blelloch pthread dynam irregular parallel proceed acmiee confer supercomput cdrom p novemb san jose ca