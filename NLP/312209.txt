t bucket heap list monoton prioriti queue a introduc heapontop hot prioriti queue data structur combin multilevel bucket data structur denardo fox heap data structur superior oper bound either structur taken alon use new data structur obtain improv bound dijkstra shortest path algorithm also discuss practic implement hot queue experiment result context dijkstra algorithm show implement hot queue perform well robust implement base heap multilevel bucket data structur b introduct prioriti queue data structur maintain set element support oper insert decreasekey extractmin prioriti queue fundament data structur mani applic typic applic includ graph algorithm eg event simul eg import subclass prioriti queue use applic event simul dijkstra shortest path algorithm class monoton pri work done author visit nec research institut support depart defens partial support nsf award ccr match fund ibm schlumberg foundat shell foundat xerox corpor queue intuit prioriti queue monoton time key element queue least big key recent element extract queue paper deal monoton prioriti queue unless mention otherwis refer prioriti queue whose oper time bound depend number element queue heap fastest implement heap describ altern implement prioriti queue use bucket eg oper time bucket base implement depend maximum event durat c defin section see relat data structur heap particularli effici number element heap small bucketbas prioriti queue particularli effici maximum event durat c small furthermor work done bucketbas implement amort element bucket yield better bound number element larg sens heap bucket complement other introduc heapontop prioriti queue hot queue combin multilevel bucket data structur denardo fox heap queue use heap instead bucket bucket would spars occupi result implement take advantag best perform featur data structur also give altern insight descript multilevel bucket data structur concurr independ similar descript given raman hot queue relat radix heap rh ahuja et al rh similar multilevel bucket use heap find nonempti bucket get best bound heap oper time rh depend number distinct key heap complic part modifi fibonacci heap meet requir contrast hot queue bound requir anyth special heap use fibonacci heap modif achiev bound rh use heap thorup obtain even better bound sideeffect obtain om implement dijk stra shortest path algorithm improv previou bound sinc thorup bound depend total number element heap rh cannot take immedi advantag data structur believ data structur especi interest work well theori practic preliminari version hot queue data structur perform well practic base experiment feedback modifi data structur practic also develop techniqu make hot queue effici practic compar implement hot queue implement multilevel bucket kari heap context dijkstra shortest path algorithm experiment result show hot queue perform best overal robust either two data structur especi signific multilevel bucket implement dijkstra algorithm compar favor implement algorithm previou studi shown robust mani problem class hot queue implement dijkstra algorithm best theori practic due page limit omit proof detail experiment data full version paper appear preliminari prioriti queue data structur maintain set element support oper insert decreasekey extractmin assum element key use compar element denot key element u aeu unless mention otherwis assum key integr valu element mean key ele ment insert oper add new element queue decreasekey oper assign smaller valu key element alreadi queue bound depend c extractmin oper remov minimum element queue return element denot number insert oper sequenc prioriti queue oper n gain intuit follow definit think event simul applic key correspond process time let u latest element extract queue event insert decreasekey oper queue given event let v element insert queue element whose key decreas event durat aeu denot maximum event durat c applic monoton event durat nonneg monoton prioriti queue prioriti queue monoton applic make definit valid first insert assum initi special element insert queue delet immedi afterward without loss gener assum valu element zero if not subtract valu element valu paper heap mean prioriti queue whose oper time bound function number element queue assum heap also support findmin oper return minimum element heap call sequenc oper prioriti queue balanc sequenc start end empti queue particular implement dijkstra shortest path algorithm produc balanc oper sequenc paper use ram model comput nonobvi result model use appear attribut b schieber result given two machin word find constant time index signific bit two word differ multilevel bucket section describ klevel bucket data structur denardo fox give simpler descript data structur treat element key basedelta number certain paramet delta consid bucket structur b contain k level bucket k posit integ except top level level contain array delta bucket top level contain infinit mani bucket top level bucket correspond interv choos delta delta consecut bucket top level nonempti need maintain bucket denot bucket j level bi j bucket contain set element way allow constanttim addit delet eg doubli link list given k choos delta small possibl subject two constraint first top level bucket must contain least c definit c key element b belong level bucket second delta must power two manipul basedelta number effici use ram oper word bit constraint mind set delta smallest power two greater equal c maintain key latest element extract queue consid basedelta represent key element u b definit c delta k least signific digit basedelta represent aeu uniqu determin aeu ae number repres k least signific digit aeu respect otherwis denot ith least signific digit basedelta represent denot number obtain delet least signific digit k similarli denot ith least signific digit aeu u denot number obtain delet least signific digit aeu u k level b number k top bottom bucket level number delta gamma let index signific digit aeu differ given u aeu say posit u respect i u u insert b insert bi u element b store posit element u bi j except signific digit aeu equal correspond digit u follow lemma follow fact key element queue least lemma everi level i bucket bi empti level i maintain number element level also maintain total number element b extractmin oper chang valu sideeffect posit element b may chang suppos minimum element delet simplest way implement top level wrap around modulo delta valu chang let valu delet let valu delet definit key element queue delet least let posit least signific digit differ differ last digit element b delet posit delet element bucket bi respect exactli whose posit differ respect element longer prefix common therefor belong lower level respect bucket expans procedur move element new posit procedur remov element bi put posit respect two key properti bucket expans follow ffl expans bi correct posit respect everi element b move expans move lower level readi describ multilevel bucket implement prioriti queue oper ffl insert insert element u comput posit i insert u bi j ffl decreasekey decreas key element u posit i follow remov u bi j set aeu new valu insert u describ abov ffl extractmin we need find delet minimum element updat move element affect chang find lowest nonempti level i find first nonempti bucket level i delet element bi j set aeu return u in case old new valu differ last digit element posit remain same examin element bi minimum element u bi j set expand bi j return u next deal effici issu lemma given u comput posit u respect constant time iter level find lowest nonempti level ok time use binari search find level olog time even better use power ram model lemma k log c lowest nonempti level b found o time see best bound achiev k log c simpl way find first nonempti bucket level go bucket take odelta time lemma find first nonempti bucket level odelta time remark one better divid bucket everi level group size dlog ce group contain consecut bucket group maintain dlog cebit number bit j equal jth bucket group empti find first nonempti group log c time first nonempti bucket group o time construct give log c factor improv bound lemma iter construct p time get log p c bound although observ improv multilevel bucket oper time bound small valu k bound optim valu k improv simplifi present use lemma rather improv version rest paper theorem amort bound multilevel bucket implement prioriti queue oper follow ok insert o decreasekey proof insert oper take o worstcas time assign amort cost k charg move element lower level insert element decreasekey oper take o worst case time assign amort cost o extractmin oper show worstcas cost ok plu cost bucket expans cost bucket expans proport number element bucket cost amort insert oper becaus except minimum element element examin bucket expans move lower level exclud bucket expans time oper o plu odelta find first nonempti bucket complet proof sinc note sequenc oper number insert oper least number extractmin oper balanc sequenc two number equal modifi proof obtain follow result theorem balanc sequenc amort bound multilevel bucket implement prioriti queue oper follow o insert o decreasekey okc k extractmin extractmin bound oc bound o c best bound log c log log c obtain log log c e remark klevel bucket data structur use hot queue hot queue use heap h multilevel bucket structur b intuit hot queue data structur work like multilevel bucket data structur except expand bucket contain less ele ment paramet set optim perform anc element bucket copi h process use heap oper number element bucket exce t bucket expand analysi charg scan bucket lower level element bucket expans level obtain improv bound klevel hot queue use klevel bucket structur addit special level k need account scan bucket level k two bucket top level nonempti time note queue nonempti least one two bucket nonempti thu bucket scan special level add constant amount work process element found use wraparound level k k activ bucket bucket whose element h one bucket activ time h empti activ bucket denot activ bucket ba b make bucket activ make h heap contain bucket element inact reset heap empti heap element activ bucket bucket h describ detail hot queue need follow definit denot number element bi j ci j given delta say element u rang bi replac least signific digit use ram oper check element rang bucket constant time maintain invari rang activ bucket detail descript queue oper follow ffl insert h empti element u insert rang activ bucket insert u b multilevel case otherwis u belong activ bucket ba b t insert u h ba b t make ba b inact add u ba b expand bucket ffl decreasekey decreas key element u follow u h decreas key u h otherwis let i j posit u b remov u j set aeu new valu insert u describ abov ffl extractmin h empti extract return minimum element h otherwis proceed follow find lowest nonempti level i find first nonempti bucket level examin bucket start bi delet element bi j set aeu return u examin element bi delet minimum element u bi j set t expand bi j otherwis make bi activ return u correct hot queue oper follow correct multilevel bucket oper lemma observ u h v b h aeu aev lemma cost find first nonempti bucket level amort insert oper okdeltat proof scan one nonempti bucket search first nonempti bucket scan empti bucket level period time prefix includ except last digit remain same furthermor scan bucket level nonempti happen higherlevel bucket expand period prefix chang charg bucket scan insert element queue element expand charg k time each give desir bound theorem let in dn time bound heap insert decreasekey findmin extractmin opera tion amort time hot queue oper follow ok decreasekey of txt kc k extractmin proof two key fact crucial analysi first fact number element h never exce sinc level account element second fact lemma given first fact theorem bound straightforward fibonacci heap amort time bound in ologn give ok o olog amort bound queue oper insert decreasekey extractmin respect set log c log c o o log c amort bound radix heap achiev bound complic thorup heap expect amort time bound in give ok o expect amort time bound queue oper insert decreasekey extractmin respect ffl posit constant set c olog c o olog ffl c expect amort time similarli theorem get bound balanc sequenc oper theorem let in dn time bound heap insert decreasekey findmin extractmin opera tion consid balanc sequenc hot queue oper amort bound oper follow oit insert odt decreasekey ok extractmin use fibonacci heap get o o amort bound queue oper consid extractmin oper nonconst bound set log c get ologc bound set log c get ologc bound set log c get o log c bound remark bound valid n use heap remark consid level implement although time bound same twolevel implement two advantag use less space time bound remain valid wider rang valu c use thorup heap set c expect amort time bound time bound allow us get improv bound dijkstra shortest path algorithm suppos given graph n vertic arc integr arc length rang c run time dijkstra algorithm domin balanc sequenc prioriti queue oper includ on insert extractmin oper om decreasekey oper see eg maximum event durat sequenc oper c bound queue oper immedi impli follow result theorem network n vertic arc integr length rang c shortest path problem solv om expect time improv determinist bound om log c the hot queue implement base fibonacci heap match determinist bound implement detail previou paper describ implement multilevel bucket implement hot queue augment multilevel bucket implement see detail multilevel bucket implement consid klevel hot queue multilevel bucket implement set delta smallest power two greater equal c k base analysi section experiment result set t maximum size activ bucket c k log c e number element activ bucket often small take advantag fact maintain element activ bucket sort list instead heap oper list becom expens point switch heap use kheap work best test see eg implement prioriti queue oper use sort list use doubli link list sort nondecreas order implement design shortest path applic applic number decreasekey oper element activ bucket tend small in fact proven random graph thi element insert list move decreasekey oper tend close begin list differ implement may better differ applic insert oper search element posit list put element posit one start search differ place implement start search begin list start end list point last insert may work better applic extractmin oper remov first element list decreasekey oper remov element list find new posit put element posit implement start search begin list start previou posit element end list place last insert may work better applic bucket becom activ put element list number element bucket heap otherwis our code use switch list heap use follow rule suggest satish rao person communica switch insert decreasekey oper examin ativ may work better applic perform wors our switch number element list exce experiment setup experi conduct pentium pro mhz processor run linux machin meg memori problem instanc fit main memori code written c compil linux gcc compil version use o optim option made effort make code effici particular set bucket array size power two allow us use word shift oper comput bucket array indic full paper report experiment result five type graph two graph type chosen exhibit properti algorithm two extrem one path start vertex vertic tend order thetan one path length order theta third graph type random spars graph fourth type construct lot decreasekey oper activ bucket meant test robust implement violat assumpt made section decreasekey oper fifth type graph meant easi hard specif implement specif number bucket level test type graph seven implement ation kari heap k klevel bucket k rang klevel hot queue k rang paramet tune result show best paramet valu test problem famili use previou paper next two section describ problem famili graph typestwo type graph explor grid produc use gridgen gener graph character length x width y graph form construct x layer path length y order layer well vertic within layer connect vertex correspond vertex adjac layer vertic first layer connect sourc first type graph use long grid constant width vertic test use graph differ length rang vertic arc length chosen independ uniformli random rang c c vari second type graph use wide grid type graph length limit layer width vari vertic c long grid third type graph includ random graph uniform arc length distribut random graph n vertic n arc fourth type graph type new compar base cycl n vertic number n addit vertex connect gamma distinct vertic length arc i j equal k k number arc cycl path j fifth type graph includ hard graph parameter number vertic desir number level k maximum arc length c c comput p number bucket level assum implement k level graph consist two path connect sourc vertic path distanc p other distanc sourc path vertic path occupi first bucket bottom level bin distanc sourc path make vertic occupi last bucket bottomlevel bin addit sourc connect last vertex first path arc length last vertex second path arc length c summari graph type appear tabl problem familiesfor graph type examin rel perform implement chang increas variou paramet type modif constitut problem famili famili summar tabl gener famili construct vari one paramet hold other constant differ famili vari paramet use differ constant valu experiment result level bucket structur robust case level hot queue perform similarli to although usual slightli better than correspond multilevel bucket structur one level hot queue significantli robust one level bucket robust level hot queue due shortag space present experiment result hard problem onli problem separ hot queue multilevel bucket tabl k denot implement h heap bi bucket level hi hot queue level report run time count oper give insight algorithm perform heap implement count total number insert decreasekey oper bucket implement count number empti bucket examin empti oper hot queue implement count number empti oper number insert decreasekey oper activ bucket plot data addit tabul it unabl run level bucket hot queue implement problem memori limit leav correspond tabl entri blank tabl give data hard hard famili design hard level bucket implement respect two element heap time heap implement effici hard problem hot queue implement bucket expand action confin two special top level bucket thu hot queue perform almost well heap except h largest valu c could handl run time time greater valu c explan discrep hard problem hard b b and expect implement poorli famili similarli bucket implement wors implement hard famili conclud remark theori hot queue data structur better heap multilevel bucket data structur experi show result implement robust heap multilevel bucket data structur new heap raman instead thorup heap improv time bound factor log ffl c replac p log log c hot queue seem practic radix heap latter data structur requir bookkeep addit hot queue heap usual contain much fewer element implement take advantag fact level hot queue data structur seem robust level hot queue usual somewhat faster data structur best applic level structur may robust larg valu c valu much smaller reduc sensit paramet activ bucket level hot queue may use event simul applic view robust version calendar queue data structur acknowledg would like thank bob tarjan stimul discuss insight comment satish rao suggest adapt strategi switch list heap harold stone use comment draft paper r design analysi comput algorithm calandar queue fast o prioriti queue implement simul event set problem shortest path algorithm theori experiment evalu determinist coin toss applic optim parallel list rank introduct algorithm algorithm shortest path forest topolog order note two problem connexion graph fibonacci heap use improv network optim algorithm implement dijkstra algorithm base multilevel bucket expect perform dijkstra shortest path algorithm fast algorithm shortest path sort data structur network al gorithm ram prioriti queue tr ctr mikkel thorup integ prioriti queue decreas key constant time singl sourc shortest path problem proceed thirtyfifth annual acm symposium theori comput june san diego ca usa stephen alstrup thore husfeldt thei rauh mikkel thorup black box constanttim insert prioriti queue note acm transact algorithm talg v n p juli piet van mieghem fernando a kuiper concept exact qo rout algorithm ieeeacm transact network ton v n p octob klau brengel andrea crauser paolo ferragina ulrich meyer experiment studi prioriti queue extern memori journal experiment algorithm jea pe ran mendelson mikkel thorup uri zwick meldabl ram prioriti queue minimum direct span tree proceed fifteenth annual acmsiam symposium discret algorithm januari new orlean louisiana mikkel thorup integ prioriti queue decreas key constant time singl sourc shortest path problem journal comput system scienc v n p novemb haim kaplan robert e tarjan kosta tsioutsioulikli faster kinet heap use broadcast schedul proceed twelfth annual acmsiam symposium discret algorithm p januari washington dc unit state