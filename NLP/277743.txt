t optim direct thread code select inlin a achiev good perform bytecod languag interpret difficult without sacrif simplic portabl due complex dynam translat justintim compil bytecod nativ code mechan employ univers highperform interpretersw demonstr simpl techniqu make possibl creat highlyport dynam translat attain much perform optim c certain numer comput translat base techniqu offer respect perform without sacrif either simplic portabl much slower pure bytecod interpret b introduct bytecod languag smalltalk gol caml ler java arn lin offer signific engin advantag convent languag higher level abstract dynam execut environ increment debug code modif compact represent execut code in case platform independ success java due larg promis platform independ compact code compact bytecod import advantag network comput code must download ondemand execut arbitrari platform oper system keep bandwidth requir minimum disadvantag bytecod interpret typic offer lower perform compil code consum significantli resourc modern virtual machin perform degre dynam translat improv program perform deu techniqu significantli increas complex virtual machin must tailor permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee sigplan montreal canada c hardwar architectur much way convent compil backend increas develop cost requir specif knowledg target architectur time write specif code reduc reliabl by introduc code debug support languag caml exampl also tradit compil produc highperform nativ code defeat advantag come platform independ compact propos novel dynam retransl techniqu appli certain class virtual machin techniqu deliv high perform optim c easi retrofit exist virtual machin requir almost effort port new architectur paper continu follow next section give brief survey bytecod interpret mechan provid context remaind paper novel dynam retransl techniqu explain section section present result appli techniqu two interpret small risclik interpret inspir work product virtual machin object caml last two section contrast techniqu relat work present conclud remark background interpret perform depend heavili represent chosen execut code mechan use dispatch opcod section describ common techniqu pure bytecod interpret inner loop pure bytecod interpret simpl fetch next bytecod dispatch implement use switch statement figur show typic pure bytecod interpret loop array bytecod calcul use run exampl interpret infinit loop contain switch statement dispatch success bytecod case bodi switch implement one bytecod pass control next bytecod break switch pass control back start infinit loop assum compil optim jump chain break implicit jump end bodi back begin overhead associ approach follow compil code unsign char bytecodeadd bytecod implement unsign char unsign char switch bytecod case bytecodepush break case bytecodepush break case bytecodeadd stackpoint stackpoint break figur pure bytecod interpret ffl increment instructionpoint ffl fetch next bytecod memori ffl redund rang check argument switch ffl fetch address destin case label tabl ffl jump address end bytecod ffl jump back start bodi fetch next bytecod eleven machin instruct must execut powerpc perform push bytecod nine instruct dedic dispatch mechan includ two memori refer two jump among expens instruct modern architectur pure bytecod interpret easi write under stand highli portabl rather slow case bytecod perform simpl oper as push exampl major execut time wast perform dispatch thread code interpret thread code bel popular forth program languag moo variou kind thread code effici gener direct thread ert bytecod simpli integ dispatch involv fetch next opcod bytecod look address associ implement either explicit tabl implicitli use switch transfer control address direct thread code improv perform elimin tabl lookup execut code repres sequenc opcod implement address dispatch involv fetch next opcod implemen tation address jump directli address addit optim elimin central di patch instead return central dispatch loop compil code void opcodeadd opcod implement dispatch next instruct defin next goto instructionpoint void start execut dispatch first opcod opcod implement opcodepush opcodepush opcodeadd stackpoint stackpoint figur direct thread code direct thread opcod implement end code requir dispatch next opcod direct thread version exampl shown figur execut begin fetch address first op code implement compil code jump address opcod perform work dispatch next opcod impli compil code henc name control flow thread way opcod order impli compil code without ever return central dispatch loop overhead associ thread code much lower associ pure bytecod inter preter opcod execut addit overhead dispatch next opcod ffl increment instructionpoint ffl fetch next opcod address memori ffl jump address five machin instruct requir implement push powerpc three associ opcod dispatch one memori refer one jump save six instruct pure bytecod approach importantli save one memori refer one jump instruct both ex pensiv dynam translat thread code benefit direct thread code easili obtain bytecod languag translat bytecod thread code exampl written use firstclass label provid gnu c express void assign address of type void statement attach given label addr control transfer locat use goto derefer address goto addr note gcc firstclass label requir implement techniqu effect achiev coupl macro contain line asm translat tabl void opcod dynam translat unsign char bytecodepoint firstbytecod void morebytecodestotransl figur dynam translat bytecod thread code direct thread code execut illustr figur translat loop read bytecod look address implement tabl write address direct thread code complic bytecod set extens byte provid addit inform cannot encod within bytecod itself branch offset indic liter tabl environ on extens byte normal place inlin translat thread code translat immedi thread opcod correspond bytecod translat thread code permit kind op timiz exampl smalltalk provid four bytecod push implicit integ constant between onto stack translat loop could easili translat singl pushinteg opcod follow constant push inlin operand treatment appli kind liter quantiti rel branch offset on anoth possibl partial decod translat loop examin over load bytecod translat time translat one sever thread opcod translat loop must awar kind operand copi rel offset exampl might requir modif scale translat loop possibl make approxim evalu approach realist system squeak ing portabl pure bytecod implement smalltalk perform numer comput approxim speed optim c brouhaha mir portabl smalltalk virtual machin similar squeak vm except dynam translat bytecod direct thread code execut mir brouhaha perform numer comput speed optim c implement care handtun perform essenti differ use dynam translat direct thread code brouhaha optim common bytecod sequenc bytecod typic repres thread opcod repres mani more sinc encod pointer translat bytecod thread code therefor give us opportun make arbitrari transform execut code one transform detect common sequenc bytecod translat singl thread macro opcod macro opcod perform work entir sequenc origin bytecod exampl bytecod push liter push variabl add store variabl translat singl addliteraltovari opcod thread code optim effect avoid overhead multipl dispatch impli origin bytecod but elid within macro opcod singl macro opcod translat sequenc n origin bytecod avoid dispatch execut time techniqu particularli import case bytecod simpl as implement bytecod short singl registerregist machin instruct cost thread often significantli larger cost use execut three instruct must execut dispatch next opcod overhead thread instruct execut instruct dispatch thread opcod overhead drop oper optim singl macro opcod four use instruct instruct thread dispatch opcod implement noncontigu address also undermin code local caus unnecessari processor pipelin stall ineffici util instruct cach tlb combin common sequenc bytecod singl macro opcod consider reduc effect compil also chanc make interbytecod optim within implement singl macro opcod imposs make implement individu bytecod determin appropri set common bytecod sequenc difficult virtual machin instrument record execut trace simpl offlin analysi reveal like candid correspond pattern match macro opcod implement incorpor manual vm exampl analysi appli earlier version object caml bytecod set result new set bytecod includ sever macrostyl oper problem static optim signific problem static approach number possibl permut even shortest common sequenc consecut bytecod pro hibit exampl smalltalk provid bytecod push popular integ constant minu one two bytecod load store temporari receiv variabl manual optim possibl permut increment decrement variabl small constant would requir translat implement explicit special case clearli unreason problem made acut sinc differ applic run virtual machin favor differ sequenc bytecod static chose singl optim set common sequenc therefor imposs techniqu focus make choic runtim allow set common sequenc nearli optim particular applic run instruct count accur way estim save sinc instruct avoid expens execut dynamicopcodepushpushadd stackpoint stackpoint stackpoint goto figur equival macro opcod push push add int nfibsint n return n figur benchmark function c dynam rewrit opcod sequenc gener implement common bytecod sequenc dynam implement avail new macro opcod singl macro opcod replac sever thread opcod gener origin common bytecod sequenc dynam gener macro opcod execut precis manner interpret predefin opcod origin execut mechan direct thread requir modif all transform perform either bytecodetothread code translat separ pass alreadi thread code figur show equival c dynam gener thread opcod sequenc three bytecod need evalu exampl translat concaten compil c implement sever intrins thread opcod one correspond bytecod sequenc optim sinc involv reloc code safe perform concaten thread opcod whose implement posit independ gener three case consid concaten opcod implement ffl thread opcod cannot inlin implement contain call c function destin address rel processor pc destin address would invalid copi form new macro opcod implement ffl thread opcod chang flow control thread code must appear end translat sequenc differ path sequenc might consum differ number inlin argument ffl thread opcod branch destin appear begin macro opcod sinc incorpor middl macro opcod would delet branch destin final thread code simplifi follow rule consid basic block inlin basic block begin jump destin end either jump nfib push r r save call move jge r r cont pop r restor r return cont move r r els arg r call nfib call nfib add add pop r restor r return start move r call nfib call nfib print figur thread code nfib benchmark inlin destin chang control flow inlin pur pose opcod contain c function call consid singleopcod basic block thi restrict relax target architectur andor compil use build vm use absolut address function call destin techniqu design and work best with finegrain opcod implement short typic machin instruct therefor cost opcod dispatch domin next section present exampl context simpl exampl illustr techniqu appli simpl risclik virtual machin execut nfib func tion shown figur exampl interpret implement registerbas execut model hand regist perform arithmet stack use save return address content clobber regist subroutin call direct thread code two kind inlin operand instruct pointerrel offset branch destin absolut address function call destin interpret translat bytecod thread code two pass make first pass bytecod expand thread opcod inlin exactli explain section figur show symbol list nfib function implement exampl interpret opcod set initi translat thread code bytecod operand place inlin thread code translat exampl offset jge opcod call destin place directli opcod stream immedi associ opcod repres pseudooperand fig doublyrecurs function interest properti result number function call requir calcul result nfib cont nfib nfib figur thread code nfib benchmark inlin implement new macro opcod shown right ure appear separ line code prefix initi translat thread code second pass perform inlin thread code basic block identifi use dynam gener new thread macro opcod correspond origin sequenc thread opcod replac singl macro opcod rewrit thread code perform insitu sinc optim opcod sequenc alway result shorter sequenc optim code possibl overwrit opcod yet consid inlin figur show code nfib function inlin taken place function reduc five thread macro opcod shown replac basic block origin code implement new macro opcod concaten implement opcod replac new implement written separ area memori call macro cach five implement requir nfib shown within curli brace figur one end copi implement pseudoopcod thr thread oper dispatch next opcod inlin argument copi verbatim except cont a jump offset adjust appropri transla tor these inlin argument use macro opcod implement point mark figur help identif basic block divid thread opcod four class follow inlin opcod implement inlin macro opcod without restrict the arithmet opcod belong class protect implement contain c function call therefor cannot inlin the print opcod belong class final opcod chang flow control therefor defin end basic block eg call rel opcod chang flow control therefor defin end basic block eg condit branch jge differ final rel way opcod inlin operand treat first case operand absolut copi directli final translat code second case operand rel current thread program counter must adjust appropri final translat code figur show translat code initi thread opcod tabl along repres implement sever thread opcod each four class thread opcod repres defin defin pop sp defin get longip read inlin operand defin next goto ip dispatch next opcod defin protect x never expand defin inlin expand defin final expand end basic block defin rel expand end basic block offset follow defin opnam narg flag case initialip break startnam opcod bodi defin initi rather execut see macro op int switch op opjgerr rel regist long r r ip offset opcal final regist long dest get dest default fprintfstderr panic op d undefinedn op abort figur opcod tabl initi translat inlin loop shown figur complex might first appear code pointer translat thread code rewritten insitu indic code point next opcod copi or inlin locat copi respect in time loop consid opcod inlin inlin loop enter current opcod opcod follow inlin case opcod copi along inlin argument directli out nextmacro pointer next unus locat macro cach inlin loop first write address it repres thread opcod macro implement gener copi compil implement opcod macro cach inlin thread opcod copi although inlin argument encount copi directli out inlin loop continu copi implement opcod explicitli end basic block rel next opcod either noninlin int int nextin long infothisopflag inlin infonextopflag protect inlin creat new macro opcod nextmacro void new macro opcod infothisopflag protect icopyinfothisopaddr ep infothisops infothisopflag rel locn offset int infothisopflag final infothisopflag rel destinationin break end basic block copi thread oper icopyinfothraddr ep infothrs cant inlin copi opcod inlin argument infothisopflag rel copi liter argument int figur dynam translat loop protect branch destin implicitli end current basic block translat append implement pseudoopcod thr thre ade oper itself final nextmacro locat updat readi next inlin oper translat loop use array flag destin identifi branch destin within thread code array easili construct translat first pass bytecod expand noninlin thread code loop also creat two array reloc patchlist use recalcul rel branch offset inlin loop concaten opcod implement use icopi function shown figur function similar bcopi except also synchron pro cessor instruct data cach ensur new macro opcod implement execut contain line platformdepend code interpret branch destin identif rel offset recalcul shown here seen full sourc code exampl interpret see appendix static inlin void icopyvoid sourc void dest sizet size bcopysourc dest size size asm dcbst sync icbi isync rp elif definedsparc asm flush stbar rp noop elif defin endif dest size figur icopi function contain singl line platformdepend code save space translat multipl copi opcod sequenc would wast space therefor keep cach dynam gener macro opcod key hash valu comput incom unoptim opcod translat case cach hit reus exist macro opcod translat code immedi reclaim macro cach space occupi newli translat version case cach miss newli gener macro opcod use translat code hash tabl updat includ new opcod ensur never one macro opcod correspond given sequenc unoptim opcod experiment result particularli interest perform benefit dynam inlin appli interpret finegrain instruct set nevertheless also curiou see techniqu would perform appli interpret coarsegrain bytecod set took measur context use risclik interpret widelyus but less suit interpret object caml languag finegrain opcod risclik interpret opcod set similar present section configur at compil time use bytecod direct thread code direct thread code dynamicallygener macro opcod perform two benchmark measur use in terpret functioncal intens fibonacci benchmark present earlier nfib memori intens function call free prime number gener siev tabl show number second requir execut benchmark sever architectur mhz pentium sparcstat mhz powerpc ev figur shown simpl bytecod interpret interpret perform translat direct thread code direct thread code dynam inlin common opcod sequenc benchmark written c compil optim option o interpret final column show perform inlin thread code compar optim c nfib machin bytecod thread inlin c inlinedc pentium siev machin bytecod thread inlin c inlinedc pentium tabl nfib siev benchmark result three architectur test final column show speed inlin thread code rel optim c pentium pentium bytecod direct thread inlin figur benchmark perform rel optim c nfib spend much time perform arithmet regist memori stack oper perform function call return interpret alloc first vm regist physic machin regist whenev possibl opcod perform arithmet therefor typic compil singl machin instruct sparc powerpc two architectur show mark improv perform common sequenc inlin singl macro opcod due significantli reduc ratio opcod dispatch real work effect less pronounc pentium machin regist vm regist must kept memori arithmet opcod compil sever pentium instruct therefor ratio dispatch overhead real work lower risc architectur observ mark improv approxim factor two success version interpret nfib siev show less pronounc improv spend major time perform memori opera tion contribut opcod dispatch overal execut time therefor smaller nfib also interest observ perform version interpret rel optim c figur show nfib gain approxim speed optim c move bytecod represent thread code gain move thread inlin thread code depend architectur approxim pentium sparc gain siev smaller less depend architectur approxim step three architectur object caml also appli techniqu object caml bytecod interpret order obtain realist measur perform overhead less favor environ object caml chosen design implement interpret core clean simpl understand make requir modif present signific challeng furthermor fullyfledg system includ bytecod com piler benchmark suit larg applic made easier collect meaning statist interpret also equip mechan bulktransl bytecod thread code startup on platform support it need extend initi translat phase perform analysi opcod sequenc gener macro opcod implementa tion rewrit thread code insitu use dynamicallygener macro opcod implement techniqu caml virtual machin took one day two small detail requir care attent first presenc switch opcod perform multiway branch follow thread code inlin tabl map valu onto branch offset ad special case translat loop handl opcod second exist hand opcod consum two inlin argument a liter rel offset introduc new opcod class rel these differ rel copi addit inlin liter argument offset translat loop translat algorithm ident respect one present section ran standard object caml benchmark suit modifi vm see tabl vm instrument gather statist relat execut speed use gcc firstclass label portablyftpftpinriafrinriaprojectscristalxavierleroy benchmarksobjcamltargz boyer fib genlex qsort qsort siev soli soli takc taku speed inlinednoninlin pentium sparc powerpc figur objectivecaml benchmark result three architectur test vertic axi show perform rel origin noninlin interpret asterisk indic version benchmark compil array bound check disabl boyer term process function call fib integ arithmet function call arg genlex lex pars symbol process kb term process function call function qsort integ array loop siev integ arithmet list process function soli puzzl solv array loop takc integ arithmet function call arg curri taku integ arithmet function call arg tuplifi tabl object caml benchmark memori usag characterist dynam gener macro opcod figur show perform benchmark inlin rel origin perform without inlin import note object caml bytecod set alreadi optim static describ section ler improv therefor due mainli elimin dispatch overhead common sequenc particular applic virtual machin whose bytecod set stat ical optim way would benefit techniqu see figur major benchmark benefit signific perform advantag inlin case inlin version run faster origin two benchmark run twice fast origin noninlin version sparc clear improv relat processor architectur probabl due differ cost thread oper sparc ex ampl avoid pipelin stall associ thread seem make signific differ figur show final size macro cach benchmark sparc plot factor size origin unoptim code final macro cach cach size origin code size origin code size kbyte figur macro cach size diamond optim thread code size cross plot factor origin code size size vari slightli architectur sinc depend size bytecod implement howev shape case averag ratio origin bytecod size macro cach size show cost three four time size origin code sparc the ratio almost ident powerpc slightli smaller pentium observ ratio decreas gradual origin code size increas expect sinc larger bodi code tend reus macro opcod rather gener new one test translat bytecod version object caml compil byte origin code gener byte macro opcod implement sparc approxim time size origin code shown rightmost point graph inlin thread code alway smaller origin code gener figur also show final optim code size benchmark observ ratio independ size benchmark also expect sinc reduct size depend averag number opcod common sequenc densiti correspond macro opcod final code depend mainli characterist languag opcod set system longliv object memori gener new execut code runtim realist implement system would recycl macro cach space possibl use profil optim popular area program exampl lc emul found macintosh system perform dynam translat powerpc code normal requir kb cach commonli use translat code sequenc store tho similar fix cach size effect brouhaha smalltalk system mir translat speed also import factor measur ran object caml bytecod compil a much larger program benchmark modifi interpret opcod object caml compil translat second sparc rate opcod per second inlin interpret execut compil rate million opcod per sec ond translat therefor approxim five time slower execut relat work brouhaha object caml demonstr benefit creat special macro opcod perform work sequenc common opcod object caml led new bytecod set brouhaha standard smalltalk bytecod translat thread code execut detect limit number predetermin common bytecod sequenc perform translat special opcod substitut execut code contribut extens techniqu dynam analyz gener implement new macro opcod runtim sever system use concaten precompil sequenc code runtim au noe complet differ context precompil code sequenc gener templat parameter runtim particular constant valu templatebas approach also use commerci smalltalk virtual machin perform dynam compil nativ code mir howev techniqu complex requir signific effort implement templat new architectur interest system portabl dynam code gener vcode eng architectureneutr runtim as sembler gener code approach perform c architectur main disadvantag retrofit exist virtual machin requir signific amount effort certainli singl day requir implement techniqu product virtual machin our simpl nfib benchmark run faster use vcode compar risclik inlin thread code virtual machin superoper pro techniqu special bytecod c interpret accord program execut possibl special sinc translat perform opcod breakeven point pass program execut six time number opcod contain interpret gener time compil bytecod represent program compiletim analysi program choos like candid super oper implement new interpret bytecod superoper similar macro opcod one advantag correspond synthes bytecod benefit interopcod optim simpl concaten implement fail exploit howev superoper requir bytecod correspond precis node use build pars tree might alway best choic bytecod set would also tricki use superoper increment system smalltalk new execut code gener runtim nevertheless investig merg techniqu superoper dynamicallygener macro opcod might worthwhil conclus work inspir need creat interpret finegrain risclik opcod set gener not tie particular highlevel languag amen tradit compil optim cost opcod dispatch signific context compar abstract interpret whose bytecod care match languag semant expect benefit techniqu relat averag semant content bytecod would expect languag tcl perl rel highlevel opcod benefit less macroiz interpret risclik opcod set benefit sinc cost dispatch signific compar cost execut bodi bytecod object caml bytecod set posit two extrem contain simpl complex opcod vcode better perform techniqu instruct set match close underli architectur exert fine control code gener perform degre reorder better instruct schedul believ similar result achiev risclik inlin thread code interpret portabl manner perform macro opcod limit inabl compil perform interopcod optim possibl static analysi perform new macro opcod implement manual in terpret believ limit less import use finegrain opcod set correspond close tradit risc architectur opcod implement singl machin instruct new opportun interopcod optim avail translat code gener techniqu portabl simpl implement orthogon implement virtual machin op code reduc overhead opcod dispatch help bring perform finegrain bytecod level abstract languagedepend opcod set signific overhead associ techniqu use check stack overflow pend signal object caml discuss beyond scope paper speed second space byte pentium sparc powerpc sparc benchmark origin inlin origin inlin origin inlin origin inlin cach boyer fib genlex kb qsort qsort siev soli soli takc taku tabl raw result objectivecaml benchmark acknowledg author would like thank xavier leroy john mal oney eliot miranda dave ungar mario wolczko anonym refere help comment draft paper r java program lan guag commun acm effici implement smalltalk system engler vcode retarget portabl forth engin back futur stori squeak object caml system releas java virtual machin specif fast direct optim ansi c interpret superoper build better virtual cpu tr smalltalk languag implement brouhaha portabl smalltalk interpret fast effect dynam compil back futur java program languag nd ed java virtual machin specif effici implement smalltalk system ctr alex iliasov templatesbas portabl justintim compil acm sigplan notic v n august fabric bellard qemu fast portabl dynam translat proceed usenix annual technic confer usenix annual technic confer p april anaheim ca jinzhan peng gansha wu gueiyuan lueh code share among state stackcach interpret proceed workshop interpret virtual machin emul june washington dc ben stephenson wade holst multicod optim virtual machin use bytecod sequenc companion th annual acm sigplan confer objectori program system languag applic octob anaheim ca usa brian davi john waldron survey optimis java virtual machin proceed nd intern confer principl practic program java june kilkenni citi ireland m anton ertl david gregg combin stack cach dynam superinstruct proceed workshop interpret virtual machin emul june washington dc andrew beatti kevin casey david gregg andrew nisbet optim java interpret connect devic embed system proceed acm symposium appli comput march melbourn florida bertil folliot ian piumarta fabio riccardi dynam configur multilanguag execut platform proceed th acm sigop european workshop support compos distribut applic p septemb sintra portug marc berndl lauri hendren dynam profil trace cach gener proceed intern symposium code gener optim feedbackdirect runtim optim march san francisco california brian davi andrew beatti kevin casey david gregg john waldron case virtual regist machin proceed workshop interpret virtual machin emul p june san diego california m anton ertl david gregg retarget jit compil use ccompil gener execut code proceed th intern confer parallel architectur compil techniqu p septemb octob henrik nssn mat carlsson konstantino sagona instruct merg special sicstu prolog virtual machin proceed rd acm sigplan intern confer principl practic declar program p septemb florenc itali mourad debbabi abdelouah gherbi lamia ketari chamseddin talhi hamdi yahyaoui sami zhioua synergi effici interpret fast select dynam compil acceler embed java virtual machin proceed rd intern symposium principl practic program java june la vega nevada mathew zaleski marc berndl angela demk brown mix mode execut context thread proceed confer centr advanc studi collabor research p octob toranto ontario canada m anton ertl david gregg optim indirect branch predict accuraci virtual machin interpret acm sigplan notic v n may yunh shi david gregg andrew beatti m anton ertl virtual machin showdown stack versu regist proceed st acmusenix intern confer virtual execut environ june chicago il usa marc berndl benjamin vital mathew zaleski angela demk brown context thread flexibl effici dispatch techniqu virtual machin interpret proceed intern symposium code gener optim p march benjamin vital tarek s abdelrahman caten special tcl virtual machin perform proceed workshop interpret virtual machin emul june washington dc k s venugop geetha manjunath venkatesh krishnan sec portabl interpret optim techniqu embed java virtual machin proceed nd java virtual machin research technolog symposium p august m anton ertl david gregg andrea krall bernd paysan vmgen gener effici virtual machin interpret softwarepractic experi v n p march jefferi von ronn ning wang michael franz interpret program static singl assign form proceed workshop interpret virtual machin emul june washington dc mathew zaleski angela demk brown kevin stoodley yeti gradual extens trace interpret proceed rd intern confer virtual execut environ june san diego california usa mourad debbabi abdelouah gherbi azzam mourad hamdi yahyaoui select dynam compil embed java virtual machin target arm processor scienc comput program v n p januari arun kejariw xinmin tian milind girkar wei li sergey kozhukhov utpal banerje alexand nicolau alexand v veidenbaum constantin d polychronopoulo tight analysi perform potenti thread specul use spec cpu proceed th acm sigplan symposium principl practic parallel program march san jose california usa david gregg andrew beatti kevin casey brain davi andi nisbet case virtual regist machin scienc comput program v n p septemb etienn m gagnon lauri j hendren sablevm research framework effici execut java bytecod proceed javatm virtual machin research technolog symposium javatm virtual machin research technolog symposium p april monterey california gregori t sullivan derek l bruen iri baron timothi garnett saman amarasingh dynam nativ optim interpret proceed workshop interpret virtual machin emul p june san diego california ana azevedo arun kejariw alex veidenbaum alexandru nicolau high perform annotationawar jvm java card proceed th acm intern confer embed softwar septemb jersey citi nj usa scott thibault charl consel julia l lawal renaud marlet gill muller static dynam program compil interpret special higherord symbol comput v n p sept mahmut taylan kandemir improv wholeprogram local use intraprocedur interprocedur transform journal parallel distribut comput v n p may john aycock brief histori justintim acm comput survey csur v n p june