t simpl fast parallel hash oblivi execut a hash tabl represent set linear size data structur support constanttim membership queri show construct hash tabl given set n key olg lg n parallel time high probabl use n processor weak version concurrentread concurrentwrit parallel random access machin crcw pram algorithm use novel approach hash oblivi execut base probabilist analysi algorithm simpl follow structur partit input set bucket random polynomi constant degre t olg lg n alloc mt memori block size kt let bucket select block random tri inject map key block use random linear function bucket fail carri next iter crux algorithm care priori select paramet mt kt algorithm use olg lg n random word implement workeffici manner b introduct let set n key drawn finit univers u hash problem construct follow attribut inject two key map h valu space effici space requir repres h on time effici everi x u hx evalu o time singl processor function induc linear space data structur perfect hash tabl repres s data structur support membership queri o time paper present simpl fast effici parallel algorithm hash problem use n processor run time algorithm olg lg n overwhelm probabl superior previous known algorithm sever respect comput model model comput use concurrentread concurr parallel random access machin crcw pram famili see eg member famili differ outcom event one processor attempt write simultan share memori locat main submodel crcw pram descend order power are prioriti lowestnumb processor succe arbitrari one processor succe known advanc one collis differ valu attempt written special collis symbol written cell collis special collis symbol written cell toler content cell chang final less standard robust two processor attempt write cell given step then attempt cell obtain valu previou work hash tabl fundament data structur numer applic comput scienc extens studi literatur see eg survey recent one particular interest perfect hash tabl everi membership queri guarante complet constant time worst case perfect hash tabl perhap even signific parallel context sinc time execut batch queri parallel determin slowest queri fredman komlo szemeredi first solv hash problem expect linear time univers size input set scheme build level hash function level function split subset bucket whose size distribut favor manner then inject level hash function built subset alloc privat memori block appropri size level scheme form basi algorithm dynam version hash problem also call dictionari problem insert delet may chang dynam algorithm given dietzfelbing karlin mehlhorn meyer auf der heid rohnert tarjan dietzfelbing meyer auf der heid dietzfelbing gil matia pippeng parallel set dietzfelbing meyer auf der heid present algorithm dictionari problem fix ffl n arbitrari dictionari instruct insert delet lookup execut on ffl expect time n gammaffl processor prioriti crcw matia vishkin present algorithm hash problem run olg n expect time use on lg n processor arbitrari crcw fastest parallel hash algorithm previou work base level scheme make extens use count sort procedur known lower bound parallel hash given gil meyer auf der heid wigderson rather gener model comput requir number parallel step omegagamma n also show restrict model one processor may simultan work key parallel hash time isomegagamma lg n also gave algorithm yield match upper bound function applic charg oper eg count sort free algorithm fall within realm mention restrict model match omegagamma lg n lower bound charg oper concret pram model result main result linear static hash tabl construct olg lg n time high probabl on space use n processor crcw pram algorithm follow properti time optim best possibl result use processor realloc shown optim speedup achiev small penalti execut time signific improv olg n time algorithm reliabl time bound olg lg n obey high probabl contrast time bound algorithm guarante constant probabl simplic arguabl simpler hash algorithm previous publish never theless analysi quit involv due tight tradeoff probabl conflict event reduc random adapt consum olg lg n random word compar omegagamma n random word previous use work optim work optim implement present timeprocessor product on run time increas factor olg n also requir olg lg n random word comput model allow lookup time olg lg n well algorithm implement robust crcw model result summar follow theorem theorem given set n key drawn univers u hash problem solv use on space i olg lg n time high probabl use n processor ii olg lg n lg n time on oper high probabl algorithm run crcw pram realloc processor key employ use olg lg bit previou algorithm implement level scheme either sequenti parallel base group key accord bucket belong requir learn size bucket bucket alloc privat memori block whose size depend bucket size approach reli techniqu relat sort count requir omegagammaeq n lg lg n time solv polynomi number processor impli lower bound beam hastad lower bound hold even random algorithm more recent result found other involv way circumv barrier cf circumv obstacl learn bucket size purpos appropri memori alloc techniqu oblivi execut sketch figur partit input set bucket random polynomi constant degre olg lg n a alloc memori block size k b let bucket select block random tri inject map block use random linear function block select anoth bucket inject map found bucket carri next iter figur templat hash algorithm crux algorithm care priori select paramet k iter t k depend expect number activ bucket expect distribut bucket size iter way make desir progress possibl or rather like execut oblivi follow sens bucket treat equal regardless size algorithm make explicit attempt estim size individu bucket alloc memori bucket base size case previou implement level scheme attempt estim number activ bucket distribut size select paramet k iter made accord priori estim random variabl estim base properti level hash function well induct assumpt behavior previou iter remark hash result demonstr power random parallel comput crcw machin memori restrict linear size boppana consid problem element distinct given n integ decid whether distinct show solv element distinct nprocessor prioriti machin bound memori requir omegagammaeq n lg lg n time bound memori mean memori size arbitrari function n rang input valu easi see memori size bound omegagamma element distinct solv o expect time use hash function fact thi howev hold linear size memori parallel hash algorithm impli incorpor random element distinct solv expect olg lg n time use n processor collis which weaker prioriti model linear memori size applic perfect hash tabl data structur use tool parallel algorithm matia vishkin propos use parallel hash scheme space reduct algorithm larg amount space requir commun processor algorithm becom space effici preserv number oper penalti introduc random increas time use hash scheme time increas may substanti smaller algorithm which use scheme result time increas olg n use new scheme time increas lg lg n lg n case construct suffix tree string name assign procedur substr larg alphabet algorithm time increas olg lg n lg lg n algorithm leav expect time unchang case integ sort polynomi rang superpolynomi rang applic discuss conclus section outlin rest paper organ follow preliminari technic use algorithm analysi given section algorithm templat present greater detail section two differ implement base differ select k given subsequ section section present implement fulli satisfi statement theorem rel simpl analysi improv implement main algorithm involv analysi present section section show reduc number random bit section explain algorithm implement optim number oper model comput discuss section also give modifi algorithm weaker model section briefli discuss extens hash problem input may consist multiset final conclus given section preliminari follow inequ standard see eg markov inequ let random variabl assum nonneg valu onli chebyshev inequ let random variabl then chernoff inequ let binomi variabl then terminolog probabl say event occur ndomin probabl occur probabl gammaomegagamma usag notat essenti follow polylogarithm number event one occur ndomin probabl conjunct occur ndomin probabl well therefor usual satisfi demonstr algorithm step succe ndomin probabl fact let independ binari random variabl let domin probabl proof recal well known fact in pairwis independ inequ e inequ inequ follow immedi abov hash function remaind section let u fix split set bucket bucket subset fx size collid bucket singleton function inject perfect element collid let im r function inject number collis pair key gener b r number rtupl key collid h polynomi hash function let prime class degre polynomi hash function map u mod m c rest section consid probabl space h select uniformli random h follow fact corollari shown fredman komlo szemeredi carter wegman the origin proof case howev gener straightforward fact e corollari hash function h inject probabl least proof function h inject fact markov inequ probabl h inject prob b follow shown fact r let r rth moment distribut im r easi see further shown complet random function r linear n high probabl fix r polynomi hash function dietzfelbing et al prove follow fact fact let r n r exist constant oe r depend r tighter estim distribut r given for complet proof attach appendix b fact let r r jr r phi r psi stirl number second kind fact let ffl constant probabl stirl number second kind number way partit set k distinct element j nonempti subset eg chapter framework hash oblivi execut algorithm templat input algorithm set n key given array hash algorithm work two stage correspond two level hash scheme fredman komlo szemeredi first stage level hash function f chosen function select random class h suffici larg constant select analysi hash function f partit input set bucket bucket i i first stage easili implement constant time main effort implement second stage describ next second level hash tabl built second stage algorithm bucket privat memori region call block assign address memori block alloc bucket record cell design array ptr size m also bucket level function construct function inject map bucket block descript level function written ptr let us call bucket activ appropri level function yet found inact otherwis begin stage bucket activ algorithm termin bucket becom inact second stage consist olg lg n iter execut constant time iter process rapidli reduc number activ bucket number activ key iter t new memori segment use segment partit block size k each k set analysi bucket key associ one processor oper activ bucket iter given figur alloc bucket select random one memori block block select anoth bucket bucket remain activ particip next step hash bucket select random two function h tri hash block separ function either one function inject descript memori address block written appropri cell array ptr bucket becom inact otherwis bucket remain activ carri next iter figur two step iter base oblivi execut last iter may becom necessari iter repeat bodi onc constant number time precis condit number repetit given section hash tabl construct algorithm support lookup queri constant time given key x search begin read cell ptrfx content cell defin level function use x well address memori block x store actual offset block x store given inject level hash function found hash step abov implement algorithm templat describ constitut framework build parallel hash algorithm execut algorithm oblivi sens iter process find level hash function requir inform number size activ bucket success termin perform depend priori set paramet d k effect alloc step reli suffici mani memori block effect hash step reli suffici larg memori block requir keep total memori linear impos tradeoff two paramet challeng find balanc k achiev desir rate decay number activ bucket number activ key deduc number activ bucket base characterist level hash function determin d show two differ implement algorithm templat lead analysi differ natur first implement given section there paramet select way iter number activ bucket expect decreas constant factor although iter may fail constant probabl geometr decreas seri bound number activ bucket iter olg lg n iter expect number activ key activ bucket becom nlg n omegagamma remain key hash addit constant time use differ approach employ olg lg n time procedur technic point view analysi implement impos rel modest requir level hash function sinc use firstmoment analysi ie markov inequ moreov requir simpler version hash step one hash function h use expect run time olg lg n run time guarante arbitrari small constant probabl second implement given section implement character doublyexponenti rate decreas number activ bucket key olg lg n sequenc v decreas exponenti rate t v v sequenc decreas doublyexponenti rate t v v ffl ffl iter key hash without process implement superior sever respect time perform high probabl key handl origin processor form basi improv reduc number random bit technic point view analysi implement subtl impos demand requir level hash function sinc use secondmo analysi ie chebyshev inequ achiev doublyexponenti rate decreas requir care select paramet done use symbol spreadsheet approach togeth implement demonstr two differ paradigm fast parallel random algorithm involv differ flavor analysi one requir exponenti rate decreas problem size reli realloc processor item subsequ work use paradigm extens mention section paradigm rel easi understand difficult analyz use framework probabilist induct analysi expect analysi show iter succe constant probabl impli overal constant success probabl contrast second implement show iter succe ndomin probabl impli overal ndomin success probabl analysi significantli subtl reli power techniqu second moment analysi second paradigm consist doublyexponenti rate decreas problem size henc requir wrapup step obtain exponenti decreas section present first implement algorithm templat use rather elementari analysi expect show iter problem size decreas constant factor onli constant probabl gener framework describ section show impli problem size decreas overal exponenti rate olg lg n iter number key reduc nlg nomegagamma simpl load balanc algorithm alloc lg nomegagamma processor remain key use excess number processor key final hash constant time design expect consid iter random algorithm iter measur problem decreas random amount companion paper show iter one actual assum previou iter algorithm far expect behavior paradigm suggest is design iter success constant probabl assumpt least constant fraction previou iter success justifi follow lemma lemma probabilist induct consid iter random process which follow hold iter probabl least provid among first iter least t success then probabilityomegagammail everi number success iter among first iter least t paramet set analysi let level function taken h further set let fact simplifi analysi allow paramet k assum nonintegr valu actual implement must round nearest integ increas memori requir constant factor perform measur improv memori usag memori space use lemma let v number activ bucket begin iter t then proof assum level function f satisfi fact hold probabl least proof continu use lemma iter success v t v thu number activ bucket j success iter gammaj probabilist induct hypothesi among first iter least t success probabilist induct step show iter paramet k chosen achiev constant deactiv probabl bucket size distinguish follow three type event failur may caus bucket remain activ end iter i alloc failur bucket may select memori block also select bucket probabl fix bucket success reserv block alloc step sinc v bucket select random one memori block ae t v m ii size failur bucket may larg current memori block size result probabl find level hash function high enough number bucket begin iter larger fi therefor without loss gener assum v t v v bucket need becom inact still consid activ thu purpos analysi iii hash failur bucket may fail find inject level hash function even though suffici small uniqu select block let ae t probabl bucket size fi success map block size k hash step corollari bucket size fi success reserv block size k success map it becom inact expect number activ bucket begin iter therefor bound markov inequ prove induct step lemma follow lemma let n number activ key begin iter t constant c ff proof follow use simpl convex argument n maxim activ bucket begin iter size q case therefor lemma lemma follow lemma lemma exponenti decreas number activ key number activ bucket probabilityomegagamma number activ key becom nlg n c constant c olg lg n iter final stage execut second stage paramet set describ abov number avail resourc memori cell processor factor lg nomegagamma larger number activ key resourc redund make possibl hash remain activ key constant time describ remaind section key hash iter process hash auxiliari hash tabl size on consequ implement lookup queri consist search key hash tabl auxiliari hash tabl built use level hash scheme level function map set activ key array size n function select random class hash function present dietzfelbing meyer auf der heid definit properti ndomin probabl bucket size smaller lg n theorem b remaind section assum event inde occur altern use n ffl univers class hash function present siegel activ key alloc lg n processor activ bucket alloc lg n mem ori alloc done map activ key inject array size on lg n map indic bucket inject array size onlg n map done olg lg n time ndomin probabl use simpl renam algorithm remain step take constant time independ select lg n linear hash function store design array hash function use bucket memori alloc bucket partit lg n memori block size lg n bucket map parallel lg n block lg n select linear hash function map test inject carri lg n processor alloc key bucket one inject map select level function select made use simpl leftmost algorithm bucket map inject construct auxiliari hash tabl fail lemma assum number key remain activ iter process nlg n then construct auxiliari hash tabl succe ndomin probabl proof recal bucket size lg n map bucket memori block size lg n inject probabl least corollari probabl bucket inject map therefor n probabl least gamma n everi bucket least one inject map easi identifi failur algorithm fail termin within design time restart hash tabl therefor alway construct sinc overal failur probabl constant expect run time olg lg n obtain doublyexponenti decreas implement algorithm templat present previou section maintain exponenti decreas number activ bucket throughout iter section present implement number activ bucket decreas doubli exponenti rate intuit stochast process behind algorithm templat potenti achiev doublyexponenti rate memori block suffici larg comparison bucket size probabl bucket remain activ invers proport size memori block corollari consid ideal situat case iter activ bucket alloc memori block size k iter k activ bucket could alloc memori block size k iter k activ bucket alloc memori block size k on less ideal set bucket deactiv larg current valu k number bucket bound use properti level hash function must guarante fraction larg bucket also decreas doublyexponenti rate illustr crude calcul given assum memori evenli distribut activ bucket make doublyexponenti rate possibl failur probabl alloc step henc ratio m must also decreas doublyexponenti rate establish bound number larg block show larg fraction bucket alloc memori block also concern previou section there howev enough show constant bound probabl alloc failur size failur hash failur paramet set establish balanc requir doublyexponenti rate present follow analysi algorithm perform section conclud descript paramet select paramet set let level function taken h further set let memori usag proposit total memori use algorithm on proof memori use first stage on memori use iter second stage total memori use second stage therefor mostx framework time perform analysi defin runtim analysi second stage carri show lemma ndomin probabl number activ bucket begin iter lemma prove induct t lg lg n lg induct base follow fact n activ bucket subsequ subsect prove induct step deriv estim number fail bucket iter assumpt begin iter activ bucket specif show induct that ndomin probabl number activ bucket end iter bucket may fail find inject level hash function estim number bucket fail find inject level function iter assum bucket uniqu select memori block bucket size larg rel current block size accordingli section distinguish follow three type event failur may caus bucket remain activ end iter i alloc failur bucket may select memori block also select bucket ii size failur bucket may larg current memori block size result probabl find level hash function high enough iii hash failur bucket may fail find level hash function even though suffici small uniqu select block provid estim number bucket remain activ due either reason lemma case i lemma case ii lemma lemma case iii estim shown hold ndomin probabl induct step follow ad estim wrap up let therefor infer proposit ndomin probabl number iter requir deactiv bucket lg lg n lg failur uniqu select block lemma let ffl fix suppos either ffl let random variabl repres number bucket fail uniqu select block proof bucket probabl m bucket select memori block select therefor further stochast smaller binomi distribut random variabl obtain perform independ trial probabl m success say gammaomegagamma otherwis situat e sinc integ valu set cover lemma gammaffl occur constant number iter throughout algorithm requir follow special treatment bodi iter repeat thu provid second alloc attempt bucket fail uniqu select memori block first trial random variabl repres number bucket fail uniqu select block first second attempt respect j gammaomegagamma therefor domin probabl second attempt fall within condit equat lemma let lg lg n lg number bucket fail uniqu select block is ndomin probabl t proof lemma number bucket fail uniqu select memori block is domin probabl hold also ndomin probabl sinc failur hash consid bucket uniqu select block fail find inject level function draw special attent bucket size lemma number bucket larger fi is ndomin probabl t proof let incorpor appropri valu stirl number second kind fact get therefor fact ndomin probabl follow number bucket bigger fi is ndomin probabl analysi hash failur bucket small enough split two case lemma suppos k n number bucket size fi fail hash step iter is ndomin probabl t proof without loss gener may assum exactli activ bucket size fi particip step bucket map memori block size k probabl map noninject is corollari fi probabl bucket fail hash attempt therefor k let total number fail bucket then fact note sinc k n hold ndomin probabl done lemma suppos n then repeat hash step iter constant number time get proof thu therefor constant ffi recal proof lemma bucket fail hash step probabl k iter bodi repeat dffie failur probabl bucket becom k lemma follow markov inequ reduc number random bit section show reduc number random bit use hash algorithm algorithm describ previou section consum thetan lg u random bit first iter alreadi use thetan lg u random bit subsequ iter number random word u use constant factor larger memori use iter result total thetan lg u random bit sequenti hash algorithm fredman komlo szemeredi implement olg lg u bit show parallel hash algorithm implement olg lg u bit first show algorithm modifi reduc number random bit olg u lg lg n first stage requir o random element u construct level function remain unchang iter second stage requir om random element u modifi follow alloc step bucket independ select random memori block om lg random bit consum reduc olg m make use polynomi hash function lemma use lg random bit set r map constant time array size number collid element proof let select random then imag bucket defin algorithm h first appli element h appli element collid h collid element g collid h h r set element collid h clearli jr consid follow three case corollari prob r follow fact probabl jr gammaffl fact markov inequ therefor domin probabl jr case corollari inject r invok procedur block alloc increas total memori consumpt algorithm constant factor hash step implement hash part iter bodi use independ hash function activ bucket consum om lg u random bit reduc olg u use hash function pairwis independ techniqu applic context hash function essenti due modif step follow hash attempt execut step four global paramet select random algorithm hash function attempt bucket hash attempt bucket fulli independ thu proof lemma unaffect modif recal fact assum pairwis independ sinc pairwis independ proof lemma remain valid well lead reduct number random bit use algorithm olg u lg lg n number random bit reduc follow employ preprocess hash step input set inject map rang done appli hash function select appropri class map univers u rang algorithm describ use build hash tabl set s lookup key x done search x hash tabl simpl class hash function h appropri univers reduct applic shown class h follow properti select random function class requir olg lg u bit select made constant time singl processor function inject ndomin probabl comput x x u done constant time preprocess tantamount reduct size univers applic algorithm requir olg n lg lg n bit total number random bit use therefor olg lg u obtain optim speedup descript algorithm section assum number processor n thu timeprocessor product on lg lg n object section workoptim implement product on p number processor maxim array bucket array divid p sector one per processor parallel step algorithm execut processor travers sector execut task includ it key activ bucket activ let n number activ key begin iter t assum implement algorithm reach point assum activ element gather array size on lg lg n then appli nonoptim algorithm section p n lg lg n processor respons np lg lg n problem instanc give run time lg lg n np workoptim first show problem size reduc suffici applic nonoptim algorithm olg lg lg lg n iter lemma exist n n n ndomin probabl proof number activ bucket decreas doublyexponenti rate seen lemma see number key decreas doublyexponenti rate well show ndomin probabl inequ r n clearli hold summat activ bucket onli convex argument total number key activ bucket maxim activ bucket equal size number activ bucket bound therefor inequ obtain replac definit substitut numer valu paramet use lemma follow choos appropri valu respect remain exhibit workeffici implement first step algorithm implement output activ element gather array size on lg lg n rest section dedic descript implement algorithm progress number activ key number activ bucket de creas howev decreas number activ element differ sector necessarili ident time implement one parallel step proport number activ element largest sector therefor crucial occasion balanc number activ element among differ sector order obtain work effici let load sector number activ element task it load balanc algorithm take input set task arbitrarili distribut among p sector use p processor redistribut set load sector greater averag load constant factor suppos load balanc algorithm whose run time use p processor lb p ndomin probabl load balanc appli step size sector on p describ simpl workoptim implement load balanc appli first parallel step parallel step execut time order total time implement order decreas least exponenti rate total time order onp use load balanc algorithm run lb time conclud ndomin probabl run time pprocessor machin load balanc algorithm appli consum op lg lg p random bit bit use random map step similar alloc step hash algorithm thu similar approach map procedur lemma may establish number random bit load balanc algorithm reduc olg p lg lg p final remark use load balanc effici yet simpl way describ yield faster workeffici implement techniqu base care choos appropri time invok load balanc procedur appli algorithm problem size exponenti rate decreas henc appli implement section well implement load balanc algorithm use olg n time result parallel hash algorithm take onplg lg n lg n time ndomin probabl model comput section give closer attent detail implement pram studi type concurr memori access requir algorithm first present implement collis extens weaker toler model proceed present implement even weaker robust model hashtabl construct implement support search olg lg n time final examin concurr read capabl need implement implement collis toler describ implement collis implement also valid toler sinc step collis simul constant time toler provid that case here linear memori use initi select level hash function done singl processor sinc level function polynomi constant degre select done singl processor read processor constant time use sing memori cell dmax flg lg u lg nge bit concurrentwrit oper requir implement stage bucket repres algorithm templat assum bucket act singl entiti oper eg select random block select random hash function sinc usual sever key belong bucket necessari coordin action processor alloc key simpl way base fact linearli mani bucket bucket uniqu index valu f level hash function member processor whose index determin bucket index act bucket repres perform action prescrib algorithm bucket alloc hash step processor repres activ bucket select memori block level hash function record select design cell processor key bucket read cell use select block hash step particip processor whose key belong activ bucket write key cell determin level examin cell content see write oper success processor write fail attempt write key posit array ptr number bucket processor belong to processor belong bucket learn level function select bucket inject read content ptri chang valu collis symbol indic noninject complet process array ptr restor next hash attempt restor done constant time sinc array linear size summari proposit algorithm theorem implement toler implement robust describ implement that expens slow lookup oper make assumpt result concurrentwrit cell specif present implement robust model lookup queri may take olg lg n time worst case o expect time key tabl difficulti robust model let processor bucket know whether level hash function bucket inject not main idea modifi implement allow iter proceed without determin whether level hash function inject not whenev key written memori cell hash step deactiv bucket size decreas modifi algorithm perform least well implement bucket deactiv key map inject total memori use modifi algorithm size represent hash tabl chang alloc step first note algorithm carri without use bucket repres all alloc memori block done use hash function lemma processor individu comput index memori block evalu function g function select design processor represent lg bit read constant time processor modifi algorithm hash step carri activ bucket is even bucket collid alloc step particip hash step modif serv improv perform algorithm sinc even share block anoth bucket probabl bucket find inject function block zero modif elimin concurr memori access need detect failur alloc step hash step select level hash function done hash step describ section seen four global paramet select made avail processor done constant time remain elimin concurr memori access requir determin level function singl bucket inject whenev key success hash function deactiv even key bucket success hash thu key bucket may store hash tabl use differ level hash function two step iter hash algorithm summar figur let x activ key bucket fx processor assign x execut follow step alloc comput i index memori block select bucket x g defin hash determin h level hash function select bucket x h defin write x cell h x memori block g i read content cell x written key x becom inact figur implement iter hash algorithm robust lookup algorithm search key x done follow let read posit h x memori block g i appropri array all random bit use hash tabl construct algorithm assum record avail search termin either x found els exce number iter construct algorithm lookup algorithm requir olg lg n iter worst case howev key x expect lookup time over random select made hash algorithm o altern simplifi implement curious sequenc modif algorithm describ section lead level hash scheme ie elimin indirect address see thi observ iter activ key x written memori cell g x function g x depend n random select made algorithm input even simpler implement level hash algorithm delin next iter t new array size use defin addit function g defin select random processor repres activ key x iter tri write x g x read cell x success written g x x deactiv otherwis x remain activ processor repres carri next iter see algorithm termin olg lg n iter observ oper key iter oper bucket alloc step section therefor analysi section reus substitut key bucket and ignor failur hash step level algorithm hash tabl consist collect array and easili verifi linear size lookup queri given key x execut olg lg n time read g x minim concurr read requir algorithm construct hash tabl toler robust modifi use concurrentread singl cell onli allow preprocess stage olg n time concurr read elimin impli ercw model suffici modif parallel lookup still requir concurr read execut time increas olg lg n worst case nevertheless expect time lookup singl key x o detail describ next concurr read toler implement two type concurr read oper requir modifi algorithm first sequenc olg lg n function g or altern g simplifi implement must agre upon processor sinc function repres olg u bit select broadcast begin iter concurrentread cell singl cell concurr read requir broadcast elimin ad olg ntime preprocess step broadcast thi special case simul crcw pram erew pram kind concurrentread oper occur processor read memori cell verifi hash cell succeed oper replac follow procedur memori cell processor stand by whenev pair hx ji written cell processor assign cell send acknowledg processor j write memori cell j design array lookup algorithm requir concurrentread capabl sens lookup oper demand construct hash tabl similar phenomenon observ karp lubi meyer auf der heid context simul random access machin distribut memori machin main challeng design parallelhash base simul algorithm execut read step congest execut write step resolv attempt write sever locat use first write succeed difficult resolv read congest sinc cell valu store alreadi determin inde read oper constitut main runtim bottleneck algorithm concurr read robust implement simplifi level hash algorithm construct hash tabl robust modifi follow elimin step processor key x read content cell tri write cell instead use acknowledg techniqu describ abov processor j handl activ key x write hx ji cell g x processor stand cell g x hx ji written send acknowledg processor j note implement introduc new type failur due unpredict concurr write oper robust acknowledg success hash may receiv consid exampl follow situat let j processor whose key x collid let i two processor collid key y ie g two processor concurr write pair hy ii hy cell g y result concurr write arbitrari particular pair hx ji would caus processor stand cell g y garbl acknowledg sent processor j recal acknowledg processor j implement write memori locat associ j number new failur describ half number collid key easi verifi analysi remain valid sinc number new failur number hash failur account section occur implement hash multiset conclud technic discuss briefli consid variat hash problem input multiset rather set first note analys exponenti doublyexponenti rate decreas problem size affect possibl multipl occurr key result reli estim number activ bucket rather number activ key number distinct keysnot number keysdetermin probabl bucket find inject function predict decreas number activ key essenti obtain optim speedup algorithm unfortun analysi section regard implement section hold understand difficulti consid case substanti fraction input consist copi key then nonneglig probabl key may belong larg bucket probabl bucket deactiv first iter memori block suffici larg small allow global decreas number key high probabl consequ rapid decreas number bucket may accompani similar decreas number key contrast natur analysi section make suscept easi extens multipl key lead optim speedup algorithm albeit expect perform onli use probabilist induct lemma requir show copi activ key stand constant posit probabl deactiv iter sinc analysi base expect onli concern regard correl copi key depend differ iter detail left reader also note model comput requir multiset collis sinc must possibl distinguish case multipl copi key written memori cell case distinct key written also extens hash algorithm requir concurr read singl memori cell use hash multiset input collis model oppos robust must assum final observ hash problem multiset input reduc ordinari hash problem in input consist set procedur known leader elect procedur select singl repres among processor share valu use olg lg ntime linearwork leader elect algorithm run toler theorem given multiset n key drawn univers u hash problem solv use on space i olg lg n time high probabl use n processor ii olg lg n lg n time on oper high probabl algorithm run toler convers note hash algorithm run arbitrari solv leader elect problem particular simpl level hash algorithm robust implement arbitrari multiset input give simpl leader elect algorithm consid anoth variant multiset hash problem data record associ key natur semant problem multipl copi key insert hash tabl data record ident processor repres copi key conflict data record termin comput error code collis model make easi enough extend implement discuss accommod variant sophist semant data record consolid requir differ treatment eg appli integ sort algorithm hash key see conclus present novel techniqu hash oblivi execut use techniqu algorithm construct perfect hash tabl fast simpl effici made possibl run time obtain best possibl model key handl origin processor number random bit consum algorithm thetalg lg u n open question close gap number thetalg lg u bit consum sequenti hash algorithm program execut processor extrem simpl inde coordin processor comput function test inject implement robust model even coordin elimin larg constant hidden oh notat analysi may render describ implement still far practic believ constant substanti improv without compromis simplic algorithm care tune paramet tighten analysi may interest subject separ research use oblivi execut approach present paper limit hash problem alon adopt simul among submodel crcw pram hash algorithm key partit subset howev partit arbitrari given input subset maximum key must comput subsequ work oblivi execut techniqu hash section implement section present preliminari form subsequ oblivi execut techniqu use sever time obtain improv run time parallel hash algorithm matia vishkin gave olg n lg lg n expect time algorithm gil matia vishkin gave tighter failur probabl analysi algorithm yield olg n time high similar improv from olg n lg lg n expect time olg n time high probabl describ independ bast hagerup olg n time hash algorithm use build block parallel dictionari algorithm present parallel dictionari algorithm support parallel batch oper insert delet lookup oblivi execut techniqu import role implement insert dictionari dictionari algorithm run olg n time high probabl improv on ffl dictionari algorithm dietzfelbing meyer auf der heid dictionari algorithm use obtain space effici implement parallel algorithm cost slowdown olg n time high probabl hash algorithm use logstar paradigm reli extens processor realloc simpl algorithm present paper moreov requir substanti larger number random bit karp lubi meyer auf der heid present effici simul pram distribut memori machin doublylogarithm time level improv previou simul logarithm time level use fast parallel hash algorithm essenti result algorithm present suffici obtain it goldberg jerrum leighton rao use techniqu paper obtain oh lg lg n random algorithm hrelat problem optic commun parallel comput model gibbon matia ramachandran adapt algorithm present obtain lowcontent parallel hash algorithm qrqw pram model impli effici hash algorithm valiant bsp model henc hypercubetyp noncombin network acknowledg thank martin dietzfelbing faith e fich provid help comment also wish thank uzi vishkin avi wigderson earli discuss part research done visit first author att bell laboratori second author univers british columbia would like thank institut support visit mani valuabl comment made two anonym refere grate acknowledg r probabilist method parallel construct suffix tree fast reliabl parallel hash optim bound decis problem crcw pram improv determinist parallel integ sort optim separ concurrentwrit parallel machin observ concern synchron parallel model comput univers class hash function new simul crcw pram power twopoint base sampl polynomi hash function reliabl relat concurrentwrit model parallel comput store spars tabl o worst case access time data structur algorithm approxim string match effici lowcontent parallel algo rithm qrqw pram account content parallel algorithm fast load balanc pram fast hash pramdesign expect design algorithm expect effect load balanc polici geometr decay algorithm fast effici simul among crcw pram simpl fast parallel hash toward theori nearli constant time parallel algorithm doubli logarithm commun algorithm optic commun parallel comput univers interconnect pattern parallel comput optim parallel approxim algorithm prefix sum integ sort concret mathemat incompar parallel comput toward optim parallel bucket sort everi robust crcw pram effici simul prioriti pram introduct parallel algorithm sort search convert high probabl nearlyconst timewith applic parallel hash parallel hash integ sort data structur algorithm i sort search data structur olg n parallel connect algorithm univers class fast high perform hash function gener purpos parallel architectur tr