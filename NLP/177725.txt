t model check modular verif a describ framework composit verif finitest process framework base two idea subset logic ctl satisfact preserv composit preorder structur captur relat compon system contain compon satisfact formula logic correspond particular structur a tableau formula preorder show assumeguaranteestyl reason within framework addit demonstr effici method model check logic check preorder sever special case implement system base method use give composit verif cpu control b introduct tempor logic model check procedur use tool verif finit state system howev procedur tradit suffer state explos problem problem aris system compos mani parallel process gener size state space grow exponenti number process introduc symbol represent set state transit relat use symbol model check procedur system larg state space state verifi further time space requir techniqu may practic polynomi number compon system research sponsor part avion laboratori wright research develop center aeronaut system divis afsc us air forc wrightpatterson afb ohio contract fc arpa order no part nation scienc foundat contract no ccr part usisra binat scienc foundat view conclus contain document author interpret repres offici polici either express impli us govern unfortun symbol procedur still limit mani realist problem tractabl due size thu motiv search addit method handl state explos problem method work well conjunct techniqu obviou method tri avoid state explos problem use natur decomposit system goal verifi properti individu compon infer hold complet system use deduc addit properti system verifi properti compon may also necessari make assumpt environ approach exemplifi pnueli assumeguarante paradigm formula logic tripl him hi tempor formula program formula true whenev part system satisfi system must also satisfi typic proof show him hi htrueim hold conclud htrueim k hi true order autom approach model checker must sever properti must abl check properti true system built use given compon gener must abl restrict given class environ check must also provid facil perform tempor reason exist model checker design provid facil instead typic assum given complet system eleg way obtain system properti provid preorder finit state model captur notion more behavior use logic whose semant relat preorder preorder preserv satisfact formula logic ie formula true model also true model smaller preorder addit composit preserv preorder system smaller preorder individu compon final satisfact formula correspond smaller particular model a tableau formula preorder framework reason sequenc might express as tableau k assumpt may given either formula directli finit state model whichev concis conveni complex form reason induct also possibl within framework choos comput model logic preorder obtain system thi guid follow consider first must abl realist model physic system circuit second effici procedur model check check preorder final possibl implement procedur effect use symbol techniqu paper propos preorder use subset logic ctl subset strictli express ltl further induc subset ctl express enough verif task effici model check algorithm also give tableau construct ctl subset construct provid mean tempor reason make possibl use formula assumpt preorder semant logic includ notion fair essenti model system commun protocol show use result verifi system compos moor machin moor machin explicit notion input output particularli suitabl model synchron circuit final suggest effici method check preorder sever interest case implement system base result system support effici composit verif tempor reason paper organ follow section survey relat work section present logic semant for kripk structur preorder properti given section next section defin semant logic moor machin given moor machin formula show effici check whether environ moor machin environ satisfi formula section present tableau construct demonstr use tempor reason method check preorder discuss section section give composit verif simpl cpu control conclud summari direct futur work relat work much work reduc complex automat verif group two class first class includ method build reduc global state graph expand need portion global state graph local model check algorithm base logic like calculu use tableaubas procedur deduc specif state the initi state system satisfi given logic formula state space gener need algorithm formula small portion space may examin main drawback algorithm often entir space gener for exampl check properti hold global also clear whether algorithm take good advantag symbol represent graf steffen describ method gener reduc version global state space given descript system structur specif compon interact clark long mcmillan describ similar attempt method still produc larg state graph state system equival much verif must redon part system chang shtadler grumberg show verifi network process whose structur describ grammar approach involv find global behavior compon network arbitrari complex verifi check one repres system mani system howev number state may still prohibit clear whether method use symbol represent second class method composit properti individu compon verifi properti global system deduc these represent global state space built josko give algorithm check whether system satisfi ctl specif environ algorithm also allow assumpt environ specifi restrict lineartim logic system abl handl assumeguarante reason method fairli ad hoc howev complex form reason induct cannot easili incorpor system within framework cc number suggest composit reason larsen investig express power formal specifi behavior process system suggest equival refin satisfact of formula three interest relat implement specif howev discuss applic idea verif suggest implement walker demonstr use preorder plu knowledg system oper simplifi verif bisimul equiv alenc cleaveland steffen use similar idea winskel propos method decompos specif properti compon system must satisfi specif hold approach appeal unfortun deal parallel composit difficult appar whether method work well symbol represent kurshan describ verif methodolog base test contain regular languag homomorph reduct use map implement specifica tion specif may use implement next level abstract dill propos eleg form trace theori use similar manner framework handl live properti well approach depend specif determinist effici neither approach make provis use logic formula specif assumpt shurek grumberg describ criteria obtain modular framework illustr idea use ctl univers path quantifi system closest work present here give provis handl fair effici use formula assumpt support tempor reason model system also associ fix decomposit compon henc unclear perform induct reason framework tempor logic logic present section branchingtim tempor logic order abl effici decid whether formula true system contain given compon elimin existenti path quantifi logic thu formula may includ univers quantifi path unlik lineartim tempor logic nest path quantifi allow ensur existenti path quantifi aris via negat assum formula express negat normal form word negat appli atom proposit logic interpret form kripk structur fair constraint path quantifi rang fair path structur logic ctl set state formula given follow induct definit constant true fals state formula everi atom proposit p p state formula state formula state formula path formula state formula state formula path formula path formula path formula a x b u also use follow abbrevi f g path formula denot true u fals v respect ctl restrict subset ctl path quantifi may preced restrict set path formula precis ctl logic obtain elimin rule ad follow rule state formula x u v state formula practic found mani formula use specifi verifi system express ctl almost express ctl exampl formula express ctl weak form absenc deadlock state alway possibl reach state p hold give semant logic use form kripk structur fair constraint tupl follow form finit set state set initi state finit set atom proposit l function map state set atom proposit true state r theta transit relat f streett accept condit repres pair set state definit path infinit sequenc state infinit mani g fair path iff everi notat n denot suffix begin n consid semant logic ctl atom proposit drawn set a definit satisfact formula satisfact state formula state path formula fair path j defin induct follow everi fair path start s state formula iff first state satisfi state formula a c indic everi emerson halpern compar express power three logic ltl ctl ctl show ltl ctl incompar express power ctl strictli express either other elimin existenti path quantifi ctl ctl affect rel express power logic ctl trivial encompass ltl ctl formula fgp formula ctl equival ltl formula hand equival ltl formula fg p thu ltl ctl incompar strictli less express ctl homomorph composit structur section defin preorder use examin properti also show properti make assumeguarante style reason possibl definit structur homomorph let two structur let state respect relat h theta homomorph m t m follow condit hold ht hs impli a b everi fair path exist fair path everi h satisfi properti say h homomorph h homomorph iff everi hs indic two path correspond item b abov write h homomorph m s m exist homomorph understood sometim write intuit two state homomorph label agre atom proposit second structur everi fair path first state correspond fair path second state two structur homomorph everi initi state first correspond initi state second one may view second structur specif first implement sinc specif may hide implement detail may smaller set atom proposit definit composit structur let two structur composit denot k structur defin follow l r choic definit composit motiv correspond composit moor machin transit composit joint transit compon state composit pair compon state agre common atom proposit first note composit oper usual properti theorem composit structur commut associ up isomorph proof straightforward tediou turn connect relat composit begin note path k fair iff restrict compon result fair path follow condit equival fair path fair path respect s state n proof assum condit abov definit composit path let definit fair path inf henc fair path similarli fair path assum condit abov definit composit path suppos p theta first case impli second case similar henc fair path theorem preorder k proof relat s s homomorph reflex thu remain show transit assum let h homomorph let h homomorph defin h relat product h h ie definit homomorph exist h similarli exist h s h s h definit homomorph fair path s exist fair path h sinc h homomorph exist fair path h homomorph thu defin h initi state km label s lsl s fair path k previou lemma fair path definit h h everi i henc h homomorph k let h homomorph defin h ni show h homomorph let s initi state k definit composit h state k sinc further initi state k definit composit definit h h first note fair path k s everi a previou lemma fair path start s fair path sinc path everi n definit homomorph ls argu abov i s state k h definit h appli previou lemma find s fair path start s correspond path s first note everi state s s state k defin definit composit s initi state k s s trivial label s use previou lemma definit composit find fair path fair path k definit h i henc h homomorph k theorem let state let h homomorph path h everi ctl state formula with atom proposit everi ctl path formula with atom proposit proof proof proce induct structur formula fals result trivial atom proposit definit homomorph lsa case induct hypothesi impli case everi fair path s fair path s definit homomorph exist fair path h induct hypothesi impli path formula consist state formula initi state satisfi induct hypothesi sinc initi state case conjunct disjunct path formula similar case a sinc h also induct hypothesi impli b impli exist n n j appli induct hypothesi n c case similar previou two case corollari everi ctl formula with atom proposit proof immedi use theorem corollari see standard ctl ctl model check algorithm restrict ctl ctl view determin whether formula true system contain given compon key composit verif theorem corollari also straightforward justifi sound assumeguarante paradigm assumpt given structur the connect structur formula examin section discharg assumpt involv check relat suppos wish check verifi follow relationship word discharg assumpt a assumpt discharg assumpt assumpt satisfi desir formula theorem corollari impli k theorem corollari also show system contain k satisfi note necessarili true either may involv atom proposit moor machin seen structur defin earlier definit use composit reason synchron system howev system typic given use common finit state model moor machin moor machin model comput explicit notion input output sinc input origin extern uncontrol environ machin alway receiv combin input valu moor machin synchron composit moor machin machin make singl step everi point thu suitabl model synchron circuit section show natur correspond moor machin empti set input structur defin earlier use correspond defin semant ctl respect moor machin show use composit reason verifi system compos moor machin definit moor machin moor machin tupl follow form finit set state set initi state finit set input proposit finit set output proposit l function map state set output proposit true state theta transit relat requir everi v i exist rs v t also let denot o composit moor machin let moor machin composit denot km moor machin defin follow l r turn question defin satisfact specif moor machin key consider wish composit method reason thu satisfi specif mean plu environ satisfi specif achiev consid behavior complet system involv definit moor machin call close intuit behavior close machin cannot alter machin structur natur correspond it defin structur precis now definit actual slightli gener assign structur nonclos machin well definit structur moor machin structur correspond moor machin denot km defin follow l s v r definit moor machin call close environ o close environ compos result moor machin close defin satisfact formula moor machin definit satisfact moor machin moor machin ctl formula atom proposit a everi close environ must demonstr effici check whether moor machin o km k km proof defin oe map state km km state kmkkm follow oe suppos map state km k km definit oe immedi definit moor machin composit v u disjoint o henc impli henc oe inject argu oe surject consid cardin two set state first consid js number state cross product km theta km compat label fix pair state ji j state km first compon ji j km first compon thu potenti jij state km correspond howev must correspond atom proposit o thu exactli state km k km correspond thu henc oe biject initi state km k oe initi state km kkm sinc initi state km impli initi state km similarli oe initi state km k km initi state km k set atom proposit two structur clearli ident label v label oe v v s v l s r km fair set structur empti definit moor machin maxim close environ denot em moor machin defin follow maxim environ for m repres environ anyth step intuit possibl behavior arbitrari environ must also possibl behavior maxim environ logic use specifi properti hold everi possibl behavior system henc plu maxim environ satisfi formula environ satisfi formula lemma close environ suppos proof defin note everi hs state l relat h everi state initi state hs definit h l fact everi state relat state plu fact r ident true impli path h everi path fair thu h homomorph lemma let moor machin km isomorph km k em map state state oe v oe obvious inject oe surject sinc subset state em must henc similarli s trivial equal also s v s v final r f f empti theorem moor machin proof suppos km find km k em j lemma km k kem close environ lemma henc theorem km k km appli corollari km k km henc lemma km thu determin system k k k n satisfi formula instead check lemma equival check formula illustr previou section use assumeguarante paradigm tri verifi latter relat thu actual verif work structur even though thing want verifi properti composit moor machin tableau construct section give tableau construct ctl formula for similar construct ltl see burch et al show tableau formula maxim model formula relat thu structur gener construct use assumpt compos structur desir system appli model check algorithm discharg assumpt simpli matter check environ satisfi formula also indic tableau use tempor reason remaind section fix ctl formula definit set sub subformula formula defin follow equat atom proposit fg negat atom proposit pg a b c definit set el elementari formula formula defin follow equat atom proposit fpg a b c special elementari subformula x fals denot nonexist fair path fals indic fair path begin s definit formula tableau denot t structur fi defin follow map el sub ftrue falseg defin follow equat a g b c i ii g g rs t iff formula x el x impli phi lemma subformula phi proof proof proce induct structur everi state satisfi true result trivial atom proposit g negat atom proposit g sinc induct hypothesi case a rs t definit r phi induct hypothesi impli chosen arbitrarili fair path satisfi second state henc b state phi either case successor trivial case induct hypothesi impli case induct hypothesi impli definit r also know rt u u phi consid fair path s note state path satisfi first condit abov two case consid i j j first state path abov everi henc path satisfi u ii everi j j j impli everi j induct hypothesi know j phi definit f contradict fact fair case imposs thu c state phi either case successor trivial case also either phi everi u rt u u phi fair path s note satisfi first condit abov induct hypothesi impli induct hypothesi impli j i j path satisfi henc let lemma defin relat h theta everi subformula elementari formula proof proof proce induct structur base case induct elementari subformula plu true fals result trivial definit h negat atom proposit induct hypothesi case given three case a fair path start induct hypothesi impli b induct hypothesi phi phi c otherwis induct hypothesi case phi u a fair path start case fals induct hypothesi impli phi induct hypothesi phi also either appli induct hypothesi again either case phi thu case lemma relat h given homomorph proof note everi state singl state hs s let set atom proposit assum hs s g definit h fair path let x x x n formula form x el satisfi state relat h previou definit h formula form x must exactli x x x n definit r see rs sinc hs continu process defin get sequenc state start hs complet proof must show sequenc fair assum fair look f see must elementari subformula x u b inf phix u b consid one state definit h impli addit previou lemma impli j i fair path start everi state path satisfi b henc fact fair path theorem proof suppos t lemma definit tableau everi initi state t satisfi ie t definit everi definit h everi pair uniqu lemma impli phi definit tableau lemma h homomorph t tableau construct also use reason formula typic interest whether everi model formula also model formula relat proposit proof everi model particular t also model assum previou corollari t sinc t sometim extend set elementari formula formula ad addit atom proposit exampl wish check whether true impli p would extend set atom proposit true includ p anoth way view imagin rewrit true true p p formula nontrivi model iff case j x fals true everi model iff true check homomorph section discuss problem determin whether exist homomorph two structur goal effici determin first note h h homomorph h h homomorph also trivial homomorph fact impli maxim homomorph set inclus actual give algorithm comput maxim homomorph also note follow fact state fair path start s homomorph exactli state state fair path start homomorph exactli state start fair path lsa state start fair path detect polynomi time elimin preprocess step henc without loss gener assum everi state start fair path describ polynomi time algorithm check preorder sever import special case suppos trivial accept condit ie f definit defin sequenc relat h follow h first h h such exist sinc h j h j j h j finit theorem everi proof first note h greatest fix point equat suppos state h s fair path start s equat exist state r continu fashion find path start h s path fair henc h homomorph ie show impli h s show homomorph h fix point equat sinc h greatest fix point h henc homomorph h hs enough show h subset set hs earlier assumpt exist fair path t henc let t fair path t sinc hs exist fair path see s set note h jsj delta js j h j also comput polynomi time h comput polynomi time anoth import case determinist ie r languag contain languag the languag state set sequenc label occur along fair path start s relat check polynomi time use techniqu clark draghicescu kurshan final result tableau construct say shown previou section check whether reduc problem check whether exampl implement bddbase model checker base theori develop previou section model checker written combin yale dialect scheme c includ facil model check tempor reason via tableau construc tion check homomorph illustr system use control simpl cpu exampl control written state machin descript languag call csml compil moor machin give brief descript cpu here clark long mcmillan give detail cpu simpl stackbas machin ie part cpu memori contain stack instruct operand pop onto result push two part cpu control first part call access unit respons cpu memori refer enc second part call execut unit interpret instruct control arithmet unit shifter etc two part oper parallel access unit execut unit commun via small number signal three signal push pop fetch input access unit indic execut unit want push pop someth stack get next instruct signal correspond readi output access unit execut unit must wait appropri readi signal proceed one addit signal branch assert execut unit want jump new program locat order increas perform access unit attempt keep valu top stack special regist call ts regist goal keep execut unit wait memori exampl ts regist contain valid data pop oper proceed immedi addit valu push stack move regist copi memori later point access unit also load instruct queue possibl fetch requir wait memori queue flush whenev cpu branch clark long mcmillan gave number correct condit control demonstr formula verifi composit fashion form condit divid three class first class consist simpl safeti properti access unit exampl one formula state access unit output topofstack pointer memori address either read write ts regist model checker verifi properti held access unit alon henc hold system contain access unit condit second class slightli complex properti safeti properti specifi sequenc oper allow exampl one condit push xtsstore pop v push tsload push abbrevi push pushrdi pop abbrevi pop poprdi formula assert push oper complet anoth push cannot complet access unit cannot attempt load ts regist memori either pop occur ts regist store stack word regist contain valu need push stack cpu cannot anyth would destroy valu valu either use success store memori sinc properti class essenti specifi access unit may assert readi signal tempt check whether hold access unit alon well possibl howev properti also depend memori acknowledg signal behav verifi properti made simpl model memori see figur concis figur show moor machin actual model use obtain ad fair constraint shown figur structur correspond moor machin properti class except one turn true system compos access unit model memori except analog previou formula deal occur pop counterexampl produc model checker formula show formula fals push pop could occur simultan examin access unit saw design assum oper would mutual exclus formula turn true addit assumpt gpush pop model checker verifi build tableau assumpt compos access unit memori model check formula f defin memrd memwr memack figur memori abstract final class criteria consist singl live properti gffetch fetchrdi formula state cpu alway fetch anoth instruct demonstr two differ way verifi properti one way observ formula true must obvious case memori respond request eventu execut unit execut infinit sequenc push pop branch memori model alreadi fair constraint ensur first these noth guarante second take care use simpl model execut unit see figur again actual model structur deriv moor machin plu indic fair constraint output idl figur abbrevi pushpopfetchbranch model checker verifi access unit plu model execut unit memori satisfi formula also verifi homomorph structur the actual execut unit model thu conclud formula hold final system provid homomorph actual memori model also check execut unit model satisfi assumpt gpush pop use abov sinc homomorph execut unit model know execut unit must satisfi assumpt well final step allow us conclud composit access execut unit satisfi entir specif provid memori homomorph model use fetchrdi pushrdi poprdi fetchrdi pushrdi poprdi f defin branch fetch idl push pop figur execut unit abstract also verifi final properti use seri ctl assumpt idea check properti execut unit order formula true access unit must eventu respond push pop request must fill instruct queue appropri guarante access unit meet condit know execut unit tri two oper remov request correspond oper complet begin properti fetch first specifi everi pair oper execut unit perform mutual exclus two formula state execut unit make push pop request deassert request oper complet model checker verifi properti hold execut unit alon use tableau construct first properti impli assumpt gpush pop use abov use formula assumpt check system compos access unit memori model satisfi formula specif state everi push oper complet similarli use formula assumpt verifi system compos access unit memori model also satisfi formula gffetchrdi branch at point either access unit eventu fill instruct queue branch occur final use formula formula assumpt model checker verifi execut unit satisfi gffetch fetchrdi again complet verif would demonstr homomorph actual memori model it conclus identifi subset ctl ctl appropri composit rea sone subset satisfact preserv composit henc standard model check algorithm use answer question formula true system contain specifi compon also propos preorder appropri ctl preorder captur relat compon system contain compon provid basi use assumeguarante style reason logic assumpt given structur discharg check preorder given tableau construct ctl subset ctl satisfact ctl formula correspond tableau formula preorder construct make possibl use ctl formula assumpt tempor reason ctl also effici model check algorithm implement verif system base result use verifi nontrivi system composit fashion sever direct futur work intuit ctl subset ctl maxim sens formula satisfact preserv composit equival formula ctl prove thi anoth idea look differ logic flavor ctl extend automata oper calculu delta modal would also interest tri extend tableau construct section ctl order accomplish howev almost certainli necessari use complex type structur given definit anoth question whether possibl appli idea branchingtim logic existenti path quantifi exampl reason algorithm determin whether ctl formula true system contain given compon fairli easi come algorithm sound complet seem difficult achiev also wish examin problem effici check preorder arbitrari structur final essenti tri appli composit reason method consid complex system order evalu techniqu r symbol model check state beyond unifi approach show languag contain equival variou type automat verif finitest concurr system use tempor logic specif composit model check languag composit specif verif finit state hardwar control partial verifi tempor properti sequenti machin without build state diagram trace theori automat hierarch verif speedindepend circuit sometim effici model check fragment proposit mucalculu composit minim finit state process introduct automata theori verifi correct aadlmodul use model check analysi discret event coordin structur induct theorem process express power implicit specif check finit state concurr program satisfi linear specif calculu commun system transit global modular tempor reason program network grammar modular framework computeraid verif moti vation local model check modal mucalculu bisimul diverg composit check valid finit state process model check modal tr myampersandldquosometimesmyampersandrdquo myampersandldquonot nevermyampersandrdquo revisit automat verif finitest concurr system use tempor logic specif structur induct theorem process trace theori automat hierarch verif speedindepend circuit composit model check concurr workbench network grammar commun behavior automat verif verifi correct aadl modul use model check analysi discret event coordin unifi approach show languag contain equival variou type myampersandohgrautomata transit global modular tempor reason program tableaubas model check proposit mucalculu express power implicit specif note model check model myampersandngrcalculu check finit state concurr program satisfi linear specif calculu commun system introduct automata theori languag comput local model check modal mucalculu modular framework computeraid verif verifi tempor properti sequenti machin without build state diagram composit minim finit state system design synthesi synchron skeleton use branchingtim tempor logic ctr pallab dasgupta arindam chakrabarti p p chakrabarti open comput tree logic formal verif modul proceed confer asia south pacif design automationvlsi design p januari robert john walter check model built use graphic base formal model languag journal system softwar v n p april alma l juarez dominguez nanci a day composit reason portbas distribut system proceed th ieeeacm intern confer autom softwar engin novemb long beach ca usa i s w b prasetya s d swierstra factor fault toler theoret comput scienc v n p januari david harel orna kupferman mosh y vardi complex verifi concurr transit system inform comput v n p march yunshan zhu jame h kukula generatorbas verif proceed ieeeacm intern confer computeraid design p novemb k mani chandi michel charpenti experi program composit proof formal method system design v n p januari arindam chakrabarti pallab dasgupta p p chakrabarti ansuman banerje formal verif modul interfac real time specif proceed th confer design autom june new orlean louisiana usa r s lazi t c newcomb a w rosco model check dataindepend system array without reset theori practic logic program v n p septemb doron bustan orna grumberg simulationbas minim acm transact comput logic tocl v n p april jason baumgartn tamir heyman vigyan singhal adnan aziz abstract algorithm verif levelsensit latchbas netlist formal method system design v n p juli juergen dingel computerassist assumeguarante reason verisoft proceed th intern confer softwar engin may portland oregon yonit kesten nir piterman amir pnueli bridg gap fair simul trace inclus inform comput v n p juli alur radu grosu modular refin hierarch reactiv machin proceed th acm sigplansigact symposium principl program languag p januari boston ma usa thoma a henzing orna kupferman sriram k rajamani fair simul inform comput v n p februari ferucio laurentiu tiplea aurora tiplea petri net reactiv modul theoret comput scienc v n p august m clark o grumberg s jha verifi parameter network acm transact program languag system topla v n p sept adnan aziz thoma shipl vigyan singhal robert brayton alberto sangiovannivincentelli formuladepend equival composit ctl model check formal method system design v n p septemb peter henderson model architectur dynam system program methodolog springerverlag new york inc new york ny alur thoma a henzing reactiv modul formal method system design v n p juli alur radu grosu modular refin hierarch reactiv machin acm transact program languag system topla v n p march orna kupferman mosh y vardi automatatheoret approach modular model check acm transact program languag system topla v n p jan yunja choi sanjai rayadurgam mat pe heimdahl automat abstract model check softwar system interrel numer constraint acm sigsoft softwar engin note v n sept doron bustan orna grumberg applic fair simul inform comput v n p octob xudong huiqun yu tianjun shi junhua ding yi deng formal analyz softwar architectur specif use sam journal system softwar v n p april edmund clark armin bier richard raimi yunshan zhu bound model check use satisfi solv formal method system design v n p juli arindam chakrabarti patric godefroid softwar partit effect autom unit test proceed th acm ieee intern confer embed softwar octob seoul korea thoma a henzing orna kupferman rupak majumdar univers existenti fragment calculu theoret comput scienc v n p march ansuman banerje pallab dasgupta open famili tempor logic annot tempor oper input constraint acm transact design autom electron system toda v n p juli f zaraket j baumgartn a aziz scalabl composit minim via static analysi proceed ieeeacm intern confer computeraid design p novemb san jose ca mat p heimdahl devaraj georg effect testsuit reduct automat gener modelbas test autom softwar engin v n p march sharon barner orna grumberg combin symmetri reduct underapproxim symbol model check formal method system design v n p septemb dongfeng wang farokh b bastani i ling yen autom aspectori decomposit processcontrol system ultrahigh depend assur ieee transact softwar engin v n p septemb s chouali j julliand pa masson f bellegard pltlpartit model check reactiv system fair assumpt acm transact embed comput system tec v n p may mauro caporuscio paola inverardi patrizio pelliccion composit verif middlewarebas softwar architectur descript proceed th intern confer softwar engin p may andrew d gordon alan jeffrey authent type secur protocol journal comput secur v n p david dharb tutori introduct symbol model check logic concurr synchronis kluwer academ publish norwel ma frdric herbreteau franck cassez olivi roux applic partialord method reactiv programswith event memor realtim system v n p may kathi fisler mosh y vardi bisimul minim symbol model check formal method system design v n p juli composit analysi verif parameter system theoret comput scienc v n p march de la riva javier tuya automat gener assumpt modular verif softwar specif journal system softwar v n p septemb r gentilini c piazza a policr bisimul simul coarsest partit problem journal autom reason v n p hakan erdogmu architecturedriven verif concurr system nordic journal comput v n p winter tevfik bultan richard gerber william pugh modelcheck concurr system unbound integ variabl symbol represent approxim experiment result acm transact program languag system topla v n p juli sara gradara antonella santon maria luisa villani use heurist search find deadlock concurr system inform comput v n p novemb stephan merz model check tutori overview model verif parallel process springerverlag new york inc new york ny christoph kern mark r greenstreet formal verif hardwar design survey acm transact design autom electron system toda v n p april edmund m clark berndholg schlingloff model check handbook autom reason elsevi scienc publish b v amsterdam netherland