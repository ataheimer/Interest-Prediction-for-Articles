t random timework optim parallel algorithm find minimum span forest a present random algorithm find minimum span forest msf undirect graph high probabl algorithm run logarithm time linear work exclus read exclus write erew pram result optim wr t work parallel time first provabl optim parallel algorithm problem measur also give simpl gener processor alloc scheme treelik comput b introduct present random parallel algorithm find minimum span forest msf edg weight undirect graph erew pram kr algorithm run expect logarithm time linear work size input bound also hold high probabl size input result optim respect work parallel time first provabl optim parallel algorithm problem measur brief summari relat result follow lineartim sequenti msf algorithm karger klein tarjan kkt and build it came linearwork parallel mst algorithm crcw pram ckt ckt erew pram pr best crcw pram algorithm known date ckt run logarithm time linear work time bound known optim best erew pram algorithm known prior work result poon ramachandran run olog n log log linear work algorithm random recent chong han lam chl present determinist erew pram algorithm msf run logarithm time linear number processor henc work om n log n n number vertic edg input graph observ poon ramachandran pr algorithm pr could speed run olog n delta log n time linear work use algorithm chl subroutin and modifi contract subroutin pr paper improv run time algorithm pr pr olog n best possibl improv algorithm ckt achiev logarithm time bound less power erew pram part work support texa advanc research program grant seth petti also support mcd fellowship algorithm simpl phase structur make subroutin call chonghan lam algorithm chl fairli complex outsid subroutin call which made simplest version algorithm chl step algorithm quit straightforward addit first timework optim parallel algorithm msf algorithm use simpler altern sever parallel algorithm crcw pram replac call chl algorithm call simpl logarithm time linearprocessor crcw algorithm one as result algorithm run logarithm time linear work consider simpler msf algorithm ckt modifi crcw pram algorithm simpler linearwork logarithmictim crcw algorithm connect compon given gaz algorithm improv erew connect span tree algorithm hz hz sinc comput minimum span tree within time work bound algorithm simpler algorithm hz hz follow use notat t denot union set use e denot set form ad element e set s say result hold high probabl or whp n probabl fail hold less n c constant rest paper describ analyz algorithm organ follow section give highlevel descript algorithm work two phase section describ detail phase algorithm main procedur phase findkmin given section section give phase whose main procedur findmsf section give proof algorithm run expect logarithm time linear work section extend result highprob bound section address issu processor alloc variou step algorithm section discuss adapt algorithm realist parallel model like bsp val qsm gmr paper conclud section highlevel algorithm algorithm divid two phase along line crcw pram algorithm ckt phase algorithm reduc number vertic graph n nk vertic n number vertic input graph perform reduct algorithm use familiar recurs tree depth log n ckt ckt pr give rise o log n recurs call time need per invoc algorithm well olog n log n thu total time phase olog n accomplish requir phase find subset msf contract subset msf obtain graph onk vertic phase use algorithm similar one pr need recurs due reduc number vertic graph thu phase abl find msf contract graph olog n time linear work assum edg weight uniqu alway uniqu forc order vertic order ident weight edg end point highlevel descript algorithm use log r n denot log function iter r time log n denot minimum r st log r n phase retain lightest k edg edgelistv g contract edg g appear phase sampl edg g prob log n theorem high probabl highlevelg return msf g olog n time use processor follow section describ analyz algorithm phase phase present proof main theorem expect run time obtain high probabl bound run time work analyz perform algorithm phase phase use timework framework assum perfect processor alloc achiev high probabl within constant factor use loadbalanc scheme hz requir superlinear space linearspac scheme claim hz discuss processor alloc section point simpl scheme similar one hz take linear space qrqw pram gmr slightli stronger model erew pram use qrqw pram lie fact algorithm design model map generalpurpos model qsm gmr bsp val well erew pram describ perform msf algorithm qsm bsp phase goal contract input graph g graph onk vertic identifi certain edg minimum span forest g contract connect compon form edg challeng identifi edg logarithm time linear work phase achiev desir reduct number vertic construct kmin forest defin below similar algorithm ckt howev algorithm consider simpler show kmin forest satisfi certain properti exploit properti design procedur boruvkaa keep size tree contract variou stage phase small total time need contract process edg tree olog n log n phase also need filter subroutin remov kmin heavi edg thi show use msf verif algorithm small tree construct perform step overal algorithm phase findkmin use two subroutin achiev state reduct number vertic within desir time work bound kmin forest phase use familiar sampl contract discard edg framework earlier random algorithm msf problem kkt ckt ckt pr howev instead comput minimum span forest construct kmin tree ckt vertex where log n contract edg kmin tree produc graph onk vertic understand kmin tree is consid dijkstrajarnikprim minimum span tree algorithm choos arbitrari start vertex v repeat contain mst g choos minimum weight edg a b st s b edg set kminv consist first k edg chosen algorithm start vertex v forest f kmin forest g f msfg v g kminv f set edg path x tree let maxweightfag maximum weight set edg a forest f g defin edg a b g f heavi weighta b maxweightfp f a bg f light otherwis b tree f a b flight let kmin tree v defin weight v w maxweightfpm v wg w appear maxweightfkminvg defin edg a b kminheavi maxfweight b weight b ag kminlight otherwis let measur weight v w defin respect k rang n weight v w maxweightfpmsf v wg proof two case w fall insid kmin tree v fall outsid w insid kminv weight v w maxweightfpmsf v wg sinc kminv msf suppos w fall outsid kminv weight v w maxweightfpmsf v wg must path v w msf consist edg lighter maxweightfkminvg howev step dijkstrajarnikprim algorithm least one edg pmsf elig chosen step sinc w kminv edg weight maxweightfkminvg never chosen contradict let k vector n valu rang n vertex u associ valu denot k u defin edg u v kminlight weightu v maxfweight u v weight v ug weight u v weight v u defin respect k u k v respect lemma let h graph form sampl edg graph g probabl p expect number edg g kminlight h less np k proof show edg kminlight g also f light f msf h lemma follow sampl lemma kkt state expect number f light edg g less np let us look kminlight edg v w weight v w maxweightfpmsf v wg measur use determin f light thu criterion kminlight maxfweight v w weight w vg must also less equal maxweightfpmsf v wg restat thi v w kminlight must f light well use properti kmin forest develop procedur findkm l take input graph g suitabl posit integ l return kmin forest g run logarithm time linear work next section describ basic step procedur use findkmin present analyz main procedur phase phase concern kmin tree vertex suffic retain lightest k edg incid vertex henc state first step phase algorithm highlevel section discard lightest k edg incid vertex sinc need phase step perform logarithm time linear work simpl random algorithm select sampl size jlj adjac list l sort sampl use sort list narrow search kth smallest element list size ojlj boruvkaa step basic boruvka step bor vertex choos minimum weight incid edg induc number disjoint tree tree contract singl vertic useless edg discard call edg connect two vertic tree intern other extern intern edg useless multipl extern edg join two tree lightest useless algorithm phase use modifi boruvka step order reduc time bound olog n per step vertic classifi either live dead modifi boruvka step vertex vs parent pointer edg minimum weight incid v addit vertex threshold keep weight lightest discard edg adjac v algorithm discard edg known kmin tree vertex threshold variabl guard vertic choos edg may msf dead vertex v use properti shown below edg a b kminv weighta b weightv pv thu dead vertic need particip boruvka step wellknown boruvka step gener forest pseudotre pseudotre tree togeth one extra edg form cycl length algorithm assum boruvka step also remov one edg cycl gener collect root tree follow three claim refer tree result modifi boruvka step proof straightforward omit sequenc edg weight encount path v rootv monoton decreas consist edg path v rootv furthermor weight v pv greater edg dminv minimumweight incid edg u u v kminu kminv tree induc boruvka step let subtre e minimum weight incid edg minimum weight incid edg either e edg proof suppos contrari minimum weight incid edg e let v v end point e e insid consid path p v root claim edg weight encount p p monoton decreas two case contain some p e must lie along p contradict contain p p edg e p adjac procedur boruvkaah l f given return contract version h number live vertic reduc factor l edg design parent pointer guarante msf h return f initi repeat log l time log l modifi boruvka step live vertex v choos min weight edg v w weightv w thresholdv v becom dead stop els tree induc edg f one two type root dead everi vertex becom dead claim contain live vertic depthv k v becom dead claim contract subtre made live vertic result vertex live parent pointer keep smallest threshold constitu vertic lemma boruvkaa design vertex dead kmin tree alreadi found proof vertic make transit live dead line indic number assumpt discard edg cannot kmin tree vertex lightest edg adjac vertex discard know kmin tree alreadi found cover line correct line follow claim sinc v pv lightest incid edg v kminv call dead sinc root tree dead vertic depth one dead impli vertic depth two dead on valid line follow directli claim vertex find depth k kmin tree lie along path vertex root lemma call boruvkaah k tree vertex subset f proof lemma dead vertic alreadi satisfi lemma singl modifi boruvka step set parent pointer associ live vertic induc number tree let v tree contain v assum induct dlog ie modifi boruvka step tree vertex origin graph found thi clearli true live vertex v let x y minimum weight edg st x v v induct hypothesi i gamma min tree v subset v y respect first extern edg v chosen dijkstrajarnikprim algorithm start v everi edg i gamma mini lighter x y subset chosen dlog ie th modifi boruvka step subset v dlog ie modifi boruvka step thu step kmin tree vertex found lemma b modifi boruvka step length edg list bound k k b proof true assum lemma hold modifi boruvka step length edg list mani step k k sinc contract tree height k length edg list b step shown next section algorithm deal graph result olog modifi boruvka step henc maximum length edg list k k olog costliest step boruvkaa calcul depth vertex minimum weight edg select process root induc tree broadcast depth depth vertic turn broadcast depth vertic etc vertex know depth may stop let descend infer depth k interleav round broadcast processor alloc step account cost separ section lemma let g edg call boruvkaag l f execut time ok olog processor proof let g result b modifi boruvka step lemma maximum degre vertex th modifi boruvka step current call boruvkaa k k bi let us look requir time th modifi boruvka step select minimum cost incid edg take time log k k bi time determin depth vertex k delta log k k bi sum log l modifi boruvka step total time bound p log l note abov algorithm perform olog modifi boruvka step graph henc time k olog work perform modifi boruvka step linear number edg sum log l step divid number processor arriv second term state run time filter step filter forest concurr modifi boruvka step maintain filter forest structur record vertic merg togeth time edg weight involv thi structur appear first king v vertex origin graph new vertex result contract set edg correspond vertex oev filter for est boruvka step vertex v becom dead new vertex w ad filter forest well direct edg oev w weight v pv live vertic contract live vertex v vertex oev ad filter forest addit direct edg weight edg v shown king heaviest weight path u v msf heaviest weight path oeu oev filter forest if path henc measur weight v w easili comput follow way let p f x y path x filter forest oev oew filter tree weight weight w v w filter tree let weight maximum weight path oev rootoev maximum weight edg rminv r proof rootoev height h result h boruvka step assum claim hold first h boruvka step number contract vertex v origin graph repres current graph v c let vc tree induc th boruvka step contain v c let e minimum weight incid edg vc induct hypothesi maxweightfp f oev oet vc shown proof claim edg path v c edg e weight weighteg edg v c pv c e correspond edg filter forest name oev c poev c oet vc poet vc sinc edg path oev poet vc maxweightfp f oev poet vc thu claim hold filter step call filterh f findkmin examin edg e h weight maxfweight v w weight w vg order carri test use olog n time om work msf verif algorithm kpr modifi algorithm case x tree test pair oex rootoex oey rootoey delet e pair identifi delet comput take time olog r r size largest tree form procedur filter discard edg cannot kmin tree vertex discard edg a b updat threshold variabl b thresholda weight lightest discard edg adjac a as minimum weight edg ever heavier thresholda kmina alreadi found becom dead graph form sampl edg h probabl p f kmin forest h call filterh f return graph contain kmin forest h whose expect number edg np proof vertex v claim state maxweightfp f oev minv valu k v build vector k valu one vertex abl check kminlight use filter forest follow lemma expect number kminlight edg h less np need show kminlight edg h remov filter step suppos edg u v kmin tree u h remov filter v k u min tree u wrt h edg u v heaviest edg cycl could msf much less kmin tree v k u min tree u wrt h weightu v maxweightfk u minug mean edg u v could pick first k step dijkstrajarnikprim algorithm find kmin forest readi present main procedur phase findkmin recal initi call given section findkm log n g graph obtain g remov k lightest edg adjac list findkminh i sampl edg h c prob log igamma n h graph vertic possibl mark dead paramet indic level recurs which determin number boruvka step perform sampl probabl lemma call findkm log n return set edg includ kmin tree vertex g proof proof induct i base return f lemma contain kmin tree vertex induct step assum induct findkminh igamma return kmin tree h consid call findkminh i induct assumpt call findkminh return kmin tree vertex h claim call filterh c f return h f set edg contain kmin tree vertic h c final induct assumpt set edg return call findkminh f contain kmin tree vertic contain log igamma nmin tree vertex h findkminh i return return edg kmin tree vertex h follow invari maintain call findkmin number live vertic h nlog i n expect number edg h mlog i n n number edg vertic origin graph proof clearli hold initi call log n lemma contract graph h c nlog igamma n live vertic sinc h deriv sampl edg probabl log igamma n expect number edg h mlog igamma n maintain invari first recurs call lemma expect number edg h f nlog igamma n log igamma n number vertic h c invari maintain second recurs call perform findkmin lemma findkm log n run expect time olog n work om n proof sinc recurs call findkmin proceed sequenti fashion total run time sum local comput perform invoc asid randomli sampl edg take constant time work linear number edg local comput consist call filter boruvkaa given invoc findkmin number boruvka step perform graph h sum boruvka step perform ancestr invoc findkmin ie p log n olog n from bound maximum length edg list lemma infer size tree filter forest k k olog n thu time need modifi boruvka step filter step k olog n sum step total time requir olog n work requir filter procedur boruvka step linear number edg number edg given invoc omlog i n olog i n boruvka step perform invoc work requir invoc om log i n recal paramet indic depth recurs sinc log ngammai invoc depth paramet i total work given p log n log ngammai om log i n om phase recal phase portion overal algorithm highlevel the number vertic g nk g sampl edg g prob log n procedur filterg f kpr return f light edg g procedur find describ below find msf g time om m log n log n number edg g graph g g f expect m log n edg sinc g deriv sampl edg probabl k sampl lemma kkt expect number edg g f mk k call findmsf graph expect size om log n call take olog n time findmsf procedur procedur findmsfh similar previou random parallel algorithm except use recurs instead separ base case algorithm use place recurs call also use slightli differ boruvka step order reduc work modif inspir pr pr respect basecas use simplest version algorithm chong et al chl take time olog n use mn log n processor guarante call graph expect size om log n run time remain olog n m processor findmsfh h sampl edg h c prob call boruvkab graph h c m log n vertic sinc h deriv sampl edg h c probabl log n expect number edg first basecas call om log n sampl lemma kkt expect number edg second basecas call m log n log n thu total time spent subcal olog n assum size h conform expect om log n call filter boruvkab also take olog n time describ below boruvkabh l f procedur return contract version h oml vertic use simpl growth control schedul design vertic inact degre exce l determin vertex inact perform list rank edg list log l time step comput stop much time edg list length l boruvkabg repeat log l time vertex let inact edg list l edg activ otherwis activ vertex v choos min weight incid edg e use edgeplug techniqu build singl edg list induc tree o time contract tree inact vertic last step take olog n time step take olog l time deal edg list length ol consequ total run time olog l iter main loop work linear number edg assum graph conform expect size om log n total work linear edgeplug techniqu well idea growth control schedul introduc johnson metaxa jm proof main theorem proof of theorem set edg return findkmin subset msf g contract edg produc g msf g given edg togeth msf g call filter produc graph g f remov g edg known msf thu msf g f msf g assum correct findmsf set edg f constitut msf g f thu f msf g earlier shown step highlevel requir olog n time work linear number edg next two section show whp number edg encount graph algorithm linear size origin graph high probabl bound consid singl invoc findkminh i h edg n vertic want place like bound number edg recurs call findkmin term i first recurs call edg h sampl independ probabl log igamma n call sampl graph h appli chernoff bound probabl size h less twice expect analyz second recurs call recal sampl lemma kkt state number f light edg conform neg binomi distribut paramet sampl probabl f msf h saw proof lemma everi kminlight edg must also f light use observ analyz size second recurs call term f light edg conclud bound attain appli equal kminlight edg bound likelihood twice expect number edg f light probabl sequenc n p flip coin probabl p head coin come head less n time sinc edg select coin toss head goe msf sampl graph appli chernoff bound expgammaomegagamma n particular instanc findkmin n mlog igamma n probabl fewer mlog igamma n edg f light given singl invoc findkminh i bound probabl h log ngammai mlog i n edg expgammaomegagamma mlog i n follow appli argument use invoc findkmin initi call current call depth log sum recurs call findkmin total number edg and thu total work bound p log n probabl phase use om work omit analysi similar analysi phase probabl bound time total work perform algorithm fail hold exponenti small input size howev assum perfect processor alloc next section show probabl work fail distribut evenli among processor less m thu overal probabl failur small algorithm run logarithm time linear work whp processor alloc state section processor alloc need algorithm perform fairli simpl algorithm given hz take logarithm time linear work use superlinear space involv algorithm claim hz run logarithm time linear work space show simpl algorithm similar spirit one hz run logarithm time linear work space qrqw pram gmr qrqw pram intermedi power erew crcw pram allow concurr memori access time taken access equal largest number processor access singl memori locat assum total size input n processor group q processor qr group size r log n make initi assign or log n element group initi assign made element choos group randomli expect number element group r log n chernoff bound whp or log n element group vertic assign group collect togeth array group olog n time on work space use qrqw pram algorithm multipl compact given gmr run logarithm time linear work high probabl we need full power algorithm gmr sinc know ahead time group c log n element whp suitabl constant c henc suffic use heavi multipl compact algorithm gmr achiev bound logarithm time linear work space simpl analysi use chernoff bound show new graph encount comput group receiv either log n element within constant factor expect number element whp henc olog log n erew pram step processor within group assign log n element group processor realloc scheme take olog log n time per stage linear space overal high probabl achiev perfect balanc within constant factor total number processor realloc step need algorithm o log n delta k log log log n henc time need perform processor alloc step olog n whp note probabl processor alloc optim to within constant increas gamma n gamma increas group size r sinc perform olog n processor alloc step r set high n log n without increas overal olog n run time thu high probabl bound number item group or log n becom gamman gamma shown gmr heavi multipl compact algorithm run time olog n log m log log m time whp m choos log log n log n obtain olog n run time initi step probabl also overal probabl bound processor alloc adapt practic parallel model result impli good msf algorithm qsm gmr bsp val model realist model parallel comput pram model theorem given follow directli result map erew qrqw comput qsm given gmr theorem follow qsm bsp emul given gmr conjunct observ slowdown emul due hash occur algorithm sinc assign vertic edg processor made processor alloc scheme achiev effect theorem msf edgeweight graph n node edg found og log n time ogm use om n space qsm simpl processor alloc scheme g gap paramet qsm theorem msf edgeweight graph n node edg found bsp ol g log n time whp use m processor om n space simpl processor alloc scheme g l gap period paramet bsp conclus present random algorithm msf erewpram provabl optim time work algorithm work within state bound high probabl input size good perform popular parallel model import open question remain obtain determinist parallel msf algorithm provabl optim time work recent optim determinist sequenti algorithm msf present pr intrigu aspect algorithm function describ run time known present although proven pr algorithm run within small constant factor best possibl parallel optim sequenti algorithm topic worth investig r new connect msf algorithm shuffleexchang network pram jistem problemu minimaaln im moravsk p parallel time complex undirect connect minimum span tree linearwork parallel algorithm find minimum span tree find minimum span tree logarithm time linear work use random sampl note two problem connexion graph qrqw pram account content parallel algorithm effici lowcontent parallel algorithm sharedmemori model serv bridg model parallel comput theori comput system optim random logarithm time connect algorithm erew pram optim random erew pram algorithm find span forest basic graph connect problem connect compon olog simpler minimum span tree verif algorithm random lineartim algorithm find minimum span tree optim erew pram algorithm minimum span tree verif parallel algorithm sharedmemori machin random linear work erew pram algorithm find minimum span forest privat commun optim minimum span tree algorithm bridg model parallel comput shortest connect network gener tr ctr aaron windsor nc algorithm find maxim acycl set graph proceed sixteenth annual acm symposium parallel algorithm architectur june barcelona spain vladimir trifonov olog n log log n space algorithm undirect stconnect proceed thirtyseventh annual acm symposium theori comput may baltimor md usa david a bader guoj cong fast sharedmemori algorithm comput minimum span forest spars graph journal parallel distribut comput v n p novemb guoj cong david a bader design irregular parallel algorithm mutual exclus lockfre protocol journal parallel distribut comput v n p june