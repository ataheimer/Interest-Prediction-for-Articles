t bitwidth awar global regist alloc a multimedia network process applic make extens use subword data sinc regist capabl hold full data word subword variabl assign regist part regist use new embed processor start support instruct set allow direct referenc bit section within regist therefor multipl subword variabl made simultan resid regist without hinder access variabl howev new regist alloc algorithm need awar bitwidth program variabl capabl pack multipl subword variabl singl regist paper present one algorithmth algorithm propos two key step first combin forward backward data flow analys develop determin bitwidth program variabl throughout program analysi requir declar bitwidth variabl often larger true bitwidth moreov minim bitwidth program variabl vari one program point anoth second novel interfer graph represent design enabl support fast highli accur algorithm pack subword variabl singl regist pack carri node coalesc phase preced convent graph color phase regist alloc contrast tradit node coalesc pack coalesc set interf node experi show bitwidth awar regist alloc algorithm reduc regist requir tradit regist alloc algorithm assign separ regist simultan live subword variabl b introduct program manipul data subword level ie bit section within word common place embed domain exampl applic includ media process well network process code key characterist applic point data exist pack form is multipl data item pack togeth singl word memori fact case input output applic consist pack data input consist pack data applic typic unpack process output requir pack form applic comput result explicitli pack gener out put sinc c languag choic embed applic pack unpack oper visibl form bitwis logic oper shift oper code addit gener extra instruct pack unpack data addit regist requir hold valu pack unpack form therefor caus increas regist pressur new instruct set architectur embed network processor allow bit section within regist directli referenc exampl follow instruct add bit valu r bit valu r store bit result r operand extend ad lead zero bit match size result addit carri out recent work incorpor bit section referenc popular arm processor shown proper use instruct elimin need explicit pack unpack oper thu reduc number execut instruct significantli anoth import consequ instruct set support multipl subword size variabl made simultan resid regist without hinder access variabl thu approach reduc regist requir program sinc embed processor support small number regist eg arm support regist even fewer directli access instruct thumb mode effici use regist resourc extrem import illustr potenti reduct regist requir let us consid exampl shown fig typic embed code code fragment taken adpcm au dio gsm speech applic respect perform unpack pack code fragment refer three variabl declar size bit each live rang variabl includ width shown examin live rang find tradit regist alloc must use two regist hold valu howev bitwidth awar regist alloc dramat reduc regist requir unpack last use delta last use delta pack unpack pack char char delta delta char alpha alpha inbuff delta alpha outbuff figur subword variabl multimedia code hold valu variabl bit bit singl regist respect two code fragment remain bit regist use hold addit subword size variabl paper describ approach achiev regist alloc use part singl regist oppos multipl regist code fragment two key compon approach first employ algorithm construct live rang variabl minim bitwidth width short live rang variou program point also com pute second employ fast effect method pack togeth multipl live rang pack phase essenti perform coalesc interf node enhanc interfer graph represent program follow pack regist alloc carri use convent graph color algorithm assign singl regist node graph number challeng develop fast yet effect algorithm compon describ below live rang construct first challeng identifi minim width live rang relev program point analysi must develop purpos due two reason illustr exam ple variabl declar larger need bitwidth eg delta declar bit entiti use bit bitwidth variabl chang one program point anoth variabl may contain multipl data item consum one one eg inbuff initi bit data delta assign contain bit use data present combin forward backward data flow analysi find minim width second challeng effici identifi minim width obviou way develop analysi which given variabl declar b bit wide determin need keep b bit regist program point cost bitwis analysi high directli depend upon bitwidth variabl achiev effici develop analysi view variabl regardless size made three bit section call lead middl trail section goal analysi determin minim size middl section must kept regist lead trail section discard approach effect practic unneed bit variabl program point typic form lead andor trail bit section pack multipl variabl regist variabl pack togeth coalesc two node interfer graph shape live rang must taken account determin whether live rang co alesc coalesc possibl characterist coalesc live rang must determin perform coalesc simpl approach problem may accur lead miss opportun coalesc exampl earlier exampl maximum width inbuff delta bit respect simpl method ignor shape assign width bit live rang result coalesc two overestim width bit therefor approach simpl thu fast miss coalesc opportun complet accur approach develop compar shape live rang relev program point determin whether coalesc possibl comput compact shape result live rang approach miss coalesc opportun expens present fast highli accur approach node coalesc base upon enhanc label interfer graph shape interf live rang pair compar exactli gener label node coalesc driven label updat constant time follow coalesc step label approxim highli accur practic therefor miss coalesc opportun rare outlin remaind paper organ follow section present live rang construct algorithm enhanc interfer graph represent node coalesc algorithm base upon affect variabl pack describ section experiment evalu present section relat work discuss section conclus given section live rang construct definit live rang live rang variabl v program region valu v live is point live rang subset bit vs current valu may use futur comput right hand side refer variabl v program statement need explicitli refer bit v execut statement consequ point vs live rang bit repres v live therefor differ amount bit may need hold valu v regist differ program point definit dead bit given variabl v accord declar repres bit subset bit say d dead program point p comput follow point p use current valu v perform without explicitli refer bit d definit live rang width given program point p variabl vs live rang width vs live rang point p denot wv p defin bit repres variabl v accord declar divid three contigu section follow lead section l v p dead bit middl section wv p live bit trail section tv p dead bit p let sv denot statement refer valu variabl v defin nousesv v order pair l t lead l bit trail bit v need explicitli refer execut sv condit subset of all bit variabl v suffici evalu express given fig first three situat exploit use compil time constant left shift right shift bitwis oper result comput express depend upon subset bit v thu remain bit consid use next two situat exploit presenc zero bit v lead zero bit present v need explicitli held regist perform arithmet relat oper result oper correctli comput without explicitli refer bit similarli result bitwis oper comput without explicitli refer lead trail zero bit v therefor consid zero bit use final case right hand side refer v consid use bit v ie nousesv v identifi dead bit henc width live rang program point live rang perform follow anali si first carri forward analysi comput safe estim lead trail zero bit section program variabl program point inform need comput nousesv v two case describ arithmeticrel oper bitwis oper comput inform fulli second carri backward analysi identifi dead bit section program variabl program point describ analys next without loss generailti assum discuss variabl declar bitwidth lead trail zero bit section describ abov lead trail zero need found result oper comput without explicitli refer thu section treat dead bit section forward analysi employ determin lead trail zero bit section variabl program point variabl v assign case examin express right hand side determin lead trail zero bit section v follow assign case constant assign look valu constant c determin zero bit section v case sign number lead zero bit section form sign extens bit ie zero one right left shift constant amount ie result creation lead trail bit section bitwis logic and oper ie result propag zero bit section copi assign zero bit section x simpli propag v noth assert valu assign v analysi conserv assum lead trail zero bit section note sinc zero bit section one variabl may depend upon zero bit section anoth variabl variabl must analyz simultan meet oper forward analysi safe comput smallest lead trail zero bit section present variabl across incom edg data flow equat comput zero bit section given fig zb inout n v repres zero bit section variabl v entryexit node n recal simplic list situat involv variabl bitwidth variabl differ size consid addit opportun aris exampl unsign short integ assign unsign long integ lead zero bit section creat latter situat found enhanc analysi lead trail dead bit section fig also give data flow equat comput dead bit section db inout n v repres lead trail dead bit section variabl v entryexit node n expect determin dead bit section base upon backward analysi examin statement sv identifi subset bit variabl v whose valu use statement inform repres nousesv v describ earlier comput statement given result zero bit section analysi bit section nousesv v dead point statement sv also dead immedi statement sv statement defin v use it bit variabl dead indic ie lead trail dead bit section size equal width variabl join oper conserv comput bit section dead exit node also dead entri point successor node exampl result appli analys illustr use exampl shown fig simplic use straightlin code exampl although techniqu appli program complex control flow structur given code fragment first show zero bit section variabl point assign valu next show result dead bit section analysi set dead variabl immedi follow statement given exampl immedi follow statement higher order bit variabl zero case entir variabl dead simpli list name variabl eg involv variabl fulli dead immedi preced code fragment result dead bit section analysi equival live rang shown area enclos solid line correspond bit section dead examin rang easi see maximum combin width live rang program point bit therefor singl bit regist suffici handl variabl note tradit regist alloc ignor width variabl need four regist code fragment sv characterist sv nousesv v trail bit v use l compil time constant l lead bit v use c compil time constant l t l lead bit trail l lead trail zero bit bit v use v op op arithmet relat oper l lead bit v use v least l lead zero bit v least l lead zero bit l t l lead bit trail bit trail zero bit v use form statement use v bit v use figur partial use variabl bit input control flow graph end node contain singl intermedi code statement definit boundari condit variabl v zb start v dbsout end v bitwidth variabl v initi set vector number variabl meet join oper v meet join oper forward backward analysi respect zero bit section analysi solv iter zb n v zbsout p v zbsout n v constant section l c constant l c constant zb n x elseif n zb n x zb n y elseif n zb n x _ zb n y elseif n zb n v otherwis dead bit section analysi solv iter db n v use v dbsout n v otherwis dbsout n v db s v figur forward backward bit section analysi int short d e bit char b c bit es last use use last use last use bx last use c last use zero bit section e d d a a b c dead bit section abcd abc abcd abcd abcd abcd acd abd abd abd abcd abcd e figur illustr live rang construct es last use use last use last use bx last use c last use use r last use r last use r last use r last use r use r last use r last use r last use r last use r origin code code use one regist code use two regist figur use regist pack variabl variablepackingiterativeco alesc interf node section present variabl pack algorithm let us first see impact variabl pack gener code fig show code result pack variabl fig s exampl one regist r subscript indic bit section within r referenc clear bit section referenc support small number regist use effect note shift oper statement translat intraregist bit section move move sequenc bit one posit anoth also two addit intraregist move preced statement requir move requir sometim variabl alloc regist defin free contigu regist bit section appropri size may avail free bit may fragment case valu live variabl present regist must shift combin smaller free bit section fragment one larg contigu bit section algorithm develop sacrific variabl pack opportun favor fast execut time preced exampl although one regist suffici algorithm alloc a b c one regist e anoth reg ister result code base upon use two regist shown figur sinc variabl pack tightli find need carri two intraregist move overcom problem fragment free bit interfer graph approach variabl pack perform prepass global regist alloc merit approach exist regist alloc algorithm use without modif variabl pack perform addit design variabl pack algorithm oper upon live rang interfer graph must construct way perform global regist alloc node interfer graph correspond live rang interfer edg introduc node pair repres overlap live rang easi see perspect interfer graph variabl pack perform iter coalesc interf node step pair interf live rang coalesc one node place program collect width greater number bit regist variabl pack regist alloc perform use transform interfer graph definit maximum interfer width given pair live rang lr lr maximum interfer width live rang denot miw lr lr maximum combin width live rang across program point two live rang overlap let p denot width live rang lr program point p miw lr lr comput follow iff n st lr lr overlap n clear lr lr coalesc iff number bit regist alway assum variabl width greater jrj desir goal coalesc set achiev maxim coales reduc number node interfer graph mimimum possibl achiev legal sequenc coalesc oper howev theorem present next establish achiev maxim coalesc npcomplet fact construct seen result hold true even straightlin code theorem live rang coalesc npcomplet given set live rang l constant l jlj exist live rang coales reduc number live rang l width coalesc variabl exce jrj program point proof trivial see live rang coalesc problem np given solut easi verifi correct polynomi time perform reduct bin pack problem see page show live rang coalesc npcomplet bin pack problem state follow given set item u size su u u posit integ bin capac b partit u disjoint set u u uk sum size item set u b less instanc bin pack problem transform instanc live rang coalesc problem fol low correspond item u u construct live rang uniform width su assum program point live rang fulli overlap other let find live rang coalesc reduc number live rang l none coalesc live rang width greater jrj essenti solv correspond instanc bin pack problem overal outcom coalesc depend upon select order pair node examin coalesc given result use iter coalesc heurist pick node graph coalesc mani neighbor node possibl repeat process remain node let us briefli consid runtim complex iter coalesc algorithm coalesc must carri seri step step two node coalesc determin whether two node say lr lr coalesc must check condit miw lr lr jrj scan two live rang across entir length program two live rang overlap time complex oper ol l bound number statement program number coalesc oper bound number node n interfer graph thu total time spent coalesc bound on l avoid expens oper scan two live rang comput miw lr lr time attempt coalesc explor use fast method base upon use conserv estim miw lr lr conserv estim overestim miw must never underestim it let us consid simpl obviou approxim scan entir program exactli onc precomput maximum width live rang lr maxlr use inform estim maximum interfer width emiw lr lr comput follow emiw lr lr note need scan program comput emiw lr lr method simpl allow estim emiw two live rang time iter coalesc o time fail handl common situat well fig live rang b shown clear alloc singl regist howev sinc cannot coalesc use simpl approach edg label node label figur vs edg label address problem node label make use edg label edg a b label pair valu ba b ba repres width b respect program point correspond maximum interfer width b ie miw exampl edg label import observ look edg label determin coalesc b possibl combin width program point exceed edg label formal defin below definit interfer graph label initi interfer edg a b label ba contribut b miw a b ie miw subsequ edg c d form coalesc label cd dc cd dc contribut c emiw c d ie emiw c node coalesc label edg eman newli creat node must comput process imprecis introduc develop fast highli accur method comput edg label next present method detail updat edg label follow coalesc edg node c one node b edg ab c transform graph must determin label abc cab edg two case aris handl shown fig first case involv situat c connect edg either b case label edg ab c label edg a c b c case may be sinc c interfer or b coalesc b maximum interfer width ab c maximum interfer width or b c note addit imprecis introduc gener label edg abc second case consid situat edg c b case addit imprecis may introduc estim abc cab edg ab c label base upon conserv estim c goal carri estim quickli avoid examin complet live rang correspond node a b c addit would like obtain label precis possibl base upon exist label three node edg them three candid estim emiw a b c denot ea eb ec fig consid ea estim sum width a b c point maximum interfer width b c take place point best estim width a b c c b respect ie repres point maximum interfer width c take place therefor valu eb ec similarli comput may case emiw a b c equal three comput valu ie ea eb ec deriv conserv estim emiw a b c valu particular sort valu ea eb ec intermedi valu eint safe approxim emiw a b c therefor shown fig choos valu depend upon whether eint ea eb ec accordingli comput abc cab theorem fig formal prove correct method case i node c edg either b abba abba acca acca case ii node c edg b abba acca bccb figur updat label coalesc b intermedi valu theorem follow singl coalesc oper take o time coalesc oper remov node interfer graph therefor number coalesc oper bound number node n interfer graph henc run time complex coalesc oper bound on recal slow algorithm complex on l exampl let us appli coalesc oper use intermedi valu theorem interfer graph live rang construct exampl fig assum regist bit wide exampl live rang construct first build five node interfer graph shown fig node interfer graph coalesc number way one order shown fig first merg e accord rule handl case i label edg eman becom label correspond edg eman de next two step node a b c coalesc case ii aris therefor label edg updat use intermedi valu theorem give result shown figur note bitwidth variabl ignor origin interfer graph requir regist color graph contain cliqu four node contrast regist alloc need use two color color coalesc interfer graph thu propos coalesc algorithm reduc regist requir interfer graph regist regist code base upon usag two regist shown fig let us conisd result applic simpl coalesc approach maintain node label assum pair node consid coalesc consid applic algorithm base upon edg label fig perform two coalesc oper shown fig thu case regist would requir therefor use edg label superior use node label exampl figur illustr node coalesc figur coalesc use node label theorem intermedi valu theorem emin eint emax st eint safe proof proof carri two part lemma show gener emin safe estim miw a bc emin less miw show emin less miw a b c valu eint emax greater miw a b c lemma lemma follow eint best safe estim miw a b c among three valu ea eb ec lemma emin miw a b c true consid construct live rang shown figur be low note construct clearli confirm inde emin may safe estim c wd wd ww wwd wwd lemma contribut a b c miw a b c definit miw must case that loss gener let us assum emin ea given emin miw bc c b wb wc ac c a b ba ec miw a b c shown ea miw a bc eb miw a b c ec miw a b c given ea emin thu conclud that emin miw c lemma lemma follow emiw a eint best safe estim miw a b c among three valu ea eb ec henc proof intermedi valu theorem complet figur intermedi valu theorem prioriti base coalesc far focuss fundament issu bitwidth awar regist alloc ie analysi live rang construct variabl pack use node coalesc address follow issu coalesc alway good order node coalesc attempt coalesc reduc chromat number graph alway case situat coalesc may increas chromat number graph graph shown chromat number two coalesc increas three coalesc solut prevent harm coalesc propos brigg et al observ node creat coalesc two node fewer k neighbor degre k more k number color result node alway color thu propos restrict coalesc situat result node guarante color cd figur increas chromat number due coalesc order node coalesc attempt impact shape final graph thu number color requir color result graph exampl reconsid exampl fig merg node b well node c d result graph contain three node color use two color oppos three color requir result graph fig e figur impact order coalesc oper one approach propos address problem assign prioriti node node highest prioriti say n pick neighbor n consid coalesc decreas order prioriti node coalesc n next highest prioriti node pick process repeat prioriti live rang l comput shown below greater save due elimin load store higher prioriti howev save normal respect amount regist resourc use regist usag base upon durat number bit occupi live rang henc simpli area live rang obtain sum togeth number bit occupi live rang relev program point liverangearea algorithm carri node coalesc follow regist alloc summar fig follow iter node coalesc phase set coalesc variabl given new name code transform use name ad dition intravari move introduc preserv program se mantic result interfer graph process use tradit color base regist alloc construct interfer graph label edg interfer width construct priorit node list node list get node say n priorit node list node ns adjac list attempt coalesc n success updat graph priorit list endfor endwhil replac coalesc variabl set new name introduc intravari move perform color base regist alloc figur algorithm summari experiment result evalu propos techniqu use benchmark taken mediabench adpcm g netbench crc dh bitwis project mit softfloat newlif motiontest bubblesort histogram repres class applic import embed domain also ad imag process applic thre appli techniqu select function benchmark larg size construct interfer graph select function measur regist requir fulli color graph use follow algorithm a bitwidth unawar algorithm given time allow singl variabl resid naiv coalesc nc algorithm label node declar width use label perform coalesc c coalesc oc algorithm build live rang use bit section analysi label edg maximum interfer width inform drive coalesc three case regist requir comput repeatedli appli chaitin algorithm find minimum number regist graph could fulli color result experi given tabl oc algorithm reduc regist requir nc algorithm nearli success reduc regist requir regist qualiti code expect improv significantli particularli true arm processor bit section referenc extens context research carri arm regist tabl regist requir benchmark regist use function bu nc oc adpcm decod adpcm coder gupdat gquantiz threshomogen motiontestmain bubblesortmain histogrammain tabl benefit coalesc benchmark number node function adpcm decod adpcm coder gupdat thresmemo threscoalesc threshomogen thresclip newlifemain motiontestmain bubblesortmain histogrammain crcmain dhencodelastquantum tabl chang maximum cliqu size benchmark number node function adpcm decod adpcm coder gquantiz thresmemo threscoalesc threshomogen thresclip newlifemain motiontestmain dhencodelastquantum tabl live rang bitwidth bit number live rang width bit live declar max size rang size bsa adpcmdecod adpcmcod gupdat gfmult gquantiz thresmemo threscoalesc threshomogen thresclip newlifemain motiontestmain bubblesortmain histogrammain crcmain dhencodelastquantum understand signific two key step algorithm name live rang construct base upon bit section analysi node coalesc examin data greater detail result tabl show extent node coalesc reduc number node interfer graph see signific amount coalesc observ occur data tabl show signific live rang construct algorithm declar width live rang well reduc maximum width bit section analysi bsa given see mani live rang declar width much larger reduc maximum width reason nc algorithm nearli success oc algorithm made clear part data declar bitwidth variabl often much greater true bitwidth final note although coalesc necessarili guarante reduct regist requir program signific reduct observ look interfer graph understand case found program significantli larg cliqu present account regist requir ment moreov maximum size cliqu interfer graph typic contain multipl subword data item thu node coalesc result reduct size maximum size cliqu henc regist requir tabl show reduct size largest cliqu program observ hold benchmark exhibit behavior omit tabl case soft float bubblesort larg cliqu case gupdat histogram although larg cliqu present reduc size node coalesc relat work bit section analysi stephenson et al propos bitwidth analysi discov narrow width data perform valu rang analysi compil proven certain data item requir complet word memori compress smaller size eg word data may compress halfword byte data number import differ bitwidth analysi analysi live rang construct first analysi aim narrow width variabl program point much possibl sinc alloc vari number regist bit variabl differ program point second approach elimin trail bit section valu rang analysi never so approach elimin lead bit section dead bit contain nonzero valu valu rang analysi elimin lead bit section contain zero bit program budiu et al propos analysi infer valu individu bit analysi much expens analysi must analyz bit variabl approach maintain summari inform form three bit section variabl final analysi zhang et al aim automat discoveri pack variabl paper aim carri analysi facilit variabl pack memori coalesc data compress davidson jinturkar first propos compil optim exploit narrow width data propos memori coalesc improv cach perform program zhang gupta propos techniqu compress narrow width pointer data improv cach perform howev techniqu explor context gener purpos processor therefor aggress pack scalar variabl regist studi contrast work present paper aim new class embed processor effici use small number regist made possibl hold multipl valu singl regist work awar deal regist alloc processor support bit section referenc wagner leuper how ever work exploit bit section referenc context variabl alreadi contain pack data carri addit variabl pack describ paper multimedia instruct set support long regist hold multipl word data carri simd oper compil techniqu alloc array section regist con trast work aim shrink scalar subword entiti pack regist one word long scalar variabl handl ignor superword techniqu final context embed processor work done deal irregular constraint regist alloc eg howev work done context arm instruct set bit referenc extens bit section pack import issu conclus multimedia network process applic make extens use subword data moreov embed processor typic support small number word size regist instruct set support bit section referenc provid us opportun make effect use small number regist pack multipl subword size variabl singl regist without incur addit penalti access pack variabl howev techniqu exist either identifi variabl bitwidth data pack regist present first algorithm solv problem present effici analys construct variabl bitwidth live rang effici variabl pack algorithm oper enhanc interfer graph experi show propos techniqu reduc regist requir embed applic acknowledg work support darpa award f nation scienc foundat grant ccr ccr ccr eia univers arizona r improv graph color regist alloc bitvalu infer detect exploit narrow width comput regist alloc spill via graph color memori access coalesc techniqu elimin redund memori access compil simd within regist data align subword parallel dsp comput intract guid theori npcomplet iter regist coalesc a represent bit section base analysi optim preferencedirect graph color exploit superword level parallel multimedia instruct set tool evalu synthes multimedia commun system bit section instruct set extens arm embed applic benchmark suit network processor a new network processor architectur high speed commun arm architectur refer manual bitwidth analysi applic silicon compil c compil design industri network processor commbench telecommun benchmark network processor data compress transform dynam alloc data structur tr improv graph color regist alloc memori access coalesc iter regist coalesc mediabench bidwidth analysi applic silicon compil exploit superword level parallel multimedia instruct set compil design industri network processor preferencedirect graph color arm architectur refer manual comput intract bit section instruct set extens arm embed applic netbench compil simd within regist bitvalu infer represent bit section base analysi optim data compress transform dynam alloc data structur regist alloc myampersandamp spill via graph color ctr ranjit jhala rupak majumdar bit level type high level reason proceed th acm sigsoft intern symposium foundat softwar engin novemb portland oregon usa bengu li rajiv gupta simpl offset assign presenc subword data proceed intern confer compil architectur synthesi embed system octob novemb san jose california usa lal georg matthia blume tame ixp network processor acm sigplan notic v n may oguz ergin deniz balkan kanad ghose dmitri ponomarev regist pack exploit narrowwidth operand reduc regist file pressur proceed th annual ieeeacm intern symposium microarchitectur p decemb portland oregon