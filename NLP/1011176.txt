t twolevel languag program optim a twolevel languag incorpor bind time inform insid type is whether piec code complet known compiletim need input evalu runtim consid use level languag framework partial evalu use level version simpli type lambda calculu recurs give oper semant equat theori denot semant give account distinct compil execut phase adequaci theorem given relat two semant show particular agre nontermin compil time final give refin model use functor categori b introduct partial evalu attempt gap interpret compil ing rst case obtain easytoprov correct good exibl modic unfortun usual get also poor runtim behaviour often order magnitud slower noninterpret counterpart hand compil code compar hard understand prove correct aim partial evalu take program input produc new program give output origin one constant evalu perform onc program gener process new program incorpor data remain constant call special version old one follow pictur illustr process program compiletim residu runtim valu view essenti distinguish comput perform compiletim call static comput need data execut call dynam process make distinct call bind time analysi classic exampl function power take two integ x y comput x xth power y function could dene follow research partial support murst suppos know compiletim x number x static variabl dynam produc residu program program typic ecient f y variou way perform bind time analysi promis techniqu use level languag languag incorpor bind time inform insid type usual languag two version data type constructor one static one dynam type level languag origin introduc studi extens use partial evalu recent exampl found paper studi semant level languag give oper semant denot model basic idea semant evalu static compon program compil obtain residu program special version origin one execut runtim second section introduc level languag essenti level variant callbynam languag pcf give oper semant give account distinct compil execut phase distinct made clear show dynam oper postpon static one perform studi equival term show unrestrict rule valid dynam term although level languag pure call bynam taken isol make dicult give abstract model two kind undened requir one level clear rst gener higher type third section relat oper semant denot model given show adequaci theorem assert model give result also preserv phase distinct oper semant last section show that although adequ model contain junk is basic element denabl within languag suggest better solut use slightli complex machineri purpos work provid insight prove correct partial evalu prove equival semant origin program semant special one give partial evalu level languag leav correct proof work give dynam semant parametris xed static semant consid partial evalu model given connect oper notion made view connect crucial understand link semant implement issu especi partial evalu prove correct partial evalu dicult often error prone shown partial evalu untyp languag consid altern solut given correct origin model prove also provid correct proof partial evalu exist model give syntact interpret dynam type name collect open term languag approach abstract similar standard treatment pcf novelti approach interpret compil execut phase framework allow studi interact respect comput eect like nontermin simpl level languag section introduc simpl languag level pcf obtain pcf augment construct dynam counterpart first explain syntax languag type format rule give oper semant equat theori denot model level pcf level pcf languag obtain pcf ad dynam type dynam term intend use languag evalu static compon compiletim execut remain part residu program runtim base type usual natur number nat dynam number nat higher type construct static arrow dynam one wellformed rule dynam type introduc origin dynam arrow must dynam type either side rule motiv consider dynam function depend static comput runtim static comput alreadi perform base case reason allow dynam function take static natur input construct lift emb term type nat dynam term moreov constraint give interest properti allow postpon dynam evalu static one oper semant type level pcf given follow grammar static type dynam one use t term type rule structur similar way essenti two copi everi construct term pred m pred m succ successor function number ifz condit whose guard check rst argument zero x recurs oper lift emb static express type nat dynam express note possibl base type purpos lift insert static valu residu program type assign written nite set variabletyp pair x distinct indic extens type format rule note dynam ifthenels requir argument dynam avoid exampl static term like whose evalu would depend evalu dynam term d would problem especi consid possibl nontermin termin runtim cannot uenc valu whole term compiletim oper semant section give oper semant level pcf basic idea give two reduct relat static reduct dynam reduct intend constraint static reduct must alway perform dynam one oper semant pred liftn liftn static context c dynam context c dene follow pred pred pred notat indic subtract natur number extend relat dene analog way usual reduct pcf nx indic capturefre substitut n x term particular exactli one pcf obviou dynam counterpart note use lift form basic constant fact canon form dynam number ie form termin comput expect reach consid static term sund dene follow sund x xx nat use sund canon term repres static undened base type clearli evalu fail termin alreadi compil phase hand consid dynam term dund dund x xx nat new term evalu compil fact cannot reduc static attempt execut runtim lead nontermin need constraint interleav static dynam reduct explain exampl consid follow term principl possibl use dynam reduct yield result care analysi reveal presenc subterm sund termin compiletim set partial evalu tri reduc it caus nontermin compil convers term static reduc although innit reduct sequenc discuss suggest term reduc dynam compil word term termin static reduct reduc dynam simplest way ensur term run safe requir static normal form snf denit term snf put two relat togeth denit given welltyp term sd snf follow lemma crucial sens show static reduct perform dynam one obtain complet separ two phase lemma postpon given welltyp term sd term proof show snf snf interest part rule snf henc problem contain subterm form x n n possibl x must dynam type due type format rule ut relax condit must welltyp previou lemma longer valid consid illtyp term clearli snf xx conclud section complet exampl partial evalu power function discuss introduct let pow natnatnat x f nxifz nthen lift els x f n x static subtract dynam product denabl obviou way reduct eect compil program yield optim version sd x x x lift argument given pow also execut phase perform sd lift exampl clear oper semant give inform compil execut program equat theori section consid rule familiar type theori state version valid set two version rule express languag one four combin invalid follow rule valid xm rule valid static fragment languag pure callbynam rule aect static behaviour term pure dynam term behav callbynam fashion rule valid fact consid term xlift liftsund cannot equal lift term sund termin compiletim thu code lift never produc borrow idea oper semant give special rule snf remark section veri introduc denot model denot semant cpo complet partial order partial order set least element least upper bound chain function cpo said continu preserv least upper bound chain henc monoton section give model languag interpret type cpo term continu function cpo write n cpo natur number with n number n gener x cpo obtain cpo x ad new least element xy indic cpo continu function x function composit interpret type interpret static type usual one callbynam pcf dynam type deserv explan seen two kind undened compiletim runtim view type nat contain two element apart natur number intend interpret term like liftsund indic failur compil phase intend interpret term like dund termin exe cute normal nat would written n use notat conveni denot inner dynam arrow idea dynam function either termin compiletim behav usual callbynam fashion run time thu semant dynam type turn lift semant correspond static type obtain remov underlin semant type one might expect valid invalid look like lazi calculu see revers true cpo x consid function xx emb x x x ident x extend send least element x two follow function essenti give semant dynam term otherwis function dyn use transform static arrow dynam type dynam arrow correspond type format rule idea behind denit dyn static function dynam type either unden dene dene argument is failur compil function appli depend dynam argument pass it unless argument fail compil dapp oper use interpret dynam applic purpos propag undened term callbyvalu style note level essenti callbynam taken isol dynam level behav like callbyvalu respect static undened given type assign environ function given judgement t write m interpret environ figur dene interpret term languag static compon languag interpret callbynam pcf use function dyn dapp alreadi explain construct interpret natur way propag static unden ness case nontermin use standard interpret otherwis reconsid rule introduc equat theori section show valid model see valid consid term pred pred f fig denot semant denot rule rule first note m sinc x free assumpt sinc dync otherwis exist f m rule trivial order prove rule need fundament lemma lemma substitut lemma proof proof induct m indic environ x n consid two import case case case ym exploit result easi see rule valid note failur rule due fail substitut lemma fact gener valid rule follow easili result next section n static normal form n adequaci far seen oper semant denot model level pcf time relat two semant prove adequaci result achiev use two dierent logic relat dene induct structur type rst one use obtain static adequaci result give semant counterpart syntact result phase distinct static dynam evalu second easier show pure dynam fragment behav exactli like callbynam pcf way introduc static undened adequaci theorem state two adequaci theorem leav proof end section theorem static adequaci let close term type nat dynam adequaci theorem state term type nat compil denot moreov compil termin runtim denot crucial result show oper distinct static dynam evalu respect model particular way two relat combin ect theorem dynam adequaci let close term type nat dynam valu d moreov liftn proof static adequaci section prove static adequaci theorem logic relat given relat oper semant denot model way ignor denot semant dynam term follow lemma state independ static reduct dynam term t n u term proof enough observ static rewrit discard duplic dynam subterm depend shape nx introduc notion valu shape term reach static reduct compil succe valu v divid static follow two lemma give character valu con uenc properti lemma term valu either abstract snf lemma equal equival consid denit logic relat dene famili relat element close term type t close exist v upn nat n nat v v c relat use prove semant term und ned static reduc valu import dynam term show static subterm complet evalu discard compil note relat essenti independ actual interpret dynam construct sinc check interpret dene lemma proof trivial case c c exist uniqu by lemma lemma relat monoton complet type close t follow hold chain c f proof interest case point form t f noth prove otherwis exist k v uniqu lemma u denit c a induct hypothesi f f follow lemma valid gener open term particular case close term state interpret term relat term itself proof variou case develop quit natur way previou lemma except case eort requir lemma t c proof induct structur let substitut let environ consid import case case xm let f xm f conclus immedi otherwis sinc xm valu show c t taken c n induct hypothesi give applic rule lemma impli fc case l n suppos l n prove fa l n fa conclus immedi otherwis also f induct hypothesi l induct hypothesi n fa xl n oper rule l give result case xm let f c proof immedi otherwis denit dyn c fc show exist valu v xm dynam type written dn nat consid easi show z induct hypothesi exist valu v x z m use lemma obtain m case xxm t let f c m x c let e e f induct hypothesi e oper semant x lemma obtain e i m shown that f lemma static sound given close term proof proof simpl case analysi involv substitut lemma ut proof theorem consid close term type nat lemma m n convers proof dynam adequaci section prove interpret pure dynam term essenti callbynam pcf dene translat level pcf standard pcf relat two denot seman tic conclud proof dynam adequaci theorem refer dynam term dynam type simpli term type introduc new notat indic interpret term level pcf usual interpret term callbynam pcf ie continu function model n given dene translat p q dynam valu level pcf term standard pcf translat type simpli remov annot translat type assign pointwis denit term follow pliftnq pred pv q px xv q understand follow logic relat note semant dynam type lift correspond static type denit logic relat r dynam type d dene logic relat r f r g b c b r c impli dappf b r gc relat intend use pure dynam term ie term compil themselv henc alway dene thu lpcf relat anyth upper level relat essenti one toon lemma type d b r c equival lemma t b r c i proof induct structur d let environ x let environ x c consid key case case xd let f b d let g c pd suppos denit dyn exist d fa r downa lemma henc induct hypothesi fa r gdowna lemma contradict henc conclud dynf show dynf r g suppos b r c show dappdynf b r gc induct hypothesi fb r gc dynf b sinc fb shown dynf r g case x let f xd g xpd case dynf r g b r c impli dappdynf b r gc lemma henc up f f proof theorem take close term type nat dynam valu d convers d lemma m suppos m upn henc adequaci pcf liftn convers liftn sound pcf upn lemma model cpo nal section introduc new model level pcf show advantag previou one show limit new model outlin ideal model would be far seen interpret level pcf categori cpo complet partial order continu function seen function dyn interpret dynam type denit complet natur use cpo allow give natur interpret denit categori cpo dene follow object tripl x a p x cpo continu function morphism x a p y b q pair hf gi follow diagram commut f ident x a p pair hid id x i composit pointwis hh li hf categori cpo cartesian close product dene pointwis exponenti object x a p y b q rst project order upper cpo dene conjunct two order function use addit notat uniqu morphism x cpo one element element f xy continu function f xy extens f map indic exponenti cpo exponenti cpo machineri give anoth model level pcf type interpret follow id y cpo use parametris visual static compil dynam model top cpo repres inform compil bottom one repres inform compil nat case bottom part say whether program compil not give character interpret dynam type consid notat x given cpo x interpret dynam type follow properti dene famili morphism dyn use interpret dynam term denit pair cpo x dene diagram natur object involv enough give upper function morphism lower one determin other note f also g give formal interpret term sinc similar cpo case note consid global element ie morphism a interpret base type dynam type cpo order isomorph interpret cpo henc interpret dynam term static construct given essenti way particular type assign interpret product interpret type static abstract applic interpret usual way use cartesian close structur cpo remain case dynam abstract interpret like cpo case use dyn instead dyn static x point interpret use cpoenrich cpo anoth exampl illustr model cpo improv previou one consid type u natnat denit intuit oper semant suggest denabl function type constant one way dynam subterm uenc compil static term side element pair hf gi follow diagram commut f id f g constant function otherwis g map constant remain element limit model seen introduct cpo model elimin junk present cpo one new model complet satisfactori clear follow exampl consid simpl languag base type boolean interpret type boolbool contain pair hf gi f commut b set ftrue falseg particular clearli denabl term would requir abl distinguish failur compiletim runtim argument show element model denabl nal remark make casestudi optim interpret even easier type consid type unit whose constant want studi denabl function type unitunit consid global element unitunit say one denabl f follow case case f also g dene xliftsund case g compon dene xydund x dene xx dene xylift x case compon dene xdund dene xlift summari denabl function type unitunit cpo interpret contain function cpo one contain function conclus work present oper denot semant level languag dynam static oper semant callbynam denot model howev bit unusu model static part standard model dynam part lift standard callbi name model lift use captur interplay static dynam evalu adequaci theorem conrm accuraci model regard model although adequ precis contain junk exampl type natnat interpret cpo n n actual denabl function either unden send dene element dene result conclus relat static dynam subtl understand perfectli yet semant point view particular natur cartesian close arrow usual interpret callbyvalu lazi calculu futur work would clarifi mean categor point view anoth area work choic evalu strategi chosen callbynam static dynam level simplic expect could work callbyvalu lazi calculu acknowledg want thank peter ohearn mani fruit discuss also grate eugenio moggi anonym refere use comment earli draft paper paul taylor macro diagram use r handbook logic comput scienc mix linear nonlinear logic proof categor model intuitionist linear logic pragmat typedirect partial evalu semant account typedirect partial evalu partial evalu untyp lambda cal culu semant program languag structur techniqu polymorph bindingtim analysi type special lambda calculu leeuwen editor handbook theoret comput scienc project factoris partial evalu categor account twolevel languag functor categori twolevel languag lcf program languag tr experi partial evalu gener compil gener project factoris partial evalu twolevel function languag semant program languag handbook logic comput scienc vol typedirect partial evalu handbook theoret comput scienc partial evalu polymorph bindingtim analysi semant account typedirect partial evalu functor categori twolevel languag multilevel lambdacalculi pragmat typedirect partial evalu type specialis lambdacalculu or new paradigm partial evalu base type infer