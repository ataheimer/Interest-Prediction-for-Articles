t mainmemori index structur fixeds partial key a perform mainmemori index structur increasingli determin number cpu cach miss incur travers index key store indirectli standard mainmemori databas cost key retriev term cach miss domin cost index travers yet ineffici time space store even moder size key directli index node paper investig perform tree structur suitabl oltp workload face expens cach miss nontrivi key size propos two index structur pkttree pkbtree significantli reduc cach miss store partialkey inform index show small fix amount key inform allow cach miss avoid allow simpl node structur effici implement final studi perform cach behavior partialkey tree compar mainmemori tree structur wide varieti key size key valu distribut b introduct follow recent dramat reduct random access memori ram competit price disk storag year ago multigigabyt main memori easili afford expand on bit architectur applic much gb data main memori built rel inexpens system moder growth space requir need concern reason spur stringent perform demand advanc busi network internet applic number mainmemori databas mainmemori databas cach product appear market product essenti fulfil expect research mainmemori databas last fifteen year see permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee acm sigmod may santa barbara california usa exampl provid approxim orderof magnitud perform improv simpl databas applica tion compar disk databas data fulli resid main memori adapt mainmemori databas algorithm becom cach consciou is perform well multilevel mainmemori storag hierarchi recent receiv attent databas literatur mention paper relat work see exampl commonli use processor execut dozen instruct time taken read main memori a cach miss instanc memori access time mhz sun ultra time slower time access data resid onchip cach fur ther dispar processor speed memori latenc expect grow sinc cpu speed increas much faster rate per year memori speed per consequ mainmemori index structur design minim cach miss index travers keep cpu cost space overhead low intuit cachemiss cost minim small node size high branch fac tor exampl found optim node size btree implement slightli larger cach block so averag number key present node would fill cach block low cpu cost index travers import sinc cach miss cost fewdozen instruct set key comparison cost import compon cpu cost especi multipart variablelength key addit alli space overhead import sinc cost ram approxim mb time expens disk storag result amount main memori avail index may limit cost factor lead constraint index size space usag depend space use repres key index node space use pointer averag occup node tree mainmemori oltp environ includ mix read updat oper ttree b tree two index structur studi previous literatur mainmemori databas product awar implement ttree index structur propos lehman carey howev author found due higher cost cach miss modern hardwar tree perform better experi conduct integ key assumpt integ key may valid olap environ assum suitabl preprocess gener purpos databas must handl complex key multipl part null valu ttree similar binari tree multipl key instead one store node variablelength field countryspecif sort valu etc further key size key storag strategi directli affect branch factor tree sinc branch factor small alreadi node size base cach block height tree vari substanti key size chang thu initi motiv research examin ttree btree perform mainmemori oltp environ order consid varieti key storag scheme key size author suggest avoid key size problem replac key valu index pointer data reconstruct key need index travers indirect keystorag approach advantag optim storag elimin duplic key valu index improv branch factor node simplifi search avoid complex store long variablelength key index node howev approach must reexamin due addit cach miss caus retriev indirect key second approach deal larg complex key use key compress allow key fit cach block keycompress approach benefit entir key valu construct without access data record dereferenc pointer howev typic compress scheme employ prefix btree disadvantag compress key variables lead undesir space manag overhead small mainmemori index node further depend distribut key valu prefixcompress key may still fairli long result low branch factor deeper tree paper propos partialkey approach use fixeds part key inform key differ minim number cach miss cost perform compar tree travers keep simpl node structur incur minim space overhead key repres partialkey tree pointer data record contain key valu key partial key given key index refer index key purpos discuss partial key consist offset first bit index key differ base key l bit index key valu follow offset l input paramet intuit base key given index key recent key encount search prior compar index key partialkey approach reli abl resolv comparison search key index key use partialkey inform index key comparison cannot resolv pointer data record dereferenc obtain full index key valu use idea partial key develop pkttree pkbtree variant ttree btree respect describ search algorithm partialkey tree well strategi maintain partialkey inform presenc updat final conduct extens perform studi pkttree pkbtree structur compar standard tree btree direct indirect key storag scheme experi consid wide rang paramet set key size key valu distribut entropi also studi sensit partialkey algorithm l number key valu bit store partial key perform result given detail section indic that ffl index scheme studi partialkey tree minim cach miss key size ffl due lower cpu cost btree direct key storag faster partialkey tree small key size slower larger key size ffl partialkey scheme good space util slightli wors ttree indirect key storag much better direct key storag scheme ffl small fix valu l the amount partial key informa avoid indirect key access wide varieti length entropi summari partialkey tree incur cach miss impos minim space overhead reduc cost key comparison without introduc variablelength structur node thu enabl larger key handl much effici smaller key further expect rel perform partialkey tree improv time increas cost cach miss remaind paper organ follow section discuss relat work section introduc partial comparison appli search pkt pkbtree section present result perform studi fi nalli section present conclus issu address futur work relat work earli studi index structur mainmemori databas undertaken author propos ttree index and order optim storag space advoc store pointer data record instead key valu index howev design choic result larg number cach miss sinc pointer derefer access key valu key comparison could potenti lead cach miss sinc time earli work mainmemori databas littl differ cost cachehit cachemiss much attent paid minim cach block miss work cacheconsci data structur outsid databas commun focus optim scientif workload cacheconsci behavior studi pointerbas structur includ search tree howev work focus action taken without programm cooper rather explicitli design data structur recent rao ross propos two new mainmemori index techniqu cachesensit search tree csstree cachesensit b tree design readintens olap environ csstree essenti compact spaceeffici tree csstree node fulli pack key laid contigu level level main memori thu children node easili locat perform simpl arith metic explicit pointer child node longer need further absenc updat key valu map integ map preserv order key valu thu key valu csstree compact int ger store node itself elimin pointer deref erenc summari csstree incur littl storag space overhead exhibit extrem good cach behavior csb tree adapt idea index structur support effici updat for csstree author recommend rebuild scratch batch updat structur store group sibl node adjac memori reduc number pointer store parent node without incur addit cach miss howev work continu assum integ key ex tent perform improv csb tree csstree partialkey tree like orthogon sinc former focus reduc pointer overhead improv space util latter focus reduc keysiz comparison cost partialkey techniqu borrow earlier work key compress howev differ discuss below partialkey tree similar bit tree introduc bit tree extend tree store partial key instead full key valu onli key contain leaf node partial key bit tree consist offset differ bit rel previou key node author describ sever properti search use offset differ bit particular show somewhat surpris result precis posit search key leaf node determin perform exactli one pointer derefer retriev indirect key focu mainmemori rather disk partialkey tree differ bit tree follow respect partial key store intern node leaf node partial key contain l bit key valu follow differ bit addit differ bit offset search key node partialkey tree requir one pointer dereferenc frequent requir pointer derefer due l bit addit inform novel search algorithm tree propos employ key compress improv storag space characterist branch factor tree suppos p common prefix key subtre root node n node n common prefix p comput tree travers suffix key valu store n further key move leaf node due split separ shortest portion key need distinguish valu split node move partialkey tree differ prefix b tree follow respect prefix tree factor portion common key node partialkey tree factor inform common pair adjac key within node typic longer prefix common whole node prefix tree entir suffix separ store partialkey tree first l bit suffix store thu partialkey tree may lose key valu inform prefix not prefix b need contrast partialkey tree pointer derefer must perform comparison cannot resolv use partialkey inform partial key store prefix tree variabl size complic implement further case separ may even fit byte cach line caus index node span multipl cach block reduc branch factor thu partial key tree trade guarante indirect key refer partialkey tree low probabl indirect key derefer exchang simpl node structur strongli bound tree height reason sinc cost cachemiss order magnitud lower cost random disk access ronstrom thesi describ httptree variat prefix tree compress perform within node store key rel previou key factor common suffix etc node also cluster page facilit distribut howev search full key reconstruct order perform comparison compress key size variabl lossless compress scheme primarili numer attribut recent propos databas literatur goldstein ramakrishnan shaft propos page level algorithm compress tabl numer attribut minimum valu occur tupl page store separ entir page further instead store origin valu attribut tupl differ origin valu minimum store tupl rec data record partial l bit figur partial key thu sinc store differ consum fewer bit storag space overhead tabl reduc tupl differenti code tdc compress method also achiev space save store differ instead actual valu attribut howev attribut valu tupl store differ rel attribut valu preced tupl partial key search section describ partial key approach algorithm perform compar search presenc partial key assum key repres fixedlength bit string though requir gener further bit number order decreas signific begin bit the signific bit partial key overview consid order index key visit compar search key travers ttree btree index observ structur key visit far closest valu search key either recent key compar less search key recent key compar greater easi see recent key compar less search key share initi bit compar less search key search similarli recent key compar greater thu observ follow fact initi bit may share recent search key when exampl key either side larg power two event rare follow discuss refer current key visit index key as oppos search key previou visit base key partialkey scheme key repres index three item pointer record contain key offset first bit index key differ base key first l bit index key follow offset illustr construct partial key figur figur other below index key search key gener refer k k j base key one approach use partial key inform would mirror use prefix prefix btree approach search code would maintain known prefix index key travers tree concaten appropri portion partial key encount known portion suffici resolv comparison search key cach miss avoid howev turn construct prefix necessari fact comparison often resolv note offset search key differ base key compar offset store partial key index key observ ensur comparison perform small fixedlength portion key precis comparison perform topic next section partialkey comparison section discuss properti differ bit formal present theorem bear directli comparison partialkey tree offset signific thu lowest bit differ key k k j also let ck result lt gt eq comparison key k depend whether k k j partialkey approach base observ index key k j base key k b note partial key key k j frequent allow full comparison k j search key k avoid index retriev particular two k j compar way lt exampl base key known possibl determin k compar k j well addit refer key unless theorem given k ae proof assum without loss gener k suppos dk first bit differ must k b s bit must follow dk bit k agre bit k b bit includ dk correspond bit k also thu hand suppos dk thu sinc k bit posit dk must k k b further sinc dk must k j k b is further bit sequenc preced bit k k j must ident thu follow k case follow symmetri key idea theorem illustr figur a here less base key k b dk greater dk thu shown figur first bit k k j k b match th bit k k b k j theorem use comput case result comparison search key k index key k j partial key index key k j store differ bit offset respect base key k b encount previous search further sinc attempt made search algorithm compar k k j must case ck avail due previou comparison search key base key thu case dk theorem use infer dk turn propag next index key comparison for k j base key case handl theorem occur dk case infer one make ident first dk one cannot determin key k k j compar exampl illustr figur b case shown figur k one k differ bit equal l bit key valu store index key compar correspond bit search key bit equal retriev indirectli store key requir note that shown figur differ bit includ l bit store partial key sinc k k j differ k b valu bit correspond bit k k j must ident procedur comparepartkeysearchkey indkey comp offset begin indkeypkoffset offset comp gt els comp lt offset indkeypkoffset els indkeypkoffset offset partkey searchkeyindkeypkoffset els partkey searchkeyindkeypkoffset comp offset comparesearchkey offset indkeypkoffset comp eq return comp offset figur comparepartkey comparison use partial key procedur comparepartkey figur util theorem comput result comparison search key index key contain partialkey inform partialkey inform consist three field pkoffset pklength partkey describ tabl input paramet comp offset comparepartkey result comparison differ bit locat search key respect base key step procedur straightforward applic theorem case differ bit locat search key index key equal key must ident differ bit further differ bit key must either depend whether key less greater base key step function compar invok comput comparison l bit follow differ bit key function comparek k return pair valu comp offset follow semant valu comp one eq lt gt depend whether bit sequenc k equal to less greater bit sequenc k two sequenc compar bit bit return valu offset locat signific bit two key differ thu step sinc partkey may repres entir index key bit partkey agre correspond bit searchkey comparison search key index key cannot resolv procedur return eq case semant return offset simpli two key agre first offsetgamma bit note that step function compar need consid bit start bit offset indkeyoffset two key sinc correspond bit preced point ident therefor a b figur exampl comparison key k k j cannot resolv tabl partialkey notat symbol descript l maximum number bit key valu store partial key offset differ bit key k base key bit follow locat k pkoffset key k pklength number partialkey bit store key k sequenc consist bit offset l key k k delta k concaten bit sequenc k k n numkey number key node n th key node n th pointer node n key further case procedur comparepartkey perform one integ comparison involv differ bit offset howev addit expens may incur sinc bit offset must comput anticip next comparison greater cost simpl integ compar compar well comparison larger key shown section partialkey scheme adapt multiseg key even segment arbitrari length idea treat pkoffset two digit number first digit indic key segment second indic offset within seg ment partkey field may limit bit singl seg ment cost complex span segment partialkey node comparepartkey procedur describ previou section basic build block perform retriev pkt tree pkbtree present complet algorithm search tree present linear encod scheme comput partial key array key index node n also present linear search algorithm find search key node present not pair adjac key node search key lie linear encod partial key base key key n simpli key immedi preced n first key nkey base key key ancestor n tree compar search key tree travers node n visit thu base key first key depend tree structur differ pkttree pkbtree discuss follow section simpl linear search algorithm search key index node n visit search key compar base key nkey let comp offset denot result comparison offset differ bit search key base key then order locat posit search key n procedur comparepartkey see figur use comput comparison differ bit offset search key nkey case comparison cannot resolv use partialkey inform nkey that is comparepartkey return eq nkey dereferenc search key compar full key correspond nkey result comparison differ bit offset use compar search key nkey on step compar search repeat success key n comparison differ bit offset previou key key greater equal search key found howev naiv linear search strategi may perform unnecessari derefer follow exampl illustr thi consid node n figur differ bit key with respect previou key mark arrow bit follow differ bit store partial key key let base key first key n search key figur linear search key node let search key search key compar base key comparison differ bit offset gt respect invok comparepartkey search key nkey gt return eq sinc nkeypkoffset search match nkey first two bit thu nkey would dereferenc comp pkoffset comparison nkey gt respect next search key compar nkey invok comparepartkey sinc greater differ bit offset search key nkey comparepartkey return gt nkey dereferenc next invoc comparepartkey nkey return gt sinc bit sequenc construct nkey smaller correspond bit search key return gt nkey parepartkey move key return lt nkey sinc find nkeypkoffset less offset return nkey thu simpl linear search algorithm stop nkey posit search key n determin use one key derefer nkey howev posit search key also determin without dereferenc key includ nkey reason comparepartkey return eq invok nkey thu point know first two bit nkey sinc first two bit nkey agre search key sinc nkeypkoffset also conclud first two bit nkey agre nkey thu sinc must case third bit nkey and third bit nkey must further fourth bit nkey obtain partial key thu conclud first four bit nkey sinc search key comparison search key nkey resolv gt subsequ comparison carri describ earlier conclud search key lie nkey nkey thu posit search key determin without dereferenc singl key linear search algorithm requir one key deref erenc procedur findnod shown figur avoid unnecessari derefer made simpl linear search algorithm compar search key index key node n case procedur comparepartkey return eq is comparison search key index key cannot resolv findnod immedi derefer index key in stead exploit semant eq offset return com procedur findnoden searchkey offset begin high n numkey low cur offset cur cmp gt cur low cur highf cur cmp cur comparepartkeysearchkey n keycur cur cmp cur off cur high cur break els cur low cur offset cur off cur high low low high offset findbittreen searchkey low high cach miss return low high offset figur findnod linear search key node use partial key parepartkey which search key index key agre first offset bit tri resolv comparison subsequ key illustr earlier exampl eq result comparison nkey use resolv comparison oper key nkey fact procedur comparepartkey alreadi state correctli handl valu eq input paramet call findnod inform proof fact found appendix a procedur findnod accept input paramet node n perform linear search differ bit offset search key base key nkey assum search key nkey greater base key respect nkey partial key comput similar simpl linear search algorithm describ earlier compar search key success index key node index key larger search key found procedur comparepartkey use perform everi comparison result previou comparison store variabl cur cmp cur off pass input paramet it unlik simpl linear search scheme index key immedi dereferenc precis result comparison key search key cannot comput instead variabl low high use keep track posit index key n search key definit known greater less than respect end sweep key node n high low greater impli precis posit search key n ambigu case procedur findbittre use locat exact posit search key low high return consecut key search key lie differ bit offset search key respect lower key procedur findbittre employ search algorithm bit tree describ requir exactli one key dereferenc nutshel algorithm perform sequenti scan key n offset low high maintain variabl po initi set low key examin differ bit offset partial key bit valu search key variabl po set posit key n hand bit valu search key key differ bit offset greater current skip next key examin key whose differ bit offset less current key examin nkeypo dereferenc compar search key comp offset pair return comparesearchkey nkeypo findbittre take one follow action suppos high posit first key rightleft po differ bit offset less nkeypo return high high offset correct findbittre case due follow properti po po key whose differ bit offset equal po key whose differ bit offset less poss refer reader detail variabl offset return findnod differ bit offset search key n keylow case low is search key less nkey offset differ bit offset search key base key nkey final search key contain n procedur return posit index key equal search key revisit exampl findnod determin posit search key node n without requir key deref erenc success invoc procedur comparepartkey sequenc key n return eq eq gt gt lt maintain partialkey inform presenc up date linear encod strategi maintain partial key inform quit straightforward insert new key node requir partial key insert key key follow recomput delet requir partial key key follow delet key recomput partialkey tree build partialkey comparison singlenod partial search algorithm present previou section discuss partial key improv perform mainmemori index structur reduc l cach miss rate particular present partialkey variant ttree btree index structur suitabl use mainmemori pktttree pkbtree refer them extend mainmemori counterpart repres key partialkey inform describ section linear encod scheme describ previou section use comput partial key index key node linear encod node level thu need specifi base key respect first key node encod sinc base key everi key node simpli key preced it pkttree ttree balanc binari tree multipl key store node leftmost rightmost key valu node defin rang key valu contain node balanc handl avl tree refer reader addit inform ttree includ detail updat strategi concurr control pkttree similar ttree except addit pointer data record contain full key valu index key entri also contain partialkey in format follow nptr nptr denot pointer left right children node n store partialkey inform first key node n base key respect partial key comput first key parent node becaus describ below leftmost key parent node key search key compar node n visit figur a depict exampl pkttree figur solid arrow denot base index key dash arrow repres pointer child node procedur findttreesearchkey t begin n root tree t lan nil offset comp gt n nil f comp offset comparepartkeysearchkey derefer nkey cach miss comp offset comparesearchkeynkey return n offset els n nptr els lan n lanoffset offset n n ptr return lan findnodelan lan searchkey lanoffset figur findttre search key ttree use partial key search key search key valu pkttree rel straightforward perform describ procedur findttre see figur procedur findttre includ optim requir node search key compar leftmost key valu node step variabl comp offset keep track result recent comparison search key leftmost key parent node pass paramet com parepartkey case comparepartkey cannot resolv comparison leftmost key current node dereferenc step search key found less key search proce left subtre found greater search proce right subtre current node note variabl lan step signific lan search reach bottom tree search key present tree node store lan greater lan procedur findnod thu employ order determin posit search key node lan sinc find node requir leftmost key greater base key it lan delet lan pass input paramet findnod maintain partialkey inform presenc up date insert delet key pkttree caus ro tation movement key node insertionsdelet a pkttree b pkbtree pointer pointer figur pkttree pkbtree key node partialkey inform case updat follow ffl case rotat parent node involv rotat may chang thu partialkey inform leftmost key node recomput respect new parent ffl leftmost key node chang partialkey inform recomput leftmost key node two children ffl case key left key node chang due key insert delet partialkey inform key recomput rel new preced key pkbtree pkbtree ident btree except structur index key index key consist pointer data record key partialkey inform leaf node contain index intern node also contain nnumkey pointer index node subtre point nptri contain key store partialkey inform base key leftmost key n largest key contain ancestor n less leftmost key thu n node n ptri point n one parent n path n n n ptr point n one parent base key rel nkey encod n illustr figur b solid arrow denot base key index key pkbtree dash arrow repres pointer child node search key procedur findbtre figur contain code search key pkbtree begin root node node procedur findnod invok determin child node visit next search variabl offset store offset differ bit search key base key nkey that is largest key ancestor n also less nkey findnod simpli return offset input search key less nkey maintain partialkey inform presenc up date insert oper caus key insert leaf node pkbtree key insert leftmost posit leaf partial key need comput rel largest key less ancestor hand key left node partial key procedur findbtreesearchkey t begin n root tree t pn nil offset n nil f pn n low high offset findnoden searchkey offset low high return n low high n nptrhigh return pn low high figur findbtre search key btree use partial key comput easili rel preced key partial key next key comput respect it case node n split split key n insert parent split thu handl simpli updat partialkey inform parent similar key insert case key delet pkbtree somewhat complic case leftmost key leaf delet partialkey inform need recomput base key ancestor delet nonleftmost key leaf simpli requir partial key key follow recomput final delet key nkeyi intern node n pkbtree caus replac smallest key subtre point node contain key everi node n n n n s partial key recomput smallest key that replac delet key nkeyi base key perform goal perform studi compar lookup perform ttree btree pkttree pkbtree mainmemori set particular goal follow studi perform wide rang key size key valu distri bution evalu impact chang amount partial inform use pkt pkbtree evalu space usag spacetim tradeoff subsequ section describ hardwar platform design experi present select result memori hierarchi latenc observ memori refer depend primarili whether data present cach whether vir system cpu l data l data dram cycl time size block latenc size block latenc l miss latenc sun ultra ns k ns ns ns sun ultra ns k ns ns ns pentium iii ns k ns k ns ns pentium iiie ns k ns k ns ns tabl latenc cach vs memori tual address translat lookasid buffer tlb modern mainmemori architectur typic includ two level cach small fast oncpu l cach larger offcpu therefor slower l cach typic paramet cach memori speed shown tabl see latenc inform gener version lmbench local avail processor intend give reader feel current cach paramet comparison system anoth compon memori hierarchi tlb cach translat virtual physic address shown signific effect perfor manc focu tlb issu paper one justif approach fact almost modern tlb capabl use superpag essenti allow singl tlb entri point much larger region pose difficulti oper system implementor facil may effect remov tlb miss issu mainmemori databas allow entir databas effect share one two tlb entri focu tlb effect appar experiment form better perform index node span multipl cach line these result shown due limit space determin effect superpag tlb cost mainmemori data structur remain futur work experiment design implement ttree btree direct indirect storag key also implement pkttree pkbtree vari size partial key store node ttree algorithm essenti lehman carey optim perform singl keycomparison given level direct key partialkey variant store en tireparti key valu leftmost key node use initi travers ttree code adapt system addit support concurr control next lock iteratorbas scan featur exercis test partialkey tree implement two scheme store offset bitwis bytewis bitwis scheme use descript section sinc scheme concept clearli articul howev may conveni implement store differ inform larger granular particular consid byte granular clearli result section hold byte offset differ sinc bit offset also differ manner how ever byte offset equal may still case bit offset would differ case one simpli store bit differ could occur word entir byte thu offset compar equal key disambigu physic characterist memori modul especi repeat access page may also factor consid paper pentium iiie l cach though rel small onchip first byte store offset larger granular trade distinguish power code simplic bit offset one alway store precis l bit capabl distinguish otherwis bit store key model key uniqu fixedlength sequenc unsign byte key comparison perform bytewis context separ function call indirect key store separ l cach line sinc typic retriev data record intuit partial key would sensit distribut key particular entropi key sinc test gener byte key independ entropi byte depend number symbol byte select specif byte select uniformli alphabet n symbol byte contain lg n bit shannon entropi intuit key higher entropi distinguish earlier compar lead lower comparison cost term partial key lower entropi lead larger common prefix lower chanc two key differ within l byte common prefix while mention section partialkey tree may use multipart variablelength key implement option test note degre implement wider varieti key and thu expens key com parison work partialkey scheme sinc scheme reduc impact key comparison cost case partial key suffici howev bytewis comparison may somewhat less effici than exampl singleinstruct integ comparison select bytewis comparison reason model key comparison expens attempt vari cost addit paramet current studi perform metric evalu variou indic base follow three perform metric walltim number l cach miss storag space requir number l measur use special regist avail ultrasparc via perfmon softwar paramet set unless otherwis state index node span three lcach block total byte index store key key chosen uniformli random reject uniqu three cach block chosen size could handl larger innod key size and experi not shown perform compar better smaller larger node size studi algorithm record repres largest size machin could easili hold memori rel larg number record requir see effect l cach miss time number test present result two choic byte entropi gener key bit bit correspond alphabet size respect though actual experi consid wide varieti entropi inbetween experi key size independ paramet fix time per lookup usec l miss per lookup time vs cach miss pkbtree pkttree time per lookup usec l miss per lookup time vs cach miss pkbtree pkttree b figur time l cach perform variou key strategi high low entropi size l partial key store byte store offset byte granular sinc found partialkey tree perform optim nearoptim choic hardwar environ experi conduct sun ultra workstat mhz ultrasparc ii processor megabyt ram shown tabl machin k l data cach size l directmap cach byte block size latenc shown lmbench ns cycl l cach ns cycl l ns cycl main memori implement index structur use sun c compil version optim level o experi ensur virtual memori access run resid ram experiment run case run consist lookup pregener list randomli select key tree search success run repeat time averag ensur overal standard deviat time low less figur shown document tree million element maximum fit main memori platform select result index perform mainmemori environ domin cpu cost perform key comparison cach miss cost thu reason btree direct key storag perform better partialkey tree small key sinc space usag compar space requir partial key partialkey comparison code somewhat expens simpl bytewis key compar howev key becom longer btree perform expect becom wors partial tree due lower branch factor higher key comparison cost low byteentropi case expect indirect index perform poorli comparison direct index data structur indirect index requir extra cach miss perform comparison expect confirm experi figur summar experiment result index scheme data set million element yaxi show number l cach miss xaxi show averag time lookup microsecond plot parametr key size key size byte high entropi case addit point size figur a show behavior low entropi entropi per byte figur b show experi run entropi given key size entropi left defin improv perform perform thu partial order one algorithm outperform anoth valu key size entropi valu algorithm faster fewer cach miss use metric cach miss lookup time make follow observ ffl pkbtree consist outperform algorithm l cach miss ffl direct btree outperform algorithm time small key size would hold integ key ffl direct ttree outperform algorithm time larg key size slightli outperform pkbtree ffl direct ttree indirect btree essenti cach perform occur ttree suffer due tree level btree suffer due key dereferenc ffl indirect ttree perform poorli compar strate gie primarili due cach miss tree level dereferenc ffl key size cachemiss behavior partialkey tree good correspond tree structur direct storag byte key one reason superior cachemiss characterist partialkey tree alway translat better time number especi smaller key size factor like cpu cost perform key comparison etc signific compon overal perform howev base cachemiss statist expect perform partialkey tree improv rel tree direct key storag long processor speed improv quickli mainmemori latenc choic l larger valu l necessari entropi low suffici entropi must present partial key high probabl differ correspond byte search key in gener random key length l lg nh ensur two key collid key disambigu length lg nh one see key wise differ inform adapt low entropi key key time per lookup usec partial key length byte pkb bit pkb byte pkt bit pkt byte time per lookup usec overhead per key byte pkbtree pkttree b figur vari partialkey size timespac tradeoff low entropi adjac key like larger common prefix further increas l advers affect branch factor node thu tradeoff reduc cach miss avoid refer indirect key reduc cach miss bushier thu shallow tree investig issu run experi wide varieti key entropi valu l experi key rel low entropi bit per byte result similar wide rang entropi valu expect partial key perform well wide varieti key distribut fact perform almost alway optim small valu l byte due efficaci store differ offset store zero byte key inform special case reduc algorithm similar bit tree gener handl intern level tree incur fewer cach miss option perform well l experi confirm follow intuit store differ bit level import order increas distinguish power space usag space overhead critic attribut mainmemori index figur b show spacetim tradeoff differ algorithm varieti key size graph xaxi space axi lookup time the lower lefthand corner optim key size paramet vari byte space number obtain tree built random insert key see graph indirect storag poor time perform excel space how ever scheme direct key storag trade space time storag overhead increas significantli key size again pkt pkbtree provid nice tradeoff take approxim twice space indirect storag key size less space directstorag btree key size greater conclus futur work paper introduc two new index structur pkt pkbtree design optim space time cachemiss perform indic mainmemori oltp databas index structur base partial key small fixeds represent key allow index node retain simpl struc ture improv branch factor speed key comparison yet resolv key comparison without refer indirectli store key perform studi found partialkey tree perform better btree in key store directli node key larger byte depend key distribut further partialkey tree incur fewer cach miss btree smallest key size lead expect perform pkbtree rel btree improv time gap processor main memori speed widen caus penalti cach miss sever fi nalli pkbtree take much less space standard btree smallest tree pkttree direct ttree perform well pkbtree perform better slightli larger howev expect time ttree replac variat btree mainmemori databas dramat better l cach coher optim perform key size perform result lead one consid hybrid approach direct storag use small fixedlength key partialkey represent use larger variablelength key futur work intend explor way architectur trend affect performancecrit mainmemori dbm code one trend increas avail instructionlevel parallel relat trend increas cost branch mispredict pipelin bubbl second trend avail superpag tlb may significantli reduc tlb cost inmemori algorithm r design analysi comput algorithm storag manag main memori databas perform critic applic organ mainten larg order index prefix btree databas architectur optim new bottleneck memori access imporv pointerbas code cacheconsci data placement pentium iii processor sc mhz mhz datasheet element inform theori implement techniqu main memori databas system perfmon user guid main memori databas system overview compress relat index virtual memori contemporari microprocessor dali high perform mainmemori storag manag evalu starburst memori resid storag compon studi index structur main memori databas manag system portabl tool perform analysi ultra ultra workstat datasheet arieskvl keyvalu lock method concurr control multiact transact oper btree index microsoft com cach consciou index decisionsupport main memori make b logic physic version mainmemori databas reduc tlb memori overhead use onlin superpag promot design model parallel data server telecom applic timesten team tr element inform theori bittre data structur fast file process reduc tlb memori overhead use onlin superpag promot storag manag inmemori data manag consum transact timesten approach prefix italicbitalictre make b tree cach consciou main memori design analysi comput algorithm implement techniqu main memori databas system virtual memori contemporari microprocessor main memori databas system evalu starburst memori resid storag compon blockori compress techniqu larg statist databas compress relat index logic physic version main memori databas studi index structur main memori databas manag system cach consciou index decisionsupport main memori databas architectur optim new bottleneck ctr peter bumbuli ivan t bowman compact btree proceed acm sigmod intern confer manag data june madison wisconsin bin cui beng chin ooi jianwen su kianle tan contort high dimension data effici main memori knn process proceed acm sigmod intern confer manag data june san diego california phil garcia multithread architectur sort benchmark proceed st intern workshop data manag new hardwar june baltimor maryland b barla cambazoglu cevdet aykanat perform queri process implement rankingbas text retriev system use invert indic inform process manag intern journal v n p juli inga sitzmann peter j stuckey compact discrimin inform spatial tree australian comput scienc commun v n p januaryfebruari main memori index case bdtree ieee transact knowledg data engin v n p juli jingren zhou john cieslewicz kenneth a ross mihir shah improv databas perform simultan multithread processor proceed st intern confer larg data base august septemb trondheim norway ke wang yabo xu jeffrey xu yu scalabl sequenti pattern mine biolog sequenc proceed thirteenth acm intern confer inform knowledg manag novemb washington dc usa bin cui beng chin ooi jianwen su kianle tan index highdimension data effici inmemori similar search ieee transact knowledg data engin v n p march shimin chen phillip b gibbon todd c mowri gari valentin fractal prefetch btree optim cach disk perform proceed acm sigmod intern confer manag data june madison wisconsin richard a hankin jignesh m patel effect node size perform cacheconsci btree acm sigmetr perform evalu review v n june shimin chen phillip b gibbon todd c mowri improv index perform prefetch acm sigmod record v n p june bingsheng qiong luo cacheoblivi nestedloop join proceed th acm intern confer inform knowledg manag novemb arlington virginia usa jeong min shim seok il song jae soo yoo young soo min effici cach consciou multidimension index structur inform process letter v n p novemb