t optim comput effect blockprocess a blockprocess decreas time power requir perform given comput simultan process multipl sampl input data effect blockprocess sever limit howev delay dataflow graph comput place suboptim paper investig applic retim improv effect blockprocess comput particular consid kdelay problem given comput dataflow graph posit integ k wish comput retim comput graph origin delay reloc k data sampl process simultan fulli regularli give exact integ linear program formul kdelay problem also describ algorithm solv kdelay problem fast practic reli set necessari condit prune search space experiment result synthet random benchmark demonstr perform improv achiev blockprocess effici algorithm b introduct mani applic domain comput defin semiinfinit long stream data rate incom data dictat natur applic often cannot satisfi straightforward implement specif although speed hardwar compon increas steadili throughput requir new applic increas even faster pace recent studi show comput requir per sampl stateoftheart commun preliminari version work present rd acmiee design autom confer june a b figur improv effect blockprocess retim blockprocess factor origin comput dataflow graph part a blockprocess factor retim graph part b doubl everi year process power hardwar doubl everi three year furthermor new applic requir low power dissip impos addit design constraint often add gap speed hardwar primit rate incom data order meet increas comput demand today commun ap plicat requir comput simultan multipl sampl incom data stream approach known blockprocess vector wide use satisfi throughput requir use parallel pipelin block process enhanc regular local comput thu greatli facilit effici implement mani hardwar platform enhanc regular reduc effort softwar switch address calcul improv local improv effect codes reduct method moreov blockprocess enabl effici util pipelin effici implement vectorbas algorithm fftbase filter errorcorrect code gener block process benefici case net cost process n sampl individu higher net cost process n sampl simultan typic cost measur includ process time memori requir energi dissip per sampl sever way increas blockprocess factor comput is number data sampl process simultan exampl one unfold basic iter comput schedul comput block differ iter execut success howev techniqu may uniformli increas blockprocess factor comput block anoth transform use increas blockprocess factor retim contrari architectur transform techniqu target highlevel synthesi retim use tradit clock period minim logic synthesi figur illustr use retim improv blockprocess comput dataflow graph cdfg figur three comput block a b c three delay input stream come block a output stream gener a assum comput implement uniprocessor system express block give initi time x comput time per block input initi time includ contextswitch overhead fetch data instruct background memori cost reconfigur pipelin singl iter comput figur a complet cycl execut block order three iter comput block execut order case new input consum everi cycl entir comput need theta cycl hand function equival cdfg figur b obtain retim origin cdfg complet three iter singl block iter requir cycl group three delay one edg comput three iter execut order thu amort initi time block three input recent retim studi context optimum vector class dsp program specif techniqu linear vector dsp program use retim present techniqu involv redistribut delay cdfg represent dsp program way maxim concentr delay edg howev fulli regular vector cannot achiev use linear vector approach paper moreov retim problem comput linear vector formul nonlinear program comput expens solv paper consid problem retim comput dataflow graph achiev given blockprocess factor k call kdelay problem first present integ linear program ilp formul kdelay problem formul set necessari condit use develop effici branchand bound algorithm kdelay problem given cdfg posit integ k algorithm comput retim cdfg achiev blockprocess factor k determin retim exist import featur approach block retim cdfg achiev blockprocess factor k execut order across iter result retim cdfg oper faster less expens implement gener blockprocess cdfg provid extens experiment result demonstr effect optim effici algorithm remaind paper organ follow section describ represent comput dataflow graph give background materi block process retim also give precis mathemat formul kdelay problem section present integ linear program formul kdelay problem section describ set effect necessari condit use necessari condit develop branchandbound algorithm section solv kdelay problem effici practic present experiment result section conclud direct futur work section preliminari section first describ dataflow graph represent comput subsequ provid background blockprocess give condit must satisfi effect blockprocess also provid background materi retim give mathemat formul kdelay problem graph represent cdfg comput structur edgeweight direct graph node v v model comput block subroutin arithmet boolean oper ator direct edg e e model interconnect data control depen denci comput block edg e e associ weight we denot number delay regist associ interconnect figur a give graph represent sampl cdfg delay state behavior synthesi correspond iter boundari softwar compil regist gatelevel descript result paper translat one domain two straightforward manner translat result behavior logic synthesi involv semant interpret blockprocess blockprocess strive maxim throughput comput simultan process multipl sampl incom data maximum number sampl process simultan immedi block v call blockprocess factor k v block blockprocess linear block a b figur type linear blockprocess a regular linear blockprocess factor b irregular linear blockprocess factor blockprocess factor k given linear blockprocess factor k k delta jv j comput block evalu gener k iter comput constitut block iter linear blockprocess factor k regular k data sampl process simultan everi comput block access block iter retim cdfg figur a exampl blockprocess linearli regularli blockprocess factor comput block cdfg execut order two input sampl consum blockiter regular blockprocess lead effici implement cdfg reduc cost address calcul softwar switch cdfg figur a illustr indic comput block use block b well first blockiter linear blockprocess need regular illustr cdfg figur b blockprocess blockprocess factor comput block cdfg execut order delta blockprocess irregular howev comput block process differ sampl given block iter first block iter exampl block b process sampl block process sampl follow lemma give necessari suffici condit achiev linear regular blockprocess cdfg achiev linear regular block process g factor k everi edg e e proof relat satisfi cdfg blockprocess linearli regularli factor k exist edg u e v process we sampl per iter sinc we k remain k gamma we sampl must access previou block iter contradict regular retim retim cdfg integ valu vertexlabel r integ valu denot assign lag vertex transform g r i edg u e defin equat retim cdfg g r wellform edg sever import properti retim transform stem directli relat one properti use repeatedli proof paper given vertex pair u v v retim r chang origin delay count everi path u v amount verifi properti express postretim delay count w r p along path p sum delay count constitu edg sinc sum equat telescop thu chang delay count path depend endpoint path corollari follow immedi equat retim chang delay count around direct cycl cdfg base properti straightforward show given edg e e maximum number delay retim place e cannot exceed w v kdelay problem accord lemma linear regular blockprocess factor k achiev cdfg exactli least k delay edg given cdfg satisfi condit relat redistribut delay retim node achiev desir blockprocess factor k call problem comput retim kdelay problem problem kdp the kdelay problem given cdfg posit integ k comput retim function r z everi edg u e e determin retim exist problem kdp cannot express directli linear program form disjunct or requir relat section reli notion companion graph describ express problem kdp integ linear program ilp companion graph g cdfg g construct segment everi edg u e two edg v x uv dummi vertex thu edg u e figur illustr construct companion graph follow lemma give necessari suffici condit hold retim solv problem kdp cdfg let g companion graph exist retim function r solv problem kdp g exist retim function r z everi edg u e everi edg u e e f a b f figur construct companion graph a origin cdfg companion graph gener segment everi edg e two edg introduc dummi vertex first edg delay count edg g segment gener edg c w xcd xcd w g proof inequ ensur retim circuit wellform inequ ensur delay count g r satisfi definit companion graph inequ ensur everi edg u e x uv one delay retim edg x uv v least k gamma delay thu edg u e e delay least k delay retim construct solut r problem kdp g deriv r simpli set follow theorem express problem kdp set oe integ linear program constraint theorem let comput flow graph let g companion graph exist retim function r solv problem kdp exist retim function r z everi edg everi edg u e e proof follow directli linear relat form inequ lemma necessari condit main challeng solv problem kdp determin edg delay not ilp formul problem kdp determin edg explicitli result constraint formul appear special structur thu need resort gener integ linear program solver comput solut comput expens larg cdfg section give set necessari condit determin implicitli edg delay next section develop branchandbound techniqu base necessari condit consider effici practic ilp formul follow four subsect deriv necessari condit feasibl problem kdp given cdfg first deriv condit ensur cycl enough delay around them identifi path must necessarili contain delay path must necessarili free delay base path deriv necessari condit feasibl problem kdp final describ construct constraint graph captur explicitli necessari condit feasibl problem kdp delay around cycl retim leav delay count around cycl unchang and therefor given cdfg g blockprocess factor k problem kdp feasibl delay count around cycl g greater k follow lemma give mathemat character result feasibl problem kdp cdfg problem kdp feasibl g everi vertex proof contradict let problem kdp feasibl g let exist vertex pair u v inequ hold sinc w u v minimum delay count simpl cycl u v exist direct cycl c g delay count less k sinc retim chang delay count around cycl conclud c edg delay count everi retim contradict assumpt problem kdp feasibl everi vertex pair u v v w u v comput effici allpair shortestpath comput ov step thu assum remaind paper given cdfg g alreadi satisfi inequ path delay use properti retim chang delay count path given vertex pair amount determin vertex pair path must necessarili contain delay solut problem kdp follow lemma give necessari condit vertex pair cdfg let r z solut problem kdp g everi vertex pair u v v exist path u p g proof contradict suppos r solv problem kdp w r u v vertex pair u v v satisfi condit lemma show exist edg e e relat hold path u q minimum delay w r u v nonzero delay count exceed k gamma thu edg path violat relat path u q statement lemma furthermor c b a figur illustr explicit implicit delayessenti de vertex pair cdfg part a transform algorithm addedg gener cdfg part b final cdfg part c bold edg part b explicit de pair weight edg indic excess delay associ correspond vertex pair bold edg part c denot explicit implicit de pair exampl pair b implicitli de becom appar de vertex pair b c c made explicit thu p nonzero delay count exceed k gamma consequ edg p violat relat follow lemma cast necessari condit lemma retim problem appropri construct constraint graph given cdfg let g constraint graph gener g follow everi vertex pair u v v exist path u p g delay count wp w u v wp k add new edg problem kdp g everi edg u e proof relat definit wellformed inequ hold everi edg e e remain show inequ hold edg set e gamma e consid vertex pair u v v connect edg e purpos contradict suppos problem kdp feasibl rv gamma ru construct g sinc r solv problem kdp lemma impli w r u v k contradict inequ call vertex pair u v v delayessenti de shortest path u q everi retim cdfg satisfi relat must contain delay exampl everi vertex exist path u p v w u delayessenti sinc satisfi condit lemma shown suffic compar delay count two shortest path vertex pair check exist path u p v w u algorithm addedg figur transform given graph g g algorithm determin delayessenti vertex pair check delay count shortest strictlysecond shortest path everi vertex pair differ less k everi delayessenti vertex pair u v edg u e introduc ensur w r u v k import note order determin whether given vertex pair delay essenti one need compar delay count shortest path strictlysecond shortest simpl path that is path whose weight strictli greater shortestpath weight although problem comput strictlysecond shortest simpl path given vertex pair npcomplet correspond problem without simpl path requir solv polynomi time graph satisfi inequ lemma straightforward show strictlysecond shortest path nonsimpl delay count exce shortest path least k convers delay count shortest strictlysecond shortest path differ less k strictlysecond shortest path guarante simpl follow lemma show algorithm addedg run polynomi time addedgesg everi vertex pair u muv fals run allpair strictlysecondshortest path algorithm g everi vertex pair u v v u p two shortest path u v muv true introduc u e return g figur algorithm addedg transform lemma ov e step algorithm addedg transform given cdfg hv ewi g proof step take ov time sinc allpair secondshortest path comput ov ev e time step take ov e time step take ov time complet thu algorithm addedg termin ov e step lemma captur explicit delay requir implicit hidden requir ment let us assum exampl wish solv problem kdp cdfg figur a sinc shortest secondshortest path vertic b delay respect condit lemma appli appear delayessenti verifi howev shortest path b must necessarili contain delay solut problem kdp sinc imposs retim given cdfg zero delay count b d sinc vertex pair b c c must satisfi condit lemma need least delay shortest path d thu delay along path move outsid b d sinc retim chang delay along path vertex pair ident manner delay edg cannot move b d order expos implicit delay requir construct new graph g delayessenti vertex pair explicit algorithm addedg figur transform graph g gener given cdfg g algorithm addedg g determin implicit delayessenti vertex pair delayessenti vertex pair determin compar everi vertex pair delay count shortest path repeat everi delayessenti vertex pair u v q muv true introduc edg u e everi delayfre vertex pair u mvu true run allpair shortest path algorithm g comput w u v everi vertex pair u delet edg u e v g q everi pair u elseif w delet edg v e u g mvu fals figur algorithm addedg transform g step new graph g delayessenti delayfre vertex pair g explicit transform graph current iter shortest path origin graph vertex pair u v delay count two path differ edg u e weight introduc ensur w r u v k it shown suffici place addit edg delay count two shortest path differ less k differ exce k condit w r u v k implicitli taken care of intuit w u excess delay pair u give upper bound number delay contribut pair rest graph new edg introduc new vertex pair becom delay essenti shown figur exampl pair b becom delayessenti delay requir pair b c c becom explicit follow lemma prove constraint introduc delayessenti vertex pair iter algorithm addedg necessari problem kdp cdfg let g transform graph gener repeat loop algorithm addedg iter let g graph gener iter augment e follow everi vertex pair u v edg u e introduc e let r z solut problem kdp g everi edg u e everi edg u e proof let u e case w inequ follow immedi inequ let u e construct w u v w u v therefor r ad left righthand side part inequ along edg shortest path u v g obtain w r u v inequ impli w r u v sinc r solut problem kdp infer otherwis edg along shortest path g r would contain fewer k delay therefor edg u e thu r satisfi inequ path without delay contrast delayessenti path path must contain delay solut call vertex pair u v v delayfre df shortest path u q everi retim cdfg satisfi relat must contain delay exampl g constraint graph construct g vertex pair u v delayfre sinc retim chang delay count around cycl cannot result w r u v k result everi vertex pair condit w r u must hold otherwis relat violat edg along shortest path u p construct graph g algorithm addedg delayfre vertex pair determin check everi vertex pair u v whether so edg v e introduc ensur w r u process repeat everi delayfre vertex pair made explicit addit edg exampl figur a pair a b delayessenti introduc bold edg new edg introduc cycl fewer k delay thu vertex pair b must delayfre enforc constraint weight bold edg b chang gammaw b follow lemma prove iter algorithm addedg introduc constraint necessari problem kdp feasibl lemma let given cdfg let g transform graph gener repeat loop algorithm addedg iter let g graph gener iter augment e follow everi vertex pair u k edg v e ca b figur delayfre path given cdfg cycl form a less k delay therefor b must delayfre weight bold edg chang gammaw b b achiev thi introduc e let r z solut problem kdp g everi edg u e everi edg u e proof u e inequ follow immedi inequ now consid edg v e vertex pair u v v construct e i ad part inequ along edg shortest path v u e obtain w r v u therefor r v u sinc r solv problem kdp last inequ impli w r u edg along shortest path u v e contain fewer k delay thu edg v e r satisfi inequ constraint graph gener necessari condit lemma encod edg edgeweight constraint graph g gener algorithm addedg de vertex pair u v g algorithm introduc edg u e k moreov df vertex pair u introduc edg v e weight w v follow lemma summar necessari condit feasibl problem kdp given cdfg g term transform graph g cdfg let g transform graph gener algorithm addedg let r z solut problem kdp g everi edg u e proof follow directli lemma follow lemma give run time algorithm addedg lemma ov ev lg v step algorithm addedg transform given cdfg g determin transform possibl proof repeat loop step execut ov time worst case iter one addit edg de df vertex pair get ad modifi graph it shown delay count addit edg get modifi onc loop algorithm addedg execut ov step sinc ov vertex pair step take ov use johnson algorithm comput allpair shortest path thu bodi repeat loop complet ov practic branchandbound algorithm section describ effici branchandbound scheme solv problem kdp scheme reli necessari condit deriv section effect prune search space comput solut g everi vertex ru return r els return infeas figur algorithm solvekdp solv problem kdp figur describ algorithm solvekdp problem kdp gener constraint graph g algorithm initi r search solut use procedur branchandbound describ figur recurs procedur branchandbound comput retim r satisfi constraint g exist violat edg e retim graph g r that is edg delay count k gamma algorithm branchandbound add constraint g forc e least k delay subsequ comput retim satisfi augment constraint set step repeat solut found obtain set necessari condit cannot satisfi retim case algorithm branchandbound backtrack backtrack step state constraint graph restor new constraint ad forc violat edg e take delay count zero given cdfg g optim blockprocess factor kmax largest number sampl process success comput block g number equal maximum number delay place edg bound f thu kmax determin binari search integ rang f feasibl valu check use algorithm solvekdp experiment result develop three program comput optim blockprocess factor kmax three program kmax determin binari search section present result applic program real synthet dsp comput purpos experi determin much blockprocess speed comput compar effici differ implement evalu effect necessari condit first program ilp solv integ linear program formul problem branchandbound satisfi inequ exist return fail save g r introduc edg u e return success els restor g r return success els restor g r return fail return success figur algorithm branchandbound call algorithm solvekdp solv problem kdp kdp describ section first gener ilp constraint solv integ program separ use lp solv publicdomain mixedinteg linear program solver second program ncilp first check necessari condit given section screen infeas problem problem satisfi necessari condit solv ilp formul fed lp solv third program bb implement algorithm solvekdp given section branchandbound scheme reli necessari condit section effect prune search space order explor comput speedup possibl blockprocess appli kdelay optim comput dataflow graph four real dsp program test suit compris adapt voic echo cancel adapt video coder two exampl size cdfg dsp program rang node result speedup experi given tabl figur data obtain uniprocessor implement cdfg improv design cycl kmax cycl improv origin cdfg optim cdfg echo cancel figur experiment result uniprocessor implement given fraction cycl optim cdfg cycl origin cdfg kdelay retim reduct achiev execut time given fraction sum contextswitch overhead node c sum comput time experi initi comput time obtain use measur typic dsp gener purpos processor tm motorola order evalu effici implement experi larg synthet graph addit real dsp program synthet graph test suit gener use sprand function random graph gener describ graph gener use sprand connect integ edg weight chosen uniformli rang given number vertic edg desir sprand gener graph randomli place edg vertic randomli assign weight specifi rang size comput dataflow graph vertic edg result applic three program synthet test suit summar figur experi conduct sparc mb main memori cpu time three program comput kmax result show ilp ineffici run time becom impract graph vertic edg ilp search entir solut space detect infeas solut binari search solut feasibl problem comput rel fast fast two program furthermor detect infeas problem extrem timeconsum ncilp effici ilp primarili due quick screen infeas problem base necessari condit section howev ncilp cannot name ilp ncilp bb figur comparison run time in cpu second taken ilp ncilp bb comput kmax random graph entri mark indic run time exceed cpu second handl effici cdfg node bb effici three program order magnitud faster ilp ncilp moreov handl graph least one order magnitud larger graph handl ilp ncilp thu conclud necessari condit effect prune search space conclus futur work blockprocess speed execut comput amort context switch overhead sever data sampl paper investig problem improv blockprocess factor dsp program use retim transform formul problem comput retim achiev given blockprocess factor k integ linear program present set necessari condit problem comput polynomi time base condit design branchandbound scheme comput regular linear blockprocess experi real synthet comput graph branchandbound scheme order magnitud effici gener integ linear program approach thu necessari condit prove particularli power prune search tree branchandbound scheme import question remain open whether necessari condit also suffici far abl prove suffici hand discov situat necessari condit feasibl yet kdelay problem infeas nevertheless conjectur necessari condit suffici interest direct investig reduct critic path length conjunct maxim blockprocess factor preliminari work area show possibl express critic path requir form constraint edg transform graph g futur work area could explor applic techniqu compil code long instruct word vliw architectur main challeng vliw machin issu mani instruct possibl clock cycl view instruct given program delay element comput graph one could model compil problem vliw architectur blockprocess problem cdfg r lp solv mixedinteg linear program solver fast algorithm digit signal process shortest path algorithm theori experiment evalu introduct algorithm softwar chronic crisi optim twophas rel schedul time constraint algorithm highlevel synthesi digit circuit vlsi array processor delay effici tool retim realist delay model comput strictlysecond shortest path retim synchron circuitri storag assign decreas code size retim resynthesi optim sequenti network combin techniqu synchron logic synthesi algorithm cycletim minim optimum vector scalabl synchron dataflow graph behavior transform algorithm level ic design retim dsp program optimum vec toriz tr vlsi array processor introduct algorithm storag assign decreas code size practic applic retim design highperform system comput strictlysecond shortest path fast algorithm digit signal process ctr dongik ko shuvra s bhattacharyya model blockbas dsp system journal vlsi signal process system v n p juli mingyung ko chungch shen shuvra s bhattachryya memoryconstrain block process dsp softwar optim journal signal process system v n p februari mingyung ko praveen k murthi shuvra s bhattacharyya beyond singleappear schedul effici dsp softwar synthesi use nest procedur call acm transact embed comput system tec v n pe may