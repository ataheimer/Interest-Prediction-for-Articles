t implement complex elementari function use except handl a algorithm develop reliabl accur evalu complex elementari function requir fortran fortran name cab csqrt cexp clog csin cco algorithm present pseudocod conveni exceptionhandl facil tight error bound deriv algorithm correspond fortran program ieee environ also develop illustr practic algorithm program test care help confirm correct algorithm error bound result test includ paper fortran program not b introduct purpos develop algorithm along error bound reliabl accur evalu complex elementari function requir fortran fortran name cab csqrt cexp clog csin cco seemingli oxi moron complex elementari function express term formula involv real arithmet real elementari function complex arithmet need care taken formula usual arrang seriou numer cancel occur evalu if cannot arrang higher precis may necessari critic point calcul work support natur scienc engin research council canada inform technolog research centr ontario well appli mathemat scienc subprogram offic energi research u s depart energi contract weng star program offic af order resd author address t e hull t f fairgriev depart comput scienc univers toronto toronto ontario canada ms email ftehulltffgcsutorontoca ping tak peter tang mathemat comput scienc divis argonn nation laboratori south cass ave argonn il usa email tangantaresmcsanlgov main difficulti remain evalu possibl overflow underflow might occur intermedi stage calcul except often spuriou sens final mathemat result within rang machin represent number circumst normal occur rare algorithm must provid altern calcul may lengthi abl circumv spuriou except situat suggest design algorithm help except handl facil algorithm would begin direct evalu origin care arrang formula would effici almost alway success except occur calcul would caus control calcul transfer except handler would need circumv difficulti possibl or possibl caus appropri except return function itself captur essenti featur algorithm present pseudocod possess conveni except handl facil section provid basic inform error bound assum real arithmet real elementari function use evalu complex func tion special attent given real sine cosin function three function need later introduc convent except return complex function also specifi precis section introduc except handl construct use pseudocod pseudocod algorithm present section along error analys special implement test describ section formula error bound deriv section tabul section extens test done ieee binari arithmet sun system issu consid product implement discuss section conclud remark given section emphas assum throughout function argument exact argument z slightli error induc error correspond valu function fz gener small special situat error also larg rel error fz deltaf zfz approxim zf zfz time rel error z deltazz rel error magnif factor zf zfz larg exampl one extrem case fz logz factor logz arbitrarili larg z near complex exponenti includ paper difficult develop algorithm much better simpli evalu cexpw clogz approxim z lambdaw hope consid problem separ paper earlier version paper appear argonn preprint basic numer oper complex elementari function describ section depend real arithmet oper real elementari function main purpos section introduc notat error error bound associ real oper use later deriv error bound complex function bound associ real sine cosin function discuss separ subsect implement logpx consid separ sinc logp alway avail one standard real function two special function manipul expon also specifi possibl except complex function specifi final subsect error error bound assum input valu complex elementari function normal complex floatingpoint number assumpt arrang intern oper might gener error such round error oper normal real floatingpoint number associ error analys mostli rel straightforward produc result simpl easi use it would also straightforward matter make provis input output valu complex number whose compon could denorm error analys would much complic also distinguish sign zero latter context see kahan except cab whose output normal real floatingpoint number if overflow return output exampl normal complex floatingpoint number if except return main assumpt make real arithmet that x normal real floatingpoint number op one four basic arithmet oper rel roundoff error bound e f l x op ffl j ffl j e provid except occur f l x op y round floatingpoint approxim x op produc machin assum f l x op also assum correspond error bound known real elementari function exampl assum bound e sqrt f l ffl sqrt similarli assum rel error bound name real elementari function use section bound small multipl e bound sin co need special attent consid detail next subsect we also assum underflow sin co assumpt deriv bound error evalu express aris section exampl conclud program express x sqrtx f l xy p x valu xy henc correct within rel error bound ee sqrt neglect term small multipl e provid except return the notat conveni note differ occurr ffl necessarili same use result like deriv rel error bound approxim obtain complex function section gener f complex function f r f real imaginari part respect f c f c r f c correspond calcul approxim magnitud rel error f c f r f r r r r rel error f c r f c respect we assum f r f zero either one zero case treat separ let us denot bound f r r r bound max r use bound e r e differ turn case exampl section except clog two exampl section csqrt cexp examin detail express bound obtain abl determin bound somewhat smaller max r case clog abl obtain bound dramat smaller max r error sine cosin approxim state previou subsect assum rel error bound e sinco sine cosin function mean assum bound e sinco f l assumpt use unless restrict rang valu x hold section give result measur valu system use test remaind subsect examin detail result depend rang x accuraci rang reduct done radix precis use calcul approxim consid detail one rel common case name case sinx cosx approxim first find x x approxim x mod j x use x standard way determin final approxim sinx cosx suppos approxim use rang reduct p ibi expect choos bound e ffl much smaller e first determin n rel high precis for good discuss might accomplish see payn hanek valu would round x say x least e x would use argument sine cosin approxim valid gamma it common practic use possibl simul high precis arithmet comput case ffl would like bound small multipl e final approxim sinx gamma n sinx even gamma ngamma cosx rel error introduc stage error commit approxim sine cosin function interv gamma bound small multipl e similar express obtain approxim cosx n even calcul approxim sinx therefor f l first requir p ibi accur enough neglect j j bound small multipl e replac thu rel error f l neglect small multipl express shown j u thu rel error f l sinx bound neglect small multipl e max taken machin represent valu x appropri rang of cours e sinco expect somewhat smaller express show clearli factor need control keep reason small result applic n even n odd cotx must replac tanx e singamma e cosgamma similar result deriv approxim cosx result combin one bound applic approxim either sinx cosx name neglect small multipl e max taken machin represent valu x appropri rang impos even stringent requir accuraci p ibi must chosen error contribut involv tangent cotang term express bound small multipl e choic depend radix precis number system well appropri rang valu x number system illustr let us consid one exampl x bit binari number determin max j n tanx almost store accur possibl bit which default case sun system p turn j n tanx circumst bound rel error sine cosin function indic store p ibi bit accur enough j x allow larger rang j x almost e suggest consider accur valu p ibi use rang reduct as option sun system provid access high precis approxim consid detail point enough illustr sort consider taken account practic bound section depend would help quantiti care document individu system algorithm might implement logp function subsect need evalu real elementari log function situat argument log function must evalu known approxim introduc seriou problem valu argument near say x x small turn often calcul x work precis real elementari function logpx approxim log without explicitli ad x ideal suit purpos sinc logp alway avail present simpl way specifi reason accur logp function use log function for accur implementa function possibl except domainerror real real e appropri initi real oneover appropri initi return domainerror return logx return x els return logi endif fig implement logp use log look three special case program take care obtain accur approxim log tion reli log function see tang program figur first look except case x gamma then x larg logpx replac logx program make replac suffici x e also ensur replac made one case necessari so x larg x x largest machin represent number round mode roundup then j x j small logpx replac x program make replac suffici also necessari make replac arithmet happen truncat otherwis could have binari machin exampl would gamma e instead logi would gamma plu possibl small multipl depend accur log function return valu would small multipl instead gamma either case rel error enorm look special case program assign round valu x y recov error x approxim rel error round valu quotient y xy denot relerr equal x high accuraci high accuraci test program standard round mode ieee arithmet where two elsif claus need believ program also valid arithmet system reason round convent includ truncat logb scalb function need two function manipul expon first return integ valu j x jc x use function second function is x real n integ unless overflow underflow case appropri except rais function exact provid cours overflow underflow second one except exampl section except return overflow underflow domainerror adopt convent overflow return whenev either one compon result overflow overflow tri provid compon valu themselv minor modif would need provid valu sigma appropri consid desir appropri normal valu compon overflow underflow could also provid one compon underflow valu compon much larger set underflow compon zero alter error bound small multipl set underflow compon zero return underflow in fact situat occur csqrt clog csin cco underflow compon smaller normal compon factor e thi quit arbitrari still set underflow compon zero return underflow increas bound requir otherwis criterion set underflow compon zero met compon underflow return underflow what describ last sentenc occur cexp set underflow compon zero account error analysi increas bound system use test underflow return tri provid compon valu themselv but again minor chang would need provid special valu denorm number pseudocod notat need except handl construct shown figur calcul enabl block normal produc requir result but enabl handl fig except handl construct enabl block would normal produc requir result handler take except occur enabl block except occur cours calcul control transfer handl block handler action taken circumv otherwis cope except situat variou way construct implement depend program languag use discuss way briefli section present purpos matter construct implement particular matter whether transfer control take place soon first except occur whether possibl ieee environ calcul continu end enabl block test made determin whether except occur make use intermedi result might obtain enabl block assum indic except occur enabl block disappear leav handler also except handl construct nest within handler construct howev assum indic type except overflow underflow etc caus transfer control avail handler seem appropri consid impr cise interrupt pipelin machin presenc parallel allow exit except handl construct except possibl return within handler whether return valu return except otherwis pseudocod reason selfexplanatori intend provid easytounderstand descript algorithm calcul good approxim complex elementari function implement program conveni languag other matter return section pseudocod algorithm section present algorithm form pseudocod program six complex elementari function requir fortran fortran error bound deriv section repeat tabular form section term precis use program denot number signific digit machin represent real number exampl ieee binari represent singl precis complex absolut valu cab first consid absolut valu function j z j z y program figur calcul approxim function base formula result calcul represent real valu valu z except overflow extrem case x larg main difficulti develop program function deal possibl spuriou overflow underflow sinc occur rare calcul good strategi attempt calcul immedi requir approxim directli basi formula sinc effici reason accur work time then approach fail program take time need look except case handler first look special case x zero otherwis logbx logbi exist use determin whether x differ greatli magnitud differ enough smaller j x j neglect otherwis close enough scale correspond scale result calcul without spuriou overflow underflow final scale valu result unscal provid requir result might happen unscal produc result overflow case overflow must return error analysi first consid case except occur analysi proce follow f l and sinc sign f l f l neglect f l f l small multipl ffl neglect thu rel error final result bound e e sqrt small multipl e neglect straightforward matter check error cannot exceed bound path handler unless cours overflow occur final unscal bound therefor valid valu input argument long overflow return function possibl except overflow real x integ logbx logbi integ precis appropri initi x zrealpart zimagpart enabl tri simplest formula work time answer sqrtx lambda handl overflow underflow occur answer els logbx logbx logbi logbi expon differ one x ignor answer maxabsx absi els scale scale absx near scaledx scalbx gammalogbx scaledi scalbi gammalogbx scaledansw sqrtscaledx lambda enabl unscal possibl might overflow answer scalbscaledansw logbx handl must overflow scalb return overflow endif endif return answer fig program absolut valu function first attempt approxim directli effici reason accur almost alway success but overflow underflow occur attempt handler take manag avoid spuriou overflow underflow usual scale howev final result still overflow except case scale undon overflow return function possibl except overflow real x x zrealpart zimagpart enabl answer sqrtx lambda handl must overflow underflow maxmag maxabsx absi enabl handl must underflow enabl answer maxmag temp handl must overflow return overflow return answer fig altern figur approach error bound somewhat larger conclud section mention anoth differ approach lead altern program shown figur note error bound approach somewhat larger name e complex squar root csqrt consid squar root function i r e i r sin r r adopt convent real part nonneg and zero imaginari part also nonneg otherwis sign sign y note neither compon overflow function cannot overflow furthermor one compon underflow compon set zero without alter error bound small multipl accord criterion describ subsect function cannot underflow avoid loss accuraci due cancel rewrit final obtain accord sign y form mathemat specif satisfi sign convent state also avoid possibl loss accuraci due cancel write pin place avoid possibl underflow latter form two remain difficulti taken account program figur one avoid spuriou overflow underflow evalu approxim t done way analog done cab except occur handler first look case x zero then expon differ enough depend larger expon smaller j x j j j ignor correspond express quit simpl final case scale use avoid except scale must done term even expon final unscal term integ expon two squar root oper requir final approxim cannot overflow unlik case final approxim cab function possibl except none real x real sqrt appropri initi integ logbx logbi evennearlogbx integ precis appropri initi complex answer x zrealpart zimagpart enabl answerrealpart t answerimagpart yt answerrealpart absyt answerimagpart signi t els answerrealpart temp answerimagpart signi temp endif handl overflow underflow occur answerrealpart temp answerimagpart signi temp answerrealpart sqrtx answerimagpart els answerrealpart answerimagpart sqrtgammax endif els determin logbx logbx logbi logbi x ignor ignor els scale unscal scale absx near even expon evennearlogbx scaledx scalbx gammaevennearlogbx scaledi scalbi gammaevennearlogbx scaledt sqrt sqrtscaledx lambda scaledi endif answerrealpart t enabl answerimagpart yt handl underflow occur answerimagpart enabl answerrealpart absyt handl underflow occur answerrealpart answerimagpart signi t endif endif return answer fig program squar root function first attempt approxim directli and success final approxim p z obtain accord whether x overflow underflow occur attempt handler take manag avoid overflow underflow two place handler underflow might still occur doe compon involv set approxim obtain approxim real imaginari part p z easili obtain depend whether x greater less zero remain difficulti that handler onli approxim j jt might underflow occur program figur replac underflow valu zero safe still preserv error bound obtain below sinc case part approxim z real part x imaginari part x alway well level requir subsect situat error analysi first consid case except occur begin final result cab name f l f l f l binari machin anoth ffl need nonbinari machin r f l r f l r binari machin anoth ffl need nonbinari machin cours assum small multipl ffl neglect binari machin divis one compon final result x mean rel error compon error compon assum constant sqrt initi within ffl also easili seen error path except handler cannot greater thu conclud that notat subsect one e r e e maximum bound rel error approxim p neglect small multipl binari machin bound tighten somewhat examin error formula detail subsect f r r r which x give f r r right hand side inequ reach maximum valu larg possibl howev x f less e result x bound even smaller thu conclud rel error approxim z bound q neglect small multipl binari machin nonbinari machin extra ffl bound t also divis one compon well divis compon x error bound compon result equal final rel error bound nonbinari machin therefor neglect small multipl complex exponenti cexp complex exponenti function z easili express term real elementari function x y relationship form lead immedi enabl block program figur handler expx first test overflow doe overflow return admittedli ignor narrow fring possibl valu x overflow could avoid name valu x expx overflow small amount multipl cosi sini would produc valu overflow level chosen ignor fring valu worth troubl detect reinstat howev one wish includ them one possibl would develop special procedur return separ significand expon e expx use result procedur determin scalb cosi e scalb sini e overflow occur one compon actual overflow otherwis handler must cope underflow expx underflow even expx maxj cosi underflow must return otherwis compon underflow one doe agre upon function possibl except overflow underflow real x real e appropri initi complex answer x zrealpart zimagpart enabl expx expx answerrealpart expx cosi answerimagpart expx sini handl overflow underflow occur enabl expx expx handl return overf low els return underf low endif cosi cosi sini sini enabl handl compon underflow return underf low one compon underflow underflow compon set zero answerrealpart expx cosi answerimagpart els answerrealpart answerimagpart expx sini endif els return underf low endif return answer fig program complex exponenti function handler first deal overflow underflow expx then one compon underflow determin whether one compon safe set zero test case whether use determin whether result set underflow compon accept otherwis underflow return error analysi straightforward absenc except rel error real part ffl imaginari part ffl give overal bound e neglect small multipl bound somewhat larger case one underflow part set zero rel error underflow part rel error overal approxim bound neglect small multipl henc case overal rel error approxim e z bound q neglect small multipl provid overflow underflow re turn bound turn system use test complex natur logarithm clog complex natur logarithm z i express term compon follow gamma the arg function approxim fortran atanyx evalu compon function conveni first introduc m maximum minimum j x j j j respect then except must return design domainerror program figur imaginari part logarithm function easili calcul arg function might underflow real part simpli logm shown underflow part set zero without signific increas error bound main difficulti complex log function aris evalu real part program first deal case real part simpli logm seriou difficulti occur x near accur approxim log function would requir accur approxim m cannot obtain directli possibl seriou cancel postpon deal difficulti time be first consid case interv thi ensur m interv remain difficulti spuriou overflow underflow may occur evalu deal except way analog cab csqrt indic program ignor expon suffici differ result real part simpli logm otherwis scale use avoid overflow underflow scale factor radix gammascal logarithm must correct ad scale theta logradix logarithm scale valu import scale chosen possibl cancel addit let us consid case case m want calcul accur approxim best way evalu express m doubl work precis round result back work precis evalu done work precis error analysi becom complic shall see turn error real part enorm although overal error bound turn less doubl quit modest bound obtain case doubl precis use if doubl precis avail could simul but sinc simul like extrem slow may worthwhil avoid simul case cancel ie cancel seriou ie close magnitud turn error analysi program figur first assum arithmet binari error bound imaginari part cours unless imaginari part underflow underflow occur imaginari part safe set zero alreadi indic and sinc real part simpli logm error bound e log overal rel error bound otherwis real part consid first case except occur f l neglect small multipl know j logm m log rel error bound real part function clog possibl except domainerror real x integ scale complex answer real sqrt logradix appropri initi integ precis appropri initi x zrealpart zimagpart return domainerror endif enabl answerimagpart argz handl must underflow arg answerimagpart return answer determin real part answerrealpart enabl answerrealpart logm handl must overflow underflow ignor answerrealpart els scale except avoid two term answerrealpart sign must overflow scale els must underflow scale logbm endif scaledm scalbm gammascal scaledm scalbm gammascal scaledr scaledm lambda answerrealpart scale logradix endif els enabl use doubl precis possibl evalu argument logp answerrealpart handl must underflow lambda answerrealpart endif return answer fig program complex logarithm function first look three special case argument zero imaginari part underflow real part calcul way depend whether maxj x outsid interv not first case scale may need cope spuriou overflow underflow second case accuraci final result sensit accur argument logp calcul e log e log bound e e log neglect small multipl except occur bound obvious still valid scale requir scale requir bound valid second term express real part first term scale logradix bound e logradix store accur possibl sinc two term sign error sum bound ee log thu case overal rel error bound max neglect small multipl consid case except occur case real part logm error bound e log otherwis need determin error evalu affect logp express express evalu within factor f l logp neglect small multipl j fflj know show error bound real part h bound j j j doubl precis use evalu exactli sum two express suffer round error ffl final round work precis present logp argument ffl final rel error real part pi therefor bound e neglect small multipl overal rel error m therefor bound neglect small multipl e provid cours domainerror return complet error analysi program figur argument logp near end program calcul within factor case doubl precis use evalu argument the bound must replac respect nonbinari machin multipl express evalu doubl precis use situat quit bit complic sinc seriou cancel may occur evalu obvious cancel argument logp simpli accur within factor case doubl precis also cancel argument accur within factor lead us bound replac cancel but cancel seriou shown case argument accur within factor bound therefor leav us situat seriou cancel take place thi deriv follow f l logp hi neglect small multipl second term express see rel error real part could enorm and confirm test next section continu toward find rel error bound overal result see absolut error real part bound and sinc j turn bound express bound e r substitut overal rel error bound develop subsect name f r r r proceed follow f r consid first part bound e r second part rel j f r j lead overal error bound accept small second term obvious bound first term consid two case one j j imaginari part argz and first case j argz j contribut first part rel error bound sinc second case j argz contribut first part rel error also turn e thu end overal rel error bound e e logp case seriou cancel take place collect togeth result obtain program figur work precis use throughout establish follow overal rel error bound clog function neglect small multipl provid cours domainerror return here must increas nonbinari machin multipl express evalu complex sine csin sine function z xiy repres term real elementari function follow program figur base formula overflow occur evalu real imaginari part function coshi sinhi larg magnitud probabl both handler return overflow case cexp fring valu z for real function possibl except overflow real x complex answer x zrealpart zimagpart enabl answerrealpart sinx coshi answerimagpart cosx sinhi handl enabl coshi coshi sinhi sinhi handl must overflow return overflow answerrealpart sinx coshi enabl answerimagpart cosx sinhi handl must underflow answerimagpart return answer fig program complex sine function straightforward although acknowledg overflow return fring valu z whose correspond real imaginari part actual slightli overflow threshold imaginari part sinz slightli overflow threshold even though least one coshi sinhi alon overflow neglect here but cexp auxiliari procedur comput expon fraction part expi separ could use avoid situat sinc sinhi coshi effect equal expi magnitud function overflow underflow occur occur multipl associ imaginari part happen real part much larger underflow part set zero without signific increas error bound upper bound overal rel error function neglect small multipl cours overflow return complex cosin cco cosin function z repres term real elementari function follow function possibl except overflow real x complex answer x zrealpart zimagpart enabl answerrealpart cosx coshi answerimagpart gammasinx sinhi handl enabl coshi coshi sinhi sinhi handl must overflow return overflow answerrealpart cosx coshi enabl answerimagpart gammasinx sinhi handl must underflow answerimagpart return answer fig program complex cosin function straightforward although acknowledg overflow return fring valu z whose correspond real imaginari part slightli overflow threshold program figur base formula overflow occur coshi sinhi larg magnitud probabl both and csin previou section handler return overflow also csin fring valu z neglect here although could includ help auxiliari procedur return expon fraction part expi separ underflow occur occur multipl associ imaginari part happen real part much larger underflow part set zero without signific increas error bound upper bound overal rel error function neglect small multipl cours overflow return special implement test implement algorithm present section sun fortran compil version order test correct especi correct error bound implement special sens tabl i observ error bound singl precis real elementari function sun librari version unit e rel error bound singl precis real arithmet result given e sinco close possibl pseudocod descript section particular modifi way improv effici effici product implement issu discuss next section except portion one version clog altern suggest subsect float point oper implement singl precis some care taken make sure case examin gener assembl languag instruct ensur extend precis use intermedi calcul enabl us use correspond doubl precis result sun system true result test purpos assum true result correct singl precis accuraci except handl construct implement allow enabl block execut test except flag rais possibl ieee environ would natur interpret use ieee handler traphandl facil provid sun system p turn ineffici somewhat difficult use test float point except flag use ieee flag subroutin p also ineffici instead access flag use math librari routin swapex test correct error bound exampl section must first determin bound turn system use requir determin e etc conveni present unit e result given tabl i rel error bound determin examin relev singl precis argument except case e sinco consid valu argument less absolut valu case e arg determin bound ad e e atan extra allow addit error induc use f l yx argument atan place yx boundari arg function least one x also consid the bound logp sinhcosh e singl precis version function use correctli round result doubl precis implement bound version logp figur use singl precis e result tabl use determin theoret bound column tabl ii observ bound column tabl ii obtain compar result implement true result provid sun system doubl precis function larg number mostli random input argument ieee singl precis argument observ bound occur given hexadecim form column random argument construct random real part random imag tabl ii comparison theoret observ rel error bound sun fortran version implement complex elementari function program figur column unit e rel error bound real arithmet sp pdp stand ieee singl precis partial ieee doubl precis respect for cexp real csin cco imag function theoret bound gamma base tabl observ bound argument cab e e sqrt e csqrt sqrt cexp clog inari part gener random expon random significand within appropri rang ten thousand random argument gener semiax gener quadrant origin also test region restrict necessari overflow underflow would avoid time time ensur good coverag proper domain function mani special case also test includ mani near boundari region separ point would probabl lead except return point would probabl lead except return import special case term tri observ larg error argument real imaginari part chosen maxim error relev real elementari function fact special case produc observ maximum much random test seen tabl ii nonexcept result error would expect basi theoret error bound fact theoret bound much larger observ bound sort discrep shown tabl surpris consid kind reason use determin theoret error bound especi case two clog function it happen rel larg discrep case cab explain ieee arithmet system satisfi assum subsect accur within half unit last place make signific differ error analysi cab special form express argu contribut express final rel error bound cab maximum valu greater follow argument obtain final rel error bound cab place special mention made result clog version make use doubl precis comput argument logp much accur term observ overal rel error bound version use singl precis howev real part former much accur real part latter observ bound e former approxim latter enorm error occur fffffc iaf the observ error bound imaginari part equal e cours claim experiment result actual prove correct theoret error bound believ evid convinc howev correct program involv correct error bound valu argument lead except return must also true except return reason so otherwis program could consid correct alway return except matter input argument accord subsect overflow return either compon overflow one function program return overflow particular valu input argument test program consid correct return least one compon true result within rel error bound true overflow specif huge largest machin represent number ulpup unit last place huge direct test underflow return correct either compon true result within rel error bound true underflow specif one compon underflow nevertheless within error bound greater valu within error bound compon specif min j f r min j f r ini smallest posit machin represent number ulpdown unit last place ini direct criteria modifi slightli obviou way allow fact fring area neglect algorithm cexp csin cco test case overflow underflow return test program determin appropri criterion satisfi except return domainerror clog special case easi check separ product implement except handl construct ada reason close use paper except unfortun fact ada recogn underflow except construct simpler ada expect handler told effect except occur propos somewhat like ada recogn underflow propos fortran reject favor except handl facil all construct could implement pl elegantli extens exist languag often provid facil implement con struct exampl provid access trap except flag ieee environ alreadi indic preced section absenc except handl facil pretest use exampl case cab j x j j j test advanc make sure overflow underflow occur evalu x case evalu express carri calcul handler use anoth pretest determin whether final unscal caus overflow implement origin pretest determin condit satisfi suffici ensur spuriou except occur may necessari case caus program execut handler often necessari cours higher precis avail may possibl avoid pretest ing long expon rang higher precis suffici broader exampl cab entir calcul done higher preci sion test need perform result calcul coerc origin precis idea littl use work precis alreadi highest avail apart tri implement except handl effici way implement made slightli effici mostli write program intermedi store oper avoid addit float point statu regist would save entri function subprogram later restor updat includ except flag ani return function conclud remark present algorithm reliabl accur evalu complex elementari function requir fortran fortran conveni describ algorithm help except handl construct implement fortran sun system test extens observ error bound theoret bound convinc evid correct theoret bound also indic theoret bound quit tight it interest discov choos argument near thought largest error might occur usual led observ bound larger found even extens random test one case test also found except return when when reason so acknowledg much work inspir discuss member ada numer work group chairmanship gil myer jim codi particularli help earli stage investig also wish thank refere help suggest r american nation standard program languag fortran implement complex elementari function use except handl ieee standard binari floatingpoint arithmet branch cut complex elementari function part radian reduct trigonometr function tr tabledriven implement logarithm function ieee floatingpoint arithmet ctr technic report floatingpoint except handl acm sigplan fortran forum v n p dec t e hull thoma f fairgriev ping tak peter tang implement complex arcsin arccosin function use except handl acm transact mathemat softwar tom v n p sept t e hull thoma f fairgriev ping tak peter tang implement complex arcsin arccosin function use except handl acm transact mathemat softwar tom v n p sept david m smith algorithm multipleprecis complex arithmet function acm transact mathemat softwar tom v n p dec david bindel jame demmel william kahan osni marqu comput given rotat reliabl effici acm transact mathemat softwar tom v n p june milo d ercegovac jeanmichel muller complex squar root operand prescal journal vlsi signal process system v n p octob john r hauser handl floatingpoint except numer program acm transact program languag system topla v n p march